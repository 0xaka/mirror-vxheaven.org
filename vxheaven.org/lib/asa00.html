<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Павел Семьянов 'Разработка интеллектуальной системы поиска неизвестных разрушающих программных средств в исполняемом коде' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Author" content="Павел Семьянов"/>
<meta name="KeyWords" lang="en" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, Семьянов, Павел,Разработка интеллектуальной системы поиска неизвестных разрушающих программных средств в исполняемом коде, файл, вируса, проверить, boot, считать, вирусов, вирус, анализа, память, сектор, рода, сигнатуры, вирусы, байт, запись"/>
<meta name="Description" content="VX Heaven site is dedicted to providing information about computer viruses (virii) and web space for virus authors and groups"/>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"047a5bcbf67431883fc9ed25fba33612",petok:"79ebf265bf05997d961d1d9006e24aa66ce359b4-1498758039-1800",zone:"vxheaven.org",rocket:"a",apps:{}}];document.write('<script type="text/javascript" src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=85b614c0f6/cloudflare.min.js"><'+'\/script>');}}catch(e){};
//]]>
</script>
<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="/style.css"/><link rel="canonical" href="http://vxheaven.org/lib/asa00.html"/>
<script type="text/rocketscript" data-rocketsrc="https://apis.google.com/js/plusone.js">{"parsetags": "explicit"}</script>
</head>
<body bgcolor="#dbc8a0" text="#302000" link="#225599" vlink="#113366">
<div class="s1">
<div style="float:right;"><a href="/lib/index.php?tbs=1"><img src="/img/max.gif" alt="Maximize"/></a></div> <form id="lf" style="margin: 0; float: right;" method="get" action="/index.php"><input type="hidden" name="action" value="set"/><select name="lang" onchange="javascript:document.getElementById('lf').submit();"><option value="ru">Русский</option><option selected="selected" value="en">English</option><option value="ua">Українська</option><option value="de">Deutsch</option><option value="es">Español</option><option value="fr">Fran&ccedil;ais</option><option value="it">Italiano</option><option value="pl">Polski</option></select></form>
<div style="float: right;"><div id="plusone"></div></div>
<script type="text/rocketscript">gapi.plusone.render("plusone", {"size":"small","count":"true"});</script>
<div style="float: right;" class="addthis_toolbox addthis_default_style">
<script type="text/rocketscript">var addthis_config = { ui_click: true }</script>
<a style="text-decoration: none; font-size: 10pt;" href="/?action=addthis" class="addthis_button_compact">Bookmark</a>
<script type="text/rocketscript" data-rocketsrc="http://s7.addthis.com/js/250/addthis_widget.js#username=herm1t"></script>
</div>
<div style="float: right;">
<script type="text/rocketscript" data-rocketsrc="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<form action="/search.php" id="cse-search-box">
<input type="hidden" name="cx" value="002577580816726040001:z9_irkorydo"/>
<input type="hidden" name="cof" value="FORID:10"/>
<input type="hidden" name="ie" value="UTF-8"/>
<input type="text" name="q" size="12" value=" "/>
<input type="submit" name="sa" value="Search"/>
</form>
</div><h1><a href="/" style="text-decoration: none; color: #000000;">VX Heaven</a></h1>
<span class="nav"><a href="/lib/">Library</a> <a href="/vl.php">Collection</a> <a href="/src.php">Sources</a> <a href="/vx.php?id=eidx">Engines</a> <a href="/vx.php?id=tidx">Constructors</a> <a href="/vx.php?id=sidx">Simulators</a> <a href="/vx.php?id=uidx">Utilities</a> <a href="/links.php">Links</a> <a href="/donate.php" style="color: #706020" id="donate">Donate</a> <a href="/forum" style="text-decoration: underline;">Forum</a> </span><br clear="all"/>
</div>
<div class="s2"><h1>Разработка интеллектуальной системы поиска неизвестных разрушающих программных средств в исполняемом коде</h1><p><a href="/lib/?lang=ru&amp;author=%D0%A1%D0%B5%D0%BC%D1%8C%D1%8F%D0%BD%D0%BE%D0%B2%2C%20%D0%9F%D0%B0%D0%B2%D0%B5%D0%BB">Павел Семьянов</a><br/> <em>Дипломная работа, Санкт-Петербург, 1995</em><br/> <em> 1995</em></p><script type="text/rocketscript">var disqus_url = 'http://vxheaven.org/lib/asa00.html';</script>[<a style="" href="/lib/?lang=RU&amp;index=AV#asa00">Вернуться к списку</a>] [<a href="/lib/asa00.html#disqus_thread">Комментарии</a>]<br/> 
<h2>Содержание</h2>
<ul>
<li><a href="#p0">Введение</a>
<ul>
<li><a href="#p01">0.1. Появление вредного программного обеспечения</a></li>
<li><a href="#p02">0.2. Разнообразие РПС</a></li>
<li><a href="#p03">0.3. Экспоненциальный рост РПС</a></li>
</ul></li>
<li><a href="#p1">Глава 1. Сравнительный анализ существующих программных средств борьбы с РПС, их недостатки и постановка задачи работы.</a>
<ul>
<li><a href="#p11">1.1. Классы существующих антивирусных средств.</a>
<ul>
<li><a href="#p111">1.1.1. Детекторы и фаги.</a></li>
<li><a href="#p112">1.1.2. Сторожа.</a></li>
<li><a href="#p113">1.1.3. Ревизоры.</a></li>
<li><a href="#p114">1.1.4. Вакцины.</a></li>
<li><a href="#p115">1.1.5. Перспективные средства защиты.</a></li>
<li><a href="#p116">1.1.6. Сравнительный анализ существующих средств защиты от вирусов</a></li>
</ul></li>
<li><a href="#p12">1.2. Недостатки существующих антивирусных средств применительно к современной ситуации.</a></li>
<li><a href="#p13">1.3. Постановка задачи работы.</a></li>
</ul></li>
<li><a href="#p2">Глава 2. Определение, модели и классификация РПС.</a>
<ul>
<li><a href="#p21">2.1. Отсутствие строгого определения компьютерного вируса.</a>
<ul>
<li><a href="#p211">2.1.1. Классическое определение компьютерного вируса.</a></li>
<li><a href="#p212">2.1.2. Невозможность создания универсального антивируса с точки зрения классического определения.</a></li>
<li><a href="#p213">2.1.3. Рекурсивные определения вируса.</a></li>
</ul></li>
<li><a href="#p22">2.2. Функциональное представление и определение РПС.</a>
<ul>
<li><a href="#p23">2.3. Классификация РПС на базе их функциональной модели.</a></li>
<li><a href="#p24">2.4. Резюме.</a></li>
</ul></li>
</ul></li>
<li><a href="#p3">Глава 3. Поэтапный подход к анализу исполняемого кода программ и общая структура системы анализа.</a>
<ul>
<li><a href="#p31">3.1. Поэтапная схема анализа исполняемого кода.</a>
<ul>
<li><a href="#p311">3.1.1. Выделение чистого кода.</a></li>
<li><a href="#p312">3.1.2. Лексический анализ.</a></li>
<li><a href="#p313">3.1.3. Дизассемблирование.</a></li>
<li><a href="#p314">3.1.4. Синтаксический анализ.</a></li>
<li><a href="#p315">3.1.5. Выделение структуры программы и перевод на ЯБВУ.</a></li>
<li><a href="#p316">3.1.6. Семантический анализ.</a></li>
</ul></li>
<li><a href="#p32">3.2. Взаимодействие синтаксического и семантического анализа.</a></li>
<li><a href="#p33">3.3. Общая структура системы анализа.</a></li>
<li><a href="#p34">3.4. Резюме.</a></li>
</ul></li>
<li><a href="#p4">Глава 4. Реализация интеллектуальной системы анализа исполняемого кода программ.</a>
<ul>
<li><a href="#p41">4.1. Построение дерева свертки РПС и набора характерных признаков.</a></li>
<li><a href="#p42">4.2. Подходы к построению системы анализа без использования динамических методов исследования.</a>
<ul>
<li><a href="#p421">4.2.1. Подход 1: метод поиска характерных признаков.</a></li>
<li><a href="#p422">4.2.2. Подход 2: метод полного дизассемблирования.</a></li>
</ul></li>
<li><a href="#p43">4.3. Принципы работы системы SubLVA.</a></li>
<li><a href="#p44">4.4. Обзор алгоритмов, необходимых для реализации системы.</a>
<ul>
<li><a href="#p441">4.4.1. Этапы лексического и синтаксического анализа.</a></li>
<li><a href="#p442">4.4.2. Этап семантического анализа.</a>
<ul>
<li><a href="#p4421">4.4.2.1. Машина логического вывода.</a></li>
<li><a href="#p4422">4.4.2.2. Форма представления знаний.</a></li>
</ul></li>
</ul></li>
<li><a href="#p45">4.5. Резюме.</a></li>
</ul></li>
<li><a href="#L">СПИСОК ЛИТЕРАТУРЫ.</a></li>
</ul>
<h2><a name="p0">Введение.</a></h2>
<h3><a name="p01">0.1. Появление вредного программного обеспечения.</a></h3>
<p>Все прогрессивные открытия человечества рано или поздно начинали служить ему во вред. И если с момента открытия радиоактивности до создания атомной бомбы прошло ровно 50 лет, то с момента изобретения компьютера до того, казалось бы, невероятного события, что он стал применяться во зло, прошел в два раза меньший срок. Этим событием стало появление программ, направленных на нарушение функционирования отдельных компьютеров или их сети, порчу или уничтожение информации. Такие программы впоследствии получили название "вредное программное обеспечение" (badware).</p>
<p>Их история начинается еще с работ теоретика современных компьютеров фон Неймана. Он разрабатывал модели автоматов, способных к самовоспроизведению и математически доказал возможность существования таких машин. После этого идея саморазмножающихся программ "витала в воздухе" и время от времени находила свою более или менее адекватную реализацию.</p>
<p>Так, в 60-х и 70-х годах, когда в основном использовались большие ЭВМ (mainframe) типа UNIVAC, среди обслуживающего персонала существовал термин "программа-кролик" (rabbit). Так называли программу на интерпретируемом командном языке, которая запускала сама себя на выполнение, что обычно приводило систему к полному краху. Однако обычно такие программы возникали непреднамеренно, в результате ошибок программистов.</p>
<p>Приблизительно в 1970 г. была создана саморазмножающаяся программа для одной из первых компьютерных сетей -- APRAnet. Она называлась Creeper (вьюнок) и распространялась по сети от одного компьютера к другому. Интересно, что для уничтожения этой вредной программы была написана другая, названная Reaper (жнец), которая также распространялась по сети и уничтожала копии Creeper.</p>
<p>Много новых идей в развитие вредящих программ внесли писатели фантасты в 70-х годах. Например, 1975 году Джоном Брунером (John Brunner) был опубликован роман "<a href="/lib/mjb01.html">The Shockwave Rider</a>". В нем была достаточно детально описана программа, называемая червем (worm), которая распространялась по компьютерной сети, подбирала имена и пароли пользователей, и была распределена по всей сети -- если одни ее фрагменты уничтожались, их заменяли аналогичные, находящиеся в других компьютерах. Примерно по этой схеме был построен самый знаменитый на сегодняшний день представитель вредного ПО -- червь Роберта Морриса.</p>
<p>В конце 70-х годов, параллельно с появлением первых персональных компьютеров "Эпл" (Apple), стали бурно развиваться компьютерные сети, основанные на обычных телефонных каналах. Появляются первые банки свободно распространяемых программ -- BBS (Bulletin Board System, электронная доска объявлений), в которые каждый мог загрузить любую программу и считать любую из имеющихся там. Это привело к появлению первых троянских коней (Trojan Horses), которые загружались на BBS под видом полезных, а при запуске уничтожали информацию на компьютере пользователя.</p>
<p>Первое достоверное сообщение о появлении компьютерного вируса появилось в 1981 году. Это был вирус Elk Cloner, поражавший загрузочные сектора дискет персонального компьютера Apple II. Вирус содержал целый набор видеоэффектов -- переворачивал экран, заставлял сверкать буквы, выводил на экран стихи.</p>
<p>В ноябре 1983 г. доктор Фредерик Коэн (Dr. Frederick Cohen), один из первых серьезных исследователей компьютерных вирусов, продемонстрировал саморазмножающиеся программы для компьютеров VAX и системы UNIX. Коэн доказал возможность практической реализации подобных программ и их функционирования даже в защищенных операционных системах (его операционная система использовала модель безопасности Bell-LaPadula).</p>
<p>В 1981 г. фирма IBM выпустила свой персональный компьютер, которому суждено было стать самым массовым компьютером в истории развития вычислительной техники. Если принять во внимание, что IBM PC оснащались и оснащаются до сих пор операционной системой MS DOS, очень слабой с точки зрения безопасности, то нельзя удивляться тому, что именно "благодаря" этому компьютеру проблема вредного программного обеспечения и особенно вирусов перестала быть уделом профессионалов и обычные неподготовленные пользователи столкнулись с ней лицом к лицу. Именно десятки тысяч компьютеров IBM PC были поражены в 1987 г. при первых случаях массового заражения -- вирусами Brain и Lehigh.</p>
<p>Наиболее известен вызвавший всемирную сенсацию и привлекший внимание к вирусной проблеме инцидент с сетевым червем в глобальной сети Internet. Второго ноября 1988 года студент Корнелловского университета Роберт Моррис (Robert Morris) запустил на компьютере Массачусетского Технологического института программу-червь, которая передавала свой код с машины на машину, используя ошибки в операционной системе UNIX на компьютерах VAX и Sun. В течении 6 часов были поражены 6000 компьютеров, в том числе Исследовательского Института НАСА и Национальной лаборатории Лоуренса в Ливерморе -- объектов, на которых проводятся самые секретные стратегические исследования и разработки. Червь представлял собой программу из 4000 строк на языке С и входном языке командного интерпретатора системы UNIX. Следует отметить, что вирус только распространялся по сети и не совершал каких-либо вредящих действий (кроме, конечно, заметного увеличения загрузки сети). Однако это стало ясно только на этапе анализа его кода, а пока вирус распространялся, в вычислительных центрах царила настоящая паника. Тысячи компьютеров были остановлены, сеть была полностью дезорганизована, ущерб составил многие миллионы долларов.</p>
<p>Таким образом, можно говорить о появлении к началу 80-х годов нового класса программ, направленных на нанесение различного ущерба компьютерам, их сетям, информации, хранящейся или передающейся по ним и, следовательно, пользователям этих компьютерных систем. Именно эта функция -- нанесение ущерба или вреда и выделяется чаще всего в названии этого класса ПО. Существуют названия типа "вредящие программы", "программы-вандалы", на Западе принят термин "вредное программное обеспечение". В дальнейшем в дипломе будет применяться название "разрушающие программные средства" (РПС).</p>
<h3><a name="p02">0.2. Разнообразие РПС.</a></h3>
<p>Выше уже приведены примеры почти всех видов РПС: это, прежде всего, компьютерные вирусы (computer viruses), их разновидность -- сетевые черви (worms); троянские кони (Trojan horses), и их разновидность -- программные закладки или "логические мины" (logic bombs); а также средства несанкционированного доступа.</p>
<p>Компьютерные вирусы и сетевые черви характеризуются в первую очередь способностью к саморепродукции. Для компьютерных вирусов это -- саморепродукция в пределах отдельного компьютера, а распространением на другие компьютеры вирус сам не занимается и предоставляет делать это человеку, копирующему программы с одной машины на другую. Для сетевого червя саморепродукция -- это именно процесс распространения с одного компьютера на другой по сети, а на одной машине иметь более одной копии ему не только не нужно, но и вредно, т.к. каждая копия отнимает дополнительные ресурсы.</p>
<p>Троянские кони характеризуются прежде всего функцией нанесения ущерба -- сразу после запуска или через некоторое время они уничтожают доступную информацию, форматируют жесткие диски, портят конфигурацию компьютера и т.п. Обычно они маскируются под игровые или развлекательные программы и делают это под красивые картинки или музыку. Программные закладки также содержат некоторую функцию, не оговоренную в спецификации, но эта функция, наоборот, старается быть как можно незаметнее, т.к. чем дольше программа не будет вызывать подозрений, тем дольше эта функция-закладка сможет работать. Примерами последних РПС могут быть: широко известная программа, осуществляющая атаку "салями" --зачисление остатков денег при округлении на определенный счет; программа, посылающая информацию о состоянии дел в конкурирующей фирме; закладка, внедренная в ПО военного комплекса, блокирующая его в некоторый момент по радиосигналу и т.п.</p>
<p>У средств несанкционированного доступа главной особенностью является способность к "проникновению" в защищенную компьютерную систему через ошибки или "дыры" в соответствующих системах безопасности или администрирования, а также "в лоб" -- путем перебора или криптографической дешифровки паролей.</p>
<h3><a name="p03">0.3. Экспоненциальный рост РПС.</a></h3>
<p>Естественно, что с появлением первых РПС (в основном, вирусов) не могли не появиться программные средства зашиты от них. (Подробнее они будут рассмотрены в главе 1). И пока число РПС исчислялось единицами или десятками, ситуация была терпимой и средства защиты более или менее справлялись с ними.</p>
<p>К сожалению, в скором времени, начиная с конца 1990 г., проявилась новая тенденция, получившая название "экспоненциальный вирусный взрыв". Количество новых вирусов, обнаруживаемых в месяц, стало исчисляться десятками, а в дальнейшем и сотнями. Поначалу эпицентром этого взрыва была Болгария, затем он переместился в Россию. Данные о количестве известных вирусов в операционной системы MS DOS по годам приведены на рис 1.</p>
<div align="center">
<img src="img/asa00_ru/Image117.gif" alt="Рис. 1 Компьютерные вирусы в MS DOS на конец года, шт."/>
<p><strong>Рис. 1. Компьютерные вирусы в MS DOS на конец года, шт.</strong></p>
</div>
<p>Этот процесс нарастания количества компьютерных вирусов можно разделить на три этапа, каждый из которых имеет свои причины. Это т.н. "болгарский вирусный взрыв", "российский вирусный взрыв" и современная ситуация.</p>
<p>Болгарский взрыв, произошедший в 1990 г., обязан группе болгарских хакеров, поставивших своей целью выпускать не просто новые вирусы, а целые семейства, постепенно их модифицируя и делая все более опасными и неуязвимыми. Так как до 1990 г. количество всех вирусов исчислялось единицами, то появление в короткое время около полусотни новых и получило название "взрыва" <a href="#L1">[1]</a>. Наиболее известными представителями этих вирусов были семейства Yankee Doodle и Dark Avenger. Очень многие идеи, реализованные в этих вирусах, до сих пор находят свое применение и продолжение. Почему это произошло в Болгарии? Очевидно, это была первая страна социалистического лагеря (соответственно, отсутствовали охрана авторского права на программы и ответственность за их несанкционированное копирование, что приводило к тому, что 99% ПО приобреталось незаконно, а это делало распространение вирусов с ним очень легким), начавшая серийно выпускать IBM PC-совместимые компьютеры.</p>
<p>Российский взрыв был тоже вполне закономерен и предсказан, в частности автором, еще в 1990 г. <a href="#L2">[2]</a>. Повальная компьютеризация СССР, введение в школах преподавания информатики, подогревающая нестабильная ситуация в стране, такое же, как и в Болгарии, отсутствие законов об охране авторского права -- все это причины этого явления.</p>
<p>Примерно с середины 1992 года существует такое явление, как компьютерный андерграунд, специализирующийся на вскрытии систем защиты, нелегальном копировании и т. д. В условиях тотальной компьютеризации и наличия глобальных и локальных сетей компьютерный андерграунд объединяет хакеров (hackers) со всего мира. Существует даже регулярный электронный журнал "40Hex", публикующий исходные тексты вирусов, алгоритмы распространения, способы преодоления систем защиты и борьбы с антивирусными средствами и т. д. Имеется (в том числе у в России) немало BBS, распространяющих как сами вирусы, так и их исходные тексты и другую информацию. Естественно, что при желании воспользоваться этой информацией может кто угодно.</p>
<p>Наконец, современная ситуация внесла еще больше драматизма в создавшееся положение. Она характеризуется двумя моментами: появлением полиморфных вирусов и генераторов (конструкторов) вирусов.</p>
<p>Полиморфные вирусы характеризуются тем, что для их обнаружения неприменимы обычные алгоритмы поиска, так как каждая новая копия вируса не имеет со своим родителем ничего общего. Это достигается шифровкой тела самого вируса и расшифровщиком, не имеющим ни одного постоянного бита в каждом своем экземпляре. На сегодняшний день известно около десятка алгоритмов (не вирусов, их намного больше!) генерации таких расшифровщиков. Обычно они оформлены в виде объектного файла, и каждый, кто хочет превратить свой вирус в полиморфный, может просто присоединить этот файл к объектному файлу вируса.</p>
<p>Появление генераторов вирусов избавляет самых ленивых авторов от необходимости программировать свой вирус -- зачем утруждать себя, если можно в меню задать способ распространения, тип, вызываемые эффекты, причиняемый вред и получить ассемблерный текст нового вируса. На сегодняшний день известно около пяти таких генераторов вирусов.</p>
<p>Таким образом, экспоненциальный рост количества вирусов привел к тому, что средства защиты просто не успевают за развитием ситуации и выходят в свет с запозданием. Если вы сегодня пользуетесь программой месячной давности -- она может вас только сбить с толку, убедив, что ваш компьютер свободен от вирусов. На самом деле он может быть заражен десятком новых, которых антивирусная программа просто не знает. А менять копию программы каждую неделю не только утомительно пользователю, но и автору приходится днями и ночами заниматься тем, чтобы исследовать все новые и новые вирусы, хотя очевидно, что в этой гонке он уже проиграл.</p>
<p>Итак, в настоящее время особенно актуальна стала задача поиска неизвестных вирусов (и других РПС) в программном обеспечении, которое, как правило, поступает в виде исполняемого кода. И хотя эта задача уже исследовалась раньше, удовлетворительного решения до сих пор нет.</p>
<h2><a name="p1">Глава 1. Сравнительный анализ существующих программных средств борьбы с РПС, их недостатки и постановка задачи работы.</a></h2>
<p>На сегодняшний день большинство существующих программных средств борьбы предназначено для защиты только от одного (самого распространенного) класса РПС - компьютерных вирусов. Только сторожа пытаются бороться также и с троянскими конями. Программ, призванных служить для защиты от других классов РПС, в настоящее время просто нет. Поэтому в этой главе далее будут рассмотрены в основном различные классы антивирусных средств. Предполагается, что читатель имеет некоторое представление (хотя бы из введения) о том, что такое компьютерные вирусы, а подробнее на их определении мы остановимся в следующей главе.</p>
<h3><a name="p11">1.1. Классы существующих антивирусных средств.</a></h3>
<p>Основная задача всех антивирусных средств -- обнаружить (или не дать возможность размножаться) вирусу в системе с максимальной степенью надежности, то есть избежать ошибок первого рода (необнаружения вируса, хотя на самом деле он присутствует) и второго рода -- т.н. "ложных тревог" (обнаружения вируса там, где на самом деле его нет).</p>
<h4><a name="p111">1.1.1. Детекторы и фаги.</a></h4>
<p>Наиболее простой и очевидный класс антивирусных средств, являвшийся основным до недавнего времени. Борьба ведется только с известными вирусами. Детекторы только обнаруживают их в системе, а фаги также "вылечивают" зараженные объекты.</p>
<p>Это группа средств достаточно распространена и основана на сканировании памяти, файлов на внешних носителях, загрузочных записей и других объектов, могущих получить управление (чтобы вирус имел возможность исполняться), с целью обнаружения известных и изученных автором антивирусной программы типов вирусов. В связи с вирусным взрывом (<a href="#p03">см. п. 0.3</a>) важнейшей характеристикой таких программ является возможность оперативного добавления новых типов вирусов в очередных версиях программы.</p>
<p>Хорошо зарекомендовавшие себя, насчитывающие десятки версий программы этого класса практически не подвержены ошибкам второго рода -- если такая программа сообщила о зараженных файлах, то можно быть уверенным, что это действительно так. Однако, если детектор не нашел вирусов в системе, это означает только одно: в системе нет вирусов, на которые он рассчитан, ведь против остальных он бессилен.</p>
<p>Имеется два алгоритма поиска вирусов в исполняемых файлах.</p>
<p>Первый связан с поиском сигнатур или регулярных выражений.</p>
<p>Сигнатурой вируса называется последовательность байтов,</p>
<ol type="a">
<li>встречающаяся во всех его копиях и</li>
<li>не встречающаяся ни в какой другой программе.</li>
</ol>
<p>Однако истинность условия б) невозможно проверить на практике, поэтому для уменьшения вероятности ложных срабатываний необходимо использовать сигнатуры как можно большей длины. (Скорость хорошего алгоритма поиска подпоследовательности только возрастает с увеличением ее длины). Идеальным с точки зрения теории представляется вариант, когда сигнатура совпадает с самим телом вируса, при этом условия а) и б) выполняются автоматически. К сожалению, такой вариант существует на практике чрезвычайно редко, но сигнатуры длиной до 90% от длины вируса для вирусов простой структуры выделить можно. На практике детекторы используют в качестве сигнатуры характерный для этого вируса фрагмент кода (например, из обработчика прерывания) длиной в несколько десятков байт (при средней длине вируса 2-3 Кбайта), что, конечно, ставит истинность условия б) под вопрос.</p>
<p>Таким образом, принцип работы таких детекторов очень прост -- если в каком-либо объекте обнаружена сигнатура, то он считается зараженным. Следует не забывать, что в последнее время появились вирусы, не поддающиеся обнаружению ни с помощью обычных, ни с помощью регулярных сигнатур (<a href="#p321">подробнее см. п. 3.2.1</a>).</p>
<p>Второй алгоритм -- это проверка кода программ. Проверяется область программы, получающая управление в начале, на предмет совпадения с командами вируса, настроенного на данный файл. Например, наличие перехода на определенное смещение от конца программы. Т.о. можно сказать, что в качестве "сигнатуры" (назовем ее структурной) здесь выступает не последовательность байт, а способ имплантации вируса в зараженную программу. В этом случае условие б) выполняться будет достаточно редко, т.к. существует немного способов внедрения вируса в программу, и этот алгоритм будет подвержен также ошибкам и второго рода.</p>
<p>Понятие структурной сигнатуры эффективно применяется и является единственным быстрым критерием при поиске полиморфных вирусов. Под структурной сигнатурой здесь понимается структура алгоритма, т.е. последовательность команд передачи управления и образующиеся при этом ветвления, циклы, вызовы подпрограмм. Недоработка MtE-алгоритма, а именно "предсказуемость" цикла расшифровки, позволила создать MtE-детекторы, не требующие интерпретации кода программ.</p>
<p>На практике применяется сочетание двух методов -- сначала программа проверяется вторым алгоритмом (более быстрым), и лишь в случае нахождения структурной сигнатуры используется первый.</p>
<p>Фаги отличаются от детекторов только тем, что кроме обнаружения вирусов они восстанавливают, если возможно, зараженные области, удаляя из них вирусы. Для процесса восстановления необходимо тщательно изучить алгоритм заражения, чтобы совершить обратные действия. В абсолютном большинстве случаев это оказывается возможным (это следует из того, что вирус должен распространяться, поэтому он сохраняет работоспособность зараженного объекта), хотя необходимо помнить, что речь идет только о восстановлении исполняемого кода, а не о ликвидации всех последствий деструктивных действий вируса.</p>
<p>Наиболее известными программами данного типа для операционной системы MS DOS являются программы Aidstest Д. Н. Лозинского, Scan/Clean фирмы McAfee Associates, Microsoft AntiVirus фирмы Central Point Software, входящий в дистрибутив MS DOS 6.0.</p>
<p>В табл. 1.1 представлена информация о количестве вирусов, обнаруживаемых известными фагами на конец 1994 г.</p>
<table border="1" cellspacing="0" cellpadding="0" summary="Табл. 1.1. Количество обнаруживаемых вирусов программами-детекторами для MS DOS на конец 1994 г.">
<tr><th>Программа </th><th>Число обнаруживаемых вирусов</th></tr>
<tr><td>Aidstest </td><td>1058</td></tr>
<tr><td>Scan/Clean </td><td>2738</td></tr>
<tr><td>Microsoft Antivirus </td><td>более 1000</td></tr>
</table>
<p><strong>Табл. 1.1. Количество обнаруживаемых вирусов программами-детекторами для MS DOS на конец 1994 г.</strong></p>
<h4><a name="p112">1.1.2. Сторожа.</a></h4>
<dl>
<dt>Сторожа (иначе -- блокировщики)</dt>
<dd>это программы, дополняющие функции операционной системы, которые ставят себе целью не пропустить вирус на компьютер или не дать ему совершить свое черное дело, запрещая программам некоторые подозрительные операции, такие как запись в системные области операционной системы, захват некоторых ресурсов, обращения к оперативной или дисковой памяти по абсолютным адресам. Для MS DOS такие программы особенно актуальны, позволяя хоть немного закрыть ее наиболее вопиющие с точки зрения безопасности "дыры".</dd>
</dl>
<p>Однако надежного способа закрыть их без аппаратной поддержки не существует. Пакеты такого типа подвержены ошибкам как первого, так и второго рода. Как показывает практика, подобные программы доставляют большие неудобства пользователям, надоедая навязчивыми сообщениями типа "Разрешать запись в такой-то файл? &lt;Да/Нет&gt;", бесполезными почти во всех случаях. Известны попытки создания интеллектуальных сторожей, пытающихся различать ложные и настоящие тревоги, однако это неизбежно ведет к снижению их надежности.</p>
<p>Несомненным достоинством сторожей является их уникальная способность блокировать РПС в момент попытки нанесения ими ущерба. Таким образом, сторожа защищают не только от вирусов, но и от троянских коней.</p>
<p>Наиболее известными программами этого класса для IBM PC являются пакет Flu-shot+ и антивирусный монитор -D Е.Касперского. Сравнительный анализ функций этих программ приведен в табл. 1.2.</p>
<table border="1" cellspacing="0" cellpadding="0" summary="Табл. 1.2. Сравнительный анализ сторожей для MS DOS.">
<tr><th>Функция</th><th>Flu-Shot+ </th><th>-D</th></tr>
<tr><td>Изменение или переименование СОМ, ЕХЕ и SYS -файлов</td><td>+</td><td>+</td></tr>
<tr><td>Оставление резидента</td> <td>+</td><td>+</td></tr>
<tr><td>Уменьшение размера свободной памяти DOS</td> <td>-</td><td>+</td></tr>
<tr><td>Уменьшение размера системных буферов</td> <td>+</td><td>+</td></tr>
<tr><td>Запись на диск по абсолютному адресу</td> <td>+</td><td>+</td></tr>
<tr><td>Форматирование диска</td> <td>+</td><td>+</td></tr>
<tr><td>Запись в MBR или BOOT-сектор</td> <td>+</td><td>+</td></tr>
<tr><td>Вызов нестандартных функций DOS</td> <td>-</td><td>+</td></tr>
</table>
<p><strong>Табл. 1.2. Сравнительный анализ сторожей для MS DOS.</strong></p>
<h4><a name="p113">1.1.3. Ревизоры.</a></h4>
<p>Программы этой группы основаны на сравнении контрольной информации о файлах, файловой системе, загрузочных областях и других элементах вычислительной среды с текущим их состоянием с целью обнаружения изменений, производимых вирусами, и локализации зараженных или поврежденных объектов. Осуществляется это очень просто -- ревизор сначала сохраняет эталонную информацию (в виде контрольных сумм, например) об этих элементах, а впоследствии проверяет соответствие начальных и текущих значений.</p>
<p>Неоспоримым преимуществом ревизоров является их устойчивость к ошибкам первого рода: если ревизор сообщает, что объект изменился, значит, это действительно так. Правда, они подвержены ошибкам второго рода -- ревизор не в состоянии определить, в результате чего изменилась программа -- потому что ее поразил вирус, или ее просто перетранслировали. Неудобство таких программ заключается в необходимости периодического сканирования вычислительной среды и большом числе ложных тревог. В связи с "вирусным взрывом" (см. введение) программы-ревизоры становятся единственным классом антивирусных средств, гарантирующих пользователю хоть какую-то безопасность.</p>
<p>Наиболее известная программа этого класса -- Adinf Д. Мостового.</p>
<h4><a name="p114">1.1.4. Вакцины.</a></h4>
<p>В то время, когда аналогия между компьютерными вирусами и их биологическими собратьями просматривалась очень четко (отсюда и произошла все современная терминология, включая само слово "вирус"), большие надежды возлагались на самые перспективные средства защиты от биологических вирусов -- вакцины. Они призваны создать такие условия для вируса (компьютерного или биологического), делающее его размножение невозможным.</p>
<p>Подавляющее большинство компьютерных вирусов проверяют возможность заражения объекта -- хватит ли памяти, не имеется ли там уже копия вируса и т.п. Поэтому задача вакцины -- изменить этот объект или вычислительную среду так, чтобы условие возможности заражения стало ложным.</p>
<p>Для вакцин можно с некоторой натяжкой говорить об ошибках первого рода (маловероятно, что вакцина не сработает против того, чего должна), но нет никакого смысла обсуждать ошибки второго рода.</p>
<p>Успешно вакцины можно применять тогда, когда способ заражения объекта не может сильно варьироваться (в связи со свойствами самого объекта). Для MS DOS такими объектами служат BOOT-сектора и MBR, и в последнее время они с успехом вакцинируются, в т.ч. на уровне BIOS.</p>
<p>На сегодняшний день нет вакцин (вернее было бы сказать -- уже нет вакцин) в MS DOS для файлов, но они должны появиться в других операционных системах как их компонент, затрудняющий распространение вирусов.</p>
<h4><a name="p115">1.1.5. Перспективные средства защиты.</a></h4>
<p>К этой группе относятся следующие средства:</p>
<ul>
<li>универсальные;</li>
<li>адаптивные и самообучающиеся;</li>
<li>интеллектуальные.</li>
</ul>
<dl>
<dt>Универсальные средства</dt>
<dd>это те, которые претендуют на противостояние абсолютно всем вирусам. С точки зрения практики невозможность создания такого средства очевидна, причем очевидно также и обратное -- нет "универсального вируса" (типа СПИДа), против которого бессильно любое средство. Как для любого вируса можно создать программу, борющуюся с ним тем или иным способом, так и для любого антивируса можно написать вирус, преодолевающий его. Ф. Коэн в своей классической работе <a href="#L9">[9]</a> доказал, что нельзя создать универсальную процедуру, решающую, есть ли в предъявляемой ей программе вирус или нет (<a href="#p212">см. п. 2.1.2</a>). Л. Адлеман подтвердил этот факт, показав, что множество всех вирусов не перечислимо <a href="#L10">[10]</a>.</dd>
<dt>К адаптивным и самообучающимся средствам относят те,</dt>
<dd>которые автоматически расширяют список вирусов, которым они противостоят. Это в первую очередь средства, содержащие постоянно пополняемые базы вирусов. Наиболее привлекательной выглядит идея создания самообучающегося средства, которое при встрече с неизвестным ему вирусом автоматически анализирует его и добавляет в свой арсенал. Для простых типов вирусов такой алгоритм, автоматически выделяющий сигнатуру вируса, уже создан <a href="#L11">[11]</a>.</dd>
<dt>Интеллектуальные средства</dt>
<dd>базируются на системах логического вывода. Их суть сводится к определению алгоритма и спецификации программы по ее коду и выявлению таким образом программ, осуществляющих несанкционированные действия. Именно к этому классу относится метод, предлагаемый в данной работе.</dd>
</dl>
<h4><a name="p116">1.1.6. Сравнительный анализ существующих средств защиты от вирусов</a></h4>
<p>Результаты этого анализа приведены в табл. 1.3. Она подтверждает, что самыми совершенными на сегодняшний день являются ревизоры, самыми неудачными -- вакцины, а перспективные средства (в перспективе) должны были бы превосходить любое из представленных.</p>
<table border="1" cellspacing="0" cellpadding="0" summary="Табл. 1.3. Сравнительная характеристика антивирусных средств для операционной системы MS DOS.">
<tr><th>Характеристика </th><th>Детекторы </th><th>Фаги </th><th>Сторожа</th><th>Ревизоры</th><th>Вакцины</th><th>Перспективн. </th><th>Коэф. значим.</th></tr>
<tr><td>Обнаружение/ неразмножение известных вирусов </td><td>+ </td><td>+ </td><td>+ </td><td>+ </td><td> + </td><td> + </td><td> 8 </td></tr>
<tr><td>Лечение известных вирусов </td><td>- </td><td>+ </td><td>- </td><td>+/- </td><td> ? </td><td> + </td><td> 4 </td></tr>
<tr><td>Обнаружение/не размножение неизвестных вирусов </td><td>- </td><td>- </td><td>+ </td><td>+ </td><td> - </td><td> + </td><td> 16 </td></tr>
<tr><td>Лечение неизвестных вирусов </td><td>- </td><td>- </td><td>- </td><td>+/- </td><td> - </td><td> +/- </td><td> 4 </td></tr>
<tr><td>Возможность борьбы с большим количеством вирусов </td><td>+ </td><td>+ </td><td>+ </td><td>+ </td><td> - </td><td> + </td><td> 8 </td></tr>
<tr><td>Количество обнаруживаемых типов вирусов </td><td>С </td><td>С </td><td>С </td><td>В </td><td> Н </td><td> В </td><td> 12 </td></tr>
<tr><td>Надежность (отсутствие ошибок первого рода) </td><td>В </td><td>В </td><td>С </td><td>В </td><td> В </td><td> С </td><td> 6 </td></tr>
<tr><td>Адекватность (отсутствие ошибок второго рода) </td><td>В </td><td>В </td><td>Н </td><td>Н </td><td> ? </td><td> С </td><td> 4 </td></tr>
<tr><td>Нетребовательность к ресурсам (памяти, времени) </td><td>В </td><td>В </td><td>С </td><td>Н </td><td> Н </td><td> Н </td><td> 4 </td></tr>
<tr><td>Взвешенная оценка, балл </td><td>4.0 </td><td>4.4 </td><td>4.8 </td><td>6.0 </td><td>2.0 </td><td>6.1 </td><td>7.3 </td></tr>
</table>
<p><strong>Табл. 1.3. Сравнительная характеристика антивирусных средств для операционной системы MS DOS.</strong></p>
<p>Символы означают:</p>
<ul>
<li>+/- -- функция реализована не полностью</li>
<li>? -- программа для этого не предназначена</li>
<li>В -- высокая</li>
<li>С -- средняя</li>
<li>Н -- низкая</li>
</ul>
<h3><a name="p12">1.2. Недостатки существующих антивирусных средств применительно к современной ситуации.</a></h3>
<p>Рассмотрим теперь недостатки перечисленных групп средств применительно к сегодняшней ситуации с компьютерными вирусами. Как указывалось во введении, она характеризуется двумя тенденциями -- соответственно, антивирусным средствам приходится решать две проблемы:</p>
<ol>
<li>с одной стороны, это -- экспоненциальный вирусный взрыв и появление генераторов вирусов, приводящее к тому, что тысячами появляются примитивные вирусы, которые нетрудно исследовать и включить в базу данных фага, но за их количеством просто не успеть;</li>
<li>с другой стороны, появление новых изощренных типов вирусов, затрудняющих их обнаружение или лечение, таких как: вирусы-драйверы (знаменитый Dir), полиморфные вирусы (в т.ч. широко известные MtE-вирусы) и другие, многие из которых описаны в <a href="#L12">[12]</a>. Причем фантазия авторов вирусов неисчерпаема, и появление в будущем абсолютно новых типов вирусов не исключено.</li>
</ol>
<p>Недостатки детекторов и фагов вытекают из их основной характеристики, что они могут бороться только с известными им вирусами. В последнее время появились программы, не требующие для обновления версии получения новой программы, а использующие открытую и постоянно пополняемую (в т.ч. и самим пользователем) базу данных. Но это, конечно, нельзя назвать решением проблемы 1. Более того, проблема 2 также оказывается непосильной для детекторов -- вирусы с само модифицирующимся расшифровщиком не могут быть обнаружены простым сигнатурным поиском. Эта проблема вроде бы успешно решалась до последнего времени введением понятия "регулярная сигнатура" (<a href="#p321">см. п. 3.2.1</a>), но после появления полиморфных вирусов такие сигнатуры оказались также непригодны для детектирования зараженных объектов.</p>
<p>Все вышесказанное относится и к вакцинам, которые оказываются еще более худшим антивирусным средством. Дело в том, что защита даже от нескольких известных вирусов с помощью них невозможная. Вакцинация от десятка вирусов приведет к тому, что вычислительная среда будет настолько сильна изменена (появятся новые обработчики прерываний, все файлы будут сильно искажены), что компьютерная система будет работать неустойчиво или не будет работать вовсе. О каких тысячах вирусов может тогда вестись речь! Также нетрудно представить себе 2 вируса, использующие такие условия возможности заражения, что ложность первого из них эквивалентна истинности второго, и поэтому вакцинация от обоих этих вирусов сразу просто невозможна. (Например, пусть один гипотетический вирус заражает только файлы длиной больше 32K, а другой -- только меньше).</p>
<p>Рассмотрим далее классы антивирусных средств, вроде бы направленных на борьбу с неизвестными вирусами.</p>
<p>Сторожам в принципе все равно, известный или новый вирус пытается отформатировать жесткий диск. Но! Только если он пытается сделать это каким-то предусмотренным автором антивируса способом. Таким образом, проблема 2 -- появление новых вирусных идей остается для сторожей открытой. Ну и большое неудобство, что на очень многие полезные программы сторож будет "ругаться", доводя пользователя до исступления.</p>
<p>Ревизоры, как уже подчеркивались, являются на сегодняшний день наиболее надежным и дающим хоть какую-то гарантию антивирусным средством. В частности, с проблемой 1 они прекрасно справляются. Но они также имеют несколько существенных недостатков. Первый очевиден -- если в момент установки ревизора в компьютерную систему там уже присутствовал вирус, он это никак не обнаружит ни при установке, ни в дальнейшем (если вирус будет достаточно аккуратен), вплоть до часа Х, когда присутствие вируса в системе уже будет понятно и без ревизора. Проблема 2 дает себя знать во втором недостатке -- если вирус применяет какую-то новую идею по внедрению в компьютерную систему, неизвестную ревизору, он не будет обнаружен. И наконец, информация, сформированная ревизором, в 99% случаев потенциально доступна любой программе, а, значит, и вирусу, который может ее исказить так, что ревизор не будет реагировать на его внедрение; или просто уничтожить, в результате чего ревизор вынужден будет собирать всю информацию заново при наличии активного вируса в системе!</p>
<p>Таким образом, мы видим, что ни одно из существующих антивирусных средств не справляется в полной мере с современной ситуацией, а средств зашиты от других РПС (кроме вирусов и троянский коней) на сегодняшний день вообще нет.</p>
<h3><a name="p13">1.3. Постановка задачи работы.</a></h3>
<p>Итак, мы видим, что для концепции открытых компьютерных систем (когда входные и выходные потоки информации ничем и никем не контролируются) нет удовлетворительного решения проблемы защиты от РПС. С другой стороны, если в полностью зарытой (изолированной) компьютерной системе изначально нет РПС, то они никогда не смогут появиться в ней. (Не будем рассматривать ситуацию, когда РПС создаются внутри этой системы -- во-первых, это больше организационная проблема, а во-вторых, в этом случае такую компьютерную систему можно рассматривать как совокупность маленьких изолированных, к каждой из которых применимы данные рассуждения).</p>
<p>Однако концепция полностью закрытой системы вряд ли сможет стать жизнеспособной (кроме разве что военных, секретных и т.п. систем -- но даже в этом случае то программное обеспечение, функционирующее внутри, должно быть сертифицировано, в т.ч. и на предмет отсутствия РПС). Поэтому была сформулирована идея "полуоткрытой" (или "полузакрытой", если вы пессимист) компьютерной системы, иначе "шлюзовой" системы <a href="#L13">[13]</a> (см. рис. 1.1). В ней предполагается контроль всей поступающей информации на предмет наличия в ней РПС. Естественно, что РПС должны находиться в информации, подлежащей исполнению, т.е. в программном коде (на любом языке). Проблема сертификации программного обеспечения на языке высокого уровня является трудной, но в достаточной степени исследованной и здесь рассматриваться не будет.</p>
<div align="center">
<img src="img/asa00_ru/Image89.gif" alt="Рис. 1.1 Схема шлюзовой компьютерной системы"/>
<p><strong>Рис. 1.1. Схема шлюзовой компьютерной системы</strong></p>
</div>
<p>Поэтому задачу, которую хотелось бы решить, можно сформулировать как поиск РПС (в т.ч. и неизвестных заранее) в исполняемом программном коде.</p>
<p>Она разбивается на ряд подзадач:</p>
<ol>
<li>Задача представления РПС. Состоит в создании адекватных моделей, удобных как для теоретического, так и практического применения. Этому посвящена следующая глава. </li>
<li>Особенности поиска РПС в исполняемом коде и возможность использования традиционных методов анализа ПО.</li>
<li>Разработка структуры интеллектуальной системы анализа исполняемого кода программ ИСАИПК. Этим две задачи рассматриваются в главе 3.</li>
<li>Реализация такой системы. В главе 4 будут описаны некоторые принципы построения и конкретные алгоритмы системы SubLVA.</li>
</ol>
<h2><a name="p2">Глава 2. Определение, модели и классификация РПС.</a></h2>
<p>Организация эффективной системы борьбы с различными видами РПС невозможна без разработки формализованной модели, описывающей их структуру и принципы функционирования. Наличие такой модели позволит создать универсальные средства противодействия, повысить их эффективность и определить область применения. Кроме того, такая модель может быть использована для определения условий распространения РПС (в частности, компьютерных вирусов), а также и для построения различных средств противодействия их распространению.</p>
<p>Основные работы, которые касаются данной предметной области, можно условно отнести к трем направлениям:</p>
<ol>
<li>Теоретические исследования, направленные на создание общих математических моделей, описывающих вирусы как специальные программы или математические объекты [10, 14].</li>
<li>Определение набора признаков, присущих конкретным вирусам и построение классификаций на базе этих признаков. В нашей стране самой фундаментальной работой такого типа является работа Н. Н. Безрукова <a href="#L1">[1]</a>. Построение таких классификаций необходимо для отождествления вирусов друг с другом и формирования однородных классов и групп вирусов, однако они не могут помочь при решении задач их поиска и уничтожения.</li>
<li>Построение моделей, описывающих структуру вируса как набор функциональных элементов, определяющих типовые алгоритмы воздействия вирусов на другие объекты: программы, данные, операционную среду. Пример такого подхода показан в <a href="#L15">[15]</a>.</li>
</ol>
<p>Последний подход, по мнению автора, выглядит наиболее перспективным, поскольку позволяет получить практические решения для задач поиска, обнаружения и ликвидации всех классов РПС, а не только компьютерных вирусов. Чтобы убедиться в правомерности такого предположения, рассмотрим ситуацию с компьютерными вирусами с точки зрения работ первого направления.</p>
<h3><a name="p21">2.1. Отсутствие строгого определения компьютерного вируса.</a></h3>
<p>Совершенно очевидно, что основным свойством вируса, с помощью которого его и надо определять, является способность к саморепродукции (репликации), т.е. к размножению и порождению себе подобных. Однако оказывается, что строго это сделать не так просто, в частности, для этого необходимо иметь формальное определение "саморепродукции" в компьютерных системах. Попытка уйти от этого делается в классическом определении вируса.</p>
<h4><a name="p211">2.1.1. Классическое определение компьютерного вируса.</a></h4>
<p>Оно остается неизменным с 1984 г., когда оно было дано Ф.Коэном в своей основополагающей работе <a href="#L9">[9]</a> и звучит как: "компьютерный вирус -- это программа, которая может заражать другие программы, изменяя их посредством добавления своей, возможно модифицированной, копии, которая сохраняет способность к дальнейшему размножению".</p>
<p>Как мы видим, Ф. Коэн уходит от понятия "саморепродукция" изменяет его производным -- "заражение" (раз вирус должен размножаться, то в результате этого некоторые объекты должны приобрести копию вируса, т.е. заразиться), считая его определяющим свойством вируса.</p>
<p>При внимательном разборе этого определения сразу возникает ряд вопросов:</p>
<ol>
<li>что это за "копии", которые могут быть "модифицированными", т.е. не совпадать с оригиналом? (Напомним, что каждый потомок полиморфных вирусов не будет совпадать со своим родителем ни в одном байте!). Очевидно, здесь имеются в виду возможность вируса к мутациям, когда в новую копию он может вставлять случайные ничего не значащие команды, шифровать свое тело с другим ключом и т.д. Назовем такие изменения вируса, не затрагивающие его алгоритм, простыми мутациями.</li>
<li>далее, почему вирус должен ограничиваться только такими мутациями? Нетрудно представить себе вирус-родитель, который способен нанести ущерб компьютерной системе, и порождающий потомков, также способных к саморепродукции, но не предназначенных для нанесения ущерба, т.е. совершенно непохожих на родителя. Такие кардинальные изменения вируса назовем эволюционными мутациями.</li>
<li>почему разговор ведется только о программах? Как известно, новые типы вирусов могут внедряться в другие объекты, модифицируя их и вычислительную среду так, что при запуске программы они получают управление. (Пример -- вирус Dir, ничего не меняющий в файлах, так модифицирует таблицу расположения файлов (FAT), что запуск любой программы приводит сначала к исполнению вируса).</li>
<li>сетевые черви полностью выпадают из этого определения, т.к. они заражают не отдельную программу, а целую компьютерную систему</li>
</ol>
<p>Неоднократно делались попытки улучшить это определение. Одна из таких последних попыток принадлежит П. Петерсону (P. Peterson) в редакции Б. Себорга (B. Seborg) <a href="#L16">[16]</a>, которые определяют компьютерный вирус как "саморепродуцирующуюся программу, которая может заражать другие программы, модифицируя их или их среду (environment) так, что запуск (call) зараженной программы приводит к запуску возможно претерпевшей эволюцию (evolved) и в большинстве случаев функционально подобной копии вируса".</p>
<p>Это попытка закрыть первые три дыры в определении Коэна, но при этом появляются другие неопределенные понятия: "копия, претерпевшая эволюцию", "функционально подобная копия", которые еще и рассматриваются только в "большинстве случаев".</p>
<h4><a name="p212">2.1.2. Невозможность создания универсального антивируса с точки зрения классического определения.</a></h4>
<p>Ф. Коэн, основываясь на своем определении, строго доказывает, что обнаруживать вирусы, используя только их основное свойство -- заражение, невозможно.</p>
<p>Чтобы определить, что данная программа P является вирусом, должно быть установлено, что P заражает другие программы. Пусть D -- это гипотетическая функция, которая возвращает значения "истина" тогда и только тогда, когда ее аргумент является вирусом. Тогда P сама может использовать эту функцию D и заражать другие программы только тогда, когда D(P) возвращает "ложь" (см. прог. 1).</p>
<pre class="source">  
VIRUS CV
{
	VIRUS;		// Признак наличия вируса в программе для повторного
			// ее незаражения
	если не D (CV) то
	{
		ЗАРАЗИТЬ_ПРОГРАММУ;
		если УСЛОВИЕ_СРАБАТЫВАНИЯ то МАНИПУЛЯЦИИ;
	}
	передать управление зараженной программе;
}
</pre>
<p><strong>Прог. 1.Вирус с противоречием.</strong></p>
<p>Если процедура D принятия решения определяет, что CV -- это вирус, то CV не будет заражать другие программы и не будет таким образом вирусом по определению. Если D определяет, что CV -- не вирус, то CV будет заражать другие программы и поэтому будет вирусом. Отсюда следует, что процедура принятия решения D противоречива и создать ее невозможно. Таким образом, универсального антивируса не существует и точное обнаружение вируса без его запуска является неразрешимой задачей.</p>
<p>Не является ли тогда бессмысленными после приведенного доказательства все дальнейшие рассуждения (ведь мы строим, в принципе, универсальную программу, определяющий принадлежность входной программы к РПС)? Более того, какое бы формальное определение вируса мы не дали (например, "вирус -- это программа, наносящая вред" или даже "вирус -- это программа, выводящая "Hello, world"), всегда можно построить программу, аналогичную приведенной выше, чтобы убедиться в невозможности построения той злополучной функции D.</p>
<p>Вывод: надо искать в другой плоскости.</p>
<h4><a name="p213">2.1.3. Рекурсивные определения вируса.</a></h4>
<p>Очень заманчивым с точки зрения формализации кажется следующее определение вируса: "вирус -- это программа, способная порождать другие вирусы". Увы, оно рекурсивно неразрешимо: нет условия окончания рекурсии.</p>
<p>Тут мы сталкиваемся с почти философской проблемой -- как определить объекты, ключевым свойством которых является порождение себе подобных, причем подобие определяется с помощью того же свойства -- порождать себе подобных и т. д.</p>
<p>Попытаемся дать более точное рекурсивное определение вируса. Во-первых, очень легко можно решить проблему простых мутаций вируса, если мы будем говорить, что понимаем под вирусом не программу, а алгоритм, число возможных реализаций которого на конкретном языке может быть любым. Тогда любые простые мутации вируса будут эквивалентны друг другу по своему алгоритму и простой мутирующий вирус можно определить как "алгоритм, который может порождать эквивалентный ему алгоритм и обеспечивать возможность получения им управления".</p>
<p>Во-вторых, что касается эволюционных мутаций, то здесь, наоборот, порождаются совершенно не эквивалентные по алгоритму вирусы.</p>
<p>Очень интересным здесь является вопрос о существовании алгоритмов, способных порождать бесконечное количество неэквивалентных алгоритмов. Например, пусть каждая новая копия вируса сдвигает срок своего проявления на один день. Таким образом, казалось бы, мы получим бесконечное число различных вирусов. Но это не так, потому что данные, где хранится дата проявления, имеют фиксированный размер, и рано или поздно произойдет переполнение. Размер данных не может увеличиваться до бесконечности, т.е. длина вируса тоже имеет ограничение, иначе, если длина каждой новой копии увеличивается, то однажды ему не хватит памяти для записи новой копии и таким образом будет нарушена способность к дальнейшему порождению. Эти, правда, не очень строгие рассуждения позволяют сделать заключение, что бесконечно неповторяющегося мутирующего вируса быть не может, и рекурсия заканчивается либо на повторении, либо на порождении алгоритма, неспособного к дальнейшему размножению.</p>
<p>Заметим также, что термин "порождать", хотя он не может быть строго определен, означает именно процесс рождения "из ничего", без всяких входных данных, иначе очень много обычных программ попали бы под определение вируса (например, транслятор, "порождающий" исполняемый код из исходного).</p>
<p>Тогда полное определение компьютерного вируса может звучать так: "Компьютерный вирус (саморепродуцирующийся алгоритм) -- это алгоритм, который может порождать без использования входных данных:</p>
<ol type="a">
<li>либо алгоритм, неспособный к порождению других;</li>
<li>либо алгоритм, эквивалентный одному из его родителей, и обеспечивать возможность получения им управления;</li>
<li>либо новый компьютерный вирус, неэквивалентный по алгоритму любому из его родителей".</li>
</ol>
<p>Vi -- комп. вирус, если он порождает Vi+1 , где</p>
<p>б) Vi+1 -- алгоритм | $ j, j=1..i, Vi ~ Vj</p>
<p>в) Vi+1 -- комп. вирус | " j, j=1..i, Vi !~ Vj</p>
<p>Однако, как было показано (<a href="#p212">см. п. 2.1.2</a>), и это свойство -- порождение других алгоритмов -- нельзя использовать для обнаружения компьютерных вирусов по внешнему виду. Поэтому мы перейдем к рассмотрению моделей и определений, пригодных с практической точки зрения.</p>
<h3><a name="p22">2.2. Функциональное представление и определение РПС.</a></h3>
<p>Наиболее приближенным к практике является подход, представляющий РПС в виде системы концептов (понятий) на функциональном уровне. Хотя он и не позволяет получить результаты столь глобального характера, как при математическом моделировании, но с точки зрения создания теоретических основ поиска РПС появляются возможности: во-первых, создать обобщенную концептуальную модель РПС для структурирования знаний по РПС и выбора способа их представления; во-вторых, реализовать целенаправленный поиск функциональных элементов РПС в прикладных программах; в-третьих, решить задачу создания структурно-алгоритмического образа РПС. Тем самым становится возможным переход к построению программной модели (синтезу) РПС для исследования механизмов его работы.</p>
<p>При введении понятия РПС было замечено, что наиболее важной их характеристикой является способность к нанесению ущерба компьютерной системе. Однако важно отметить, что такую характеристику не так просто конкретизировать и сопоставить ей конкретные признаки. Связано это с двумя причинами: во-первых, любая прикладная программа, заведомо не относящаяся к числу РПС, потенциально может содержать в себе алгоритмические ошибки, проявление которых приведет к разрушению элементов вычислительной среды. Во-вторых, злоумышленник-пользователь может нанести ущерб элементам операционной или вычислительной среды, используя штатное программное обеспечение (системные или сервисные программы ОС), превращая его в РПС.</p>
<p>Таким образом, мы получаем первый функциональный элемент, часто встречающийся в РПС -- процедуру нанесения ущерба (ПНУ, другие названия: нарушения целостности, нападения, разрушения), под результатом действия которой будем понимать нанесение ущерба компонентам вычислительной среды.</p>
<p>Не менее значимым для РПС является наличие еще двух элементов: процедуры саморепродукции (ПСР) и процедуры преодоления защиты (ППЗ), также являющиеся "вредными", т.е. не встречающиеся в "хороших" программах.</p>
<p>Как показано в п. 2.1, точного определения понятия саморепродукции по отношению к программам не существует. По аналогии с биологическими системами мы будем понимать под свойством саморепродукции способность к порождению некоторого программного кода. Это несколько расширяет приведенное рекурсивное определение саморепродуцирующегося алгоритма, но для практического применения является пригодным).</p>
<p>Под процедурой преодоления защиты понимается попытка преодоления системной и/или дополнительной защиты. Системной защитой будем называть систему безопасности, являющуюся частью ОС (система разделения пользователей, защита доступа к файлам, защита ядра ОС). Под дополнительной защитой понимаются все компоненты системы безопасности, не являющиеся частью ОС (обычно это системы криптографической защиты и т. д.). Факт преодоления системы защиты означает осуществление действий, запрещаемых системой защиты (получение неавторизованного доступ, подбор пароля и т. д.).</p>
<p>Тогда на основе этих трех элементов можно дать функциональное определение РПС: под РПС будем понимать программный код, реализующий одну из этих процедур.</p>
<p>Далее можно сформулировать условия необходимости и достаточности, позволяющее провести классификацию РПС по трем основным классам (иллюстрация на рис. 3):</p>
<ol type="a">
<li>Необходимым и достаточным условием для отнесения РПС к классу компьютерных вирусов является наличие в его составе процедуры саморепродукции.</li>
<li>Необходимым для отнесения РПС к классу троянских коней является наличие в его составе процедуры нанесения ущерба, а достаточным -- отсутствие процедуры саморепродукции.</li>
<li>Необходимым условием для отнесения РПС к классу средств НСД является наличие в его составе процедуры преодоления защиты, а достаточным -- отсутствие процедур саморепродукции и нанесения ущерба.</li>
</ol>
<div align="center">
<img src="img/asa00_ru/Image91.gif" alt="Рис. 3 Признаки классификации РПС по условию необходимости и достаточности"/>
<p><strong>Рис. 3 Признаки классификации РПС по условию необходимости и достаточности</strong></p>
</div>
<p>Приведенная классификация является единой формализованной формой представления различных видов РПС. Более того, такое представление не только не противоречит основному принципу современной технологии программирования -- принципу модульности, -- когда программа строится в виде совокупности процедур, но и хорошо согласуясь с ним, дает некоторую базу для создания методик поиска РПС (или элементов РПС) в исполняемых кодах программ, основанных на такой концептуальной модели РПС.</p>
<p>Введя дополнительный набор возможных функциональных элементов РПС: процедуру захвата управления, процедуру мутации, процедуру синтеза, процедуру шифровки и т.п., можно построить обобщенную концептуальную модель (рис. 4) в виде совокупности его функциональных элементов. Обобщенная модель отражает возможную структуру трех основных классов РПС.</p>
<div align="center">
<img src="img/asa00_ru/Image92.gif" alt="Рис. 4 Обобщенная концептуальная модель РПС"/>
<p><strong>Рис. 4. Обобщенная концептуальная модель РПС</strong></p>
</div>
<h3><a name="p23">2.3. Классификация РПС на базе их функциональной модели.</a></h3>
<p>Учитывая введенные три основные функции, присущие РПС, получаем 8 различных их комбинаций, т.е. видов РПС (9-ая не является РПС). В зависимости от того, какой признак мы будем рассматривать в качестве базового, можно построить три возможных классификаций РПС (табл. 4, 5, 6).</p>
<table border="1" cellspacing="0" cellpadding="0" summary="Таблица 4. Классификация РПС на база вирусов">
<tr><th rowspan="3">Признак</th><th colspan="7"> Классификация</th></tr>
<tr><th colspan="4">Вирусы</th><th colspan="2" rowspan="2">Средства НСД</th><th rowspan="2">Тр. кони</th></tr>
<tr><th>безопасные</th><th>проникающие</th><th>разрушающие</th><th>разрушающие и проникающие</th></tr>
<tr><td>Саморепродукция </td><td>X</td><td>X</td><td>X</td><td>X</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Преодоление защиты </td><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>X</td><td>X</td><td>X</td><td>&nbsp;</td></tr>
<tr><td>Нанесение ущерба </td><td>&nbsp;</td><td>&nbsp;</td><td>X</td><td>X</td><td>&nbsp;</td><td>X</td><td>X</td></tr>
</table>
<p><strong>Таблица 4. Классификация РПС на база вирусов</strong></p>
<table border="1" cellspacing="0" cellpadding="0" summary="Таблица 5. Классификация РПС на базе средств НСД">
<tr><th rowspan="3">Признак</th><th colspan="7"> Классификация</th></tr>
<tr><th colspan="4">Средства НСД</th><th colspan="2" rowspan="2">Вирусы</th><th rowspan="2">Тр. кони</th></tr>
<tr><th>проникающие</th><th>самораспространяющиеся</th><th>разрушающие</th><th>разрушающие и самораспространяющиеся</th></tr>
<tr><td>Саморепродукция </td><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>X</td><td>X</td><td>X</td><td>&nbsp;</td></tr>
<tr><td>Преодоление защиты </td><td>X</td><td>X</td><td>X</td><td>X</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Нанесение ущерба </td><td>&nbsp;</td><td>&nbsp;</td><td>X</td><td>X</td><td>&nbsp;</td><td>X</td><td>X</td></tr>
</table>
<p><strong>Таблица 5. Классификация РПС на базе средств НСД</strong></p>
<table border="1" cellspacing="0" cellpadding="0" summary="Таблица 6. Классификация РПС на базе троянских коней">
<tr><th rowspan="3">Признак</th><th colspan="7"> Классификация</th></tr>
<tr><th colspan="4">Троянские кони</th><th colspan="2" rowspan="2">Вирусы</th><th rowspan="2">Ср. НСД</th></tr>
<tr><th>простые</th><th>самораспространяющиеся</th><th>проникающие</th><th>самораспространяющиеся и проникающие</th></tr>
<tr><td>Саморепродукция </td><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>X</td><td>X</td><td>X</td><td>&nbsp;</td></tr>
<tr><td>Преодоление защиты </td><td>&nbsp;</td><td>&nbsp;</td><td>X</td><td>X</td><td>&nbsp;</td><td>X</td><td>X</td></tr>
<tr><td>Нанесение ущерба </td><td>X</td><td>X</td><td>X</td><td>X</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
</table>
<p><strong>Таблица 6. Классификация РПС на базе троянских коней</strong></p>
<p>Наконец, можно классифицировать все известные виды РПС по предлагаемым признакам (табл. 7). Как видно, различий между троянскими конями и программными закладками здесь нет, что вполне естественно, т.к. как-то конкретизировать функции, присущие только программным закладкам, чрезвычайно трудно.</p>
<h3><a name="p24">2.4. Резюме.</a></h3>
<p>Итак, для определения принадлежности программы к РПС нам достаточно найти в ее составе одну из процедур: саморепродукции, нанесения ущерба, преодоления защиты. Чтобы определить, что данная процедура принадлежит к числу искомых, необходимо проанализировать ее семантический смысл, т.е. понять алгоритм.</p>
<p>Таким образом, задача, поставленная в главе 1, может быть конкретизирована как семантический анализ исполняемого кода программ на предмет наличия заданной функции.</p>
<p>Поэтому пора рассмотреть методы анализа исполняемого кода, что и будет сделано в следующей главе.</p>
<h2><a name="p3">Глава 3. Поэтапный подход к анализу исполняемого кода программ и общая структура системы анализа.</a></h2>
<h3><a name="p31">3.1. Поэтапная схема анализа исполняемого кода.</a></h3>
<p>При анализе программ на любом языке обязательно присутствуют три этапа (цифры соответствуют рис. 5 и рис. 8):</p>
<ol>
<li value="2">лексический анализ;</li>
<li value="4">синтаксический анализ;</li>
<li value="6">семантический анализ.</li>
</ol>
<p>Первые два из них обычно осуществляются автоматически (например, компиляторами), а семантику отслеживает человек. В этой главе мы попытаемся применить эту схему и к анализу программ в исполняемом коде, хотя точной аналогии между понятиями, существующими в теории компиляторов и вводимыми здесь, провести нельзя.</p>
<p>Каждый из этих этапов также требует предварительной подготовки:</p>
<ol>
<li>выделение чистого кода -- удаление кода, отвечающего за защиту этой программы от несанкционированного запуска, копирования и т.п. и преобразование остального кода в стандартный, правильно интерпретируемый дизассемблером. Как частные случаи, это может быть разархивация, расшифровка кода;</li>
<li value="3">дизассемблирование -- перевод команд на язык ассемблера;</li>
<li value="5">перевод в форму, удобную для следующего этапа -- выделение основных процедур, циклов и др. управляющих конструкций, основных структур данных, а также, возможно, перевод на язык более высокого уровня (ЯБВУ);</li>
</ol>
<p>Таким образом, общая поэтапная схема анализа программ будет выглядеть так (рис. 5):</p>
<div align="center">
<img src="img/asa00_ru/Image99.gif" alt="Рис. 5 Поэтапная схема анализа исполняемого кода"/>
<p><strong>Рис. 5. Поэтапная схема анализа исполняемого кода</strong></p>
</div>
<h4><a name="p311">3.1.1. Выделение чистого кода.</a></h4>
<p>Задачей первого этапа анализа исполняемого кода программ является подготовка его к этапу лексического анализа и дизассемблирования. Можно назвать две основные причины, по которым исполняемый код может быть затруднен для дизассемблирования. Это:</p>
<ol>
<li>специально предпринятые меры для противодействия исследованию этого кода. Такой код будем называть защищенным, а алгоритмы, их реализующие -- системами собственной защиты программ.</li>
<li>меры, направленные на преобразование кода в другую форму и не преследующие задачи противодействия. Чаще всего это архивация или шифрация исходного кода. (Шифрация может применяться и с полезными целями: например, преобразование кода так, чтобы он состоял только из печатаемых символов -- это необходимо для пересылки его по каналам электронной почты). Для простоты такие алгоритмы тоже будем называть системами защиты.</li>
</ol>
<p>Таким образом, преобразованный код будет состоять из процедуры защиты (дешифровки) и защищенной (зашифрованной) части, а алгоритмам, отвечающим за восстановление чистого кода, необходимо проделать обратные действия:</p>
<ul>
<li>удалить систему защиты и</li>
<li>преобразовать оставшийся код в стандартный.</li>
</ul>
<p>Здесь мы сталкиваемся с той же проблемой: чтобы удалить систему защиты, надо понять, как она работает, т.е. провести семантический анализ ее алгоритма.</p>
<p>Однако, если ввести ограничение (справедливое для большинства защит и упаковщиков программ), что система защиты не включается в программу на этапе ее разработки, а внедряется в уже готовый исполняемый файл (также, как и вирусы), то анализа системы защиты возможно избежать и автоматизировать восстановление исходного кода с помощью т.н. "универсальных распаковщиков" (блок 9.5 на рис 8). Это следует из того, что в этом случае система защиты отрабатывается сразу, при любом наборе входных данных. И после ее отработки можно снять дамп памяти, содержащий уже расшифрованный код.</p>
<p>Здесь возникает всего две проблемы:</p>
<ol type="a">
<li>как определить, что система защиты уже отработала, т.е. найти начало "чистого" кода. Оказывается, что это не так трудно сделать, в частности, начальный код, генерируемый любым компилятором, стандартен и известен.</li>
<li>определить размер снимаемого дампа (в случае архивации он может быть даже больше, чем начальный размер программы). Здесь тоже существуют некоторые эвристические методы, но в крайнем случае ничто не мешает взять некоторый максимальный размер.</li>
</ol>
<p>Для системы MS DOS известно много "универсальных распаковщиков" (UUP, Intruder, AutoHack), позволяющих не просто получить код в виде дампа памяти, а обычный нормально запускающийся EXE-файл. Не вдаваясь в подробности, заметим, что для генерации EXE-файла необходимо еще и определить, какие данные относятся к таблице перемещения и восстановить ее. Это достигается тем, что исходная программа запускается два раза с разных адресов и данные, корректируемые таблицей перемещения, в двух разный дампах оказываются неодинаковыми.</p>
<p>Если же система защиты не является такой простой, то в этом случае на помощь могут прийти трассировщики (блок 9.2 рис. 8)<a href="#L6">[6]</a>. Они записывают каждую инструкцию, проходящую через процессор (т.е. содержимое ячейки, на которую указывает IP) в специальную область памяти или файл, совершенно "не вникая", путем каких преобразований была получена эта инструкция, запоминая таким об разом список действительно исполняемых команд, трассу (trace).Очевидность этого метода следует из того, что любая система защиты должна восстановить исходный код по крайней мере в момент считывания его центральным процессором. Однако трассировщики применимы только тогда, когда система защиты не включает и динамическую защиту. В противном случае она может распознать изменения, вносимые трассировщиком в вычислительную среду.</p>
<p>Получаемый трассировщиком код, конечно, не очень похож на компилированный, однако в нем можно автоматически выделить процедуры, циклы и т.п., сократив его в десятки раз. Это можно делать как сразу, по мере получения трассы, так и потом, работая уже с готовой.</p>
<p>Если же в результате этого этапа не удалось получить стандартный код, это уже может служить основанием для отнесения входной программы к подозрительным, т.к. она использует весьма сложную систему защиты, что подавляющему большинству полезных программ явно не нужно.</p>
<h4><a name="p312">3.1.2. Лексический анализ.</a></h4>
<p>(Пока не введены определения последующих этапов, необходимо заметить, что они появятся автоматически, как только будет дано определение лексемы. Весь излагаемый материал строится на аксиоме, что лексемой является сигнатура РПС, но совершенно не лишены смысла и другие ее определения. Например, вполне возможно ввести как лексему машинную команду).</p>
<p>Согласно <a href="#L17">[17]</a>, лексический анализ -- это процесс распознавания транслятором во входном тексте смысловых единиц (лексем): идентификаторов, чисел, операторов и т.п. По аналогии, лексическим анализом при исследовании исходного кода программ будем называть процесс поиска и распознавания лексем, которыми в данном случае будут являться определенные регулярные последовательности, называемыми сигнатурами РПС (блок 8.1 рис. 8).</p>
<p>Определение сигнатуры РПС отличается от определения сигнатуры вируса и звучит как: "Сигнатурой РПС называется любая регулярная последовательность байт, встречающаяся в исполняемом коде РПС". Таким образом, сигнатуры вирусов -- это частный случай сигнатур РПС.</p>
<p>Функцией лексического анализатора, несколько выпадающей из общей схемы анализа, является т.н. "экспресс-анализ" (блок 2.1 рис. 8) -- поиск сигнатур известных РПС, нахождение которых однозначно свидетельствует, что программа содержит "вредный" код (т.е. той или иной РПС), и в этом случае не требуется дальнейшего исследования.</p>
<p>До сих пор именно лексический анализ являлся основным и очень эффективным средством поиска вирусов (<a href="#p111">см. п. 1.1.1</a>). Это связано с весьма большим быстродействием и простотой в реализации, позволяющей также исправлять и наращивать базу искомых сигнатур. Именно эти характеристики позволяют применять лексический анализ в качестве начального этапа анализа исполняемого кода -- "экспресс-анализа".</p>
<p>Рассмотрим подробнее, какого вида регулярные последовательности можно применять для этом этапе для наиболее полного и эффективного поиска разных классов РПС.</p>
<p>Самым простым их видом являются последовательности байт определенной длины или т.н. простые байтовые сигнатуры. Они могут записываться в десятичном, шестнадцатиричном, двоичном или символьном виде, а алгоритмы их поиска эффективны и широко описаны <a href="#L18">[18]</a>.</p>
<p>Однако не все вирусы и другие РПС имеют такие сигнатуры. В частности, многие вирусы часто вставляют в свой код некоторое переменное число байтов, чтобы довести размер зараженной программы до числа, кратного 16 (округление по границе параграфа). Далее, в теле вируса могут быть неизвестные заранее последовательности байт определенной длины, попадающие в него из заражаемой программы (например, первые байты из начала заражаемой программы).</p>
<p>Наличие таких фрагментов в разных местах тела вируса, с одной стороны, резко уменьшает длину максимальной байтовой сигнатуры и, с другой, увеличивает число таких сигнатур, каждую из которых можно использовать для поиска вируса. Конечно, для осуществления поиска любых вирусов, имеющих сигнатуру, в принципе можно было бы использовать и такие короткие простые байтовые сигнатуры, но для увеличения длины сигнатуры и, соответственно, существенного повышения качества диагностирования, вводятся так называемые регулярные сигнатуры.</p>
<p>Эти более сложные сигнатуры можно искать, применяя широко известные регулярные выражения, отсюда их название. Эти сигнатуры являются расширениями простых байтовых сигнатур с помощью двух специальных символов: '*' и '?'. Первый означает любое количество (0 и больше) байт, а второй строго один байт. Таким образом, сигнатура</p>
<pre>EB ? ? FF * FF</pre>
<p>может означать</p>
<pre>   
   EB 10 00 FF FF
   
   EB FF FF FF FF FF
   
   и т.д.
</pre>
<p>К сожалению, мысль создателей РПС с точки зрения их маскировки пошла дальше. Сначала появились вирусы, самошифрующиеся с переменным ключом. Очевидно, что для такого вируса в качестве сигнатуры может выступать только фрагмент незашифрованного кода, т.е. расшифровщик, который обычно представляет собой очень короткую последовательность байт, что ухудшает качество их диагностирования. Но потом появились вирусы, вообще не содержащие ни простых, ни регулярных байтовых сигнатур -- так называемые вирусы с самомодифицирующимся расшифровщиком. Это вирусы, использующие помимо шифрования кода, специальную процедуру расшифровки, изменяющую саму себя в каждом новом экземпляре вируса. Достигается это за счет того, что один и тот же алгоритм можно реализовать большим количеством способов на конкретном языке. Например, в машинных кодах (т.е. в исполняемом коде) можно:</p>
<ol>
<li>добавить к нему ничего не значащие команды;</li>
<li>поменять используемые регистры;</li>
<li>переставить команды местами.</li>
</ol>
<p>Для поиска таких вирусов пришлось применить новый тип сигнатур: битовые регулярные сигнатуры. Первый способ изменения кода легко обходится использованием уже известного символа '*', который имеет здесь тот же смысл, что и выше: 0 или более байт. (Отметим, что именно байт, а не бит, т.к. вряд ли существует машинный язык, на котором команды имели бы переменное число бит). Второй способ -- чередование используемых регистров -- описывается введением битового символа '?', означающего битовый 0 или 1. Дело в том, что регистр, используемый в команде, кодируется либо в каком-то конкретном байте этой команды (и тогда можно применять более эффективный символ '*'), либо в конкретных битах команды, а остальные биты остаются постоянными. (Для MS DOS справедлив второй случай). Третий способ -- чередование команд местами -- может быть обойден введением асинхронных выражений, выделяемых символами начала '{' и конца '}'. Все группы байт, попадающих в эти выражения, могут быть переставлены местами во входной последовательности. Регулярная битовая сигнатура и ей соответствующая последовательность представлены на рис. 6:</p>
<div align="center">
<img src="img/asa00_ru/Image100.gif" alt="Рис. 6. Пример регулярной битовой сигнатуры"/>
<p><strong>Рис. 6. Пример регулярной битовой сигнатуры</strong></p>
</div>
<p>Однако в 1992 г. появились вирусы, для поиска которых непригодны даже регулярные битовые сигнатуры! Это все те же вирусы с самомодифицирующимся расшифровщиком, но использующие очень совершенный алгоритм такой самомодификации, называемый MtE (Mutant Engine). В нем, помимо приведенных выше способов мутации, применяется еще и четвертый:</p>
<ol>
<li value="4">использование других команд (xor ax, ax вместо mov ax, 0; push/ret вместо jmp и т.д.).</li>
</ol>
<p>Расшифровщик, сгенерированный по этому алгоритму, не имеет ни одного постоянного бита, а используется в нем более половины всех инструкций процессора 8086. Таким образом, лексический поиск для таких вирусов просто неприменим (<a href="#p111">см. п. 1.1.1</a>).</p>
<p>Вместо регулярных битовых сигнатур гораздо более удобно использовать регулярные ассемблерные сигнатуры, являющиеся их расширением. Они избавляют пользователя от необходимости перевода вручную самомодифицирующегося кода в регулярные битовые последовательности. Их элементами являются ассемблерные команды и расширенные регулярными выражениями, состоящие из префикса и регулярного символа. В качестве префикса могут выступать: x, l, h -- означают регистр, его младший и старший байт соответственно;</p>
<pre>   
   s  -- сегментный регистр; 
   c  -- команду; 
   o  -- операнд; 
   a  -- адрес; 

   без префикса
   -- всю команду.
</pre>
<p>К регулярным символам добавились, помимо '*' и '?', цифры, означающие конкретный объект. Например, x1 означает любой (но один и тот же в данном регулярном выражении) регистр.</p>
<p>Символ '*' применяется только к целой команде и не имеет префиксов.</p>
<p>Приведем примеры таких сигнатур:</p>
<ol>
<li><pre>mov x1, ax cmp x1, 4B00h je 070</pre>
<p>Эта конструкция означает присваивание в любой регистр регистра AX, а затем сравнение именно этого регистра с числом 4B00h и переход по конкретному относительному адресу.</p></li>
<li><pre>c? o?, 15FEh</pre>
<p>Это -- любая двухоперандная инструкция с числом 15FEh.</p></li>
<li><pre>
{
	mov x1, a?
	mov x2, 100h
}
a1:
xor byte ptr cs:[x1], o?
{
	inc x1
	*
	dec x2
}
*
cmp x2, 0 
jne a1</pre>
<p>Пример очень простого самомодифицирующегося расшифровщика.</p></li>
</ol>
<p>Регулярные ассемблерные сигнатуры реализованы переводом их в регулярные битовые последовательности, расширенные символами i, j,... r для конкретных регулярных символов 0..9. Первый пример переводится в следующую последовательность:</p>
<pre>   
   10001011 11jjj000
   
   00111001 11jjj000 01001011 00000000
   
   01110100 01110000
</pre>
<p>Дальнейшим расширением регулярных сигнатур могли бы служить так называемые макрокоманды. Например, макрокоманда</p>
<pre>MOV ah, 25h (записывается большими буквами)</pre>
<p>означает любую последовательность команд, приводящую в конечном счете к присваиванию в регистр AH числа 25h, причем манипуляции с другими регистрами, памятью и т.п. здесь нас не интересуют. Ясно, что подходящих регулярных последовательностей команд может быть бесконечно много, например:</p>
<ol>
<li>mov ah, 25H</li>
<li>mov ax, 2513H</li>
<li>mov h1, 25H
<p>*</p>
<p>xchg ah, h1</p></li>
<li>mov ah, 20h
<p>*</p>
<p>add ah, 5h</p></li>
<li>push 2513
<p>pop ax</p></li>
</ol>
<p>Однако здесь, также как и при реализации транслятора, необходимо найти разумный компромисс между лексическим и синтаксическим анализом и не перекладывать задачи первого на второй и наоборот. Поэтому поиск макрокоманд вряд ли необходим в лексическом анализаторе. (По крайней мере, без средств динамического исследования он не может быть реализован).</p>
<h4><a name="p313">3.1.3. Дизассемблирование.</a></h4>
<p>Дизассемблированием называется процесс перевода программы из исполняемых или объектных кодов на язык ассемблера.</p>
<p>Задача дизассемблирования практически решена и не будет поэтому здесь рассматриваться. Для MS DOS существует много хороших дизассемблеров, почти стопроцентно справляющихся со стандартным кодом. (Дизассемблированный текст может считаться 100% правильным, если при повторном ассемблировании получается исходный код. Аналогично, код считается 100% стандартным, если дизассемблер получает 100% правильный текст).</p>
<p>С помощью этапа дизассемблирования поэтому можно проверить качество выполнения этапа получения чистого кода если дизассемблер не генерирует 100% правильный код, то тот этап был не закончен.</p>
<p>В системе анализа исполняемого кода программ однако удобнее применять не стандартные дизассемблеры, а специализированный (блок 8.2 рис. 8), который, помимо ассемблерного текста, может выдавать и другую полезную информацию. Самой важной для следующего этапа будет информация о передаче управления в программе, т.е. последовательность вызова процедур.</p>
<h4><a name="p314">3.1.4. Синтаксический анализ.</a></h4>
<p>Синтаксическим анализом при проектировании компиляторов называют процесс отождествления лексем, найденных во входной цепочке, одной из языковых конструкций, задаваемых грамматикой языка. Иначе его можно рассматривать как процесс построения дерева грамматического разбора. По аналогии будем говорить, что синтаксический анализ исполняемого кода программ состоит в отождествлении сигнатур, найденных на этапе лексического анализа, одному из видов РПС.</p>
<p>Для синтаксического анализа любого языка необходимо иметь его грамматику, описывающую, по каким правилам из лексем (терминальных символов или терминалов) строятся его предложения. Т.е., применительно к РПС, мы должны формализовать "грамматику" РПС, описывающую, по каким правилам из лексем (сигнатур РПС) строятся "предложения" (т.е. различные типы РПС). Это можно сделать с помощью любой формы записи грамматики, например БНФ. Но т.к. грамматика является очень простой и не содержит, в частности, рекурсии, то нагляднее всего отобразить ее в виде дерева, которое будем назвать грамматическим деревом или деревом свертки (рис. 7):</p>
<div align="center">
<img src="img/asa00_ru/Image101.gif" alt="Рис. 7. Макет грамматики РПС в виде дерева свертки"/>
<p><strong>Рис. 7. Макет грамматики РПС в виде дерева свертки</strong></p>
</div>
<p>Уровень 0 представляет собой конкретные типы РПС, на уровне 1 они раскрываются достаточно общими функциями, описывающими их алгоритм, на уровне 2 каждая из этих функций конкретизируется функциями более низкого уровня и т.д. до уровня N, где появляются сигнатуры. Таким образом, уровни 0..N-1 содержат нетерминалы, а уровень N -- терминальные символы.</p>
<p>Если бы существовала полная аналогия между анализом программ в исполняемом коде и компиляцией, то на этом этапе анализ программ мог быть закончен, т.к. входная цепочка лексем (исполняемый код) должна была бы быть либо принята синтаксическим анализатором (РПС присутствует), либо отвергнута (РПС нет). Однако при компиляции программ цепочка задается абсолютно строго: известны ее длина, порядок следования терминальных символов и т.п. Так же строго задается и грамматика входного языка.</p>
<p>При анализе исполняемого кода это не так:</p>
<ul>
<li>могут быть не распознаны некоторые лексемы. Это следует из того, что, как отмечалось (п. 3.1.2), макроассемблерные конструкции могут быть представлены бесконечным числом регулярным ассемблерных выражений;</li>
<li>порядок следования лексем может быть известен с некоторой вероятностью или вообще неизвестен. Передачи управления в программе приводят к тому, что лексемы, стоящие рядом в программном файле, могут исполняться совершенно непоследовательно, и наоборот.</li>
<li>грамматика языка может пополняться, т.к могут возникать новые типы РПС или механизмы их работы.</li>
</ul>
<p>Таким образом, окончательное заключение об отсутствии или наличии РПС можно дать только на этапе семантического анализа, а задачу этого этапа можно конкретизировать как свертку терминальных символов в нетерминалы как можно более высокого уровня там, где входная цепочка задана строго.</p>
<h4><a name="p315">3.1.5. Выделение структуры программы и перевод на ЯБВУ.</a></h4>
<p>Этот этап выполняется с полученным ассемблерным текстом программы и состоит в нахождении и выделении соответствующим образом управляющих конструкций, таких как: циклы, подпрограммы и т.п.; основных структур данных. В какой-то мере этот этап также уже реализован: в частности, дизассемблер Sourcer ((с) V Communications) выделяет процедуры и некоторые структуры данных еще на этапе дизассемблирования, а для выделения управляющих конструкций служит специальная утилита ASMTool (блок 8.4 рис. 8).</p>
<p>Семантический анализ программы, как уже отмечалось, удобнее всего вести на языке высокого уровня. Однако на сегодняшний день задача о переводе из машинных кодов на язык высокого уровня (дискомпиляции -- блок 8.3 рис. 8) не имеет приемлемого решения. Поэтому на данном этапе вполне подходящим языком более высокого уровня мог бы стать специализированный макроассемблер, который был описан в п. 3.1.1. Специализированным он называется в том плане, что нацелен на выделение макроконструкций, используемых в РПС. Не нужно смешивать этот процесс с возможным переводом на язык макроассемблера на предыдущих этапах, т.к. там осуществлялась свертка лексем, а не перевод всего текста.</p>
<h4><a name="p316">3.1.6. Семантический анализ.</a></h4>
<p>Семантический анализ программы -- исследование программы изучением смысла составляющих ее функций (процедур) в аспекте операционной среды компьютера <a href="#L1">[19]</a>.</p>
<p>Введенное определение существенно отличается от толкования понятия "семантический анализ программ" из <a href="#L17">[17]</a>, поскольку там оно интерпретируется только с позиции транслятора программы с языка высокого уровня. Но перевод программ с языка высокого уровня в исполняемые коды не лишает ее смысла, поэтому такое определение не может претендовать на полноту. Напротив, новое определение подразумевает полное сохранение смысла программы и ее интерпретацию компьютерной системой при любой форме представления. Этот этап должен дать окончательный ответ на вопрос о том, содержит ли входной исполняемый код РПС, и если да, то какого типа. При этом он использует всю полученную на предыдущих этапах информацию, которая, как уже отмечалось, может считаться правильной только с некоторой вероятностью, причем не исключены вообще ложные факты или умозаключения.</p>
<p>Таким образом, формально на этапе семантического должна быть закончена свертка нетерминалов, полученных на этапе синтаксического анализа, в нетерминалы уровней 0, 1, 2. Очевидно, что нечеткость имеющейся информации приводит к появлению на этом этапе некоторой машины логического вывода (блок 10 рис. 8) со всеми присущими ей элементами: форме представления знаний и правил, алгоритмами логического вывода, вероятностными заключениями и т.п.</p>
<p>В целом, задача семантического исследования исполняемого кода программ является очень сложной и нуждается в серьезных исследованиях. Вероятнее всего, что полностью автоматизировать ее будет невозможно.</p>
<h3><a name="p32">3.2. Взаимодействие синтаксического и семантического анализа.</a></h3>
<p>Как мы видим, оба этапа -- синтаксического и семантического анализа -- преследуют общую цель: построить дерево грамматического разбора и тем самым закончить анализ кода.</p>
<p>Известно, что при построении компиляторов все методы синтаксического анализа можно разбить на два класса: восходящие и нисходящие. Первые (методы сверху вниз) начинают с правила грамматики, определяющего конечную цель анализа, и пытаются так наращивать дерево грамматического разбора, чтобы его узлы соответствовали синтаксису анализируемой цепочки. Вторые (методы снизу вверх) берут за основу терминальные символы и пытаются их свернуть в нетерминалы все более и более высоких уровней.</p>
<p>Совершенно аналогично, в теории экспертных систем различают два подхода: с прямой цепочкой рассуждений и с обратной. Первые, опираясь на известные факты, пытаются по ним построить умозаключение. Вторые, наоборот, беря за основу некоторую гипотезу, пытаются найти данные для ее подтверждения или опровержения.</p>
<p>Похоже, применительно к нашей задаче, эти пары методов являются разными точками зрения на одно и тоже, и, говоря о взаимодействии методов синтаксического и семантического анализа, мы приходим к двум основным объединенным методам анализа исполняемого кода: нисходящие с прямой цепочкой рассуждений и восходящие с обратной цепочкой рассуждений.</p>
<p>Первые последовательно строят гипотезы, что РПС относится к типу 1, типу 2 и т.д. (т.е. начинает с корня дерева свертки) и постепенно спускаются вниз, на каждом этапе пытаясь опровергнуть или подтвердить свою гипотезу, ища соответствующие сигнатуры. Вторые начинают с терминалов уровня N и постепенно поднимаются вверх, сворачивая их в нетерминалы высших уровней с соответствующими вероятностями.</p>
<p>Можно охарактеризовать эти методы и с другой точки зрения: первые можно назвать методами ведущего семантического разбора (где машина логического вывода является первичной, а синтаксический анализатор помогает ей в подборе фактов), а вторые методами ведущего синтаксического разбора (где первичной будет синтаксическая свертка, которую облегчают вероятностные рассуждения семантического анализатора). К точно таким же выводам приходят авторы в <a href="#L19">[19]</a>, рассуждая с несколько других позиций. Более того, они предлагают как наиболее эффективный и многообещающий метод, основанный на сочетании этих двух, но ведь именно сочетание методов логического вывода привело к созданию машины логического вывода с косвенной цепочкой рассуждений <a href="#L20">[20]</a>, которая объединяет достоинства как первого, так и второго подхода.</p>
<h3><a name="p33">3.3. Общая структура системы анализа.</a></h3>
<p>Общая структура отражает взаимодействие основных модулей системы анализа, описанных выше, а также управляющих модулей, методов статического и динамического исследования и интерфейса с пользователем (рис. 8). Она несколько отличается от приведенной в <a href="#L19">[19]</a>.</p>
<div align="center">
<img src="img/asa00_ru/Image102.gif" alt="Рис. 8. Общая структурная схема системы аналища ИСАИПК"/>
<p><strong>Рис. 8. Общая структурная схема системы аналища ИСАИПК</strong></p>
</div>
<p>Объект исследования -- исполняемый код программы -- поступает на входной интерфейс ИСАИПК (13.1) для согласования фактической формы представления входной информации с требуемой формой ее представления для ИСАИПК.</p>
<p>Администратор задач ИСАИПК (7) посредством интерфейса с пользователем (13.2) начинает диалог с пользователем по конкретизации цели исследования. Полученная от него информация дает возможность администратору сделать выбор по передаче управления между подсистемами ИСАИПК. В дальнейшем администратор принимает решения о дальнейших передачах управления, продолжении или прекращении исследования и т.д.</p>
<p>Основные этапы анализа (1, 2, 4, 6) описаны выше. Для своих целей они применяют статические (8) или динамические (9) методы исследования, а семантический анализатор еще и машину логического вывода (10).</p>
<p>По завершению процесса анализа администратор передает управление системе анализа РПС, которая определяет его свойства и заносит в общую базу данных (12.1). Результаты анализа поступают на выходной интерфейс (13.3).</p>
<h3><a name="p34">3.4. Резюме.</a></h3>
<p>Доведение предложенных в этой главе общих схем системы анализа до программной реализации ИСАИПК на сегодняшний день представляется весьма проблематичным из-за сложности и неоднозначности применяемых в них алгоритмов.</p>
<p>Поэтому в следующей главе мы рассмотрим практическую реализацию некоторой подсистемы ИСАИПК (блоки 2.2, 4, 6, 8.1, 8.2, 10, помеченные '*'), выполняющую, однако, ее основную функцию поиск неизвестных РПС в исполняемом коде программ для операционной системы MS DOS.</p>
<h2><a name="p4">Глава 4. Реализация интеллектуальной системы анализа исполняемого кода программ.</a></h2>
<p>Для доказательства практического применения идей, рассмотренных в предыдущей главе, необходимо было построить макет ИСАИПК, получивший название SubLVA. С самого начала, при разработке технического задания на эту программу, было введено ограничение, что она не будет использовать методы динамического анализа исполняемого кода. Это, конечно, уменьшает мощность программы, но, с другой стороны, значительно увеличиваются скорость, надежность и простота проектирования. Не использование средств динамического исследования также приводит к тому, что первый этап -- снятие защиты -- не присутствует в системе SubLVA, которая получает на вход уже "чистый" код. Этот этап, тем не менее, можно реализовать как внешний, не нарушая логики приведенных схем анализа.</p>
<h3><a name="p41">4.1. Построение дерева свертки РПС и набора характерных признаков.</a></h3>
<p>Первоочередной задачей для реализации ИСАИПК является построение максимально полного дерева свертки, общая структура которого была представлена в предыдущей главе на рис. 7. Для реализации системы анализа необходимо наполнить это дерево конкретными узлами, присущими РПС. Для системы SubLVA оказалось достаточно ограничить глубину этого дерева 5 уровнями (т.е. N=4).</p>
<p>Ниже приведено используемое в системе дерево свертки (с сокращениями), представленное описанием в форме Бэкуса-Науэра (БНФ).</p>
<h4>Уровень 0.</h4>
<pre>  
   ПСР ::= ПСР.Одиночная | ПСР.Сетевая
   ПСР.Одиночная ::= ПСР.Резидентная | ПСР.Файловая | ПСР.Бутовая
   ПСР.Сетевая ::= Не_Рассматр

   ПНУ ::= ПНУ.Файл | ПНУ.Видео | ПНУ.Порт | ПНУ.Клавиатура | ПНУ.Система
   ПНУ.Файл ::= ПНУ.Формат | ПНУ.BOOT_MBR_FAT | ПНУ.Сектор |
   ПНУ.Исполн_Файл
   ПНУ.Видео ::= Не_Рассматр
   ПНУ.Клавиатура ::= ПНУ.Блокировка_Клав | ПНУ.Запись_Клав
   ПНУ.Система ::= ПНУ.Зависание | ПНУ.Перезагрузка |
   ПНУ.Замедление | ПНУ.Блокировка_Запуска

   ППЗ ::= ППЗ.Системная | ППЗ.Дополнительная
   ППЗ.Системная ::= Пусто
   ППЗ.Дополнительная ::= ППЗ.Вход | ППЗ.Программа | ППЗ.Антивирус
</pre>
<h4>Уровень 1.</h4>
<pre>   
   ПСР.Резидентная ::=
     Проверить_Наличие.Память
     Выделить.Память
     Перехватить.Прер
     Скопироваться.Память
     Замести_Следы.Память
   ПСР.Файловая ::=
     Найти_Жертву.Файл
     Проверить_Тип.Файл
     Проверить_Наличие.Файл
     Скопироваться.Файл
     Замести_Следы.Файл
   ПСР.Бутовая ::=
     Проверить_Наличие.BOOT
     Найти_Место.BOOT
     Скопироваться.BOOT
     Замести_Следы.BOOT

   ПНУ.Формат ::= Отформатировать_Дорожку
   ПНУ.BOOT_MBR_FAT ::= Записать.BOOT | Записать.MBR | Записать.FAT
   ПНУ.Сектор ::= Записать.Абс
   ПНУ.Исполн_Файл ::= Записать.Исполн_Файл
   ПНУ.Блокировка_Клав ::= Не_Рассматр
   ПНУ.Запись_Клав ::= Записать_Буфер.Клав
   ПНУ.Зависание ::= Бесконеч_Цикл
   ПНУ.Перезагрузка ::= Вызвать_Перезагр
   ПНУ.Замедление ::= Замедлить.Таймер
   ПНУ.Блокировка_Запуска ::=
     Проверить.EXEC
     Сравнить.EXEC
</pre>
<h4>Уровень 2.</h4>
<pre>   
   Проверить_Наличие.Память ::= Вызвать.Нестд_прер | Вызвать.Нестд_функц |
	   Сканировать.Память
   Выделить.Память ::= int21.AA | Манипуляция.MCB | Системная_Область
   Скопироваться.Память ::=
     Найти_себя.Память
     Скопировать.Память |
     Остаться_Резидентным
   Перехватить.Прерывание ::= int21.25 | Запись_Табл
   Замести_Следы.Память ::= Пусто
   Найти_Жертву.Файл ::= Поиск.PATH | Поиск.Тек_каталог | Поиск.Корень |
   Поиск.Дерево | Поиск.Все_диски | Поиск.COMMAND
   Поиск.PATH ::=
     Считать.PATH
     Сканировать.PATH
     Проверить.Файл
   Поиск.Тек_каталог ::= Проверить.Файл
   Поиск.Корень ::=
     ChDir.Root
     Проверить.Файл
   Поиск.Дерево ::=
     FindFirst
     Проверить.Дир
     Считать.DTA
     Поиск.Дерево
     Записать.DTA
     FindNext
   Поиск.Все_диски ::=
     Найти_колич.Диск
     Перейти.Диск
     Поиск.Дерево
   Поиск.COMMAND ::= Считать.COMSPEC | C.COMMAND.COM
   Проверить_Тип.Файл ::=
   Считать_Начало.Файл
   Проверить.MZ
   Проверить_Наличие.Файл ::= Проверить.Дату_Время | Проверить.Сигнатуру
   Скопироваться.Файл ::= Скопироваться.COM | Скопироваться.EXE |
   Скопироваться.BAT | Скопироваться.SYS
   Скопироваться.COM ::=
     Проверить.Условие_Заражения.COM
     Снять.Read_Only.Файл
     Запомнить.Дату.Файл
     Открыть_Запись.Файл
     Считать_Начало.Файл
     Записать_Конец.Файл
     Записать_Начало.Файл
     Закрыть.Файл
     Поставить.Дату.Файл
     Поставить.Read_Only.Файл
   Скопироваться.EXE ::=
     Проверить.Условие_Заражения.EXE
     Снять.Read_Only.Файл
     Запомнить.Дату.Файл
     Открыть_Запись.Файл
     Считать_Заголовок.Файл
     Записать_Конец.Файл
     Записать_Заголовок.Файл
     Закрыть.Файл
     Поставить.Дату.Файл
     Поставить.Read_Only.Файл
   Замести_Следы.Файл ::= Не_рассматр
   Проверить_Наличие.BOOT ::=
     Считать.BOOT
     Проверить.Сигнатуру |
     Считать.Метку_Диска
     Проверить_Сигнатуру
   Найти_Место.BOOT ::= Свободный_Сектор | Системный_Сектор |
   Новый_Сектор
   Новый_Сектор ::= Форматировать_Дорожку
   Скопироваться.BOOT ::=
     Считать.BOOT
     Записать.Сектор
     Записать.BOOT
   Замести_Следы.BOOT ::= Пометить_Сбойный.Сектор
   Пометить_Сбойный.Сектор ::=
     Поиск_FAT.Сектор
     Пометить_BAD.FAT
   Замедлить.Таймер ::=
     Считать.Прер.Таймер
     Обработчик_Цикл
     Записать.Прер.Таймер
   ППЗ.Вход ::= Пусто
   ППЗ.Программа ::= ППЗ.Программа.ADM | ППЗ.Программа.Stacker |
   ППЗ.Программа.Перебор
   ППЗ.Программа.ADM ::= Вскрыть.ADM
   ППЗ.Программа.Stacker ::= Вскрыть.Stacker
   ППЗ.Программа.Перебор ::=
     Сформировать.Пароль
     Вызов.Программы
   ППЗ.Антивирус ::= ППЗ.Aidstest | ППЗ.Scan | ППЗ.Adinf | ППЗ.Сторож |
   ППЗ.Детектор
   ППЗ.Aidstest ::= Не_зараж.Aidstest
   ППЗ.Scan ::= Не_зараж.Scan
   ППЗ.Adinf ::= Не_зараж.Adinf | Испортить_файлы.Adinf
   ППЗ.Сторож ::= Найти_обработчик.21 | Найти_обработчик.13
   ППЗ.Детектор ::= Корректировать_длину.Файл | Корректировать.BOOT
</pre>
<h4>Уровень 3.</h4>
<pre>   
   Вызвать.Нестд_прер ::=
     INT [00-09 34-55 87-C0] (1)
     Вызвать.Нестд_функц ::=
     MOV ah, [6D-FF]
     int 21
   Сканировать.Память ::=
     MOV si, o?
     MOV di, o?
     MOV cx, o?
     rep scas
     int21.AA ::=
     MOV ah, AA
     int 21
   Манипуляция.MCB ::= Не_рассматр
   Системная_Область ::=
     MOV x1, [0000 A000]
     MOV s?, x1
   Найти_себя.Память ::=
     call 0000 (2)
     pop x?
   Скопировать.Память ::=
     MOV si, o?
     MOV di, o?
     MOV cx, o?
     rep movs
   int21.25 ::=
     MOV ah, 25
     int 21
   Запись_Табл ::=
     MOV s1, 0 (3)
     MOV s1:[a1], o?
     MOV s1:[a1+2], o?
   Остаться_Резидентным ::=
     MOV ah, 31
     MOV al, o?
     MOV dx, o?
     int 21 |
     MOV dx, o?
     int 27
   Считать.PATH ::= Не_рассматр
   Сканировать.PATH ::= Не_рассматр
   Проверить.Файл ::=
     MOV ax, 22 (4)
     MOV dx, a1
     int 21h
     a2: *
     MOV ax, 23
     int 21h
     *
     JNE a2
     a1: db '*.COM' |
     db '*.EXE' |
     db '*.*'
   ChDir.Root ::=
     MOV dx, a1
     MOV ah, 3b
     int 21
     a1: db '\'
   Считать.DTA ::=
     MOV ah, 2f
     int 21
     c? o?, es:[bx]
   Записать.DTA ::=
     MOV ah, 1a
     int 21
   C.COMMAND.COM :: =
     db 'COMMAND' | (5)
     db 'COMMAND.COM' |
     db 'C:\COMMAND.COM'
   Считать_Начало.Файл ::=
     MOV dx, o?
     MOV ah, 3f
     int 21
   Проверить.MZ ::=
     CMP x?, 'MZ' | (6)
     CMP x?, 'ZM'
   Проверить.Дату_Время ::=
     MOV AX, 5700
     int 21
   Проверить.Сигнатуру ::= Не_рассматр
   Проверить.Условие_Заражения.COM ::= (7)
     MOV cx, 0
     MOV dx, 0
     MOV ax, 4202
     int 21
     ADD ax, o?
     CMP ax, FFFF
   Снять.Read_Only.Файл ::=
     MOV ax, 4300 (8)
     MOV dx, o?
     int 21
     AND cx, FFFE
     MOV ah, 01
     int 21
   Запомнить.Дату.Файл ::=
     MOV ax, 5700 (9)
     int 21
     [ c? o?, cx ]
     c? o?, dx
   Открыть_Запись.Файл ::=
     MOV ah, 3d
     MOV al, 2
     int 21
   Считать_Начало.Файл ::=
     MOV ah, 3fh
     MOV cx, o?
     MOV dx, o?
     int 21
   Записать_Конец.Файл ::=
     MOV cx, 0
     MOV dx, 0
     MOV ax, 4202
     int 21
     MOV ah, 40h
     MOV cx, o?
     int 21
   Записать_Начало.Файл ::=
     [ MOV cx, 0
     MOV dx, 0
     MOV ax, 4200
     int 21
     ]
     MOV ah, 40h
     MOV cx, o?
     int 21
   Закрыть.Файл ::=
     MOV ah, 3eh
     int 21
   Поставить.Дату.Файл ::=
     MOV dx, o?
     MOV ax, 5701
     int 21
   Поставить.Read_Only.Файл ::=
     MOV ax, 4301
     int 21
   Считать.BOOT ::=
     MOV ax, 0201 (10)
     MOV cx, 0
     MOV bx, o?
     MOV dx, o?
     int 13
   Записать.BOOT ::=
     MOV ax, 0301 (11)
     MOV cx, 0
     int 13
   Записать.Сектор ::=
     MOV ah, 03 (12)
     int 13
   Проверить.Сигнатуру ::= Не_рассматр
   Считать.Метку_Диска ::=
     MOV ah, 4e
     MOV dx, o?
     MOV cx, 8
     int 21
   Найти_обработчик.21 ::= Не_рассматр
   Найти_обработчик.13 ::=
     MOV dx, o? (13)
     MOV ah, 13
     int 2f
     c? o?, ds
     c? o?, dx
     int 2f
</pre>
<h4>Уровень 4 (Пример).</h4>
<pre>   
   int21.AA ::=
     mov ah, AA
     int 21
   int21.AA ::=
     mov ax, AA??
     int 21
</pre>
<dl>
<dt>Уровень 0</dt>
<dd>представляет собой конкретизацию трех необходимых процедур РПС до их наиболее общих типов, например, ПСР.Резидентная, ПНУ.Файловая, ППЗ.Антивирус. Свертка исполняемого кода до такого уровня характеризует свойства РПС (в предложенном примере это будет резидентный вирус, наносящий ущерб файловой системе и имеющий средства борьбы с антивирусными программами).</dd>
<dt>Уровень 1</dt>
<dd>описывает алгоритм каждого из типов РПС наиболее общим образом (Найти_Жертву, Скопироваться и т.п.). </dd>
<dt>Уровень 2</dt>
<dd>раскрывает каждую из функций, используемую на предыдущем уровне, до алгоритма ее реализации на псевдоязыке высокого уровня.</dd>
<dt>Уровень 3</dt>
<dd>в свою очередь, переводит каждую из функций предыдущего уровня на специализированный макроассемблер (<a href="#p312">см. п. 3.1.2</a>).</dd>
<dt>Наконец, уровень 4</dt>
<dd>представляет наиболее очевидные реализации макроассемблерных функций в виде регулярных ассемблерных сигнатур. Необходимо помнить, что возможно бесконечное количество способов представления выражений уровня 3 на уровне 4. Для реального дерева выбираются наиболее очевидные из них, обычно взятые из реальных РПС.</dd>
</dl>
<p>Таким образом, все конструкции уровня 4 представляют собой сигнатуры РПС в виде регулярных ассемблерных выражений и могут использоваться как признаки РПС, т.к. каждая содержится в том или ином РПС. Однако многие из них вполне невинны и могут содержаться в любой программе (например, как int 21.25, Открыть_Запись.Файл и т.п.). Другие же, наоборот, весьма характерны для РПС: Найти_Себя.Память, Проверить.MZ (они помечены номерами 1..13). Многие не представленные на 4 уровне выражения также будут являться характерными для РПС признаками: Пометить_BAD.FAT, Обработчик_Цикл, Не_зараж.Aidstest, Не_зараж.Scan, Не_зараж.Adinf, Испортить_файлы.Adinf, Найти_обработчик.21, Корректировать_длину.Файл, Корректировать.BOOT и т.д.</p>
<h3><a name="p42">4.2. Подходы к построению системы анализа без использования динамических методов исследования.</a></h3>
<p>Как уже отмечалось в п. 3.2, в ИСАИПК различают два основных метода анализа: восходящий с прямой цепочкой рассуждений и нисходящий с обратной цепочкой рассуждений. Рассмотрим возможные реализации каждого из них с учетом ограничения на неиспользование динамических методов исследования.</p>
<h4><a name="p421">4.2.1. Подход 1: метод поиска характерных признаков.</a></h4>
<p>Это восходящий метод с прямой цепочкой рассуждений.</p>
<p>Основная его идея состоит во том, что после построения дерева свертки из уровня N берутся наиболее типичные для РПС фрагменты (для нашего дерева это будут помеченные номерами выражения). (Вообще говоря, дерево можно не строить, а получить такие фрагменты, анализируя исходные тексты РПС и представляя основные алгоритмы их работы) и они ищутся на этапе лексического анализа. Этап синтаксического анализа практически отсутствует, а на этапе анализа семантики применяются правила, позволяющие сделать вероятностный вывод о наличии и типе РПС в исходном коде.</p>
<p>Для полученных нами характерных признаков это могут быть правила типа:</p>
<pre class="source">
   ЕСЛИ
	Проверить. Файл 
   ТО
	ПСР. Файловая с вер. 40%. 
   ЕСЛИ
	Проверить. Файл 
   ТО
	ПСР. Резидентная с вер. 20%.

   ЕСЛИ
	Найти_Себя. Память 
   ТО
	ПСР. Резидентная с вер. 80%.

   ЕСЛИ
	Записать. BOOT 
   ТО
   	ПСР. Бутовая с вер. 70%.
</pre>
<p>Этот метод привлекает своей простой и очевидностью алгоритмов, и первые "универсальные" антивирусы применяли именно его (первая такая программа, Lie Detector, была представлена в 1989 г.). Более того, простота в данном случае не ухудшает их эффективности в поиске неизвестных вирусов, -- Lie Detector занял первое место на Всесоюзной киевской конференции по вирусам 1990 г., детектируя 97% от известных тогда вирусов. Эта программа использовала даже более простые правила, которые сводились по сути только к присваиванию различных весов различным признакам вирусов и потом их суммированию. Если сумма превышала некоторый лимит, то программа объявлялась подозрительной.</p>
<p>Как характерные для вирусов признаки Lie Detector использовал следующие: "базирование", т.е. определение текущего IP (Найти_себя.Память), открытие файла на запись или смещения указателя записи в конец (Открыть_Запись.Файл и Записать_Конец.Файл), изменение даты или атрибутов у файла (Поставить.Дату.Файл, Поставить.Read_Only.Файл), строки типа "*.COM", "*.EXE", "*."', "MZ", "ZM" (Проверить_Файл, Проверить.MZ). Как мы видим, все эти признаки присутствуют и в нашем дереве на уровне 4, что подтверждает практическую его ценность.</p>
<p>Если к программе такого рода добавить первый этап (снятие защиты), то она может быть вполне конкурентоспособной и сегодня, а по скорости проверки с ней не сможет сравниться ни один метод. (По таблице 3 оценка такой программы равнялась бы 5.0 баллам, уступая только ревизорам!)</p>
<p>Недостатки у такого подхода тоже очевидны. Это все те же ошибки первого и второго рода (<a href="#p11">см. п. 1.1</a>): программа будет подвержена многим ошибкам второго рода, срабатывая на ни в чем неповинные программы; и, реже, первого рода, если вирус применит некоторые алгоритмы, не попадающие в характерные.</p>
<h4><a name="p422">4.2.2. Подход 2: метод полного дизассемблирования.</a></h4>
<p>Второй метод будет относиться к нисходящим с обратной цепочкой рассуждений.</p>
<p>Итак, строится полное дерево свертки и процесс синтаксического разбора идет сверху (иначе говоря, предполагается, что в программе присутствует РПС и последовательно строятся гипотезы, что он относится к типу 1, 2 и т.д.). Одновременно весь входной код полностью дизассемблируется (на этапе 3 рис. 5 и 8 предыдущей главы) и переводится, насколько это возможно статическими методами, на макроассемблер. Теперь для подтверждения текущей гипотезы последовательно ищутся сигнатуры, которые ее подтверждают, уже на языке макроассемблера (для нашего дерева -- это уровень 3), а дизассемблированный текст дает некоторую информацию о передачах управления в программе, т.е. о порядке следования этих сигнатур. Таким образом, эта методика включает 2, 3, 4, 5 и 6 этапы.</p>
<p>По достоинствам и недостаткам этом метод полностью противоположен первому, т.к. он будет весьма надежно оценивать наличие РПС в программе (если дерево свертки полно), но применяемые алгоритмы будут нетривиальны и медленны. По таблице 3 оценка такой системы равнялась бы 5.3 баллам.</p>
<h3><a name="p43">4.3. Принципы работы системы SubLVA.</a></h3>
<p>Как часто встречается в практических системах, методы, применяемые в них, являются сочетанием двух, казалось бы, противоположных. Это имеет место и для рассматриваемой системы, т.к. она сочетает два вышеописанных подхода.</p>
<p>Для работы системы SubLVA необходимо полное дерево свертки (как и в подходе 2). В исполняемом коде на этапе лексического анализа ищутся наиболее важные или характерные для РПС сигнатуры, задаваемые регулярными ассемблерными выражениями уровня 4 (как в подходе 1). Но далее они поступают не в машину логического вывода, а на следующие этапы. На этапе 3 происходит дизассемблирование кода, расположенного непосредственно вблизи от найденной сигнатуры (выбирается некоторое фиксированное смещение). Этап синтаксического анализа заключается в переводе этого небольшого фрагмента ассемблерного текста на макроассемблер (как в подходе 2). Если перевод будет успешным, т.е. найденная ассемблерная сигнатура является действительно сворачивается в соответствующий не терминал уровня 3, то именно эти нетерминалы поступают на этап семантического анализа, правила которого практически аналогичны правилам из подхода 1.</p>
<p>Таким образом, данный подход сочетает в себе достоинства описанных выше:</p>
<ul>
<li>машина логического вывода работает с утверждениями более высокого уровня 3, что повышает достоверность полученных результатов;</li>
<li>правила, применяемые ей, настолько же просты, как и при использовании утверждений уровня 4;</li>
<li>отсутствуют сложные алгоритмы полного дизассемблирования, перевода на макроассемблер, т.к. дизассемблирование и перевод ведутся в пределах сравнительно небольшого фрагмента;</li>
<li>не требуется анализа передач управления, т.к. свертка на уровни выше 3 не ведется.</li>
</ul>
<h3><a name="p44">4.4. Обзор алгоритмов, необходимых для реализации системы.</a></h3>
<h4><a name="p441">4.4.1. Этапы лексического и синтаксического анализа.</a></h4>
<p>Применяемые на этапе лексического анализа алгоритмы поиска регулярных выражений хотя и являются достаточно сложными, но широко описаны. Для поиска регулярных ассемблерных выражений, как отмечалось в п. 3.1.2, их необходимо перевести в соответствующие регулярные битовые. Для этого необходим алгоритм ассемблирования, реализация которого также не вызывает трудностей.</p>
<p>Применяемое на этапе 3 дизассемблирование в том виде, как оно необходимо для данной системы, будет являться однопроходным, без составления таблиц процедур и переменных и тем самым также относительно несложно. Более того, на этом этапе может вызываться внешняя процедура с параметрами -- адресами начала и конца дизассемблируемого участка (что и сделано в системе).</p>
<p>Этап синтаксического анализа является самым сложным для программирования. Как было подчеркнуто, выражения уровня 3 на макроассемблере могут приводить к бесконечному числу выражений уровня 4. Очевидно и обратное -- свертка сигнатур уровня 4 в сигнатуры уровня 3 может иметь бесконечное число решений. К счастью, мы знаем обе сигнатуры -- найденную и ту, в которую пытаемся свернуть. Поэтому остается только доказать, что фактически найденная сигнатура может получаться из макроассемблерного выражения.</p>
<p>Нет ли здесь противоречия с тем, что это вроде бы должно следовать из смысла самого дерева свертки? К сожалению, нет. Здесь и проявляются нечеткость получаемой информации. Приведем пример.</p>
<p>Рассмотрим макроассемблерное выражение уровня 3:</p>
<pre class="source">
   MOV ax, 0С
   MOV es, 00
</pre>
<p>Это выражение приводит к вполне естественному представлению на уровне 4:</p>
<pre class="source">
   mov ax, 0C 
   mov x1, 00 
   mov es, x1
</pre>
<p>И в качестве конкретной сигнатуры могла бы быть найдена такая:</p>
<pre class="source">
   mov ax, 0C 
   mov ax, 00 
   mov es, ax
</pre>
<p>Которая, очевидно, не является представлением искомого макровыражения.</p>
<p>Для решения подобной задачи обычно применяют динамические методы: ставится точка останова после последней проверяемой команды, управление передается на найденную последовательность и при останове проверяются значения регистров. Поскольку мы отказались от динамических методов, приходится в некоторой степени моделировать этот процесс.</p>
<p>Похожий алгоритм реализован в программе Sourcer, которая довольно точно определяет, какая и с какими параметрами была вызвана функция DOS, даже если явного присваивания в регистры сделано не было.</p>
<p>Для моделирования работы процессора вводится следующие структуры данных: регистры (начальное состояние каждого -- "неизвестно", небольшой стек размером 32 слова (начальное состояние -- пуст). Моделируются наиболее распространенные команды: mov, inc, dec, cmp, xchg, xor, add, sub, push, pop и некоторые другие. Приведем типичный пример ассемблерного текста, где предложенная схема правильно определит содержимое регистров (прог. 2):</p>
<pre class="source">   
   push ss 
   ; начало дизассемблируемого текста.
   db   F6 
   ; Явно неправильное, т.к. попали в середину команды
   ...
   mov   ax, bx 
   ; пока ни ax, ни bx не известны
   mov   bx, 6
   push  bx 
   ; стек содержит 6
   call  0123
   xor   ax, ax 
   ; ax = 0
   pop   bx 
   ; bx = 6, стек снова пуст
   mov   cx, ax 
   ; cx = 0
   int   F5 
   ; значения регистров ax, bx, cx известны
   ...
</pre>
<p><strong>Прог. 2. Пример дизассемблированного текста на этапе синтаксического анализа.</strong></p>
<h4><a name="p442">4.4.2. Этап семантического анализа.</a></h4>
<p>Как было отмечено, блок семантического анализа представляет собой небольшую систему логического вывода, состоящую из машины логического вывода, работающую с фактами (сигнатурами) уровня 3 и базы знаний. База знаний представляет собой правила, по которым может быть проведена вероятностная свертка с уровня 3 на уровень 0. Машина логического вывода оперирует этими правилами и производит эту свертку, получая на выходе выражение уровня 0, т.е. тип РПС с некоторой вероятностью.</p>
<h5><a name="p4421">4.4.2.1. Машина логического вывода.</a></h5>
<p>В машине логического вывода применен широко известный байесовский подход к вычислению вероятностей <a href="#L20">[20]</a>, который оказывается очень адекватным для данной предметной области.</p>
<p>Суть его состоит в следующем. Проверке подлежит некоторая гипотеза Н, с которой связаны некоторые утверждения А1, А2 и т.д. Тогда, проверив одно из них (A), мы можем пересчитать вероятность гипотезы Н с учетом истинности (форм. 4.1) или ложности (форм. 4.2) этого утверждения:</p>
<p><img src="img/asa00_ru/Image103.gif" alt="Форм. 4.1"/> (4.1)</p>
<p><img src="img/asa00_ru/Image104.gif" alt="Форм. 4.2"/> (4.2)</p>
<p>где:</p>
<p><img src="img/asa00_ru/Image105.gif" alt="априорная вероятность H"/> -- априорная вероятность H;</p>
<p><img src="img/asa00_ru/Image106.gif" alt="априорная вероятность (не Н), т.е. 1 - p(H)"/> -- априорная вероятность (не Н), т.е. 1 - p(H);</p>
<p><img src="img/asa00_ru/Image107.gif" alt="апостериорные вероятности гипотезы Н"/>,
<img src="img/asa00_ru/Image108.gif" alt="апостериорные вероятности гипотезы Н"/> -- апостериорные вероятности гипотезы Н;</p>
<p><img src="img/asa00_ru/Image109.gif" alt="вероятность A, если H верна"/> -- вероятность A, если H верна;</p>
<p><img src="img/asa00_ru/Image110.gif" alt="вероятность A, если H неверна"/> -- вероятность A, если H неверна;</p>
<p><img src="img/asa00_ru/Image111.gif" alt="вероятность (не A), если H верна, т.е. 1 - p(A/H)"/> -- вероятность (не A), если H верна, т.е. 1 - p(A/H);</p>
<p><img src="img/asa00_ru/Image112.gif" alt="вероятность (не A), если H неверна"/> -- вероятность (не A), если H неверна, т.е. 1 -
<img src="img/asa00_ru/Image110.gif" alt="вероятность (не A), если H неверна"/>.</p>
<p>Для нашего исследования гипотезами будут все выражения уровня 0 (например, пусть проверяется гипотеза H, что РПС -- резидентный вирус), а утверждениями -- сигнатуры уровня 3 (например, Остаться_Резидентным). Тогда для получения p(H/A) или <img src="img/asa00_ru/Image108.gif" alt=""/> необходимо знать:</p>
<ol>
<li>априорную вероятность p(H), т.е. заранее заданную вероятность того, что случайно выбранная программа окажется резидентным вирусом. Эта величина, конечно, определяется очень грубо. Для нашего примера пусть это будет 0.001;</li>
<li>p(A/H), т.е. вероятность того, что резидентный вирус использует функцию Остаться_Резидентным. Для нашего примера этой вероятностью вполне может быть 0.5, т.к. только около половины вирусов используют для этого стандартные функции;</li>
<li><img src="img/asa00_ru/Image110.gif" alt=""/> , т.е. вероятность того, любая другая программа может использовать эту функцию. Величина 0.02 вполне подойдет, т.к. резидентных программ не так много.</li>
</ol>
<p>Таким образом, если в коде мы находим сигнатуру Остаться_Резидентным, то по формуле 4.1 получим вероятность того, что это -- резидентный вирус, равную 0.024 (т.е. она увеличится 25 раз), а если нет, то по формуле 4.2 -- 0.00051 (т.е. уменьшится вдвое). И теперь эта вероятность может выступать в качестве априорной p(H) на следующем шаге, при проверке следующего утверждения, увеличиваясь или уменьшаясь таким образом в зависимости от истинности или ложности текущего утверждения.</p>
<p>В конце мы получим конечные вероятности всех гипотез р(H1/A1A2...As), p(H2/A1A2...As) ... p(Hg/A1A2...As), где g=K+L+M (рис. 7), из которых выбираются те, вероятность которых превышает некоторый порог P (для системы SubLVA P=0.7).</p>
<p>Для данной предметной области байесовский подход имеет следующие преимущества:</p>
<ol>
<li>в полученном дереве свертки, как уже отмечалось, далеко не все сигнатуры уровня 4 присущи исключительно РПС. Наличие вероятности <img src="img/asa00_ru/Image110.gif" alt=""/> для каждой гипотезы, отражающей тот факт, что эта сигнатура может встретиться в "полезной" программе, позволяет применять формулы 4.1 и 4.2, не задумываясь о том, насколько характерной для РПС является данная сигнатура;</li>
<li>формулы 4.1 и 4.2 легко видоизменяются с учетом неопределенностей, возникающей при поиске сигнатур. В блок синтаксического анализа может быть вставлена (и это предполагается сделать) вероятность свертки найденной сигнатуры уровня 4 на уровень 3. (В теории экспертных систем это носит название "неопределенность реакции пользователя").</li>
</ol>
<p>Пусть вероятность свертки равна r, тогда из 4.1 и 4.2 получается одна общая формула</p>
<p><img src="img/asa00_ru/Image113.gif" alt="4.3"/> (4.3)</p>
<p>где:</p>
<p>p(H/A,r) -- вероятность гипотезы H с учетом истинности утверждения A с вероятностью r;</p>
<p>p(H/A), <img src="img/asa00_ru/Image108.gif" alt=""/> -- вычисляются по формулам 4.1 и 4.2;</p>
<p>p(A,r) -- функция учета неопределенности утверждения A;</p>
<p><img src="img/asa00_ru/Image114.gif" alt=""/> = 1 - p(A,r).</p>
<p>Функция p(A,r) должна удовлетворять следующим условиям:</p>
<p>p(A,0) = 0</p>
<p>p(A,1) = 1</p>
<p>p(A,0.5) ищется как решение уравнения</p>
<p><img src="img/asa00_ru/Image115.gif" alt="4.4"/> (4.4),</p>
<p>т.е. при отсутствии информации относительно A вероятность p(H/A) не изменяется и остается равной априорной p(H). Решением этого уравнения является</p>
<p><img src="img/asa00_ru/Image116.gif" alt="4.5"/> (4.5)</p>
<h5><a name="p4422">4.4.2.2. Форма представления знаний.</a></h5>
<p>Итак, в базе знаний необходимо иметь следующую информацию: гипотезы принадлежности к тому или иному типу РПС (g штук) плюс априорную вероятность каждой из них p(H) и утверждения -- сигнатуры (s штук) плюс две вероятности p(A/H), <img src="img/asa00_ru/Image110.gif" alt=""/> для каждой.</p>
<p>База знаний имеет следующий формат:</p>
<pre>   
   Тип_РПС.Уровень.0 ЕСЛИ p(H) // Комментарий 
   Сигнатура.Уровень.3 p(A/H) [Image110.gif]
</pre>
<p>а фрагмент ее приведен на рис. 9:</p>
<pre class="source">
   ПСР.Резидентная ЕСЛИ 0.001
   
   // Уровень 1 - Проверить_Наличие.Память 
   
   Вызвать.Нестд_прер   0.4 0.03
   
   Вызвать.Нестд_функц  0.4 0.03
   
   Сканировать.Память   0.2 0.1
   
   // Уровень 1 - Выделить.Память
   
   int21.AA             0.3 0.9
   
   Манипуляция.MCB      0.5 0.001
   
   Системная_Область    0.2 0.01
   
   // Уровень 1 - Перехватить.Прер
   
   int21.25             0.35 0.95
   
   Запись_Табл          0.65 0.01
   
   // Уровень 1 - Скопироваться.Память
   
   Найти_себя.Память    0.8 0.001
   
   Скопировать.Память   0.95 0.95
   
   Остаться_Резидентным 0.5 0.02
   
   
   ПСР.Файловая ЕСЛИ 0.001
   
   ...
   
   
   ППЗ.Дополнительная ЕСЛИ 0.0001
   
   ...
</pre>
<p><strong>Рис. 9. Фрагмент базы знаний системы SubLVA.</strong></p>
<p>При анализе приведенной базы можно выявить некоторые ее любопытные особенности. Например, сигнатура int21.AA у вирусов встречается реже, чем у нормальных программ, т.к. они чаще пытаются выделить под себя память незаметно, а все нормальные программы делают это "законными" методами. Это крайний случай того, о чем говорилось в п. 4.4.2.1. А сигнатура Скопировать.Память одинаково часто встречается и в вирусах, и в полезных программах(и, наверное, является вообще одним из самых распространенных действий) и поэтому ее поиск не даст, вообще говоря, никакой новой информации относительно наличия вируса (формулы 4.1 и 4.2 вырождаются в p(H/A) = [Image108.gif] = p(H) ).</p>
<h3><a name="p45">4.5. Резюме.</a></h3>
<p>Система SubLVA показала себя вполне работоспособной, несмотря на то, что использовала далеко не полное дерево свертки и очень грубые оценки вероятностей в базе знаний. Алгоритмы, применяемые в ней, действительно являются достаточно быстрыми, например, анализ средней программы в 30 Кбайт занимает несколько секунд на машине класса 80486DX2-66. Степень достоверности выдаваемой ей информации составила порядка 80% на тестовых примерах, состоящих из реальных экземпляров РПС. Она, бесспорно, подвержена ошибкам первого и второго рода, в частности, оказалось, что почти все программ защиты классифицировались ей как РПС. (Это, вообще говоря, неудивительно, если принять во внимание постоянное их соперничество).</p>
<p>Система нуждается в совершенствовании, как в доработке применяемых алгоритмов (<a href="#p4421">см. п. 4.4.2.1</a>, учет неопределенности при нахождении сигнатуры), так и в присоединении остальных блоков из общей схемы ИСАИПК (в частности, введении динамического анализа).</p>
<h2><a name="L">СПИСОК ЛИТЕРАТУРЫ.</a></h2>
<ol>
<li><a name="L1"> Безруков Н.Н. <a href="/lib/anb00.html">Компьютерная вирусология</a>. - К.: УРЕ, 1991.</a></li>
<li><a name="L2"> Семьянов П. Красная волна. // НОВИНТЕХ, 1991, N 2.</a></li>
<li><a name="L3"> Моисеенков И. Безопасность компьютерных систем. // Компьютер Пресс, 1991, N 10-12.</a></li>
<li><a name="L4"> Thompson K. Reflection on trusting trust. // CACM, 1984,v. 27, N 8.</a></li>
<li><a name="L5"> Защита программного обеспечения. Под ред. Гроувера Д. -М.: Мир, 1992.</a></li>
<li><a name="L6"> Семьянов П., Зегжда Д. Анализ средств противодействия исследованию программного обеспечения. // Компьютер Пресс, 1993, N11.</a></li>
<li><a name="L7"> Расторгуев С.П., Дмитриевский Н.Н. Искусство защиты и "раздевания" программ. - М.: 1991.</a></li>
<li><a name="L8"> Спесивцев А.В. и др. Защита информации в персональных ЭВМ. М.: Радио и связь, 1992.</a></li>
<li><a name="L9"> Cohen F. <a href="/lib/afc01.html">Computer viruses - theory and experiments</a>. Proceedings of the 7th National Computer Security Conference. -1984.</a></li>
<li><a name="L10">Leonard M. Adleman. <a href="/lib/ala01.html">An Abstract Theory of Computer Viruses</a>. Proceedings of CRYPTO-88 conference. - 1988.</a></li>
<li><a name="L11">Зегжда Д. П., Котляров В. П. Средство сертификации и контроля несанкционированного доступа программ и данных компьютерных сетей. Тезисы докладов третьего всесоюзного семинара "Качество программного обеспечения". - М.: Алгоритм, 1991.</a></li>
<li><a name="L12">Касперский Е. Компьютерные вирусы: эволюция вверх, вниз и в стороны. Материалы эхо-конференции SU.VIRUS. - 1994.</a></li>
<li><a name="L13">Зегжда Д.П., Матвеев В.А., Молотков С.В., Тихомиров Ю.В., под редакцией Шмакова Э. М. Защита информации в компьютерных системах. Теоретические аспекты защиты от вирусов. - СПб.: СПбГТУ, 1993.</a></li>
<li><a name="L14">Cohen F. Computer viruses. Theory and experiments // Adv.Comput. Syst. Secur. Vol. 3 - Norwood (Mass), 1988.</a></li>
<li><a name="L15">Зегжда Д.П., Матвеев В.А., Мешков А.В., Семьянов П.В. Автоматизация анализа безопасности программного обеспечения. Тезисы докладов республиканского научно-технического семинара "Методы и технические средства защиты информации". - Обнинск: 1993.</a></li>
<li><a name="L16">Peterson P.E. Virus Definition Revisited. Материалы эхо-конференции comp.virus. - 1994.</a></li>
<li><a name="L17">Заморин А.П., Марков А.С. Толковый словарь по вычислительной технике и программированию. Основные термины. - М.:Рус.яз., 1988.</a></li>
<li><a name="L18">Вирт Н. Алгоритмы и структуры данных. - М.:Мир, 1989.</a></li>
<li><a name="L19">Матвеев В.А., Молотков С.В., Зегжда Д.П., Мешков А.В., Семьянов П.В., Шведов Д.В. Основы верификационного анализа безопасности исполняемого кода программ. - СПб.:СПбГТУ, 1994.</a></li>
<li><a name="L20">Экспертные системы. Принципы работы и примеры. Под ред. Р. Форсайта. - М.: Радио и связь, 1987.</a></li>
</ol>
[<a style="" href="/lib/?lang=RU&amp;index=AV#asa00">Вернуться к списку</a>] [<a href="/lib/asa00.html#disqus_thread">Комментарии</a>]<br/> <div id="disqus_thread"></div>
<script type="text/rocketscript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'vxheaven'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="/agreement.php">Terms of Use</a>!</small> <small>vxheaven.org aka vx.netlux.org</small></div>
<div style="margin-top: 2px; float: left;" class="adsapeu">
<script type="text/rocketscript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script>
</div>
<script data-rocketsrc="http://www.google-analytics.com/urchin.js" type="text/rocketscript"></script><script type="text/rocketscript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="/lib/index.php?lang=de&amp;id=asa00">de</a><a href="/lib/index.php?lang=en&amp;id=asa00">en</a><a href="/lib/index.php?lang=es&amp;id=asa00">es</a><a href="/lib/index.php?lang=it&amp;id=asa00">it</a><a href="/lib/index.php?lang=fr&amp;id=asa00">fr</a><a href="/lib/index.php?lang=pl&amp;id=asa00">pl</a><a href="/lib/index.php?lang=ru&amp;id=asa00">ru</a><a href="/lib/index.php?lang=ua&amp;id=asa00">ua</a></div>
</body>
</html>
