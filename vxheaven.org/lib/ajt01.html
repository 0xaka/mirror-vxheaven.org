<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Jamie Twycross, Matthew Williamson 'Implementing and testing a virus throttle' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Author" content="Jamie Twycross, Matthew Williamson"/>
<meta name="KeyWords" lang="en" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, Twycross, Jamie; Williamson, Matthew,Implementing and testing a virus throttle, worm, installed, delay, approach, queue, working, packet, device, infected, http, test, network, signature, machines, traffic"/>
<meta name="Description" content="In this paper we build on previous theoretical work and describe the implementation and testing of a virus throttle - a program, based on a new approach, that is able to substantially reduce the spread of and hence damage caused by mobile code such as worms and viruses. Our approach is different from current, signature-based anti-virus paradigms in that it identifies potential viruses based on their network behaviour and, instead of preventing such programs from entering a system, seeks to prevent them from leaving. The results presented here show that such an approach is effective in stopping the spread of a real worm, W32/Nimda-D, in under a second, as well as several different configurations of a test worm."/>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"047a5bcbf67431883fc9ed25fba33612",petok:"34c0558bde5f802b2327f28e09b5ba8a6f678b78-1498756470-1800",zone:"vxheaven.org",rocket:"a",apps:{}}];document.write('<script type="text/javascript" src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=85b614c0f6/cloudflare.min.js"><'+'\/script>');}}catch(e){};
//]]>
</script>
<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="/style.css"/><link rel="canonical" href="http://vxheaven.org/lib/ajt01.html"/>
<script type="text/rocketscript" data-rocketsrc="https://apis.google.com/js/plusone.js">{"parsetags": "explicit"}</script>
</head>
<body bgcolor="#dbc8a0" text="#302000" link="#225599" vlink="#113366">
<div class="s1">
<div style="float:right;"><a href="/lib/index.php?tbs=1"><img src="/img/max.gif" alt="Maximize"/></a></div> <form id="lf" style="margin: 0; float: right;" method="get" action="/index.php"><input type="hidden" name="action" value="set"/><select name="lang" onchange="javascript:document.getElementById('lf').submit();"><option value="ru">Русский</option><option selected="selected" value="en">English</option><option value="ua">Українська</option><option value="de">Deutsch</option><option value="es">Español</option><option value="fr">Fran&ccedil;ais</option><option value="it">Italiano</option><option value="pl">Polski</option></select></form>
<div style="float: right;"><div id="plusone"></div></div>
<script type="text/rocketscript">gapi.plusone.render("plusone", {"size":"small","count":"true"});</script>
<div style="float: right;" class="addthis_toolbox addthis_default_style">
<script type="text/rocketscript">var addthis_config = { ui_click: true }</script>
<a style="text-decoration: none; font-size: 10pt;" href="/?action=addthis" class="addthis_button_compact">Bookmark</a>
<script type="text/rocketscript" data-rocketsrc="http://s7.addthis.com/js/250/addthis_widget.js#username=herm1t"></script>
</div>
<div style="float: right;">
<script type="text/rocketscript" data-rocketsrc="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<form action="/search.php" id="cse-search-box">
<input type="hidden" name="cx" value="002577580816726040001:z9_irkorydo"/>
<input type="hidden" name="cof" value="FORID:10"/>
<input type="hidden" name="ie" value="UTF-8"/>
<input type="text" name="q" size="12" value=" "/>
<input type="submit" name="sa" value="Search"/>
</form>
</div><h1><a href="/" style="text-decoration: none; color: #000000;">VX Heaven</a></h1>
<span class="nav"><a href="/lib/">Library</a> <a href="/vl.php">Collection</a> <a href="/src.php">Sources</a> <a href="/vx.php?id=eidx">Engines</a> <a href="/vx.php?id=tidx">Constructors</a> <a href="/vx.php?id=sidx">Simulators</a> <a href="/vx.php?id=uidx">Utilities</a> <a href="/links.php">Links</a> <a href="/donate.php" style="color: #706020" id="donate">Donate</a> <a href="/forum" style="text-decoration: underline;">Forum</a> </span><br clear="all"/>
</div>
<div class="s2"><h1>Implementing and testing a virus throttle</h1><p><a href="/lib/?lang=en&amp;author=Twycross%2C%20Jamie">Jamie Twycross</a>, <a href="/lib/?lang=en&amp;author=Williamson%2C%20Matthew">Matthew Williamson</a><br/> <em>Proceedings of the 12th USENIX Security Symposium, August 4-8, 2003, Washington, DC, USA</em><br/> <em>May 2003</em></p><script type="text/rocketscript">var disqus_url = 'http://vxheaven.org/lib/ajt01.html';</script><div class="ci"><a href="/lib/?ci=ajt01">2</a></div><img src="/img/pdf.gif" alt="PDF"/><a href="/lib/pdf/Implementing%20and%20testing%20a%20virus%20throttle.pdf">Download</a> PDF (136.83Kb) (You need to be registered on <a href="/forum">forum</a>)<br/>[<a style="" href="/lib/?lang=EN&amp;index=AT#ajt01">Back to index</a>] [<a href="/lib/ajt01.html#disqus_thread">Comments</a>]<br/> 
 
<address>
Jamie Twycross <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="157f74787c7055787c797c7060263b7b7061">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script><br/>
Matthew Williamson <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="f39e9287879b9684dd849a9f9f9a929e809c9db39b83dd909c9e">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script><br/>
Hewlett-Packard Labs, Bristol, U.K.
</address>
<h2>Abstract</h2>
<p>In this paper we build on previous theoretical work and describe the implementation and testing of a <em>virus throttle</em> - a program, based on a new approach, that is able to substantially reduce the spread of and hence damage caused by mobile code such as worms and viruses. Our approach is different from current, signature-based anti-virus paradigms in that it identifies potential viruses based on their network behaviour and, instead of preventing such programs from entering a system, seeks to prevent them from leaving. The results presented here show that such an approach is effective in stopping the spread of a real worm, W32/Nimda-D, in under a second, as well as several different configurations of a test worm.</p>
<h2>Introduction</h2>
<p>CNET dubbed 2001 the ``<em>Year of the Worm</em>'' [<a href="#lemos01">14</a>] and 2002 has only seemed to confirm this, with high-speed mobile code forming the majority of entries in the top ten of most infectious programs. Indeed, on the weekend this paper was being completed, the W32/SQLSlam-A worm [<a href="#sqlslam">22</a>] infected what is currently estimated at 75,000 machines in 30 minutes [<a href="#weaver03">16</a>] and caused major network disruption. Finding effective ways to prevent such activity is a high priority.</p>
<p>The work we present here provides just that - an extremely effective way of halting the propagation of certain classes of worms. Our approach, <em>virus throttling</em> [<a href="#williamson02">27</a>], [<a href="#williamson03">30</a>], is based on the observation that under normal activity a machine will make fairly few outgoing connections to new machines, but instead is more likely to regularly connect to the same set of machines. This is in contrast to the fundamental behaviour of a rapidly spreading worm, which will attempt many outgoing connections to new machines. The idea behind the virus throttle is to put a rate limit on connections to new machines such that normal traffic remains unaffected but suspect traffic is slowed, quickly detected and stopped.</p>
<p>Our approach is different from current approaches in <em>three</em> key ways: it focuses on the <em>network behaviour</em> of the virus and prevents certain types of behaviour, in our case the attempted creation of a large number of outgoing connections per second. It is also unique in that, instead of stopping mobile code from entering a system, it restricts the code from <em>leaving</em>. Lastly, because connections over the allowed rate are <em>delayed</em> and not dropped, the system is tolerant to false positives and is therefore robust.</p>
<p>In this paper we give a detailed description of an implementation of the virus throttle and our experimental setup, and present the results of a number of tests. These tests show that the virus throttle is able to very quickly detect and prevent worms spreading from an infected machine. For example, the throttle is able to stop the W32/Nimda-D worm [<a href="#nimdad">21</a>] in under <em>one</em> second. Furthermore, since the throttle prevents subsequent infection, the effect on the global spread of the virus will depend on how widely it is deployed. Our results also show that when 75% of machines are installed with the throttle, the global spread of both real and constructed worms is substantially reduced. Throttled machines do not contribute any network traffic in spite of being infected, significantly reducing the amount of network traffic produced by a virus.</p>
<p>The next section, Section 2, paints the background against which our work stands, briefly reviewing what mobile code is and how it propagates and discussing current approaches to limiting this propagation. It then goes on to outline the foundations on which our perspective is based, and briefly reviews related work. Section 3 describes in detail the design and implementation of our virus throttle, the performance of which, along with our experimental setup, we describe in Section 4. Concluding remarks are made in Section 5.</p>
<h2>Background</h2>
<p>In this section we offer a brief review of mobile code and current approaches to limiting its spread. We then go on to introduce the conceptual framework upon which our work rests, and end the section with a summary of related work.</p>
<h3>Mobile code</h3>
<p>We are interested in a class of software broadly known as <em>mobile code</em> [<a href="#grimes01">10</a>]. For our purposes we define mobile code pragmatically as any program that is able to transfer itself from system to system with little or no human intervention. Many examples of such mobile code can be found in real life, the most common of which are the many viruses and worms that are becoming an increasingly prevalent feature of the Internet [<a href="#chess97">5</a>, <a href="#lemos01">14</a>]. While mobile code can propagate through different media, for example, removable storage, since we are particularly interested in propagation across <em>networks</em>, we will restrict our discussion to code that spreads across this medium. Although technical difference do exist between virus and worms [<a href="#cohen84">6</a>, <a href="#cohen92">7</a>], in what follows we will use these terms and mobile code interchangeable.</p>
<p>An archetypal piece of mobile code can in general be seen as repeating a cycle composed of several distinct stages. The code will perform some form of <em>scan</em> to attempt to locate target machines which are vulnerable to infection, and will then attempt to <em>exploit</em> any target machines found. If successful, the exploit will allow the mobile code to <em>transfer</em> a copy of itself to the target machine, which will itself begin its own scan/exploit/transfer cycle.</p>
<h3>Current approaches</h3>
<p>Current approaches to virus protection involve preventing a virus from entering a system, predominantly through signature-based detection methods [<a href="#cohen94">8</a>]. These methods concentrate on the physical characteristics of the virus i.e. its program code, and use parts of this code to create a unique signature of the virus. Programs entering the system are compared against this signature and discarded if they match. In terms of the three-stage scan/exploit/transfer cycle described above, current approaches can be seen as focusing on the <em>transfer</em> stage.</p>
<p>While this approach has up to now been fairly effective in protecting systems it has several limitations which, as the number of virus samples increases, decrease its effectiveness. It is fundamentally a reactive and case-by-case approach in that a new signature needs to be developed for each new virus or variant as it appears. Signature development is usually performed by skilled humans who are only able to produce a certain number of signatures in a given time. As the number of viruses increases, the time between initial detection and release of a signature increases, allowing a virus to spread further in the interim. Furthermore, comtemporary viruses are using techniques such as polymorphism and memory-residency to sidestep signature detection entirely.</p>
<h3>Agents and complex systems</h3>
<p>An alternative and fruitful approach can be gained by viewing the mobile code as an autonomous agent acting within a complex system [<a href="#schuster01">19</a>]. Such a paradigm shift leads to an emphasis on different concepts and also allows a vast amount of literature on complex and adaptive systems from fields concerned with these entities to be drawn upon. For example, when viewed as an agent the question of how the agent behaves within the environment it inhabits becomes as important as the purely mechanistic details of its construction on which the current approach described in the last section is based.</p>
<p>The distinction between mechanism and behaviour can lead to some simple but potentially powerful conclusions. While a virus is able to instantiate an effective spreading mechanism in an extremely large number of ways, each requiring a separate signature, the number of ways in which a virus can behave to spread effectively is perhaps much more limited. This is especially the case with the class of high-speed worms which are becoming increasingly prevalent and which, due to their high-speed nature, need to scan a large number of hosts per second. Behaviour is a much more powerful discriminator than that employed in current, mechanistically-orientated signature-based methods, as it potentially allows the automatic identification and hence removal of an entire class of worms.</p>
<p>Considering behaviour also leads to some less obvious insights, one being that it could be more productive to focus on preventing viruses leaving a system, as opposed to stopping them entering, the strategy taken by current methods. While such a seemingly altruistic approach may at first sight appear ineffective, recent work by Williamson and Leveille [<a href="#williamson02-2">29</a>] and other work discussed in the next section indicates that it can be extremely effectual in preventing the spread of viruses across networks.</p>
<h3>Related work</h3>
<p>Our approach is related to the ``<em>behaviour blocking</em>'' of Messmer [<a href="#messmer02">15</a>] which seeks to specify policies defining normal or acceptable behaviour for applications. If an application breaches such a policy it is reported to an administrator. The approach we take differs in that it is able to automatically respond to abnormal behaviour, taking the administrator out of the loop in this respect. The benign facet of this response is particularly important as it makes the throttle more tolerant to false positives. Another example of a benign response used in an intrusion detection application is given by Somayaji and Forrest [<a href="#somayaji00">20</a>], although their application implements this response in relation to abnormal sequences of syscalls. Bruschi and Rosti [<a href="#bruschi00">2</a>] discuss various ways in which hosts can be prevented from participating in network attacks and describe a tool, AngeL [<a href="#bruschi02">3</a>], which can be used to prevent systems from participating in such attacks. AngeL, however, relies on a signature-based algorithm to detect attacks, inspecting network packets for predefined sequences of data, for example, shellcode or unusual HTTP requests, in contrast to our behaviour-based approach.</p>
<h2>The virus throttle</h2>
<p>After outlining the context of our work in the last section, we now go on to give a detailed explanation of the design and implementation of a virus throttle, of which an initial description and proof-of-concept based on theory and simulation was presented in [<a href="#williamson02">27</a>]. The main focus of this section will be on a TCP implemention of the virus throttle, although we have also tested UDP, SMTP and Exchange throttles with similar designs.</p>
<h3>Design</h3>
<p>The virus throttle is a program that limits the rate of outgoing connections to new machines that a host is able to make in a given time interval. For the purposes of simplicity in this section we will assume that the host has <em>one</em> unique address - its source IP address, although the implementation described below allows for multiple source IP addresses. Connections to a remote machine are established through what is known as a three-way-handshake in which the initiator of the connection, the source machine, sends a TCP SYN packet to the target machine, identified by a destination IP address. The target machine then sends back a SYN-ACK packet, which the source machine replies to with an ACK packet [<a href="#postel81">17</a>]. By controlling the number of SYN packets transmitted from the source machine we can control the number of connections it is able to make.</p>
<p>A note should be made about the relationship between connection attempts and SYN packets. At the application layer, a connection is usually initiated by opening a socket [<a href="#stevens90">23</a>]. This results in the sending of an initial TCP SYN packet and, if no response is received within a certain time, the sending of further, identical, SYN packets. This continues up to a maximum time, the socket timeout, when the socket will give up and return control to the application. Thus, in attempting to open a single connection a machine may actually transmit several SYN packets. In our implementation we make no attempt to differentiate initial SYN packets from retries, and count the retries as separate connection attempts.</p>
<p>A machine will establish many such connections in the course of normal usage, for example when requesting a web page or the delivery of email. Many worms also use such connections when scanning in order to establish the existence and configuration of remote machines, with high-speed worms such as W32/Nimda-D [<a href="#nimdad">21</a>] or CodeRed [<a href="#codered">4</a>] initiating large numbers of connections to different targets per second. The virus throttle rests on the observation that the patterns of connections due to normal usage are very different from the patterns of connections created by such mobile code. Our research has suggested that under normal usage often no more than <em>one</em> connection to a target not recently connected to is made per second, and that the majority of connections are made to destination addresses that have recently been connected to [<a href="#williamson02">27</a>].</p>
<p>The virus throttle parses all outgoing packets from a machine for TCP SYN packets. The destination address of an intercepted SYN packet is then compared against a list of destination addresses of machines to which connections have previously been made, which we term the <em>working set</em>. The working set can hold up to 5 such addresses. If the destination address is in this working set the connection is allowed immediately. If the addresses is not in the working set and the working set is not full i.e. it holds less than 5 addresses, the destination address is added to the working set and the connection is once again allowed to proceed immediately. If none of these two conditions are met, the SYN packet is added to what we term the <em>delay queue</em> and is not transmitted immediately.</p>
<p>Once every second the delay queue is processed and the SYN packet at its head and any other SYN packets with the same destination address are popped and sent, allowing the establishment of the requested connection. The destination address of this packet is also added to the working set, the oldest member of which is discarded if the working set is full. If the delay queue is empty at processing time and the working set is full, the oldest member of working set is also discarded, allowing for the potential establishment of one connection per second to a target not recently connected to.</p>
<p>This design, summarised schematically in Figure <a href="#fig1">1</a>, allows hosts to create as many connections per second as they want to the 5 most recently connected-to machines. Any further connection attempts will be delayed for at least a second, and then attempted. Delaying connections rather than simply dropping them is important as such a benign response [<a href="#somayaji00">20</a>] allows the virus throttle a certain amount of leeway in its conception of normal behaviour and a response that, if incorrectly targeted at legitimate connection attempts, will introduce an often imperceptible delay in the connection, instead of prohibiting it entirely.</p>
<div align="center"><a name="fig1"></a>
<img src="img/ajt01/img1.gif" alt="Figure 1: A schema of the control flow of the virus throttle"/>
<p><strong>Figure 1: A schema of the control flow of the virus throttle</strong></p>
</div>
<p>In [<a href="#williamson02">27</a>], it was argued that if the rate of connections to new targets is high, as is the case with many worms, the delay queue would rapidly grow resulting in attempted connections being severely delayed. When implementing the throttle, we took this idea further and introduced an upper limit to the size of the delay queue which, once reached, will disallow all further connection requests by the host. Thus the throttle can be said to behave benignly within certain limits. From observation of the normal behaviour of a range of users we saw that the delay queue rarely grew bigger than a handful of packets and concluded that the size of the delay queue could offer an indication of the presence of a worm on the host: large delay queue sizes would almost certainly indicate an application behaving in a suspect manner. In our throttle we set this upper limit on the delay queue size to 100 packets.</p>
<p>Lastly, as mentioned previously, we have also implemented UDP, SMTP and Exchange versions of the throttle. The UDP throttle works in exactly the same way as its TCP counterpart except that instead of parsing outgoing network traffic for TCP SYN packets, it looks for outgoing UDP packets, each of which is considered a separate connection attempt. The email throttle is described fully in [<a href="#williamson03-2">28</a>].</p>
<h3>Implementation</h3>
<p>In this section we describe how the virus throttle was implemented, beginning with a short overview of the structure of the Linux network stack. Necessarily, this section is fairly technical, and the reader is referred to more complete works such as [<a href="#bovet02">1</a>, <a href="#rubini01">18</a>] for further information.</p>
<p>The Linux network stack strictly consists of two data structures, the <em>ptype_all</em> linked list and the <em>ptype_base</em> hash table, containing pointers to packet handler functions [<a href="#kossak99">13</a>], but, at a conceptual level, can simply be thought of as a list of packet handler functions. Outgoing packets are placed onto the list by a packet handler and traverse the list until they reach its head, after which the packets are passed to the <em>hard_start_xmit</em> function supplied by the appropriate network device driver for transmission on the wire. The virus throttle works by replacing the pointer to the <em>hard_start_xmit</em> function registered by the network device driver with a pointer to a function of its own. This means that, since the <em>hard_start_xmit</em> function is called every time a packet has finished traversing the network stack and is ready to be transmitted on the network interface, we are able to intercept and control every packet leaving the network device. In essence, the throttle can be viewed at this level as an ethernet device driver wrapper.</p>
<p>To accomplish this wrapping the virus throttle is implemented as a Linux 2.4.18 kernel module which, in its <em>init_module</em> routine, fetches the pointer to the <em>net_device</em> structure registered by the current network device driver. The <em>net_device</em> structure contains entries to pointers to the packet handling functions registered by the network device driver, including the <em>hard_start_xmit</em> function, whose pointer we replace with a pointer to our own transmit function.</p>
<p>Our own transmit function is a simple packet parser which looks for TCP SYN packets, the packets used to establish stream-based connections between applications. If the packet being parsed is <em>not</em> a TCP SYN packet, it is passed on to the original <em>hard_start_xmit</em> function for transmission as usual. If, however, it is a TCP SYN packet it is, as described in the previous section, either allowed to pass immediately, in which case it is handed off to the original <em>hard_start_xmit</em> function and possibly added to the working set or, if the working set is full, is added to the delay queue for later transmission. Both the working set and delay queue data structures are instantiated as linked lists using the linked list structure provided by the Linux kernel. The working set list stores the destination address of the packet, while the delay queue list stores the source and destination addresses of the packet, a copy of the <em>sk_buff</em> data structure associated with the packet, and the time it was enqueued. The limit on the size of the delay queue is implemented by monitoring the size of the delay queue in the packet parser and setting a flag if this size increases beyond the specified upper limit. The packet parser will never allow a connection attempt to commence if this flag is set.</p>
<p>Processing of the delay queue is handled by a kernel thread which wakes up a specified number of times per second, in our case once per second. The delay queue is then processed as described in the previous section, with packets deemed suitable for transmission dequeued and passed on to the original <em>hard_start_xmit</em> function. Due to the fact that the delay queue and working set are data structures shared by the enqueueing packet parsing routines and the dequeueing delay queue routines, these two data structures are carefully protected by spinlocks.</p>
<p>In order to allow for the fact that one host may have several different IP addresses or that the virus throttle may be placed on some intermediate system such as a bridge or gateway and hence see packets transmitted with a number of different source IP addresses, our implementation actually keeps an array of working set and delay queue data structures. Each entry in this array corresponds to a working set and delay queue for a particular source IP address.</p>
<h2>Testing</h2>
<p>Now that we have detailed the design and implementation of the throttle, in this section we move on to describe how we evaluated its performance. Initially, we outline our experimental setup and then go on to present the experiments we performed and their results.</p>
<h3>Experimental setup</h3>
<p>In order to effectively test our throttle in a range of different scenarios we first had to develop a secure testbed on which the virus throttle could be exposed to real and constructed mobile code. It is this testbed that we now describe, more details of which can be found in [<a href="#twycross02">25</a>].</p>
<h3>Testbed</h3>
<p>The testbed consists of a rack mounted single-chassis HP Blade Server bh7800 [<a href="#hp02">12</a>] providing the physical infrastructure for 3 separate LANs and housing what includes three 25-port 10/100 switches and 16 bh1100 Server Blades. Each Blade has a 700MHz Pentium III processor with a 30GB harddisk, onboard graphics and 3 network interfaces. One network interface is provided to the management LAN by a remote management card (RMC) daughterboard, while the other two provide connections to the remaining two LANs.</p>
<p>As well as being physically separate, the functional roles of the three LANs have also been separated. The <em>management LAN</em> provides access to the RMC daughterboard on each Server Blade which can be used for tasks such as power-cycling the Blade. The second LAN is designated the <em>administrative LAN</em> and is used to handle the installation and configuration of the Blades, and the coordination of experiments and collation of data from these experiments. The third LAN, the <em>experimental LAN</em>. is the network on which the experiments are actually performed. This setup is summarised in Figure <a href="#fig2">2</a>.</p>
<div align="center"><a name="fig2"></a>
<img src="img/ajt01/img2.gif" alt="Figure 2: The configuration of the testbed"/>
<p><strong>Figure 2: The configuration of the testbed</strong></p>
</div>
<p>In addition to the Blade Server, we are also employing four 1.8GHz Pentium 4 boxes, two of which act as servers on the administrative and experimental LANs respectively. The administrative LAN server, as well as running services such as PXE, DHCP and FTP necessary for the configuration of the Server Blades also coordinates our experiments. A third machine acts as our data collector and is in essence a network sniffer. A monitoring port [<a href="#procurve">11</a>] has been configured on the switch on the experimental LAN and the sniffer machine, running tcpdump [<a href="#tcpdump">24</a>], listens on this port and keeps a copy of all traffic on this LAN. The fourth machine is our infector which, at the start of some of our experiments, we bring up and use to inject a copy of the virus under study into one of the machines on the experimental LAN. This machine is then brought down and plays no further role in the experiments. For coordination purposes, the sniffer and infector machines have network connections to both the experimental and administrative LANs, and particular care has been taken to ensure that no traffic from one of these LANs is able to cross to the other LAN.</p>
<p>A slimmed-down Redhat 7.3 Linux installation with a custom 2.4.18 kernel forms the operating system on the Server Blades. As the experiments involve a variety of operating systems and settings, to ease configuration and save time we run VMware Workstation 3.2 [<a href="#vmware">26</a>] on each Server Blade. VMware allows the running of one operating system, the guest operating system, inside another operating system, the host operating system, in our case Linux. For the experiments below we use a standard installation of Windows 2000 Professional as the guest OS with VMware configured in bridged-only networking mode. Setting a VMware guest OS to use bridged-only networking means that the guest will largely use its own network stack, as opposed to that of the host OS if host-only networking is configured. This results in more realism in the network behaviour of applications running under the guest OS but, since bridged-only networking employs a proprietary VMware driver located fairly low down in the Linux network stack, places constraints on the implementation of the virus throttle not necessarily present in a production version of the throttle.</p>
<p>This configuration of the testbed allows us to automate the process of running experiments to a large extent, essential when it is necessary to repeat experiments a number of times to reduce the noise inherent in the random nature of the programs we are studying. Obviously, when a network has machines known to be infected with viruses, the security and isolation of this network is of prime importance. As well as the measures described above and careful configuration and testing of all software, the testbed is housed in a secure laboratory physically preventing connections to all other networks and strict policies concerning data transfer are imposed.</p>
<h3>Test worm</h3>
<p>In order to test the effectiveness of the virus throttle at allaying the spread of worms which scan at different rates a test worm was developed. The test worm consists of a basic stream-socket server [<a href="#stevens90">23</a>] which listens for connections on a specified port. When it receives a connection attempt the server starts a scanner whose properties, such as scan rate and address range, can also be specified. This scanner then scans the IP address space by attempting to make connections to addresses on the port the test worm server is listening on. As the type of scanning used is TCP connect scanning [<a href="#fyodor97">9</a>], if the scanner discovers the IP address of a machine running a test worm server it will trigger the server to start the scanner on this machine. This scheme allows a fairly realistic simulation of the scan/exploit/transfer worm lifecycle but, since no actual exploit or file transfer is involved and since any machines infected by the worm have, <em>a priori</em>, to already have been infected with the worm, guarantees that the test worm will never spread autonomously.</p>
<h2>Results</h2>
<p>Using the testbed setup described above we have been able to securely observe a variety of different viruses spreading across the experimental network and have performed a number of different experiments with the virus throttle, which we now go on to detail.</p>
<h3>Stopping speed</h3>
<p>We were first interested in the time it would take worms scanning at a number of different rates to cause the delay queue to reach its upper limit, 100 packets in our implementation. Remembering that once the delay queue has reached this limit we disable all further connection attempts, this time is effectively the time it takes the throttle to stop a worm. The experimental LAN on the testbed was configured with two machines, a gateway and a Server Blade running a Windows 2000 Professional guest OS. Table 1 records the time taken for the delay queue to reach 100 and the number of connection attempts made before this time when the Blade Server is infected with the real W32/Nimda-D virus [<a href="#nimdad">21</a>] and the test worm configured to scan at various rates. As this table shows, the virus throttle takes only 0.25 seconds to stop Nimda, which scans at a rate of around 200 connections per second, from spreading, and under 5 seconds to stop any application that scans at a rate of 20 connections or more per second. In the Nimda case, the throttle only allows one packet out on to the wire before networking is shut down, and a maximum of 5 packets for the test worm configured to scan at 20 connections per second. The stopping times for the SQLSlammer worm [<a href="#sqlslam">22</a>] of a UDP implementation of the throttle have also been included in Table 1 and show that the throttle is able to stop this worm in 0.02 seconds.</p>
<table summary="Table 1: Average time taken by the throttle to stop real and test worms" border="1">
<caption>Table 1: Average time taken by the throttle to stop real and test worms</caption>
<tr><th>connections per second</th><th>stopping time</th><th>allowed connections</th></tr>
<tr><th colspan="3">Nimda</th></tr>
<tr><td>120</td><td>0.25s</td><td>1</td></tr>
<tr><th colspan="3">Test Worm</th></tr>
<tr><td>20</td><td>5.44s</td><td>5</td></tr>
<tr><td>40</td><td>2.34s</td><td>2</td></tr>
<tr><td>60</td><td>1.37s</td><td>1</td></tr>
<tr><td>80</td><td>1.04s</td><td>1</td></tr>
<tr><td>100</td><td>0.91s</td><td>1</td></tr>
<tr><td>150</td><td>0.21s</td><td>0</td></tr>
<tr><td>200</td><td>0.02s</td><td>0</td></tr>
<tr><th colspan="3">SQLSlammer</th></tr>
<tr><td>850</td><td>0.02s</td><td>0</td></tr>
</table>
<h3>Mobile code propagation</h3>
<p>In order to test the effectiveness of the virus throttle at reducing the propagation of a real worm, the testbed was set up with one class C network containing 16 Server Blades running a VMware-encapsulated copy of Windows 2000 Professional vulnerable to the W32/Nimda-D virus [<a href="#nimdad">21</a>]. A machine which acted as the default gateway and DHCP server for this network was also configured. One of the Windows machines was then infected with W32/Nimda-D and its progress through the network observed by gathering data using the sniffer configured as described above. This data was then analysed and the time at which each system became infected with the Nimda virus determined. By varying the number of machines on the network which had the throttle installed and by repeating each experiment 10 times, we were able calculated the average time taken for a given number of machines to be infected assuming that a certain percentage of the machines on the network had virus throttles installed. These results are shown in Figure <a href="#fig4">4</a>.</p>
<div align="center"><a name="fig4"></a>
<img src="img/ajt01/img4.gif" alt="Figure 4: Infection times for different numbers of installed virus throttles (Nimda)"/>
<p><strong>Figure 4: Infection times for different numbers of installed virus throttles (Nimda)</strong></p>
</div>
<p>As Figure <a href="#fig4">4</a> shows, when no throttles are installed on any of the 16 machines Nimda takes on average just over 20 minutes to spread to all 16 machines. This time is slightly reduced when 25% and 50% of machines have throttles installed. However, when at least 75% of machines are installed with the throttle, Nimda is only able to spread to on average around half the machines on the network in the same amount of time, and has not spread to all 16 machines even after over 70 minutes. This represents both a decrease of 50% in the number of machines infected and a substantial increase the time taken for the worm to spread. When every machine is installed with the throttle, the worm is unable to spread at all.</p>
<p>Aside from the damage caused by the malicious payloads of many high-speed worms, these worms often cause denial-of-service attacks through the amount of network traffic they generate. The Sapphire worm caused network uplinks to become saturated due to the sheer quantity of traffic infected machines generated, whereas Nimda, while generating substantially less quantities of network traffic, caused routers and firewalls to fall over due to their inability to process the increased number of connection requests generated by infected machines. Figure <a href="#fig5">5</a> shows, for the experiment described at the start of this section, the traffic load over time on the test network. Here, the effect of having a network protected by the throttle is even more marked, with an approximately 25% reduction in viral traffic when only 25% of the network in protected by the throttle. When 50% of the machines are throttled the traffic load is reduced by over half, and when 75% are throttled to around 10% of its unthrottled average. Having all machines installed with the throttle quickly reduces all viral traffic to <em>zero</em>. These results show the ability of the virus throttle to substantially reduce the amount of network traffic generated by mobile code.</p>
<div align="center"><a name="fig5"></a>
<img src="img/ajt01/img5.gif" alt="Figure 5: Traffic loads for different numbers of installed virus throttles (Nimda)"/>
<p><strong>Figure 5: Traffic loads for different numbers of installed virus throttles (Nimda)</strong></p>
</div>
<h3>User trials</h3>
<p>While the previous section shows that the virus throttle is extremely effective in slowing and stopping the spread of certain classes of worms, an equally important aspect in determining its overall utility is establishing its impact on the performance of applications which legitimately establish connections in the course of normal user behaviour. If the throttle, for example, prevents users from accessing their emails, or slows this down to an unacceptable speed, it will soon be uninstalled.</p>
<p>From preliminary tests in which the throttle was installed on a number of researchers' machines, we received no reports of impaired network performance. We are currently involved in a series of much larger user trials in which the throttle is installed on the gateway used by a considerable number of users running a wide range of network-capable applications under several different operating systems. Initial results also point to no noticeable degradation in network performance.</p>
<p>To further explore the interaction of the throttle with legitimate network-aware applications, we have also implemented a throttle simulator which takes packet traces as input. To gather these packet traces we configured a monitoring port on a 80-port switch on HP's internal network and ran a packet sniffer on this port. This has allowed us to gather large quantities of data over extended periods of time from a range of different machines. Separating out these traces on a machine-by-machine basis and then running them through the simulator allows us to rapidly assess the applicability of the throttle to different classes of machines running different services. Preliminary results from the simulator show that the majority of network traffic from a throttled machine passes onto the network undelayed, and that none of the large quantities of legitimate network traffic we have gathered is mistaken for viral traffic. A fuller discussion of the applicability of our approach is given in [<a href="#williamson02">27</a>].</p>
<h2>Conclusion</h2>
<p>In this paper we have, after presenting the necessary background, described in detail the implementation and testing of a virus throttle. From the tests described above we have been able to show that the virus throttle is highly effective in detecting, slowing and stopping both real worms such as W32/Nimda-D and a test worm configured to scan at different rates. Our results also show that the virus throttle can substantially reduce the global spread of a worm, and hence the amount of network traffic produced.</p>
<p>In conclusion, this paper has demonstrated virus throttling to be a powerful tool in the prevention of high-speed worm propagation. We believe that throttling, when combined with current signature-based methods, will be an essential ingredient in any multilayered anti-virus solution.</p>
<h2>Bibliography</h2>
<ol>
<li><a name="bovet02"></a>D. P. Bovet and M. Cesati. <em>Understanding the Linux kernel</em>. O'Reilly &amp; Associates, 2002.</li>
<li><a name="bruschi00"></a>D. Bruschi and E. Rosti. Disarming offense to enable defense. In <em>Proc. of the New Security Paradigms Workshop 2000</em>, pages 69-75, Ireland, 2000.</li>
<li><a name="bruschi02"></a>D. Bruschi and E. Rosti. AngeL: A tool to disarm computer systems. In <em>Proc. of the 2001 Workshop on New Security Paradigms</em>, 2001.</li>
<li><a name="codered"></a>CERT Advisory CA-2001-19. CERT Coordination Center. http://www.cert.org/advisories/CA-2001-19.html.</li>
<li><a name="chess97"></a>D. Chess. <a href="/lib/adc02.html">The future of viruses on the Internet</a>. Presented at the Virus Bulletin International Conference, October 1-3, 1997.</li>
<li><a name="cohen84"></a>F. Cohen. <a href="/lib/afc01.html">Computer viruses - theory and experiments</a>. In <em>Proc. of the 7th Security Conference</em>, pages 143-158, 1984.</li>
<li><a name="cohen92"></a>F. Cohen. <a href="/lib/afc11.html">A formal definition of computer worms and some related results</a>. <em>Computers and Security</em>, 11(7):641-652, 1992.</li>
<li><a name="cohen94"></a>F. Cohen. <em><a href="/lib/afc13.html">A short course on computer viruses</a></em>. John Wiley &amp; Sons, Inc., 1994.</li>
<li><a name="fyodor97"></a>fyodor. The art of port scanning. <em>Phrack Magazine</em>, Volume 7, Issue 51, 11 of 17, 1997.</li>
<li><a name="grimes01"></a>R. A. Grimes. <em>Malicious mobile code</em>. O'Reilly &amp; Associates, 2001.</li>
<li><a name="procurve"></a>HP Procurve Series 2500 switches - management and configuration guide. Hewlett-Packard Company, 2000.</li>
<li><a name="hp02"></a>HP Blade Server bh7800 service guide. Hewlett-Packard Company, 2002.</li>
<li><a name="kossak99"></a>kossak and lifeline. Building into the Linux network layer. <em>Phrack Magazine</em>, Volume 9, Issue 55, 12 of 16, 1999.</li>
<li><a name="lemos01"></a>R. Lemos. Year of the worm. http://new.com.com/2102-1001-254061.html.</li>
<li><a name="messmer02"></a>E. Messmer. Behaviour blocking repels new viruses. http://www.nwfusion.com/news/2002/0128antivirus.html.</li>
<li><a name="weaver03"></a>D. Moore, V. Paxson, S. Savage, C. Shannon, S. Staniford, and N. Weaver. The spread of the Sapphire/Slammer worm. http://www.cs.berkeley.edu/ nweaver/sapphire/.</li>
<li><a name="postel81"></a>J. Postel. Transmission control protocol. RFC 793, DARPA, 1981.</li>
<li><a name="rubini01"></a>A. Rubini and J. Corbet. <em>Linux device drivers</em>. O'Reilly &amp; Associates, 2001.</li>
<li><a name="schuster01"></a>H. G. Schuster. <em>Complex Adaptive Systems</em>. Scator Verlag, 2001.</li>
<li><a name="somayaji00"></a>A. Somayaji and S. Forrest. Automated response using system-call delays. In <em>Proc. of the 9th USENIX Security Symposium</em>, pages 185-197, 2000.</li>
<li><a name="nimdad"></a>W32/Nimda-D. Sophos Anti-Virus. http://www.sophos.org/virusinfo/analysis/w32nimdad.html.</li>
<li><a name="sqlslam"></a>W32/SQLSlam-A. Sophos Anti-Virus. http://www.sophos.org/virusinfo/analysis/w32sqlslama.html.</li>
<li><a name="stevens90"></a>W. R. Stevens. <em>UNIX network programming</em>. Prentice Hall, 1990.</li>
<li><a name="tcpdump"></a>tcpdump. http://www.tcpdump.org.</li>
<li><a name="twycross02"></a>J. Twycross. Studying mobile code: an experimental setup. Technical report, Hewlett-Packard Labs, 2002.</li>
<li><a name="vmware"></a>VMware Workstation 3.2. VMware Inc. http://www.vmware.com.</li>
<li><a name="williamson02"></a>M. M. Williamson. Throttling viruses: Restricting propagation to defeat malicious mobile code. In <em>Proc. of the ACSAC Security Conference</em>, Las Vegas, Nevada, 2002.</li>
<li><a name="williamson03-2"></a>M. M. Williamson. The design, implementation and testing of an email throttle. Submitted to the Annual Computer Security Applications Conference, Las Vegas, N.V., 2003.</li>
<li><a name="williamson02-2"></a>M. M. Williamson and J. Leveille. An epidemiological model of virus spread. To appear in the Proceedings of the Annual Virus Bulletin Conference, 2003.</li>
<li><a name="williamson03"></a>M. M. Williamson, J. Twycross, J. Griffin, and A. Norman. Virus throttling. In <em>Virus Bulletin</em>, U.K., 2003.</li>
</ol>
[<a style="" href="/lib/?lang=EN&amp;index=AT#ajt01">Back to index</a>] [<a href="/lib/ajt01.html#disqus_thread">Comments</a>]<br/> <div id="disqus_thread"></div>
<script type="text/rocketscript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'vxheaven'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="/agreement.php">Terms of Use</a>!</small> <small>vxheaven.org aka vx.netlux.org</small></div>
<div style="margin-top: 2px; float: left;" class="adsapeu">
<script type="text/rocketscript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script>
</div>
<script data-rocketsrc="http://www.google-analytics.com/urchin.js" type="text/rocketscript"></script><script type="text/rocketscript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="/lib/index.php?lang=de&amp;id=ajt01">de</a><a href="/lib/index.php?lang=en&amp;id=ajt01">en</a><a href="/lib/index.php?lang=es&amp;id=ajt01">es</a><a href="/lib/index.php?lang=it&amp;id=ajt01">it</a><a href="/lib/index.php?lang=fr&amp;id=ajt01">fr</a><a href="/lib/index.php?lang=pl&amp;id=ajt01">pl</a><a href="/lib/index.php?lang=ru&amp;id=ajt01">ru</a><a href="/lib/index.php?lang=ua&amp;id=ajt01">ua</a></div>
</body>
</html>
