<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Elise de Doncker 'Self-Replicating Turing Machines and Computer Viruses' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Author" content="Elise de Doncker"/>
<meta name="KeyWords" lang="en" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, Doncker, Elise de,Self-Replicating Turing Machines and Computer Viruses, viruses, recursive, computer, problems, cohen, deﬁned, turing, program, questions, answer, sigma, deﬁnition, decidable, wegner, theory"/>
<meta name="Description" content="This paper reviews self-replication in the context of (partial) recursive functions and Turing computability. By the Church-Turing thesis, these are equivalent to other models of computation. The theory is linked to applications in the area of computer viruses. We address the views of various authors with respect to the (in)adequacy of Turing machine equivalent models for computer viruses."/>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"047a5bcbf67431883fc9ed25fba33612",petok:"568987e48d19d920954a2a704e6d6a4a0c43b9fc-1498757114-1800",zone:"vxheaven.org",rocket:"a",apps:{}}];document.write('<script type="text/javascript" src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=85b614c0f6/cloudflare.min.js"><'+'\/script>');}}catch(e){};
//]]>
</script>
<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="/style.css"/><link rel="canonical" href="http://vxheaven.org/lib/aed00.html"/>
<script type="text/rocketscript" data-rocketsrc="https://apis.google.com/js/plusone.js">{"parsetags": "explicit"}</script>
</head>
<body bgcolor="#dbc8a0" text="#302000" link="#225599" vlink="#113366">
<div class="s1">
<div style="float:right;"><a href="/lib/index.php?tbs=1"><img src="/img/max.gif" alt="Maximize"/></a></div> <form id="lf" style="margin: 0; float: right;" method="get" action="/index.php"><input type="hidden" name="action" value="set"/><select name="lang" onchange="javascript:document.getElementById('lf').submit();"><option value="ru">Русский</option><option selected="selected" value="en">English</option><option value="ua">Українська</option><option value="de">Deutsch</option><option value="es">Español</option><option value="fr">Fran&ccedil;ais</option><option value="it">Italiano</option><option value="pl">Polski</option></select></form>
<div style="float: right;"><div id="plusone"></div></div>
<script type="text/rocketscript">gapi.plusone.render("plusone", {"size":"small","count":"true"});</script>
<div style="float: right;" class="addthis_toolbox addthis_default_style">
<script type="text/rocketscript">var addthis_config = { ui_click: true }</script>
<a style="text-decoration: none; font-size: 10pt;" href="/?action=addthis" class="addthis_button_compact">Bookmark</a>
<script type="text/rocketscript" data-rocketsrc="http://s7.addthis.com/js/250/addthis_widget.js#username=herm1t"></script>
</div>
<div style="float: right;">
<script type="text/rocketscript" data-rocketsrc="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<form action="/search.php" id="cse-search-box">
<input type="hidden" name="cx" value="002577580816726040001:z9_irkorydo"/>
<input type="hidden" name="cof" value="FORID:10"/>
<input type="hidden" name="ie" value="UTF-8"/>
<input type="text" name="q" size="12" value=" "/>
<input type="submit" name="sa" value="Search"/>
</form>
</div><h1><a href="/" style="text-decoration: none; color: #000000;">VX Heaven</a></h1>
<span class="nav"><a href="/lib/">Library</a> <a href="/vl.php">Collection</a> <a href="/src.php">Sources</a> <a href="/vx.php?id=eidx">Engines</a> <a href="/vx.php?id=tidx">Constructors</a> <a href="/vx.php?id=sidx">Simulators</a> <a href="/vx.php?id=uidx">Utilities</a> <a href="/links.php">Links</a> <a href="/donate.php" style="color: #706020" id="donate">Donate</a> <a href="/forum" style="text-decoration: underline;">Forum</a> </span><br clear="all"/>
</div>
<div class="s2"><h1>Self-Replicating Turing Machines and Computer Viruses</h1><p><a href="/lib/?lang=en&amp;author=Doncker%2C%20Elise%20de">Elise de Doncker</a><br/> <em>Artificial Life X. Workshop Proceedings on Machine Self-Replication, pp. 129-132.</em><br/> <em> 2006</em></p><script type="text/rocketscript">var disqus_url = 'http://vxheaven.org/lib/aed00.html';</script><img src="/img/pdf.gif" alt="PDF"/><a href="/lib/pdf/Self-Replicating%20Turing%20Machines%20and%20Computer%20Viruses.pdf">Download</a> PDF (48.03Kb) (You need to be registered on <a href="/forum">forum</a>)<br/>[<a style="" href="/lib/?lang=EN&amp;index=TH#aed00">Back to index</a>] [<a href="/lib/aed00.html#disqus_thread">Comments</a>]<br/> <form method="post" action="">
<img src="/img/cache/0b9fd596a90421f9f1f68a9760275737.gif" alt="\text{T_EX size}" valign="middle"/>
<select name="TeX_size"><option value="-2">-2</option><option value="-1">-1</option><option value="0" selected="selected">0</option><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option> </select>
<input type="submit" value="Scale"/>
</form>
<address>
Elise de Doncker<br/>
Western Michigan University, Kalamazoo, MI 49008, USA<br/>
<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="0f6a63667c6a4f6c7c217862666c67216a6b7a">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>
</address>
<ul>
<li><a href="#c0">Abstract</a></li>
<li><a href="#c1">Self-replication</a></li>
<li><a href="#c2">Recursive and partial recursive functions</a></li>
<li><a href="#c3">Church-Turing Thesis</a></li>
<li><a href="#c4">Recursive and recursively enumerable sets</a></li>
<li><a href="#c5">Questions about self-replicating programs/TM</a></li>
<li><a href="#c6">Application to Computer Viruses</a></li>
<li><a href="#c7">Conclusions</a></li>
<li><a href="#c8">Acknowledgments</a></li>
<li><a href="#c9">References</a></li>
</ul>
<h2><a name="c0"></a>Abstract</h2>
<p>This paper reviews self-replication in the context of (partial) recursive functions and Turing computability. By the Church-Turing thesis, these are equivalent to other models of computation. The theory is linked to applications in the area of computer viruses. We address the views of various authors with respect to the (in)adequacy of Turing machine equivalent models for computer viruses.</p>
<h2><a name="c1"></a>Self-replication</h2>
<p>The book <em>“G&ouml;del, Escher, Bach, An Eternal Golden Braid”</em>, by Douglas Hofstadter (Hofstadter, 1999) gives examples of self-replication (<em>self-rep</em>) and self-reference (<em>self-ref</em>).</p>
<p>Hofstadter lists a self-replicating computer program which, called with a “<em>template</em>” argument as speciﬁed in the procedure declaration part, calls itself recursively with its own text as the <em>template</em>, resulting in delivering itself as output. It is noted that the program consists of two parts, the procedure deﬁnition and the recursive call where it uses the template data.</p>
<p>In the example of self-replication of DNA, parallels are drawn between self-rep in DNA and self-ref in a formal logic system, the <em>Typographical Number System (TNT)</em>. For example, DNA strands correspond to <em>TNT</em> strings, genetic code to G&ouml;del code, and translation of <em>RNA ⇒ proteins</em> to arithmetization from <img src="/img/cache/e54582e6ddb8e68dc206351bdae4b937.gif" alt="\cal{N} \Rightarrow" valign="middle"/> to <em>meta TNT</em>. As a futher analogy, one strand of the double-stranded DNA piece is referred to as the <em>template</em> since it does not encode the DNA enzymes endonuclease, polumerase and ligase.</p>
<p>In the remainder of this paper we review recursive and partial recursive functions, the Church-Turing thesis, recursive and recursively enumerable sets, and self-replicating programs/Turing machines. We furthermore discuss an application to computer viruses and related computability issues.</p>
<h2><a name="c2"></a>Recursive and partial recursive functions</h2>
<p>In this section we deﬁne partial recursive and recursive functions operating on strings of symbols. The deﬁnition can be transformed to natural numbers through G&ouml;del numbering.</p>
<p>Let us use the introductory deﬁnition in (Brainerd and Landweber, 1974) of (partial) recursive functions. An <em>alphabet</em> <img src="/img/cache/025b3f94d79319f2067156076bf05243.gif" alt="\Sigma" valign="middle"/> is a non-empty, ﬁnite set of symbols. <img src="/img/cache/8faa4dec1bc65d3b299bb9e4c0bbd147.gif" alt="W = \Sigma^*" valign="middle"/> is the set of all strings that can be made with symbols from <img src="/img/cache/025b3f94d79319f2067156076bf05243.gif" alt="\Sigma" valign="middle"/> and also includes the empty string, <img src="/img/cache/92e4da341fe8f4cd46192f21b6ff3aa7.gif" alt="\epsilon" valign="middle"/>.</p>
<p>In view of the recursive nature of the deﬁnition following, we need a set of basis functions:</p>
<p><img src="/img/cache/3b3f303b07c2a469cfba1854894d5c20.gif" alt="
\begin{align}
	\iota : W \mapsto W &amp;&amp; \iota(x) = x\ (identity),\\
	\varsigma : W \mapsto W &amp;&amp; \varsigma(x) = x + 1\ (successor),\\
	\zeta : W^0 \mapsto W &amp;&amp; \zeta() = \epsilon\ (zero\ function),\\
	\pi : W \mapsto W^0 &amp;&amp; \pi(x) = ()\ (projection).
\end{align}" valign="middle"/></p>
<p>The recursion proceeds with the use of four operators on functions:</p>
<p><img src="/img/cache/15f05890761b82c4cf18bc38bf88a790.gif" alt="
f \circ g(x) = f(g(x))\ (composition),\\
f \times g(x,y) = (f(x),g(y))\ (combination),\\
f^y(x) = f \circ f \dots \circ f\ (exponentiation,\ y\ times\ composed),\\
f^\bigtriangledown(x,y) = x'\text{ where }f^k(x,y) = (x', 1)
" valign="middle"/></p>
<p>and <img src="/img/cache/8ce4b16b22b58894aa86c421e8759df3.gif" alt="k" valign="middle"/> is the smallest value such that the second argument listed becomes 1 (<em>repetition</em>). Repetition may not be deﬁned at <img src="/img/cache/90cbc22edf225adf8a68974f51227f05.gif" alt="(x,y)" valign="middle"/> in view of the fact that successive compositions of <img src="/img/cache/8fa14cdd754f91cc6554c9e71929cce7.gif" alt="f" valign="middle"/> may never yield 1 as the second argument.</p>
<p>A partial recursive function <img src="/img/cache/859d0fc786a268d58a7ba066e82dfdf9.gif" alt="F : W^r \mapsto W^s" valign="middle"/> is either one of the basis functions, or obtained from these by a ﬁnite number of compositions, combinations, exponentiations or repetitions. This corresponds to the ability to implement a partial recursive function as a program in an algorithmic language; the program may not terminate for all arguments as the function may not be everywhere deﬁned. A <em>recursive function</em> is partial recursive and total (deﬁned for all arguments). As a simple example, <img src="/img/cache/d1727ba1c892eb1ca9634aca85e0a1b8.gif" alt="\varsigma^y(x) = x+y" valign="middle"/> is a recursive function deﬁned in terms of successor and exponentiation.</p>
<h2><a name="c3"></a>Church-Turing Thesis</h2>
<p>As an amazing result/claim, the classical <em>Church-Turing thesis</em> states that the set of the recursive functions as deﬁned above coincides with that of the functions which can be implemented by any algorithmic means (and terminate for all arguments). Computational models including those of Turing machines (TM), Post systems, and algorithmic programming languages, are all equivalent. This can be extended to partial recursive functions by allowing, e.g., programs/TM which do not halt for all inputs in the sense that termination is guaranteed for arguments where the function is deﬁned, but may not be otherwise.</p>
<p>By G&ouml;del numbering, the strings in a language are mapped to natural numbers, and the string membership problem in a language is mapped to classifying natural numbers with respect to some characteristic. In this context, (Hofstadter, 1999) lists various versions of the Church-Turing thesis, of different strenghts. The “standard” version goes as follows: <em>“Suppose there is a method which a sentient being follows in order to sort numbers into two classes. Suppose further that this method always yields an answer within a ﬁnite amount of time, and that it always gives the same answer for a given number. Then some general recursive function exists which gives exactly the same answers as the sentient being’s method does”</em>. The “isomorphism version” (which strengthens the conclusion) is: <em>“Suppose there is a method which a sentient being follows in order to sort numbers into two classes. Suppose further that this method always yields an answer within a ﬁnite amount of time, and that it always gives the same answer for a given number. Then some general recursive function exists which gives exactly the same answers as the sentient being’s method does. Moreover, the mental process and the recursive function are isomorphic in the sense that on some level there is a correspondence between the steps being carried out in both computer and brain”</em>, also suggesting that the logical structure of this calculation (on a high enough level) in the brain can be implemented as a recursive function.</p>
<p>If we consider (partial) recursive functions giving an answer to decision problems, then recursive functions can be implemented by procedures which always halt and give a YES/NO answer in all instances of the problem addressed; whereas partial recursive functions are only guaranteed to give a YES answer for instances of the problem where the answer is, indeed, afﬁrmative.</p>
<h2><a name="c4"></a>Recursive and recursively enumerable sets</h2>
<p>A recursive set <em>L</em> is recognized by a TM which decides the membership problem in <em>L</em>, thereby accepting inputs <img src="/img/cache/4631ed4fd2fe4dbf2f7bb7ec1ed77cc1.gif" alt="w \in L" valign="middle"/> and rejecting otherwise. Here the membership problem is <em>decidable</em>, corresponding to a recursive characteristic function for <em>L</em>. For a <em>recursively enumerable (r.e.)</em> set, the membership problem is <em>semi-decidable</em> (which falls in the <em>undecidable</em> class). For an r.e. language <em>L</em> there is a TM which accepts strings <img src="/img/cache/4631ed4fd2fe4dbf2f7bb7ec1ed77cc1.gif" alt="w \in L" valign="middle"/> but may not halt for <img src="/img/cache/9db262731153b2f96eccf378ff83fdbf.gif" alt="w \not\in L" valign="middle"/>. In this case, <em>L</em> has a partial recursive characteristic function.</p>
<p>As an example, the <em>universal language</em></p>
<p><img src="/img/cache/0745f84c28285a85faf6866380f7ba8c.gif" alt="L_u = \{&lt; M &gt; w | w \in L(M)\}," valign="middle"/></p>
<p>where <img src="/img/cache/e495e8d59b125539684d751e5cb4292d.gif" alt="&lt; M &gt;" valign="middle"/> is a binary encoding of TM <em>M</em> and <img src="/img/cache/27c04cb00963aadde6d8e111e59e9f95.gif" alt="w \in {0,1}^*" valign="middle"/>, is r.e. but not recursive. This relates to the undecidability of the <em>halting problem</em> (for TM); i.e., it is undecidable to determine for an arbitrary TM <em>M</em> and input <em>w</em>, whether or not <em>M</em> will halt with input <em>w</em>.</p>
<p>Furthermore, a language is r.e. iff there is a TM which enumerates the strings of the language on its tape.</p>
<p>A <em>property</em> <img src="/img/cache/9abb186f2b6523a1618822f0451c294d.gif" alt="\cal{L}" valign="middle"/> of r.e. languages is a set of r.e. languages <img src="/img/cache/9548db1e502d64ec7f12711c4ce217d4.gif" alt="\cal{L} \subseteq \Sigma^*" valign="middle"/>, such that <em>L</em> is said to have property <img src="/img/cache/9abb186f2b6523a1618822f0451c294d.gif" alt="\cal{L}" valign="middle"/> if <img src="/img/cache/62765beda9f33c83f59035da648da1d0.gif" alt="L \in \cal{L}" valign="middle"/> (Hopcroft and Ullman, 1979). <img src="/img/cache/9abb186f2b6523a1618822f0451c294d.gif" alt="\cal{L}" valign="middle"/> is called a trivial property if <img src="/img/cache/45621a105e474267f619172e730ca35c.gif" alt="\cal{L} = \not0" valign="middle"/> or if it consists of all r.e. languages. Instead of studying <img src="/img/cache/9abb186f2b6523a1618822f0451c294d.gif" alt="\cal{L}" valign="middle"/>, we focus on a set of encodings <img src="/img/cache/e495e8d59b125539684d751e5cb4292d.gif" alt="&lt; M &gt;" valign="middle"/> of TM <em>M</em> corresponding to its languages <em>L(M)</em>, i.e.,</p>
<p><img src="/img/cache/c00a229d8e7867c7f5b0549176e22172.gif" alt="{\cal{M}}_{\cal{L}} = \{&lt; M &gt; | L(M) \in \cal{L} \}." valign="middle"/></p>
<p>It is well-known that every non-trivial property <img src="/img/cache/9abb186f2b6523a1618822f0451c294d.gif" alt="\cal{L}" valign="middle"/> of r.e. languages is undecidable, corresponding to the non-recursiveness of <img src="/img/cache/a4b4a6ffa65e1e2643d7e99790c25d59.gif" alt="\cal{M}_{\cal{L}}" valign="middle"/> for non-trivial <img src="/img/cache/9abb186f2b6523a1618822f0451c294d.gif" alt="\cal{L}" valign="middle"/>.</p>
<p>Some properties are r.e. whilst other ones are not. For example,</p>
<p><img src="/img/cache/68f30f5eb0475e50c3bf84df064dd45a.gif" alt="\{&lt; M &gt; | w \in L(M)\ for\ some\ fixed\ string\ w\}" valign="middle"/></p>
<p>is r.e., and</p>
<p><img src="/img/cache/70f930520e0a3f5c6c494101ce328efa.gif" alt="\{&lt; M &gt; | L(M)\ is\ a\ singleton\}" valign="middle"/></p>
<p>is not r.e.</p>
<h2><a name="c5"></a>Questions about self-replicating programs/TM</h2>
<p>With a basis of theoretical computer science aspects in previous sections, we now turn to questions related with self-replication. These may be of practical importance, for example, to check whether a given program replicates itself accurately. Consider a program <img src="/img/cache/d1cdbf2fe7e18516c3a793a652b36039.gif" alt="\cal{P}" valign="middle"/> which outputs strings. Some questions are:</p>
<ul>
<li>Is it possible to write a program <img src="/img/cache/071348882f63b72122066ad8a0d7c90f.gif" alt="\cal{U}" valign="middle"/> that, when given <img src="/img/cache/d1cdbf2fe7e18516c3a793a652b36039.gif" alt="\cal{P}" valign="middle"/> as input, determines if <img src="/img/cache/d1cdbf2fe7e18516c3a793a652b36039.gif" alt="\cal{P}" valign="middle"/> outputs (replicates) itself (as one of its outputs)?</li>
<li>Is it possible to write a program <img src="/img/cache/071348882f63b72122066ad8a0d7c90f.gif" alt="\cal{U}" valign="middle"/> that, when given <img src="/img/cache/d1cdbf2fe7e18516c3a793a652b36039.gif" alt="\cal{P}" valign="middle"/> as input, determines if <img src="/img/cache/d1cdbf2fe7e18516c3a793a652b36039.gif" alt="\cal{P}" valign="middle"/> outputs only itself?</li>
<li>Is it possible to write a program <img src="/img/cache/071348882f63b72122066ad8a0d7c90f.gif" alt="\cal{U}" valign="middle"/> that, when given <img src="/img/cache/d1cdbf2fe7e18516c3a793a652b36039.gif" alt="\cal{P}" valign="middle"/> as input, determines if <img src="/img/cache/d1cdbf2fe7e18516c3a793a652b36039.gif" alt="\cal{P}" valign="middle"/> replicates itself within a set number of steps or set time?</li>
</ul>
<p>These questions can be formulated with the expectation that <img src="/img/cache/071348882f63b72122066ad8a0d7c90f.gif" alt="\cal{U}" valign="middle"/> would decide the problem (give a yes/no answer for each instance of the problem); or, with the expectation that <img src="/img/cache/071348882f63b72122066ad8a0d7c90f.gif" alt="\cal{U}" valign="middle"/> would output “yes” in the afﬁrmative case but may not otherwise give an answer.</p>
<p>For example, the set</p>
<p><img src="/img/cache/0517430890e6a444a99c43868d66f531.gif" alt="\{&lt; M &gt; | &lt; M &gt;\ halts\ when\ run\ with\ input\ &lt; M &gt;\}" valign="middle"/></p>
<p>is r.e. but not recursive.</p>
<h2><a name="c6"></a>Application to Computer Viruses</h2>
<p>Programs that replicate themselves have been important in the study of computer viruses. A computer <em>virus</em> is deﬁned by (Cohen, 1985) as <em>a program that can infect other programs by modifying them to include a (possibly evolved) copy of itself (so that a virus can spread to the transitive closure of information paths from an initial source).</em></p>
<p>This gives rise to the deﬁnition of a <em>viral set</em>, the elements of which produce other elements of the set upon execution. Cohen uses a Turing machine model where each virus in a viral set produces an element of the set on some part of the TM tape outside of the original virus speciﬁcation.</p>
<p>Formally, a viral set is a pair <em>(M,V)</em> where <em>M</em> is a TM and <em>V</em> is a set of viruses written as strings in the tape alphabet of <em>M</em>. When <em>M</em> (in its start state) reads <img src="/img/cache/489f07bffe8b7e18a6112f5022b09410.gif" alt="v \in V" valign="middle"/>, it writes a string <img src="/img/cache/489f07bffe8b7e18a6112f5022b09410.gif" alt="v \in V" valign="middle"/> somewhere else on its tape.</p>
<p>In (Thimbleby et al., 1998), the notion of <em>viral infection</em> is associated with the following attributes:</p>
<ul>
<li>A <em>trojan (Trojan horse) component, since an infected program behaves in an unwanted manner under some conditions;</em></li>
<li>A <em>dormancy component, as the infection may conceal itself;</em></li>
<li>An <em>infective component, since infected programs are destined to infect other programs.</em></li>
</ul>
<p>Cohen’s undecidability results (Cohen, 1985; Cohen, 1987; Cohen, 1989; Chess and White, 2000) show that</p>
<ul>
<li><em>There is no algorithm that can detect all viruses.</em> Some infected ﬁles may be missed (<em>false negative</em>); or non-infected ﬁles may be detected as infected (<em>false positive</em>); or no answer may be returned.</li>
<li><em>There is no algorithm (TM) that can decide if one virus evolves into another.</em></li>
</ul>
<p>Other results (Chess and White, 2000) include that <em>there are viruses for which no error-free detection algorithm exists (undetectable computer viruses).</em></p>
<p>For the study of trojans and computer viruses, a number of authors have pointed out inadequacies with the classic (TM equivalent) computation models. According to (Wegner, 1996; Wegner, 1997; Thimbleby et al., 1998), TM equivalent models are not sufﬁcient to describe systems that interact. A virus entering a system indeed constitutes an interaction (Thimbleby et al., 1998).</p>
<p>(Thimbleby et al., 1998) also show that the virus biological metaphor is inadequate. They introduce a new framework for modelling computer viruses and other malicious programs, and make suggestions for the construction of virally resistant systems.</p>
<p>(M&auml;kinen, 2001) comments on (Thimbleby et al., 1998) and uses a universal TM (UTM) at the basis of his model for computer viruses. In this model, simulation of a viral TM <em>v</em> by the UTM produces a viral TM <em>v'</em> on the tape of the UTM. (M&auml;kinen, 2001) ﬁnds the UTM model suitable for addressing basic undecidability problems related to computer viruses.</p>
<p>In their reply to M&auml;kinen’s paper, (Thimbleby et al., 2001) comment, e.g. that, whilst M&auml;kinen’s model is appropriate for basic undecidability issues, virus replication is <em>too narrowly speciﬁed; and the formalism fails to address infection mechanisms, which makes it hard to explore virus prevention.</em></p>
<h2><a name="c7"></a>Conclusions</h2>
<p>We draw analogs between self-replicating programs (”machines” in general) and self-replicating Turing machines, based on the Church-Turing thesis. Sayama (Sayama, 2006) (this conference) addresses similar problems based on links between von Neumann’s universal constructors and Turing machines.</p>
<p>We distinguish between recursive sets (decidable problems), sets which are r.e. but not recursive (semi-decidable problems) and non-r.e. sets. The latter two correspond to undecidable problems. The question can be raised whether being r.e. but not recursive has applications in practice.</p>
<p>Furthermore we discuss computer viruses and related computability issues in the framework of self-replicating programs.</p>
<h2><a name="c8"></a>Acknowledgments</h2>
<p>The reviewers’ comments, especially regarding the application to computer viruses, are greatly appreciated.</p>
<h2><a name="c9"></a>References</h2>
<ul>
<li>Brainerd, W. S. and Landweber, L. H. (1974). <em>Theory of Computation</em>. John Wiley and Sons.</li>
<li>Chess, D. M. and White, S. R. (2000). <a href="/lib/adc06.html">An undetectable computer virus</a>. In Virus Bulletin Conference. http://www.research.ibm.com/antivirus/SciPapers/VB2000DC.htm.</li>
<li>Cohen, F. (1985). Computer viruses. Dissertation, USC.</li>
<li>Cohen, F. (1987). <a href="/lib/afc01.html">Computer viruses: Theory and experiments</a>. <em>Computers and Security</em>, 6:22–35.</li>
<li>Cohen, F. (1989). <a href="/lib/afc10.html">Computational aspects of computer viruses</a>. <em>Computers and Security</em>, 8:297–298.</li>
<li>Hofstadter, D. R. (1999). <em>G&ouml;del, Escher, Bach: An Eternal Golden Braid</em>. Basic Books, Perseus Book Group.</li>
<li>Hopcroft, J. E. and Ullman, J. D. (1979). <em>Introduction to Automata Theory, Languages and Computation</em>. Addison-Wesley.</li>
<li>M&auml;kinen, E. (2001). <a href="/lib/aem01.html">Comment on ’A Framework for Modelling Trojans and Computer Virus Infection</a>. <em>Computer Journal</em>, 44(4):321–323.</li>
<li>Sayama, H. (2006). Self-replicating machines attempting to solve the unsolvable. Workshop on Machine Self-Replication, Tenth International Conference on the Simulation and Synthesis of Living Systems (ALife X).</li>
<li>Thimbleby, H., Anderson, S., and Cairns, P. (1998). <a href="/lib/aht01.html">A framework for modelling trojans and computer virus infection</a>. <em>Computer Journal</em>, 41(7):444–458.</li>
<li>Thimbleby, H., Anderson, S., and Cairns, P. (2001). <a href="/lib/aht02.html">Reply to ‘Comment on ”A Framework for Modelling Trojans and Computer Virus Infection”’</a>. <em>Computer Journal</em>, 44(4):321–323.</li>
<li>Wegner, P. (1996). The paradigm shift from algorithms to interaction. http://jeffsutherland.com/ // papers/wegacm.pdf.</li>
<li>Wegner, P. (1997). Why interaction is more powerful than algorithms. <em>Commun. ACM</em>, 40(5):80–91.</li>
</ul>
[<a style="" href="/lib/?lang=EN&amp;index=TH#aed00">Back to index</a>] [<a href="/lib/aed00.html#disqus_thread">Comments</a>]<br/> <div id="disqus_thread"></div>
<script type="text/rocketscript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'vxheaven'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="/agreement.php">Terms of Use</a>!</small> <small>vxheaven.org aka vx.netlux.org</small></div>
<div style="margin-top: 2px; float: left;" class="adsapeu">
<script type="text/rocketscript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script>
</div>
<script data-rocketsrc="http://www.google-analytics.com/urchin.js" type="text/rocketscript"></script><script type="text/rocketscript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="/lib/index.php?lang=de&amp;id=aed00">de</a><a href="/lib/index.php?lang=en&amp;id=aed00">en</a><a href="/lib/index.php?lang=es&amp;id=aed00">es</a><a href="/lib/index.php?lang=it&amp;id=aed00">it</a><a href="/lib/index.php?lang=fr&amp;id=aed00">fr</a><a href="/lib/index.php?lang=pl&amp;id=aed00">pl</a><a href="/lib/index.php?lang=ru&amp;id=aed00">ru</a><a href="/lib/index.php?lang=ua&amp;id=aed00">ua</a></div>
</body>
</html>
