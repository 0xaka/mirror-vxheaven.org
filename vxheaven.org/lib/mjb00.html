<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Jan Bergstra, Alban Ponse 'A Bypass of Cohen's Impossibility Result' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Author" content="Jan Bergstra, Alban Ponse"/>
<meta name="KeyWords" lang="en" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, Bergstra, Jan; Ponse, Alban,Bypass of Cohen's Impossibility Result, text, shrat, shft, algebra, viruses, underline, pglc, virus, test, security, omega, instruction, downarrow, system, worm"/>
<meta name="Description" content="Detecting illegal resource access in the setting of network communication or grid computing is similar to the problem of virus detection as put forward by Fred Cohen in 1984. We disucuss Cohen's impossibility result on virus detection, and introduce &quot;risk assessment of security hazards&quot;, a notion that is decidable for a large class of program behaviors."/>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"047a5bcbf67431883fc9ed25fba33612",petok:"9048adf2ceac87611eccfb43fea628f4a9d3b9d5-1498755697-1800",zone:"vxheaven.org",rocket:"a",apps:{}}];document.write('<script type="text/javascript" src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=85b614c0f6/cloudflare.min.js"><'+'\/script>');}}catch(e){};
//]]>
</script>
<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="/style.css"/><link rel="canonical" href="http://vxheaven.org/lib/mjb00.html"/>
<script type="text/rocketscript" data-rocketsrc="https://apis.google.com/js/plusone.js">{"parsetags": "explicit"}</script>
</head>
<body bgcolor="#dbc8a0" text="#302000" link="#225599" vlink="#113366">
<div class="s1">
<div style="float:right;"><a href="/lib/index.php?tbs=1"><img src="/img/max.gif" alt="Maximize"/></a></div> <form id="lf" style="margin: 0; float: right;" method="get" action="/index.php"><input type="hidden" name="action" value="set"/><select name="lang" onchange="javascript:document.getElementById('lf').submit();"><option value="ru">Русский</option><option selected="selected" value="en">English</option><option value="ua">Українська</option><option value="de">Deutsch</option><option value="es">Español</option><option value="fr">Fran&ccedil;ais</option><option value="it">Italiano</option><option value="pl">Polski</option></select></form>
<div style="float: right;"><div id="plusone"></div></div>
<script type="text/rocketscript">gapi.plusone.render("plusone", {"size":"small","count":"true"});</script>
<div style="float: right;" class="addthis_toolbox addthis_default_style">
<script type="text/rocketscript">var addthis_config = { ui_click: true }</script>
<a style="text-decoration: none; font-size: 10pt;" href="/?action=addthis" class="addthis_button_compact">Bookmark</a>
<script type="text/rocketscript" data-rocketsrc="http://s7.addthis.com/js/250/addthis_widget.js#username=herm1t"></script>
</div>
<div style="float: right;">
<script type="text/rocketscript" data-rocketsrc="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<form action="/search.php" id="cse-search-box">
<input type="hidden" name="cx" value="002577580816726040001:z9_irkorydo"/>
<input type="hidden" name="cof" value="FORID:10"/>
<input type="hidden" name="ie" value="UTF-8"/>
<input type="text" name="q" size="12" value=" "/>
<input type="submit" name="sa" value="Search"/>
</form>
</div><h1><a href="/" style="text-decoration: none; color: #000000;">VX Heaven</a></h1>
<span class="nav"><a href="/lib/">Library</a> <a href="/vl.php">Collection</a> <a href="/src.php">Sources</a> <a href="/vx.php?id=eidx">Engines</a> <a href="/vx.php?id=tidx">Constructors</a> <a href="/vx.php?id=sidx">Simulators</a> <a href="/vx.php?id=uidx">Utilities</a> <a href="/links.php">Links</a> <a href="/donate.php" style="color: #706020" id="donate">Donate</a> <a href="/forum" style="text-decoration: underline;">Forum</a> </span><br clear="all"/>
</div>
<div class="s2"><h1>A Bypass of Cohen's Impossibility Result</h1><p><a href="/lib/?lang=en&amp;author=Bergstra%2C%20Jan">Jan Bergstra</a>, <a href="/lib/?lang=en&amp;author=Ponse%2C%20Alban">Alban Ponse</a><br/> <em>Advances in Grid Computing - EGC 2005, LNCS 3470, pages 1097-1106. Springer-Verlag, 2005</em><br/> <em>ISBN 3-540-26918-5</em><br/> <em> 2005</em></p><script type="text/rocketscript">var disqus_url = 'http://vxheaven.org/lib/mjb00.html';</script><img src="/img/pdf.gif" alt="PDF"/><a href="/lib/pdf/A%20Bypass%20of%20Cohen%27s%20Impossibility%20Result.pdf">Download</a> PDF (106.73Kb) (You need to be registered on <a href="/forum">forum</a>)<br/>[<a style="" href="/lib/?lang=EN&amp;index=TH#mjb00">Back to index</a>] [<a href="/lib/mjb00.html#disqus_thread">Comments</a>]<br/> <form method="post" action="">
<img src="/img/cache/0b9fd596a90421f9f1f68a9760275737.gif" alt="\text{T_EX size}" valign="middle"/>
<select name="TeX_size"><option value="-2">-2</option><option value="-1">-1</option><option value="0" selected="selected">0</option><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option> </select>
<input type="submit" value="Scale"/>
</form>
<p><em>Extended Version for SSN - 29 November 2004</em></p>
<address>
<p>Jan Bergstra, Alban Ponse<br/>
University of Amsterdam, Programming Research Group, Kruislaan 403,<br/>
1098 SJ Amsterdam, The Netherlands<br/>
www.science.uva.nl/research/prog/</p>
<p>Jan Bergstra<br/>
Utrecht University, Department of Philosophy, Heidelberglaan 8,<br/>
3584 CS Utrecht, The Netherlands<br/>
www.phil.uu.nl/en/</p>
</address>
<ul>
<li><a href="#c0">Abstract</a></li>
<li><a href="#c1">1 Introduction</a></li>
<li><a href="#c2">2 Basics of Program Algebra</a>
<ul>
<li><a href="#c21">2.1 The program Algebra PGA</a></li>
<li><a href="#c22">2.2 BPPA, Basic Polarized Process Algebra</a></li>
<li><a href="#c23">2.3 Behavior Extraction: from PGA to BPPA</a></li>
<li><a href="#c24">2.4 The program notations PGLB and PGLC</a></li>
</ul></li>
<li><a href="#c3">3 Forecasting Security Hazards</a>
<ul>
<li><a href="#c31">3.1 A Setting with Security Hazards</a></li>
<li><a href="#c32">3.2 SHFT, a Security Hazard Forecasting Tool</a></li>
<li><a href="#c33">3.3 Modifying SHFT</a></li>
</ul></li>
<li><a href="#c4">4 Security Risk Assessment</a>
<ul>
<li><a href="#c41">4.1 SHRAT, a Security Hazard Risk Assessment Tool</a></li>
<li><a href="#c42">4.2 Divergence Risk Assessment</a></li>
</ul></li>
<li><a href="#c5">5 Digression: Using a Turing Machine</a>
<ul>
<li><a href="#c51">5.1 Preliminaries</a></li>
<li><a href="#c52">5.2 Proof of the Undecidability of Virus-Detection</a></li>
</ul></li>
<li><a href="#c6">References</a></li>
<li><a href="#c7">A Appendix - Terminology and Quotes from the Web</a></li>
</ul>
<h2><a name="c0"></a>Abstract</h2>
<p>Detecting illegal resource access in the setting of network communication or grid computing is similar to the problem of virus detection as put forward by Fred Cohen in 1984. We disucuss Cohen's impossibility result on virus detection, and introduce "risk assessment of security hazards", a notion that is decidable for a large class of program behaviors.</p>
<p><em>Keywords</em>: Malcode, Program algebra, Polarized process algebra, Virus, Worm.</p>
<h2><a name="c1"></a>1 Introduction</h2>
<p><em>Virus, Worm, Trojan horse, Malcode</em>.... There is a vast amount of literature on these matters, and opinions seem to differ wildly. Many authors agree that malcode contains all others, and that both a virus and a worm can replicate.<sup><a href="#f1" name="b1">1</a></sup> Furthermore, a worm is more autonomous than a virus. Some authors claim that a virus can only replicate as a consequence of actions of users, and that sound education and awareness can protect users from acting with such effect. So, a virus uses a user for its replication; that user may or may not be a victim of the virus' harmful action at the same time. Unclear is if each of these users must be a human one or if background processes in a machine can also be "used" as users.</p>
<p>This paper is about virus detection and discusses two fundamental questions. First, we consider Cohen's result about the impossibility of a uniform tool (or algorithm) for detecting viruses in all programs [4]. This is done in the setting of the program algebra PGA [1]. Then, we define an associated notion of testing -- <em>security hazard risk assessment</em> -- with which the occurrence of security hazards is decidable for a large class of program behaviors. However, if divergence (the absence of halting) is considered also as a security hazard, decidability is lost.</p>
<p>The paper is organized as follows: in Section 2, we introduce some basics of program algebra. Then, in Section 3, we consider Cohen's impossibility result and some related issues. In Section 4 we introduce our notion of security risk assessment. In Section 5 we discuss a variant of the Halting Problem that applies to the present setting. The paper is ended with an Appendix.</p>
<h2><a name="c2"></a>2 Basics of Program Algebra</h2>
<p>Program algebra (PGA, [1]) provides a very simple notation for sequential programs and a setting in which programs can be systematically analyzed and mapped onto behaviors. Program behaviors are modeled in BPPA, Basic Polarized Process Algebra. Finally, we consider in this section some other program notations based on program algebra.</p>
<h3><a name="c21"></a>2.1 The program Algebra PGA</h3>
<p>In PGA we consider basic instructions <img src="/img/cache/bb6018fda9755072b0c4e5955a103c7b.gif" alt="a,b,\dots" valign="middle"/>, given by some collection <img src="/img/cache/9d5ed678fe57bcca610140957afab571.gif" alt="B" valign="middle"/>. Furthermore, for each <img src="/img/cache/dbc1669c2b6246f49c58696e02fe9c21.gif" alt="a \in B" valign="middle"/> there is a <em>positive test</em> instruction <img src="/img/cache/02fbb41700ff02150dc744e1b2961c6e.gif" alt="+a" valign="middle"/> and a <em>negative test</em> instruction <img src="/img/cache/37caf0ee262229a9ddc60877eec6883f.gif" alt="-a" valign="middle"/>. The control instructions are <em>termination</em>, notation !, and (relative) jump instructions <img src="/img/cache/d879ec3f218b297efa5a47f50a3b87fd.gif" alt="#k (k \in \mathbb{N})" valign="middle"/>. Program expressions in PGA, or shortly PGA-programs, have the following syntax:</p>
<ul>
<li>each PGA-instruction is a PGA-program,</li>
<li>if <img src="/img/cache/02129bb861061d1a052c592e2dc6b383.gif" alt="X" valign="middle"/> and <img src="/img/cache/57cec4137b614c87cb4e24a3d003a3e0.gif" alt="Y" valign="middle"/> are PGA-programs, so is their <em>concatenation</em> <img src="/img/cache/7b1841ef32ed3c20417c5788cbbc5ce6.gif" alt="X; Y" valign="middle"/>,</li>
<li>if <img src="/img/cache/02129bb861061d1a052c592e2dc6b383.gif" alt="X" valign="middle"/> is a PGA-program, so is its repetition <img src="/img/cache/287ae932718e3fb63658825213c805e4.gif" alt="X^\omega" valign="middle"/>.</li>
</ul>
<p>The behavior associated with the execution of PGA-programs is explained below in Section 2.2. Instruction congruence of programs has a simple axiomatization, given in Table 1.</p>
<p><strong>Table 1: Axioms for PGA's instruction sequence congruence</strong></p>
<img src="/img/cache/87ecf3fd083f4ff966400f84274c538c.gif" alt="
\begin{align}
	(X; Y ); Z = X; (Y ; Z)			&amp; (PGA1)\\
	(X^n)^\omega = X^\omega for n &gt; 0	&amp; (PGA2)\\
	X^\omega; Y = X^\omega			&amp; (PGA3)\\
	(X; Y)^\omega = X; (Y ; X)^\omega	&amp; (PGA4)
\end{align}
" valign="middle"/>
<p>The axioms PGA1-4 imply <em>Unfolding</em>, i.e. the law <img src="/img/cache/478e6158bbbf4aa3c02b35d027c3ff4a.gif" alt="X^\omega = X; X^\omega" valign="middle"/>, and PGA2-4 may be replaced by Unfolding and the proof rule
<img src="/img/cache/6616304cb770b706d6e8e1f4af988edc.gif" alt="Y = X; Y \Rightarrow Y = X^\omega" valign="middle"/>.</p>
<h3><a name="c22"></a>2.2 BPPA, Basic Polarized Process Algebra</h3>
<p>Execution of PGA-programs is modeled in BPPA, Basic Polarized Process Algebra. Given <img src="/img/cache/9d5ed678fe57bcca610140957afab571.gif" alt="B" valign="middle"/>, now considered as a collection of <em>actions</em>, it is assumed that upon execution each action generates a Boolean reply (<tt>true</tt> or <tt>false</tt>). Now, behavior is specified in BPPA by means of the following constants and operations:</p>
<dl>
<dt><em>Termination.</em></dt><dd>The constant <img src="/img/cache/dc8287dd113720a46c8f04bb86ae0430.gif" alt="S \in \text{BPPA}" valign="middle"/> represents (successful) termination.</dd>
<dt><em>Inaction.</em></dt><dd>The constant <img src="/img/cache/5f2fe34f07e97b92e3b2a92306df6076.gif" alt="D \in \text{BPPA}" valign="middle"/> represents the situation in which no subsequent behavior is possible. (Sometimes <img src="/img/cache/f623e75af30e62bbd73d6df5b50bb7b5.gif" alt="D" valign="middle"/> is called <em>deadlock</em> or <em>divergence</em>.)</dd>
<dt><em>Post conditional composition.</em></dt><dd>For each action <img src="/img/cache/dbc1669c2b6246f49c58696e02fe9c21.gif" alt="a \in B" valign="middle"/> and behavioral expressions <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/> and <img src="/img/cache/f09564c9ca56850d4cd6b3319e541aee.gif" alt="Q" valign="middle"/> in BPPA, the post conditional composition <img src="/img/cache/7d70d3a9f711021244561a62ee0f9895.gif" alt="P \underline{\triangleleft} a \underline{\triangleright} Q" valign="middle"/> describes the behavior that first executes action <img src="/img/cache/0cc175b9c0f1b6a831c399e269772661.gif" alt="a" valign="middle"/>, and continues with <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/> if <tt>true</tt> was generated, and <img src="/img/cache/f09564c9ca56850d4cd6b3319e541aee.gif" alt="Q" valign="middle"/> otherwise.</dd>
<dt><em>Action prefix.</em></dt><dd>For <img src="/img/cache/dbc1669c2b6246f49c58696e02fe9c21.gif" alt="a \in B" valign="middle"/> and behavioral expression <img src="/img/cache/936e061aa57e591872edc4cf67920b06.gif" alt="P\in\text{BPPA}" valign="middle"/>, the action prefix <img src="/img/cache/20e9e2cda3396a461dfd5f6a2af0c775.gif" alt="a \circ P" valign="middle"/> describes the behavior that first executes <img src="/img/cache/0cc175b9c0f1b6a831c399e269772661.gif" alt="a" valign="middle"/> and then continues with <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/>, irrespective of the Boolean reply. Action prefix is a special case of post conditional composition: <img src="/img/cache/80bee4ebe8012f97d8c964f823a61199.gif" alt="a \circ P = P \underline{\triangleleft} a \underline{\triangleright} P" valign="middle"/>.</dd>
</dl>
<h3><a name="c23"></a>2.3 Behavior Extraction: from PGA to BPPA</h3>
<p>The <em>behavior extraction</em> operator <img src="/img/cache/e4240ff886dbbfcedd3db989e33b4853.gif" alt="|X|" valign="middle"/> assigns a behavior to program <img src="/img/cache/02129bb861061d1a052c592e2dc6b383.gif" alt="X" valign="middle"/>. Instruction sequence equivalent programs have of course the same behavior. Behavior extraction is defined by the thirteen equations in Table 2, where <img src="/img/cache/dbc1669c2b6246f49c58696e02fe9c21.gif" alt="a \in B" valign="middle"/> and <img src="/img/cache/7b774effe4a349c6dd82ad4f4f21d34c.gif" alt="u" valign="middle"/> is a PGA-instruction.</p>
<p><strong>Table 2: Equations for behavior extraction on PGA</strong></p>
<img src="/img/cache/03f528ec34c34c842b4b9bb0debc7e13.gif" alt="
\begin{eqnarray}
	|!| &amp;=&amp; S		&amp;&amp; |!; X| &amp;=&amp; S							&amp;&amp; |#k| &amp;=&amp; D		\\
	|a| &amp;=&amp; a \circ D	&amp;&amp; |a; X| &amp;=&amp; a \circ |X|					&amp;&amp; |#0; X| &amp;=&amp; D	\\
	|+a| &amp;=&amp; a \circ D	&amp;&amp; |+a; X| &amp;=&amp; |X| \underline{\triangleleft} a \underline{\triangleright} |#2; X|	&amp;&amp; |#1; X| &amp;=&amp; |X|	\\
	|-a| &amp;=&amp; a \circ D	&amp;&amp; |-a; X| &amp;=&amp; |#2; X| \underline{\triangleleft} a \underline{\triangleright} |X|	&amp;&amp; |#k+2; u| &amp;=&amp; D	\\
	&amp;&amp;			&amp;&amp; &amp;&amp;								&amp;&amp; |#k+2; u; X| &amp;=&amp; |#k+1; X|
\end{eqnarray}
" valign="middle"/>
<p>Some examples: <img src="/img/cache/fd801df3a9799bf7f342a070486406d8.gif" alt="|(#0)^\omega| = |#0; (#0)^\omega| = D" valign="middle"/> and, further taking action prefix to bind stronger than post conditional composition,</p>
<img src="/img/cache/fde4356a78238532105988b4b40d82fb.gif" alt="
\begin{eqnarray}
	|-a; b; c|
		&amp;=&amp; |#2; b; c| \underline{\triangleleft} a \underline{\triangleright} |b; c|\\
		&amp;=&amp; |#1; c| \underline{\triangleleft} a \underline{\triangleright} b \circ |c|\\
		&amp;=&amp; |c| \underline{\triangleleft} a \underline{\triangleright} b \circ c \circ D\\
		&amp;=&amp; c \circ D \underline{\triangleleft} a \underline{\triangleright} b \circ c \circ D.
\end{eqnarray}
" valign="middle"/>
<p>In some cases, these equations can be applied (from left to right) without ever generating any behavior, e.g.,</p>
<img src="/img/cache/08c9b2b11acf6e8dbb77028eb52efe2a.gif" alt="
	|(#1)^\omega| = |#1; (#1)^\omega| = |(#1)^\omega| = \dots\\
	|(#2; a)^\omega| = |#2; a; (#2; a)^\omega| = |#1; (#2; a)^\omega| = |(#2; a)^\omega| = \dots
" valign="middle"/>
<p>In such cases, the extracted behavior is defined as <img src="/img/cache/f623e75af30e62bbd73d6df5b50bb7b5.gif" alt="D" valign="middle"/>.</p>
<p>It is also possible that behavioral extraction yields an infinite recursion, e.g., <img src="/img/cache/9d7261b5d752ad57eb768ab9d188274f.gif" alt="|a^\omega| = |a; a^\omega| = a \circ |a^\omega|" valign="middle"/>, and therefore,</p>
<img src="/img/cache/a16a44fb06a9916152a8b6c2c30d70f5.gif" alt="
\begin{eqnarray}
	|a^\omega|
		&amp;=&amp; a \circ |a^\omega|\\
		&amp;=&amp; a \circ a \circ |a^\omega|\\
		&amp;=&amp; a \circ a \circ a \circ |a^\omega|\\
		&amp;\vdots&amp;
\end{eqnarray}
" valign="middle"/>
<p>In such cases the behavior of <img src="/img/cache/02129bb861061d1a052c592e2dc6b383.gif" alt="X" valign="middle"/> is infinite, and can be represented by a finite number of behavioral equations, e.g., <img src="/img/cache/3e5b33299289d65134240bd5f6660788.gif" alt="|(a; +b; #3; -b; #4)^\omega| = P" valign="middle"/> and</p>
<img src="/img/cache/f1d982ae45782220347acb8a64e6fb5b.gif" alt="
	P = a \circ (P \underline{\triangleleft} b \underline{\triangleright} Q),\\
	Q = P \underline{\triangleleft} b \underline{\triangleright} Q.
" valign="middle"/>
<p>Note. Observe that the following identity holds: <img src="/img/cache/b2827a2b89db259e9097fdaa3a587d7e.gif" alt="|X| = |X; (#0)^\omega|" valign="middle"/>. This identity characterizes that for a finite program object (i.e., a finite sequence of instructions), a missing termination instruction yields inaction. Conversely, this identity makes six out of the thirteen equations in Table 2 derivable (namely, those for programs of length 1 and the equation <img src="/img/cache/e28e5b46b7489338bc246234d97f17d6.gif" alt="|#k+2; u| = D" valign="middle"/>).</p>
<h3><a name="c24"></a>2.4 The program notations PGLB and PGLC</h3>
<p>The program notation PGLB is obtained from PGA by adding backwards jumps <img src="/img/cache/cd64ad20b3b84b81c037c13c0e5b6e98.gif" alt="\backslash #k" valign="middle"/> and leaving out the repetition operator. For example, <img src="/img/cache/2dc94d670a995dcd5de71198784a8ae6.gif" alt="+a; #0; \backslash #2" valign="middle"/> behaves as <img src="/img/cache/d389f0e092e42ee3b315f1d6e00818ac.gif" alt="(+a; #0)^\omega" valign="middle"/>. This can be defined with help of a projection function <tt>pglb2pga</tt> that translates PGLB-programs in a context-dependent fashion to PGA-programs. For a PGLB-program <img src="/img/cache/02129bb861061d1a052c592e2dc6b383.gif" alt="X" valign="middle"/> we write <img src="/img/cache/37bc8f951b4f792cc54a467b30312fa1.gif" alt="|X|_{pglb} = |\text{pglb2pga}(X)|" valign="middle"/> (see further [1]).</p>
<p>The language PGLC is the variant of PGLB in which termination is modeled implicitly: a program terminates after the last instruction has been executed and that instruction was no jump into the program, or after a jump outside the program. The termination instruction ! is not present in PGLC. For example,</p>
<img src="/img/cache/e15aa336d097ba042eb0b0d87aa1bca3.gif" alt="
\begin{eqnarray}
	|+a; #2; \backslash #2; +b|_{pglc}
		&amp;=&amp; |+a; #2; \backslash #2; +b; !; !|_{pglb}\\
		&amp;=&amp; |(+a; #2; #6; +b; !; !; #0; #0)^\omega|\\
		&amp;=&amp; P
\end{eqnarray}
" valign="middle"/>
<p>for <img src="/img/cache/e45a1f6c3dc8d78972f0958b8fa3b135.gif" alt="P = b \circ S \underline{\triangleleft} a \underline{\triangleright} P" valign="middle"/> (see [1] for precise definitions of <img src="/img/cache/884bb04f66311a2a9433926ff59beb27.gif" alt="|X|_{pglc}" valign="middle"/> and <img src="/img/cache/543ad07ffbdaee958af04b2b088ac36c.gif" alt="|Y|_{pglb}" valign="middle"/>.)</p>
<h2><a name="c3"></a>3 Forecasting Security Hazards</h2>
<p>In this section we introduce the setting in which we will analyze code security risks. We then recall Cohen's impossibility result on forecasting security hazards and draw some conclusions.</p>
<h3><a name="c31"></a>3.1 A Setting with Security Hazards</h3>
<p>Let <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/> be some behavior that uses communication with other devices -- further called <em>reactors</em> -- <img src="/img/cache/fd924fb508487271b79b39da90ab763b.gif" alt="H_f" valign="middle"/>, <img src="/img/cache/7fb05d4ede94d3616aa8920300f04462.gif" alt="H_g" valign="middle"/> and <img src="/img/cache/4364cc592f00033e08416646e1e6aa9b.gif" alt="H_e" valign="middle"/>:</p>
<img src="/img/cache/b2d2b2dc41dba52981f0740ce806784d.gif" alt="
\begin{array}{rccclBCB}
	&amp; \fbox{\fbox{P}} &amp;\rightarrow^e 	&amp; \fbox{H_e}	&amp; \text{(external focus)}\\
f	&amp; \downarrow		&amp; \searrow g	&amp; \fbox{H_g}	&amp; \text{(low risk focus, no security hazard)}\\
	&amp; \fbox{H_f}		&amp; 		&amp;		&amp; \text{(high risk focus, security risk)}
\end{array}
" valign="middle"/>
<p>Such communication will be modelled using "focus-method" notation: the reply of a basic instruction <img src="/img/cache/edea68a1b55bd86e28a89151bd5392be.gif" alt="e.m" valign="middle"/> will be determined by the reactor <img src="/img/cache/4364cc592f00033e08416646e1e6aa9b.gif" alt="H_e" valign="middle"/>. Likewise, instructions with focus <img src="/img/cache/8fa14cdd754f91cc6554c9e71929cce7.gif" alt="f" valign="middle"/> or <img src="/img/cache/b2f5ff47436671b6e533d8dc3614845d.gif" alt="g" valign="middle"/> communicate with <img src="/img/cache/fd924fb508487271b79b39da90ab763b.gif" alt="H_f" valign="middle"/> and <img src="/img/cache/7fb05d4ede94d3616aa8920300f04462.gif" alt="H_g" valign="middle"/>, respectively.</p>
<p>Let furthermore <em>skip</em> be the identity on <img src="/img/cache/fd924fb508487271b79b39da90ab763b.gif" alt="H_f" valign="middle"/>. Now, execution is <em>secure</em> if no <img src="/img/cache/3a3a080a3171f031cfb0bfb87e9f4a87.gif" alt="f.m" valign="middle"/> is called until termination or first call of some <img src="/img/cache/edea68a1b55bd86e28a89151bd5392be.gif" alt="e.m" valign="middle"/> (to the external focus). A behavior can have low risk actions (secure execution expected) and high risk actions (insecure execution expected). For example,</p>
<img src="/img/cache/fb6a948814a33e924bbbf2adde8ed55c.gif" alt="
\begin{align}
&amp;&amp; S
	&amp;&amp;&amp; \text{-- a low risk behavior,}\\
&amp;&amp; f.skip \circ S
	&amp;&amp;&amp; \text{-- a high risk behavior,}\\
&amp;&amp; f.skip \circ S \underline{\triangleleft} g.m \underline{\triangleright} g.skip \circ S
	&amp;&amp;&amp; \text{-- risk depends on }H_g.
\end{align}
" valign="middle"/>
<h3><a name="c32"></a>3.2 SHFT, a Security Hazard Forecasting Tool</h3>
<p>In this section we discuss the impossibility of a tool (algorithm) that forecasts security hazards. Let SHFT be a Security Hazard Forecasting Tool with focus <img src="/img/cache/9c8a1326c1e7303b84f6191ed0b6fd37.gif" alt="shft" valign="middle"/>, thus a reactor that forecasts a security hazard. As assumed earlier, a security hazard is in this simple setting a call (action) <img src="/img/cache/3a3a080a3171f031cfb0bfb87e9f4a87.gif" alt="f.m" valign="middle"/> for some <img src="/img/cache/6f8f57715090da2632453988d9a1501b.gif" alt="m" valign="middle"/>. Furthermore, let <img src="/img/cache/6870e406910dc2c40b4bccace7e7e0bc.gif" alt="shft.test" valign="middle"/> be the test that uses SHFT in the following way: in</p>
<img src="/img/cache/e13e46d9d56efcc39b40b76f4815d599.gif" alt="
	P \underline{\triangleleft} shft.test \underline{\triangleright} Q,
" valign="middle"/>
<p>the action <img src="/img/cache/6870e406910dc2c40b4bccace7e7e0bc.gif" alt="shft.test" valign="middle"/> returns <tt>true</tt> if <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/> has a security hazard, and false if <img src="/img/cache/f09564c9ca56850d4cd6b3319e541aee.gif" alt="Q" valign="middle"/> has no security hazard.</p>
<p><strong>Theorem 1.</strong> <em>A Security Hazard Forecasting Tool cannot exist.</em></p>
<p><em>Proof.</em> Consider <img src="/img/cache/65a31ad3ec6c270d1cee753aa075b980.gif" alt="S \underline{\triangleleft} shft.test \underline{\triangleright} f.skip \circ S" valign="middle"/>.
If the test action <img src="/img/cache/6870e406910dc2c40b4bccace7e7e0bc.gif" alt="shft.test" valign="middle"/> returns <tt>false</tt>, <img src="/img/cache/03c93709130e9157d6dbcebeca3d7bd4.gif" alt="f.skip \circ S" valign="middle"/> will
be performed, which is a security hazard; if <tt>true</tt> is returned, then <img src="/img/cache/5dbc98dcc983a70728bd082d1a47546e.gif" alt="S" valign="middle"/> is performed and no security
hazard arises.</p>
<div align="right"><img src="/img/cache/09cfa2435552d2f8a90d85e99701606a.gif" alt="\boxempty" valign="middle"/></div>
<h2>A Bypass of Cohen's Impossibility Result: SSN - 29/11/04 5</h2>
<p>The behavior in the proof above illustrates the impossibility of prediciting that a behavior (or a program) contains a virus, a general phenomenon that was described in Cohen's seminal 1984-paper [4] and that will be further referred to as <em>Cohen's impossiblity result</em>. For the sake of completeness, we recall Cohen's line of reasoning. In the pseudo-code in Figure 1 (taken from [4]), <tt>D</tt> is a decision procedure that determines whether a program is (contains) a virus, <tt>~D</tt> stands for its negation, and <tt>next</tt> labels the remainder of some (innocent) program.</p>
<pre class="source">
{1234567;
subroutine infect-executable:=
 {loop:file = get-random-executable-file;
 if first-line-of-file = 1234567 then goto loop;
 prepend virus to file;
 }

subroutine do-damage:=
 {whatever damage is to be done}

subroutine trigger-pulled:=
 {return true if some condition holds}

main-program:=
 {if ~D(contradictory-virus) then
    {infect-executable;
    if trigger-pulled then do-damage;
    }
 goto next;
 }
}
</pre>
<p><strong>Figure 1: Cohen's program contradictory-virus</strong></p>
<p>In PGLC, the program <tt>contradictory-virus</tt> can be represented by the following term <tt>CV</tt>:</p>
<img src="/img/cache/150f012be2d757e6266560e2a687723c.gif" alt="\text{CV} = #8; \text{Pre}; #3; -shft.\text{test}(\text{CV}); \backslash #8; \text{Next}" valign="middle"/>
<p>where <tt>Pre</tt> abbreviates the six instructions that model the security hazard:</p>
<img src="/img/cache/df98ef6fc6a51d39d91b9fb76f5483f2.gif" alt="
\begin{align}
&amp;\text{Pre} =	&amp;\text{file:=get-random-executable-file;}\\
&amp;		&amp;\text{+first-line-of-file=1234567;}\\
&amp;		&amp;\backslash #2;\\
&amp;		&amp;\text{prepend;}\\
&amp;		&amp;\text{+trigger-pulled;}\\
&amp;		&amp;\text{do-damage}
\end{align}
" valign="middle"/>
<p>and <tt>Next</tt> models the remainder of the program. Applying behavior extraction on this program yields</p>
<img src="/img/cache/90f2167511c2b02c49b7cfe3e349c1dd.gif" alt="
\begin{eqnarray}
|CV|_{pglc}
	&amp;=&amp; |\text{Next}|_{pglc} \underline{\triangleleft} shft.\text{test}(\text{CV}) \underline{\triangleright} |\text{Pre}; #3; -shft.\text{test}(\text{CV}); \backslash #8; \text{Next}|_{pglc}\\
	&amp;=&amp; |\text{Next}|_{pglc} \underline{\triangleleft} shft.\text{test}(\text{CV}) \underline{\triangleright} |\text{Pre}; \text{Next}|_{pglc}.
\end{eqnarray}
" valign="middle"/>
<p>So, <img src="/img/cache/65a31ad3ec6c270d1cee753aa075b980.gif" alt="S \underline{\triangleleft} shft.test \underline{\triangleright} f.skip \circ S" valign="middle"/> is indeed a faithful characterization of Cohen's impossibility result.</p>
<p>Even with the aid of universal computational power, the problem whether a behavior has a security hazard (issues an <img src="/img/cache/3a3a080a3171f031cfb0bfb87e9f4a87.gif" alt="f.m" valign="middle"/> call) is undecidable. In Section 5.2 we give a proof of this fact.</p>
<h3><a name="c33"></a>3.3 Modifying SHFT</h3>
<p>Alternatively, we can modify our definitions concerning forecasting security hazards:</p>
<ol>
<li>If all code is malcode, SHFT should always return <tt>true</tt>. This is correct. It follows that Cohen's impossibility result depends on the assumption that for some <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/>, SHFT returns <tt>false</tt>.</li>
<li>We can restrict our class of behaviors: if security hazards occur only in the lefthand-sides of behavioral expressions, as in <img src="/img/cache/1a71d00c79659e86dc9011a51fcaad8b.gif" alt="f.skip \circ S \underline{\triangleleft} shft.test \underline{\triangleright} S" valign="middle"/>, then a negative reply (<tt>false</tt>) is always correct (using the definition that malcode is code for which the extracted behavior contains a security hazard).</li>
</ol>
<p>Cohen's impossibility result needs the notion of a secure run (no security hazards), as well as a secure program or behavior (a behavior that will have secure runs only). So, Cohen's impossibility result emerges if:</p>
<ul>
<li>secure runs exist,</li>
<li>secure programs (polarized processes) exist,</li>
<li>there is a full match between these two, and</li>
<li>forecasting is possible.</li>
</ul>
<p>Now there is a difficulty with forecasting: if <img src="/img/cache/6870e406910dc2c40b4bccace7e7e0bc.gif" alt="shft.test" valign="middle"/> returns <tt>false</tt> one hopes to proceed in such a way that the security hazard is avoided (why else do the test?). But that is not sound as was shown above. Thus we conclude: this type of forecasting security hazards is a problematic idea for security assessment.</p>
<p>Yet another perspective on these problems is to consider the option that test actions <img src="/img/cache/6870e406910dc2c40b4bccace7e7e0bc.gif" alt="shft.test" valign="middle"/> may also yield a third truth value <img src="/img/cache/69691c7bdcc3ce6d5d8a1361f22d04ac.gif" alt="M" valign="middle"/> (Meaningless). At the same time we can avoid the problem that the true-reply of the test <img src="/img/cache/6870e406910dc2c40b4bccace7e7e0bc.gif" alt="shft.test" valign="middle"/> is about a different behavior (the left-argument) as the <tt>false</tt>-reply, making such a type of test (a little) more plausible. So, consider the following modification of <img src="/img/cache/6870e406910dc2c40b4bccace7e7e0bc.gif" alt="shft.test" valign="middle"/>: in</p>
<img src="/img/cache/6aac19d52a9f59e9abdafb093e02f23b.gif" alt="P \underline{\triangleleft} shft.test2 \underline{\triangleright} Q," valign="middle"/>
<p>the action <img src="/img/cache/e3d234babc14c63289049467e61b950d.gif" alt="shft.test2" valign="middle"/> returns <tt>true</tt> if <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/> has a security hazard, <tt>false</tt> if both <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/> and <img src="/img/cache/f09564c9ca56850d4cd6b3319e541aee.gif" alt="Q" valign="middle"/> have no security hazard, and <img src="/img/cache/69691c7bdcc3ce6d5d8a1361f22d04ac.gif" alt="M" valign="middle"/> in all other cases. `the behavior associated with the reply <img src="/img/cache/69691c7bdcc3ce6d5d8a1361f22d04ac.gif" alt="M" valign="middle"/> can be taken <img src="/img/cache/f623e75af30e62bbd73d6df5b50bb7b5.gif" alt="D" valign="middle"/>, but other options are possible (see e.g. [3]). This seems a more consistent definition. However, in</p>
<img src="/img/cache/a1d6b2c5e1858bdb9843da5977586657.gif" alt="S \underline{\triangleleft} shft.test2 \underline{\triangleright} f.skip \circ S" valign="middle"/>
<p>the test action <img src="/img/cache/e3d234babc14c63289049467e61b950d.gif" alt="shft.test2" valign="middle"/> returns <img src="/img/cache/69691c7bdcc3ce6d5d8a1361f22d04ac.gif" alt="M" valign="middle"/>, showing that forecasting security hazards in the style of Cohen remains a problematic issue.</p>
<h2><a name="c4"></a>4 Security Risk Assessment</h2>
<p>In this section we introduce a <em>security risk assessment tool</em>, taking into account the above-mentioned considerations. This tool turns out to be a more plausible modeling of testing the occurrence of security hazards. However, if we add divergence (the absence of halting) as a security risk, this tool can not exist.</p>
<h3><a name="c41"></a>4.1 SHRAT, a Security Hazard Risk Assessment Tool</h3>
<p>The following security risk assessment tool SHRAT with focus <img src="/img/cache/e2bbe8e2d9752237ff61060c0e001267.gif" alt="shrat" valign="middle"/> may be conceived of as assessing a security hazard risk. In</p>
<img src="/img/cache/b53a95b70ca28b5268a17d96bd1b47b5.gif" alt="P \underline{\triangleleft} shrat.ok \underline{\triangleright} Q" valign="middle"/>
<p>the test action <img src="/img/cache/8f9be90215c50475ff81794f987e1e00.gif" alt="shrat.ok" valign="middle"/> returns <tt>true</tt> if <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/> is secure, and <tt>false</tt> if <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/> is insecure (then <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/> is avoided and <img src="/img/cache/f09564c9ca56850d4cd6b3319e541aee.gif" alt="Q" valign="middle"/> is done instead). This seems to be a more rational test, because it only tests a property of a single behavior (its left argument). Using an external focus <img src="/img/cache/e1671797c52e15f763380b45e841ec32.gif" alt="e" valign="middle"/>, the test action <img src="/img/cache/8f9be90215c50475ff81794f987e1e00.gif" alt="shrat.ok" valign="middle"/> in</p>
<img src="/img/cache/e9a4e21febabe310d123c7bc02622e5d.gif" alt="(P_1 \underline{\triangleleft} e.m \underline{\triangleright} P_2) \underline{\triangleleft} shrat.ok \underline{\triangleright} Q" valign="middle"/>
<p>yields <tt>true</tt> because <img src="/img/cache/edea68a1b55bd86e28a89151bd5392be.gif" alt="e.m" valign="middle"/> is seen as an action that is beyond control of assessing security hazards.</p>
<p>For testing <img src="/img/cache/8f9be90215c50475ff81794f987e1e00.gif" alt="shrat.ok" valign="middle"/> actions we can employ a backtracking model: at <img src="/img/cache/b53a95b70ca28b5268a17d96bd1b47b5.gif" alt="P \underline{\triangleleft} shrat.ok \underline{\triangleright} Q" valign="middle"/>,</p>
<ul>
<li>temporarily remove loaded program (or behavior),</li>
<li>place <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/> instead</li>
<li>execute until
<img src="/img/cache/aee4b7743c4a723fe3200afc3351ae20.gif" alt="
		\{\begin{eqnarray}
			true 		&amp;\Rightarrow&amp; commit,\\
			external\ call	&amp;\Rightarrow&amp; commit,\\
			hazard		&amp;\Rightarrow&amp;backtrack.
		\end{eqnarray}
	" valign="middle"/></li>
</ul>
<p>So, for a behavior <img src="/img/cache/e058cfd288a66fa17ad60bbee0044813.gif" alt="(P_1 \underline{\triangleleft} shrat.ok \underline{\triangleright} P_2) \underline{\triangleleft} shrat.ok \underline{\triangleright} Q" valign="middle"/>, first evaluate the leftmost <img src="/img/cache/8f9be90215c50475ff81794f987e1e00.gif" alt="shrat.ok" valign="middle"/> test action. If this yields <tt>true</tt>, then the rightmost does as well, otherwise evaluate <img src="/img/cache/fd2499ee44d419ec3af8b91308f38b2a.gif" alt="P_2 \underline{\triangleleft}shrat.ok\underline{\triangleright} Q" valign="middle"/>. For finite behaviors this is a terminating procedure, and not problematic. Some examples of the reply of <img src="/img/cache/8f9be90215c50475ff81794f987e1e00.gif" alt="shrat.ok" valign="middle"/>:</p>
<img src="/img/cache/00a0ee171195185e54dfb018f1ddee81.gif" alt="
	S \underline{\triangleleft} shrat.ok \underline{\triangleright} Q \Rightarrow \text{true}\\
	D \underline{\triangleleft} shrat.ok \underline{\triangleright} Q \Rightarrow \text{true}\\
	(P_1 \underline{\triangleleft} f.m \underline{\triangleright} P_2) \underline{\triangleleft} shrat.ok \underline{\triangleright} Q \Rightarrow \text{false}
" valign="middle"/>
<p>Evaluation of <img src="/img/cache/8f9be90215c50475ff81794f987e1e00.gif" alt="shrat.ok" valign="middle"/> actions can be extended to a larger class of behaviors. A polarized regular behavior over <img src="/img/cache/9d5ed678fe57bcca610140957afab571.gif" alt="B" valign="middle"/> is defined by a finite system of equations over <img src="/img/cache/14c66954d8a539115b3bece65a3215ea.gif" alt="\overline{P} = P_1,\dots,P_n" valign="middle"/> (for some <img src="/img/cache/1ad810342a232a36a57e5314053472dc.gif" alt="n \ge 1" valign="middle"/>) of the following form:</p>
<img src="/img/cache/e16975fbc7946140cfba52b77b57dbdf.gif" alt="
\begin{eqnarray}
	P_1 &amp;=&amp; F_1(\overline{P})\\
	&amp;\vdots&amp;\\
	P_n &amp;=&amp; F_n(\overline{P})
\end{eqnarray}
" valign="middle"/>
<p>with <img src="/img/cache/ea48ad034f2b142c85e51ff82453799c.gif" alt="F_i(\overline{P}) ::= S | D | P_{i,1} \underline{\triangleleft} a_i \underline{\triangleright} P_{i,2}" valign="middle"/> where <img src="/img/cache/40939164488b4a4bb2b618cdf1285b6c.gif" alt="P_{i,j} \in \{P_1,\dots,P_n}" valign="middle"/> and <img src="/img/cache/b72377c3d9a4d8a7513a98e6c292e6bf.gif" alt="a_i \in B" valign="middle"/>.</p>
<p>Consider <img src="/img/cache/29cac09052c68d121ccee249badaf97e.gif" alt="P_1 \underline{\triangleleft} shrat.ok \underline{\triangleright} Q" valign="middle"/>, thus <img src="/img/cache/b2099e5c5fe6e05e3c32190ea9e243c3.gif" alt="F_1(\overline{P}) \underline{\triangleleft} shrat.ok \underline{\triangleright} Q" valign="middle"/>. Again we can decide the outcome of the test action <img src="/img/cache/8f9be90215c50475ff81794f987e1e00.gif" alt="shrat.ok" valign="middle"/> by doing a finite number of substitutions, linear in <img src="/img/cache/7b8b965ad4bca0e41ab51de7b31363a1.gif" alt="n" valign="middle"/>. (Loops and divergence are not considered security hazards.) This leads us to the following result:</p>
<p><strong>Theorem 2.</strong> <em>For regular behaviors, the tool SHRAT is possible.</em></p>
<p>We give an example: if</p>
<img src="/img/cache/d9a4b506451c126627d2d59e62f4d166.gif" alt="
	P_1 = P_2 \underline{\triangleleft} a \underline{\triangleright} P_1\\
	P_2 = P_1 \underline{\triangleleft} f.skip \underline{\triangleright} P_1 (= f.skip \circ P_1),
" valign="middle"/>
<p>then <img src="/img/cache/8f9be90215c50475ff81794f987e1e00.gif" alt="shrat.ok" valign="middle"/> in <img src="/img/cache/4992e739d96b3380b8cae61c0ad6fc42.gif" alt="(P_2 \underline{\triangleleft} a \underline{\triangleright} P_1) \underline{\triangleleft} shrat.ok \underline{\triangleright} Q" valign="middle"/> yields <tt>true</tt> if it does in both</p>
<img src="/img/cache/e2ae72b96458bfd6b08d41fd91e3df34.gif" alt="P_1 \underline{\triangleleft} shrat.ok \underline{\triangleright} Q\text{ and }P_2 \underline{\triangleleft} shrat.ok \underline{\triangleright} Q." valign="middle"/>
<p>Obviously, it does not in the latter case, so this behavior equals <img src="/img/cache/f09564c9ca56850d4cd6b3319e541aee.gif" alt="Q" valign="middle"/>.</p>
<p>So, evaluation of the reply of <img src="/img/cache/8f9be90215c50475ff81794f987e1e00.gif" alt="shrat.ok" valign="middle"/> is decidable for regular behaviors. This even remains the case if a stack is added as a reactor (based on the decidability of DPDA-equivalence [5]). We conclude that Cohen's impossibility result does not apply in this case; apparently, that result is about forecasting. Of course, the decidability of the reply of <img src="/img/cache/8f9be90215c50475ff81794f987e1e00.gif" alt="shrat.ok" valign="middle"/> actions is lost if a Turing Tape is used as a reactor (see Section 5).</p>
<h3><a name="c42"></a>4.2 Divergence Risk Assessment</h3>
<p>If we consider divergence as a security hazard, say by focus <img src="/img/cache/a9ae10f488d0ae799cb24bae02a30c46.gif" alt="drat" valign="middle"/> and reactor DRAT (Divergence Risk Assessment Tool), we have a totally different situation: in the behavior defined by</p>
<img src="/img/cache/fa9b98435d29d147339c79493475a5ab.gif" alt="P = P \underline{\triangleleft} drat.ok \underline{\triangleright} S" valign="middle"/>
<p>we then obviously want that the test action <img src="/img/cache/c42a88238aef8e5690c1cf93b6dbe220.gif" alt="drat.ok" valign="middle"/> returns the answer <tt>false</tt>. It is well-known that (in general) DRAT can not exist, as it would solve the Halting Problem (further discussed in Section 5).</p>
<p>Now, involving divergence as a security hazard in <img src="/img/cache/8f9be90215c50475ff81794f987e1e00.gif" alt="shrat.ok" valign="middle"/> actions, we also find that in</p>
<img src="/img/cache/a4e37576741a7e55cdf38ccd203ef2cd.gif" alt="P = P \underline{\triangleleft} shrat.ok \underline{\triangleright} f.m \circ S" valign="middle"/>
<p>the test should yield <tt>false</tt> (otherwise divergence). However, this yields a problem: in</p>
<img src="/img/cache/a985be4a2a88a3f6e8443fcb68985a46.gif" alt="P = P \underline{\triangleleft} shrat.ok \underline{\triangleright} S" valign="middle"/>
<p>this goes wrong: the termination problem (Turing impossibility result) "wins", and hence the backtracking model is not suitable anymore. We conclude that SHRAT (a Security Hazard Risk Assessment Tool) does not exist if <img src="/img/cache/f623e75af30e62bbd73d6df5b50bb7b5.gif" alt="D" valign="middle"/> (divergence) is considered a security hazard.</p>
<h2><a name="c5"></a>5 Digression: Using a Turing Machine</h2>
<p>In this section we elaborate on a variant of the Halting Problem, which we call the Security Hazard Property (SHP), formalizing the situation that the execution of a certain program in a certain initial state establishes a security hazard. In order to give a concise presentation, we rely on a few notations and explanations given in [3], and we will be very precise about the part of that paper that is used below.</p>
<h3><a name="c51"></a>5.1 Preliminaries</h3>
<p>Behaviors as considered in the above arise from PGA-programs (or programs in PGLB or PGLC). A more fundamental view on generators of behavior is the so-called SPI, the <em>Sequence of Primitive Instructions</em>. Of course, each program in PGA, PGLB or PGLC represents a SPI, but not each (computable) SPI can be represented by a program in one of the above-mentioned program notations, a simple example being</p>
<img src="/img/cache/b12b4b8b8672a8dbc3136592e8a31bad.gif" alt="a; b; a; b; b; a; b^3; a; b^4;\dots" valign="middle"/>
<p>The above SPI defines a behavior that is not regular, and because each behavior definable by a PGA-program (PGLC-program) is regular, it is clear that we need an extended setting to specify such behaviors.</p>
<p>One such extension is the use of reactors, as was sketched in the above. In [2] we provide a formal treatment of the (potential) interaction of a behavior <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/> with reactors <img src="/img/cache/4364cc592f00033e08416646e1e6aa9b.gif" alt="H_e" valign="middle"/>, <img src="/img/cache/7fb05d4ede94d3616aa8920300f04462.gif" alt="H_g" valign="middle"/> and <img src="/img/cache/fd924fb508487271b79b39da90ab763b.gif" alt="H_f" valign="middle"/>. Notation for that situation is the expression</p>
<p><img src="/img/cache/e3254d18288d13f026fc78fbacceb828.gif" alt="((P/_f H_f )/_gH_g)/_eH_e" valign="middle"/> or equivalently, <img src="/img/cache/4fa90a82b7cb8466dbcd41de05d5cb1b.gif" alt="P/_f H_f /_g H_g /_e H_e" valign="middle"/>.</p>
<p>The operator <img src="/img/cache/f603b32e64ae9d6122bdb28b618d2144.gif" alt="/_h" valign="middle"/> (that takes as its left-argument a behavior and as its right-argument a reactor) is called the <em>use operator</em>, where <img src="/img/cache/2510c39011c5be704182423e3a695e91.gif" alt="h" valign="middle"/> is some dedicated focus. In the previous part of the paper we considered all communications of <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/> with a reactor <img src="/img/cache/17f9f9e0383414f16b88eeb1cb5ad146.gif" alt="H_h" valign="middle"/> implicit and wrote <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/> instead. In other words, an expression like <img src="/img/cache/dc73370623349c1d5eb887e45e9c8776.gif" alt="P \underline{\triangleleft} h.m \underline{\triangleright} Q" valign="middle"/> as occurring in the previous part of this paper is considered to abbreviate</p>
<img src="/img/cache/647e35fb45d6a24fa5b7ba897ba18c54.gif" alt="(P \underline{\triangleleft} h.m \underline{\triangleright} Q)/_h H_h," valign="middle"/>
<p>and this type of interaction is formalized in [2]. Furthermore, the variants of PGA and PGLC that use instructions with a focus explicitly intended for use-applications are called PGA:FMN and PGLC:FMN, where FMN abbreviates <em>focus-method notation</em>.</p>
<p>In the next section we prove that even with the availability of Turing computational power, it is undecidable that security hazards can be predicted. For this proof we use the notation and terminology explained in [3, Sections 3 and 4]. However, the material presented in Section 3.4 of [3] is not used in this exposition.</p>
<h3><a name="c52"></a>5.2 Proof of the Undecidability of Virus-Detection</h3>
<p>The <em>Security Hazard Property</em> (SHP) can be modeled as follows: a PGLCi:FMN program <img src="/img/cache/83878c91171338902e0fe0fb97a8c47a.gif" alt="p" valign="middle"/> executing on the ETMT with initial configuration <img src="/img/cache/b1f1b4081d8395d17066895efeb6a412.gif" alt="\hat{b}wb" valign="middle"/> (<img src="/img/cache/f1290186a5d0b1ceab27f4e77c0c5d68.gif" alt="w" valign="middle"/> a bit sequence) has a security hazard, notation <img src="/img/cache/b80ef21a154e1c55d6b6c6dfc003c7f4.gif" alt="(p, w) \in SHP" valign="middle"/>, if</p>
<img src="/img/cache/bfa450547c3ebfb8cb5166888e498955.gif" alt="\text{pgaEA}(|p|_{pglc}, etmt:\text{ETMT}(\hat{b} w b ))" valign="middle"/>
<p>issues an action of the form <img src="/img/cache/3a46564f257e123151d1fbd5a9d5d43d.gif" alt="f.m." valign="middle"/> We stipulate that program <img src="/img/cache/a25d4693e4ab95a16cff5fc3f5a7314f.gif" alt="q \in \text{PGLCi:FMN}" valign="middle"/> <em>solves</em> the question whether <img src="/img/cache/b80ef21a154e1c55d6b6c6dfc003c7f4.gif" alt="(p, w) \in SHP" valign="middle"/> in the following way:</p>
<img src="/img/cache/17a554a457fd987d3aabbcbbeec1b183.gif" alt="\text{pgaEA}(|q|_{pglc}, etmt:\text{ETMT}(\hat{b} p; w b ))" valign="middle"/>
<p>where <img src="/img/cache/83878c91171338902e0fe0fb97a8c47a.gif" alt="p" valign="middle"/> is stored as a bit sequence always halts, and after halting, the tape configuration is of the form</p>
<dl>
<dt><img src="/img/cache/3b0a78a0edec6dc1de17446bb80d6f73.gif" alt="\text{ETMT}(\hat{b} 1 \sigma)" valign="middle"/> for some <img src="/img/cache/a2ab7d71a0f07f388ff823293c147d21.gif" alt="\sigma" valign="middle"/></dt>
<dd>if <img src="/img/cache/e22f640260bb6c5f84ceda65d90bc071.gif" alt="\text{pgaEA}(|p|_{pglc}, etmt:\text{ETMT}(\hat{b} w b))" valign="middle"/> has a security hazard, thus <img src="/img/cache/303b46fbfd6bd874c1cb583a7d509c15.gif" alt="(p, w) \in \text{SHP}" valign="middle"/>,</dd>
<dt><img src="/img/cache/49055dc7498ac440bfa89d4ef3ff521c.gif" alt="\text{ETMT}(\hat{b} 0 \rho)" valign="middle"/> for some <img src="/img/cache/d2606be4e0cd2c9a6179c8f2e3547a85.gif" alt="\rho" valign="middle"/></dt>
<dd>if <img src="/img/cache/e22f640260bb6c5f84ceda65d90bc071.gif" alt="\text{pgaEA}(|p|_{pglc}, etmt:\text{ETMT}(\hat{b} w b))" valign="middle"/> has no security hazard, i.e., <img src="/img/cache/f0cdb14b70aae214abacf0f3c50023bf.gif" alt="(p, w) \not\in \text{SHP}" valign="middle"/>.</dd>
</dl>
<p>Of course, it is assumed that the program <img src="/img/cache/7694f4a66316e53c8cdd9d9954bd611d.gif" alt="q" valign="middle"/> in no circumstance itself issues an <img src="/img/cache/3a3a080a3171f031cfb0bfb87e9f4a87.gif" alt="f.m" valign="middle"/> action, i.e., <img src="/img/cache/33f322753a6b840c7dfe89e5594ffacd.gif" alt="(q, w)\not\in\text{SHP}" valign="middle"/> for all tape configurations <img src="/img/cache/f1290186a5d0b1ceab27f4e77c0c5d68.gif" alt="w" valign="middle"/>, and that its execution always terminates.</p>
<p><strong>Theorem 3.</strong> <em>The security hazard property is unsolvable by means of any program in PGLCi:FMN.</em></p>
<p><em>Proof.</em> Suppose the contrary, i.e., there exists a program <img src="/img/cache/a57f54ef892c1c07cc1ce64687c3c702.gif" alt="q\in\text{PGLCi:FMN}" valign="middle"/> that solves SHP. Let program <img src="/img/cache/03c7c0ace395d80182db07ae2c30f034.gif" alt="s" valign="middle"/> be defined as follows:</p>
<img src="/img/cache/80c114525401b5daba2c71f25bb6c599.gif" alt="s = etmt.dup; q; r" valign="middle"/>
<p>with <img src="/img/cache/d492ad64f767a466fd2aa2b0e6fae1a2.gif" alt="r = etmt.mv:right; -etmt.test:1; f.skip; etmt.mv:begin" valign="middle"/>. Consider the question <img src="/img/cache/fab558b6a2542ab04bab74e5e2597191.gif" alt="(s, s)\in\text{SHP}" valign="middle"/>. We show below that both assumptions <img src="/img/cache/c42a6cf93a1d858c4c5afe5cf41bf3a4.gif" alt="(s,s)\not\in\text{SHP}" valign="middle"/> and <img src="/img/cache/91aa2642aeec04794b809560bbf5883f.gif" alt="(s,s)\in\text{SHP}" valign="middle"/> lead to a contradiction. Hence, <img src="/img/cache/03c7c0ace395d80182db07ae2c30f034.gif" alt="s" valign="middle"/> cannot exist, and thus <img src="/img/cache/7694f4a66316e53c8cdd9d9954bd611d.gif" alt="q" valign="middle"/> cannot exist.</p>
<p>First, assume that <img src="/img/cache/c42a6cf93a1d858c4c5afe5cf41bf3a4.gif" alt="(s,s)\not\in\text{SHP}" valign="middle"/>. Then</p>
<img src="/img/cache/8654b2643ba6bb794710b16ee9364fd0.gif" alt="
	\text{pgaEA}(|s|_{pglc}, etmt:\text{ETMT}(\hat{b} s b))\\
	\downarrow\tau\ (dup)\\
	\text{pgaEA}(|q; r|_{pglc}, etmt:\text{ETMT}(\hat{b} s; s b)).
" valign="middle"/>
<p>Because <img src="/img/cache/a57f54ef892c1c07cc1ce64687c3c702.gif" alt="q\in\text{PGLCi:FMN}" valign="middle"/>, the program <img src="/img/cache/f215eb30d8f85327cf16f3899461b1f0.gif" alt="q; r" valign="middle"/> first executes <img src="/img/cache/7694f4a66316e53c8cdd9d9954bd611d.gif" alt="q" valign="middle"/> (which terminates successfully by assumption) and then starts with the first instruction of <img src="/img/cache/4b43b0aee35624cd95b910189b3dc231.gif" alt="r" valign="middle"/>. Thus,</p>
<img src="/img/cache/3485e445b16a8dff2aa98ff3a4e4ca21.gif" alt="
	\text{pgaEA}(|q; r|_{pglc}, etmt:\text{ETMT}(\hat{b} s; s b))\\
	\downarrow\tau\ (\text{by program }q)\\
	\text{pgaEA}(|r|_{pglc}, etmt:\text{ETMT}(\hat{b} 0 b))
" valign="middle"/>
<p>for some string <img src="/img/cache/a2ab7d71a0f07f388ff823293c147d21.gif" alt="\sigma" valign="middle"/>. The remaining behavior is displayed in Figure 2, and results in</p>
<img src="/img/cache/514601207652815d94f3d248c05db351.gif" alt="\text{pgaEA}(|f.skip; etmt.mv:begin|_{pglc}, etmt:\text{ETMT}(b\hat{0}\sigma b))." valign="middle"/>
<p>This last AnArch clearly represents a security hazard because of the first instruction <img src="/img/cache/6fa9b54cab95d27fa43ea6fe939d3df0.gif" alt="f.skip" valign="middle"/>, and therefore <img src="/img/cache/91aa2642aeec04794b809560bbf5883f.gif" alt="(s,s)\in\text{SHP}" valign="middle"/>. Contradiction.</p>
<hr/>
<img src="/img/cache/737bf20716ba27281ac3289d2a0fd69d.gif" alt="
	\text{pgaEA}(|r|_{pglc}, etmt:\text{ETMT}(\hat{b} 0 \sigma b ))\\
	\ =\\
	\text{pgaEA}(|etmt.mv:right; -etmt.test:1; f.skip; etmt.mv:begin|_{pglc}, etmt:\text{ETMT}(\hat{b} 0 \sigma b))\\
	\ \downarrow\tau\ \ (etmt.mv:right)\\
	\text{pgaEA}(|-etmt.test:1; f.skip; etmt.mv:begin|_{pglc}, etmt:\text{ETMT}(b\hat{0}\sigma b))\\
	\ \downarrow\tau\ \  (-etmt.test:1)\\
	\text{pgaEA}(|f.skip; etmt.mv:begin|_{pglc}, etmt:\text{ETMT}(b\hat{0} \sigma b)).
" valign="middle"/>
<p><strong>Figure 2: Critical state of the behavior in case <img src="/img/cache/c42a6cf93a1d858c4c5afe5cf41bf3a4.gif" alt="(s,s)\not\in\text{SHP}" valign="middle"/> in the proof of Thm. 3</strong></p>
<p>Now assume that <img src="/img/cache/91aa2642aeec04794b809560bbf5883f.gif" alt="(s,s)\in\text{SHP}" valign="middle"/>. The resulting computation is displayed in Figure 3 (for some string <img src="/img/cache/d2606be4e0cd2c9a6179c8f2e3547a85.gif" alt="\rho" valign="middle"/>). Here the last configuration represents halting without having executed any <img src="/img/cache/3a3a080a3171f031cfb0bfb87e9f4a87.gif" alt="f.m" valign="middle"/> action, and therefore <img src="/img/cache/c42a6cf93a1d858c4c5afe5cf41bf3a4.gif" alt="(s,s)\not\in\text{SHP}" valign="middle"/> and again a contradiction occurs.</p>
<hr/>
<img src="/img/cache/704ecf9d9d7e9a3a9b0699c403a588b3.gif" alt="
	\text{pgaEA}(|s|_{pglc}, etmt:\text{ETMT}(\hat{b} s b))\\
	\ \downarrow\tau\ \ (dup)\\
	\text{pgaEA}(|q; r|_{pglc}, etmt:\text{ETMT}(\hat{b} s; s b))\\
	\ \downarrow\tau\ \ (\text{by program }q)\\
	\text{pgaEA}(|r|_{pglc}, etmt:\text{ETMT}(\hat{b}1\rho b))\\
	\ =\\
	\text{pgaEA}(|etmt.mv:right; -etmt.test:1; f.skip; etmt.mv:begin|_{pglc}, etmt:\text{ETMT}(\hat{b}1\rho b))\\
	\ \downarrow\tau\ \ (etmt.mv:right)\\
	\text{pgaEA}(|-etmt.test:1; f.skip; etmt.mv:begin|_{pglc}, etmt:\text{ETMT}(b\hat{1}\rho b ))\\
	\ \downarrow\tau\ \ (-etmt.test:1)\\
	\text{pgaEA}(|etmt.mv:begin|_{pglc}, etmt:\text{ETMT}(b\hat{1}\rho b))\\
	\ \downarrow\tau\ \ (etmt.mv:begin)\\
	{}^\surd\text{with ETMT's configuration: }etmt:\text{ETMT}(\hat{b}1\rho b).
" valign="middle"/>
<p><strong>Figure 3: The case that <img src="/img/cache/91aa2642aeec04794b809560bbf5883f.gif" alt="(s,s)\in\text{SHP}" valign="middle"/> in the proof of Thm. 3</strong></p>
<p>So our supposition was definitely wrong, i.e., there is no program <img src="/img/cache/a57f54ef892c1c07cc1ce64687c3c702.gif" alt="q\in\text{PGLCi:FMN}" valign="middle"/> that solves the security hazard property.</p>
<h2><a name="c6"></a>References</h2>
<ol>
<li>J.A. Bergstra and M.E. Loots. Program algebra for sequential code. <em>Journal of Logic and Algebraic Programming</em>, 51(2):125-156, 2002.</li>
<li>J.A. Bergstra and A. Ponse. Combining programs and state machines. <em>Journal of Logic and Algebraic Programming</em>, 51(2):175-192, 2002.</li>
<li>J.A. Bergstra and A. Ponse. Execution architectures for program algebra. Logic Group Preprint Series 230, http://preprints.phil.uu.nl/lgps/?lang=en, Dept. of Philosophy, Utrecht University, 2004.</li>
<li>F. Cohen. <a href="/lib/afc01.html">Computer viruses - theory and experiments</a>, 1984. http://vx.netlux.org/lib/afc01.html. Version including some corrections and references: <em>Computers &amp; Security</em> 6(1): 22-35, 1987.</li>
<li>C.P. Stirling. Decidability of DPDA equivalence. <em>Theoretical Computer Science</em>, 255, 1-31, 2001.</li>
</ol>
<h2><a name="c7"></a>A Appendix - Terminology and Quotes from the Web</h2>
<p><strong>Ball State University.</strong> <u>What is a Computer Virus?</u><sup><a href="#f2" name="b2">2</a></sup> A computer virus is a type of computer program that is designed to hide in the background and replicate itself from one computer to another by attaching itself to existing programs or parts of the operating system. Users can unknowingly transmit a virus from one system to another by copying infected program files from one machine to another or by using an infected program downloaded from the Internet. Computer viruses often infect many programs on the same system or even parts of the operating system in an attempt to spread themselves as far as possible.</p>
<p>A computer virus will often have a "trigger" such as a specific date or a specific program being run that will perform a benign event such as flashing a message on the users screen. Some viruses will perform more malicious deeds however, deleting or scrambling users files or their entire system. Some viruses also slow down a users system, disable certain functions, or cause erratic system behavior.</p>
<p><u>Computer Worm (Definition).</u><sup><a href="#f3" name="b3">3</a></sup> Worms are very similar to viruses in that they are computer programs that replicate themselves and that often, but not always, contain some functionality that will interfere with the normal use of a computer or a program.</p>
<p>The difference is that unlike viruses, worms exist as separate entities; they do not attach themselves to other files or programs. A worm can spread itself automatically over the network from one computer to the next. Worms take advantage of automatic file sending and receiving features found on many computers.</p>
<p><strong>Webopedia.</strong> <u>Virus.</u><sup><a href="#f4" name="b4">4</a></sup> A program or piece of code that is loaded onto your computer without your knowledge and runs against your wishes. Viruses can also replicate themselves. All computer viruses are manmade. A simple virus that can make a copy of itself over and over again is relatively easy to produce. Even such a simple virus is dangerous because it will quickly use all available memory and bring the system to a halt. An even more dangerous type of virus is one capable of transmitting itself across networks and bypassing security systems.</p>
<p>Since 1987, when a virus infected ARPANET, a large network used by the Defense Department and many universities, many antivirus programs have become available. These programs periodically check your computer system for the best-known types of viruses.</p>
<p>Some people distinguish between general viruses and worms. A worm is a special type of virus that can replicate itself and use memory, but cannot attach itself to other programs.</p>
<p><u>Worm.</u><sup><a href="#f5" name="b5">5</a></sup> A program or algorithm that replicates itself over a computer network and usually performs malicious actions, such as using up the computer's resources and possibly shutting the system down.</p>
<p><u>Trojan horse.</u><sup><a href="#f6" name="b6">6</a></sup> A destructive program that masquerades as a benign application. Unlike viruses, Trojan horses do not replicate themselves but they can be just as destructive. One of the most insidious types of Trojan horse is a program that claims to rid your computer of viruses but instead introduces viruses onto your computer.</p>
<p>The term comes from a story in Homer's Iliad, in which the Greeks give a giant wooden horse to their foes, the Trojans, ostensibly as a peace offering. But after the Trojans drag the horse inside their city walls, Greek soldiers sneak out of the horse's hollow belly and open the city gates, allowing their compatriots to pour in and capture Troy.</p>
<hr/>
<p><a name="f1" href="#b1">1</a> See Appendix A for some quotes about these topics.</p>
<p><a name="f2" href="#b2">2</a> www.bsu.edu/ucs/article/0,1370,6254-1978-3303,00.html</p>
<p><a name="f3" href="#b3">3</a> www.bsu.edu/ucs/article/0,1370,6254-1978-4488,00.html</p>
<p><a name="f4" href="#b4">4</a> www.webopedia.com/TERM/v/virus.html</p>
<p><a name="f5" href="#b5">5</a> www.webopedia.com/TERM/w/worm.html</p>
<p><a name="f6" href="#b6">6</a> www.webopedia.com/TERM/T/Trojan_horse.html</p>
[<a style="" href="/lib/?lang=EN&amp;index=TH#mjb00">Back to index</a>] [<a href="/lib/mjb00.html#disqus_thread">Comments</a>]<br/> <div id="disqus_thread"></div>
<script type="text/rocketscript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'vxheaven'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="/agreement.php">Terms of Use</a>!</small> <small>vxheaven.org aka vx.netlux.org</small></div>
<div style="margin-top: 2px; float: left;" class="adsapeu">
<script type="text/rocketscript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script>
</div>
<script data-rocketsrc="http://www.google-analytics.com/urchin.js" type="text/rocketscript"></script><script type="text/rocketscript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="/lib/index.php?lang=de&amp;id=mjb00">de</a><a href="/lib/index.php?lang=en&amp;id=mjb00">en</a><a href="/lib/index.php?lang=es&amp;id=mjb00">es</a><a href="/lib/index.php?lang=it&amp;id=mjb00">it</a><a href="/lib/index.php?lang=fr&amp;id=mjb00">fr</a><a href="/lib/index.php?lang=pl&amp;id=mjb00">pl</a><a href="/lib/index.php?lang=ru&amp;id=mjb00">ru</a><a href="/lib/index.php?lang=ua&amp;id=mjb00">ua</a></div>
</body>
</html>
