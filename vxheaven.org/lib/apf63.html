<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Peter Ferrie 'This sig doesn't run' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Author" content="Peter Ferrie"/>
<meta name="KeyWords" lang="en" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, Ferrie, Peter,This sig doesn't run, host, relocation, ﬁles, byte, saved, original, body, data, mask, instruction, entry, point, ﬁeld, random, size"/>
<meta name="Description" content="Some virus writers like to brag about themselves or their creations. Sometimes the bragging is done via the virus author’s choice of name for the virus. Of course, it’s rare that the content justiﬁes the bragging, since lots of viruses contain bugs. Here we have the ultimate combination of bragging and bugs. The author of the virus gave it the name ‘Sigrún’, which is Old Norse for ‘victory rune’. However, there is no victory because the virus does not work (the reason why will not be described here). Just in case the bug is ﬁxed, let’s call it W64/Svafa, because ‘Sváfa’ is the previous incarnation of Sigrún, and the name is thought to derive from the word for ‘sleep-maker’, which seems appropriate."/>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"047a5bcbf67431883fc9ed25fba33612",petok:"594f672abfdeee0f3dcd489c3f7e3ea3fc574070-1498757289-1800",zone:"vxheaven.org",rocket:"a",apps:{}}];document.write('<script type="text/javascript" src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=85b614c0f6/cloudflare.min.js"><'+'\/script>');}}catch(e){};
//]]>
</script>
<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="/style.css"/><link rel="canonical" href="http://vxheaven.org/lib/apf63.html"/>
<script type="text/rocketscript" data-rocketsrc="https://apis.google.com/js/plusone.js">{"parsetags": "explicit"}</script>
</head>
<body bgcolor="#dbc8a0" text="#302000" link="#225599" vlink="#113366">
<div class="s1">
<div style="float:right;"><a href="/lib/index.php?tbs=1"><img src="/img/max.gif" alt="Maximize"/></a></div> <form id="lf" style="margin: 0; float: right;" method="get" action="/index.php"><input type="hidden" name="action" value="set"/><select name="lang" onchange="javascript:document.getElementById('lf').submit();"><option value="ru">Русский</option><option selected="selected" value="en">English</option><option value="ua">Українська</option><option value="de">Deutsch</option><option value="es">Español</option><option value="fr">Fran&ccedil;ais</option><option value="it">Italiano</option><option value="pl">Polski</option></select></form>
<div style="float: right;"><div id="plusone"></div></div>
<script type="text/rocketscript">gapi.plusone.render("plusone", {"size":"small","count":"true"});</script>
<div style="float: right;" class="addthis_toolbox addthis_default_style">
<script type="text/rocketscript">var addthis_config = { ui_click: true }</script>
<a style="text-decoration: none; font-size: 10pt;" href="/?action=addthis" class="addthis_button_compact">Bookmark</a>
<script type="text/rocketscript" data-rocketsrc="http://s7.addthis.com/js/250/addthis_widget.js#username=herm1t"></script>
</div>
<div style="float: right;">
<script type="text/rocketscript" data-rocketsrc="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<form action="/search.php" id="cse-search-box">
<input type="hidden" name="cx" value="002577580816726040001:z9_irkorydo"/>
<input type="hidden" name="cof" value="FORID:10"/>
<input type="hidden" name="ie" value="UTF-8"/>
<input type="text" name="q" size="12" value=" "/>
<input type="submit" name="sa" value="Search"/>
</form>
</div><h1><a href="/" style="text-decoration: none; color: #000000;">VX Heaven</a></h1>
<span class="nav"><a href="/lib/">Library</a> <a href="/vl.php">Collection</a> <a href="/src.php">Sources</a> <a href="/vx.php?id=eidx">Engines</a> <a href="/vx.php?id=tidx">Constructors</a> <a href="/vx.php?id=sidx">Simulators</a> <a href="/vx.php?id=uidx">Utilities</a> <a href="/links.php">Links</a> <a href="/donate.php" style="color: #706020" id="donate">Donate</a> <a href="/forum" style="text-decoration: underline;">Forum</a> </span><br clear="all"/>
</div>
<div class="s2"><h1>This sig doesn't run</h1><p><a href="/lib/?lang=en&amp;author=Ferrie%2C%20Peter">Peter Ferrie</a><br/> <em><a href="/vx.php?fid=2005#f2005">Virus Bulletin, January 2012</a>, pp. 4-5</em><br/> <em>ISSN 0956-9979</em><br/> <em>January 2012</em></p><script type="text/rocketscript">var disqus_url = 'http://vxheaven.org/lib/apf63.html';</script><div class="ci"><a href="/lib/?ci=apf63">1</a></div>[<a style="" href="/lib/?lang=EN&amp;index=AN#apf63">Back to index</a>] [<a href="/lib/apf63.html#disqus_thread">Comments</a>]<br/> <form method="post" action=""><input type="hidden" name="pages" value="1"/><input type="submit" value="Turn on page numbers"/></form>
<address>
Peter Ferrie<br/>
Microsoft, USA
</address>
<ul>
<li><a href="#c1">Í upphafi (initially)</a></li>
<li><a href="#c2">Relocation allowance</a></li>
<li><a href="#c3">I'm looking for... my mask!</a></li>
<li><a href="#c4">Touch and go</a></li>
<li><a href="#c5">I like to ‘MOV’ it</a></li>
<li><a href="#c6">Conclusion</a></li>
<li><a href="#c7">References</a></li>
</ul>
<p>Some virus writers like to brag about themselves or their creations. Sometimes the bragging is done via the virus author’s choice of name for the virus. Of course, it’s rare that the content justiﬁes the bragging, since lots of viruses contain bugs. Here we have the ultimate combination of bragging and bugs. The author of the virus gave it the name ‘Sigrún’, which is Old Norse for ‘victory rune’. However, there is no victory because the virus does not work (the reason why will not be described here). Just in case the bug is ﬁxed, let’s call it W64/Svafa, because ‘Sváfa’ is the previous incarnation of Sigrún, and the name is thought to derive from the word for ‘sleep-maker’, which seems appropriate.</p>
<h2><a name="c1"></a>Í upphafi (initially)</h2>
<p>The ﬁrst generation of the virus begins by saving the relative address of the original entry point on the stack. However, depending on the imagebase value that was used when building it, this value might be completely wrong. The virus applies the current imagebase value from the ImageBaseAddress ﬁeld in the Process Environment Block, in order to account for Address Space Layout Randomization (ASLR). This is an interesting way to deal with ASLR. It is more common simply to calculate the difference between a branch instruction and the host entry point.</p>
<p>The virus also saves the current stack pointer to a ﬁeld in its body. Using this value the virus can undo any changes to the stack at any point during the execution of the code. This is particularly important during API resolution, since the virus cannot easily know how many APIs have been saved before something goes wrong.</p>
<p>The virus begins by retrieving the base address of ntdll.dll. It does this by walking the InMemoryOrderModuleList from the PEB_LDR_DATA structure in the Process Environment Block. This is compatible with the changes that were made in <em>Windows 7</em>. The virus also saves the pointer to the current position in the list so that it can resume the parsing later to ﬁnd the base address of kernel32.dll. If the virus ﬁnds the PE header for ntdll.dll, it resolves the two required APIs: RtlAddVectoredExceptionHandler and RtlRemoveVectoredExceptionHandler.</p>
<p>The virus uses hashes instead of names, but the hashes are sorted alphabetically according to the strings they represent. This means that the export table needs to be parsed only once for all of the APIs. Each API address is placed on the stack for easy access, but because stacks move downwards in memory, the addresses end up in reverse order in memory. The virus also checks that the exports really exist by limiting the parsing to the number of exports in the table.</p>
<p>The hash table is terminated with a single byte whose value is 0x2a (the ‘*’ character). This is a convenience that allows the ﬁle mask to follow immediately in the form of ‘*.exe’. The virus retrieves the base address of kernel32.dll by fetching the next entry in the list, using the pointer that was saved earlier. The same routine is used to retrieve the addresses of the API functions that it requires, and which is the absolute minimum set of APIs that it needs for replication – ﬁnd ﬁrst/next, open, map, unmap, close.</p>
<p>As with previous viruses by the same author, this virus only uses ANSI APIs. The result is that some ﬁles cannot be opened because of the characters in their names, and thus cannot be infected. The virus searches in the current directory (only), for objects whose names end in ‘.exe’. This is intended to be restricted to ﬁles, but can also include any directories that have such a name, and there is no ﬁltering to distinguish between the two cases.</p>
<p>For each such ﬁle that is found, the virus attempts to open it and map a view of the contents. There is no attempt to remove the read-only attribute, so ﬁles that have that attribute set cannot be infected. In the case of a directory, the open will fail, and the map will be empty. The virus registers an exception handler at this point, and then checks whether the ﬁle can be infected.</p>
<h2><a name="c2"></a>Relocation allowance</h2>
<p>The virus is interested in Portable Executable ﬁles for the x64 platform. Renamed DLL ﬁles are not excluded, nor are ﬁles that are digitally signed. The subsystem value is checked, but incorrectly. The check is supposed to limit the types to GUI or CUI but only the low byte is checked. Thus, if a ﬁle uses a (currently non-existent) subsystem with a value in the high byte, then it could potentially be infected too.</p>
<p>The virus checks the Base Relocation Table data directory to see if the relocation table begins at the start of the last section. If so, then the virus assumes that the entire section is devoted to relocation information. This could be considered to be a bug. The virus checks that the physical size of the section is large enough to hold the virus code. There are multiple bugs with this check alone. The ﬁrst bug is that the size of the relocation table could be much smaller than the size of the section, and other data might follow it. The data will be overwritten when the virus infects the ﬁle.</p>
<p>Further, the value in the Size ﬁeld of the Base Relocation Table data directory cannot be less than the size of the
 
relocation information, and it cannot be larger than the size of the section. This is because the value in the Size ﬁeld is used as the input to a loop that applies the relocation information. It must be at least as large as the sum of the sizes of the relocation data structures. However, if the value were larger than the size of the relocation information, then the loop would access data after the relocation table, and that data would be interpreted as relocation data. If the relocation type were not a valid value, then the ﬁle would not load. If the value in the Size ﬁeld were less than the size of the relocation information, then it would eventually become negative and the loop would parse data until it hit the end of the image and caused an exception.</p>
<p>The second bug is that by checking only the physical size and not the virtual size, whatever the virus places in the ﬁle might be truncated in memory if the virtual size of the section is smaller than the physical size of the section. Both of these bugs are also present in the W64/Holey virus [1], by the same virus author.</p>
<p>However, it is the third bug that is very serious, very silly, and should have been very obvious. It is that the size of the virus code is less than one third of the total size that is needed to hold the data that the virus adds to a ﬁle. The true size of the virus is the size of the virus code multiplied by three, plus the size of the decoder. Thus, the section might be nowhere near large enough for the ﬁle to be infected correctly, but the virus won’t notice the problem.</p>
<h2><a name="c3"></a>I'm looking for... my mask!</h2>
<p>If the section appears to be large enough, then its attributes are marked as executable and writable. The virus ‘encrypts’ its code using a byte-mask technique. There are two tables involved here, both of which are the same size as the virus code. One table contains the byte-mask, and the other contains a selection of host bytes. For each byte in an eight-byte set, the virus chooses randomly if it will be encoded or not.</p>
<p>If the byte is to be encoded, then the byte-mask will have the top bit set in the mask table, and the other seven bits will be set to a random value. The corresponding entry in the host table will contain the host byte, and the value at the original location in the host will be set to a random value.</p>
<p>If the byte is not to be encoded, then the byte mask will have the top bit clear in the mask table, and the other seven bits will be set to a random value. The corresponding entry in the host table will contain a random value, and the value at the original location in the host will maintain its original value. This process is repeated over the entire host body.</p>
<p>Once the encoding is complete, the virus zeroes the values in the Offset and Size ﬁelds of the Base Relocation Table data directory, saves the original entry point in the virus body, and then sets the host entry point to point directly to the virus code.</p>
<h2><a name="c4"></a>Touch and go</h2>
<p>The virus code ends with an instruction to force an exception to occur. This is used as a common exit condition. However, the virus does not recalculate the ﬁle checksum, even though it might have changed as a result of infection. It also does not restore the ﬁle’s date and timestamps, making it very easy to see which ﬁles have been infected, even though the ﬁle size does not change.</p>
<h2><a name="c5"></a>I like to ‘MOV’ it</h2>
<p>When an infected ﬁle is executed, the virus decodes itself. The special thing here is that the decoding is done using three MMX instructions, one of which might be considered to be a bit obscure: MASKMOVQ. The MASKMOVQ instruction accepts two parameters which correspond to the two tables that the virus constructed. For each byte in the mask table whose high bit is set, the corresponding byte in the host table is copied into the host body at the location to which the EDI register points at that moment. If the high bit is clear, then no copy occurs. Thus, prior to decoding, the virus body is a mixture of real values and random values, and so is the host table.</p>
<p>There have been suggestions that MMX is not safe to use on the 64-bit platform, because the ﬂoating-point state (and thus the MMX state, which shares the same memory region) is not saved, but this is not the case. In user mode, the ﬂoating-point state is always saved during a context switch. Therefore, there is no problem at all for user-mode processes. In kernel mode, the context is not saved, but it was not saved on the 32-bit platform either, so there is no new behaviour here.</p>
<h2><a name="c6"></a>Conclusion</h2>
<p>The MASKMOVQ technique is another surprise from the MMX instruction set, and one which makes static analysis a bit inconvenient. However, anti-malware emulators will see just another instruction, and shortly afterwards, just another virus.</p>
<h2><a name="c7"></a>References</h2>
<ol>
<li>Ferrie, P. <a href="/lib/apf59.html">‘Holey’ virus, Batman!</a> <a href="/vx.php?fid=2000#f2000">Virus Bulletin, September 2011</a>, p.4. http://www.virusbtn.com/pdf/magazine/2011/201109.pdf.</li>
</ol>
 
[<a style="" href="/lib/?lang=EN&amp;index=AN#apf63">Back to index</a>] [<a href="/lib/apf63.html#disqus_thread">Comments</a>]<br/> <div id="disqus_thread"></div>
<script type="text/rocketscript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'vxheaven'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="/agreement.php">Terms of Use</a>!</small> <small>vxheaven.org aka vx.netlux.org</small></div>
<div style="margin-top: 2px; float: left;" class="adsapeu">
<script type="text/rocketscript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script>
</div>
<script data-rocketsrc="http://www.google-analytics.com/urchin.js" type="text/rocketscript"></script><script type="text/rocketscript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="/lib/index.php?lang=de&amp;id=apf63">de</a><a href="/lib/index.php?lang=en&amp;id=apf63">en</a><a href="/lib/index.php?lang=es&amp;id=apf63">es</a><a href="/lib/index.php?lang=it&amp;id=apf63">it</a><a href="/lib/index.php?lang=fr&amp;id=apf63">fr</a><a href="/lib/index.php?lang=pl&amp;id=apf63">pl</a><a href="/lib/index.php?lang=ru&amp;id=apf63">ru</a><a href="/lib/index.php?lang=ua&amp;id=apf63">ua</a></div>
</body>
</html>
