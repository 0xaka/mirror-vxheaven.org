<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Peter Ferrie 'Frankie say relax' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Author" content="Peter Ferrie"/>
<meta name="KeyWords" lang="en" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, Ferrie, Peter,Frankie say relax, segment, header, relocation, dynamic, program, offset, host, symbol, virtual, function, relax, size, page, symbols, table"/>
<meta name="Description" content="When a virus infects a ﬁle, it usually needs to know its loading address so that it can access its variables. This is done most commonly by using a ‘delta offset’. There are two main types of delta offset: one is the difference between the location where the virus is currently loaded and the original location where the virus was loaded when it was created; the other is the difference between the location of the variable and the start of the virus code. One alternative method is to append relocation items to the host relocation table (if one exists), so that the addresses in the virus code are updated appropriately by the operating system itself. However, touching the host relocation table can be a complex task, depending on the ﬁle format and its location within the ﬁle. Another alternative is to carry a relocation table in the virus body and use that to update the addresses to constant values during the infection phase. This is the method that is used by Linux/Relax.A. Linux/Relax.B uses the same method, but in this case the relocation table is generated dynamically."/>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"047a5bcbf67431883fc9ed25fba33612",petok:"d31b08cb6f88f977018c1576e8bf5e20de8e27f5-1498755116-1800",zone:"vxheaven.org",rocket:"a",apps:{}}];document.write('<script type="text/javascript" src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=85b614c0f6/cloudflare.min.js"><'+'\/script>');}}catch(e){};
//]]>
</script>
<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="/style.css"/><link rel="canonical" href="http://vxheaven.org/lib/apf58.html"/>
<script type="text/rocketscript" data-rocketsrc="https://apis.google.com/js/plusone.js">{"parsetags": "explicit"}</script>
</head>
<body bgcolor="#dbc8a0" text="#302000" link="#225599" vlink="#113366">
<div class="s1">
<div style="float:right;"><a href="/lib/index.php?tbs=1"><img src="/img/max.gif" alt="Maximize"/></a></div> <form id="lf" style="margin: 0; float: right;" method="get" action="/index.php"><input type="hidden" name="action" value="set"/><select name="lang" onchange="javascript:document.getElementById('lf').submit();"><option value="ru">Русский</option><option selected="selected" value="en">English</option><option value="ua">Українська</option><option value="de">Deutsch</option><option value="es">Español</option><option value="fr">Fran&ccedil;ais</option><option value="it">Italiano</option><option value="pl">Polski</option></select></form>
<div style="float: right;"><div id="plusone"></div></div>
<script type="text/rocketscript">gapi.plusone.render("plusone", {"size":"small","count":"true"});</script>
<div style="float: right;" class="addthis_toolbox addthis_default_style">
<script type="text/rocketscript">var addthis_config = { ui_click: true }</script>
<a style="text-decoration: none; font-size: 10pt;" href="/?action=addthis" class="addthis_button_compact">Bookmark</a>
<script type="text/rocketscript" data-rocketsrc="http://s7.addthis.com/js/250/addthis_widget.js#username=herm1t"></script>
</div>
<div style="float: right;">
<script type="text/rocketscript" data-rocketsrc="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<form action="/search.php" id="cse-search-box">
<input type="hidden" name="cx" value="002577580816726040001:z9_irkorydo"/>
<input type="hidden" name="cof" value="FORID:10"/>
<input type="hidden" name="ie" value="UTF-8"/>
<input type="text" name="q" size="12" value=" "/>
<input type="submit" name="sa" value="Search"/>
</form>
</div><h1><a href="/" style="text-decoration: none; color: #000000;">VX Heaven</a></h1>
<span class="nav"><a href="/lib/">Library</a> <a href="/vl.php">Collection</a> <a href="/src.php">Sources</a> <a href="/vx.php?id=eidx">Engines</a> <a href="/vx.php?id=tidx">Constructors</a> <a href="/vx.php?id=sidx">Simulators</a> <a href="/vx.php?id=uidx">Utilities</a> <a href="/links.php">Links</a> <a href="/donate.php" style="color: #706020" id="donate">Donate</a> <a href="/forum" style="text-decoration: underline;">Forum</a> </span><br clear="all"/>
</div>
<div class="s2"><h1>Frankie say relax</h1><p><a href="/lib/?lang=en&amp;author=Ferrie%2C%20Peter">Peter Ferrie</a><br/> <em>Virus Bulletin, August 2011, page 4-6</em><br/> <em>ISSN 0956-9979</em><br/> <em>August 2011</em></p><script type="text/rocketscript">var disqus_url = 'http://vxheaven.org/lib/apf58.html';</script><img src="/img/pdf.gif" alt="PDF"/><a href="/lib/pdf/Frankie%20say%20relax.pdf">Download</a> PDF (42.08Kb) (You need to be registered on <a href="/forum">forum</a>)<br/>[<a style="" href="/lib/?lang=EN&amp;index=AN#apf58">Back to index</a>] [<a href="/lib/apf58.html#disqus_thread">Comments</a>]<br/> <form method="post" action=""><input type="hidden" name="pages" value="1"/><input type="submit" value="Turn on page numbers"/></form>
<address>
Peter Ferrie<br/>
Microsoft, USA
</address>
<ul>
<li><a href="#c1">All your base</a></li>
<li><a href="#c2">Get it. ‘GOT’ it? Good.</a></li>
<li><a href="#c3">Protection detail</a></li>
<li><a href="#c4">Hole-y work</a></li>
<li><a href="#c5">Conclusion</a></li>
</ul>
<p>When a virus infects a ﬁle, it usually needs to know its loading address so that it can access its variables. This is done most commonly by using a ‘delta offset’. There are two main types of delta offset: one is the difference between the location where the virus is currently loaded and the original location where the virus was loaded when it was created; the other is the difference between the location of the variable and the start of the virus code. One alternative method is to append relocation items to the host relocation table (if one exists), so that the addresses in the virus code are updated appropriately by the operating system itself. However, touching the host relocation table can be a complex task, depending on the ﬁle format and its location within the ﬁle. Another alternative is to carry a relocation table in the virus body and use that to update the addresses to constant values during the infection phase. This is the method that is used by Linux/Relax.A. Linux/Relax.B uses the same method, but in this case the relocation table is generated dynamically.</p>
<h2><a name="c1"></a>All your base</h2>
<p>Both viruses begin by registering two signal handlers: one to intercept invalid regular memory accesses (for example, a pointer to unallocated memory), and the other to intercept misaligned addresses or invalid mapped-memory accesses (for example, in a ﬁle that is memory-mapped according to its original ﬁle size, but which is then truncated by another process). The viruses use the ‘int 0x80’ interface directly here, because no external symbols have yet been resolved (that is, the host has access to its own symbols, but the virus does not know where they are yet). These two int 0x80 calls are the only ones in the virus code. However, what might be considered a bug exists here – if an exception occurs, then the signal handlers are not restored to their default values. Thus, if an exception occurs in the host (perhaps due to the presence of the virus) and in the absence of another registered signal handler, the signal handlers will run the host entrypoint again – at which point further exceptions seem likely to occur, so the signal handlers will run again (and again, and again). The result is an inﬁnite loop.</p>
<p>At this point, Relax.A ﬁnds the image base of its host (Relax.B does this the ﬁrst time that a function is called in libc) by walking backwards one page at a time, beginning at the start of its code, until ‘an’ ELF header is found. The ‘an’ here refers to the fact that that no veriﬁcation is made that the signature belongs to an actual header, as opposed to the (unlikely) case that the magic value happens to appear at the start of a page. However, the signal handler will intercept any problem relating to fake headers. This lack of veriﬁcation could exclude certain ﬁles from being infected, but this is a minor point. It would be possible to inoculate ﬁles against these and similar viruses by placing the fake signature in the right place, but the idea is a little silly. The simplest approach would be to remove the writable ﬂag on the ﬁle, since the viruses make no attempt to set it.</p>
<h2><a name="c2"></a>Get it. ‘GOT’ it? Good.</h2>
<p>Once the header is found, the viruses search within the Program Header Table for the segment that contains the virus code. The virus code segment is identiﬁed by ﬁnding the loadable segment which has the lowest virtual address. The viruses also search for the segment that holds the dynamic linking information. The viruses search within the tags in the dynamic segment for the one that describes the Global Offset Table. If the third entry in the Global Offset Table is non-zero then the viruses use that pointer to search for the segment that holds the dynamic linking information, and then search the tags within that segment for the one that describes the Global Offset Table. The Global Offset Table is a table of pointers. The third value in the table is a pointer to the ‘_resolve’ symbol inside the dynamic linker. If the dynamic linker is not required (because the symbols have all been resolved statically before the process started) then the value at that location will be zero.</p>
<p>In either case, the viruses perform the same search for the dynamic segment and another Global Offset Table, using the ﬁfth entry in the current Global Offset Table. The new table should point into libc. There is no requirement for it to do so, but there is no other library that the loader would need. The viruses search within the tags in the dynamic segment for the symbol table and the string table. In order to call external functions, the viruses need to resolve the external symbols. To do so, they would normally need to know how many symbols exist. They attempt to retrieve the number of symbols from a hash table which is located by searching the tags within the dynamic segment. The viruses know about two hash table tags. If neither of these is found, then they use a hack to calculate it by determining the number of symbol structures that can ﬁt in the symbol table.</p>
<p>It is not known why the viruses determine the number of symbols, except perhaps as a leftover from code that used one of the hash tables correctly (see <a href="/lib/apf30.html"><em>VB</em>, August 2009 p.4</a> for details of how the hash table is used for symbol resolution). They could perform the symbol search without an upper limit (the symbols that the viruses need ought
 
to exist), and simply allow the signal handler to trap any error. Since the virus is using a brute-force search anyway, the performance is actually worse with the check for the upper limit than it would be without it. The virus author knows how to use the hash table correctly, but since the viruses recognize two types of hash table, which have different formats, there would need to be two parsing algorithms.</p>
<p>Relax.A uses the gathered information to resolve the address of a single function, mprotect(), while Relax.B uses it for multiple functions. Further, Relax.B waits until a function in libc is called for the ﬁrst time, and then resolves the address of that function. Thereafter, the proper address is used directly.</p>
<h2><a name="c3"></a>Protection detail</h2>
<p>Relax.A uses the mprotect() function to make the code section writable. Then the virus parses the relocation table that it carries in its data section, searching for the relocation items that correspond to external symbols. The virus resolves the addresses of the external symbols that it needs in order to infect ﬁles. The relocation table is in a custom format, and is produced by a standalone tool that is run after the ﬁle is compiled. The details of that tool are not relevant here. After applying all of the required relocations, the virus restores the section attributes, and then calls the main virus body.</p>
<p>Relax.B does not carry a relocation table in its data section. Instead, the virus disassembles its code at runtime and creates the relocation table dynamically. As a result, the mprotect() function is not needed by the virus. The virus has no concerns about the code versus data problem, since the entire virus body is known. Of course, if there were any misinterpretation, it would have prevented the ﬁrst generation of the virus from running at all, and thus would have been detected instantly.</p>
<p>Since the viruses can run from any address thanks to the relocation table, they are also able to make use of external functions instead of calling the int 0x80 interface directly. In this case, the viruses use the ftw() function to search for ﬁles to infect instead of performing the ﬁle enumeration on their own. The ftw() function accepts a pointer to a function to be called for each item that is found. The infection routine begins by attempting to open the item and map the ﬁrst 4KB of the ﬁle. The viruses are interested in ELF ﬁles that are at least 1KB long (this appears to be an oversight given the size of the map above), but not more than 3MB large. In contrast to all of the previous pieces of malware from this virus author, the viruses are quite strict about the ﬁle format:</p>
<ul>
<li>the ELF signature must match</li>
<li>the size of the ELF header must be the standard value</li>
<li>the ﬁle must be 32-bit format</li>
<li>the ﬁle must use little-endian byte-ordering</li>
<li>the ﬁle must be executable</li>
<li>it must be for an <em>Intel</em> 386 or better CPU</li>
<li>the version must be current</li>
<li>the size of a program header table entry must be the standard value</li>
<li>there must not be too many program header table entries</li>
<li>the program header table must ﬁt within the ﬁle</li>
<li>the ABI must either not be speciﬁed or it must be for <em>Linux</em></li>
<li>the size of a section header table entry must be the standard value</li>
<li>the section header table must ﬁt within the ﬁle</li>
<li>the ﬁle must not be infected already.</li>
</ul>
<p>The infection marker for the viruses is the last byte of the e_ident ﬁeld being set to 1. This has the effect of inoculating the ﬁle against a number of other viruses (including several by the same virus author), since a marker in this location is quite common.</p>
<h2><a name="c4"></a>Hole-y work</h2>
<p>The viruses search the Program Header Table for the interpreter segment. The segment will be present if the ﬁle uses dynamic linking. If the segment is found, then the viruses check that it ﬁts within the ﬁle, and that the virus code can ﬁt in the space between the end of the interpreter segment and the start of the next page (though there is an off-by-one bug here such that an exact ﬁt will not be accepted). There is an implicit assumption here that the interpreter segment is in the ﬁrst page of the ﬁle. The viruses also search for the loadable segment which has the highest virtual address. If the interpreter segment is not found, then the viruses will try to place their code immediately after the Program Header Table, otherwise they will try to place their code immediately after the interpreter segment. There is an implicit assumption here that the Program Header Table appears before the interpreter segment. If the two elements are swapped, then the virus will overwrite the Program Header Table as a result.</p>
<p>The viruses initially increase the ﬁle size by 4KB and create a hole at the chosen location (into which the virus
 
code will be placed). The bytes between the end of the virus code and the start of the next page are zeroed. There is a bug here in that some bytes in the following page are also zeroed because the length is calculated incorrectly. The viruses add 4KB to the ﬁle offset of the Section Header Table, and to the ﬁle offset of each of the entries in the table, to compensate for the size of the hole that was inserted.</p>
<p>The viruses ﬁnd the Program Header Table entry that corresponds to the ﬁle header, increase its physical and virtual size by 4KB, and decrease its physical and virtual addresses by 4KB. The physical and virtual addresses of the Program Header Table and the interpreter segment are also decreased by 4KB, to ensure that they remain within the ﬁrst page of the ﬁle. All of the other Program Header Table entries have their physical address increased by 4KB.</p>
<p>The viruses increase the physical and virtual sizes of the loadable segment with the highest virtual address by the size of the virus data. They create a hole at the chosen location, into which the virus data will be placed. The viruses then increase by a corresponding amount the ﬁle offset of each entry in the Section Header Table whose previous offset was after the end of the affected loadable segment.</p>
<p>The viruses parse their relocation table again, and for each entry that is not an external symbol in the Relax.A code, or for each entry in Relax.B (Relax.B does not carry relocation information for the external symbols), the viruses apply the appropriate relocation value in the newly infected ﬁle, such that all of the addresses are made absolute according to the host loading address. Of course, this requires that the address is constant. It will not work if the ﬁle is a position-independent executable. To achieve that would require the use of a delta offset in order to locate the data section in the ﬁrst place, and then to apply the relocations dynamically to the entire virus body.</p>
<p>Finally, the viruses set the entrypoint to point to the virus code, mark the ﬁle as infected, and then allow the search to continue for more ﬁles.</p>
<h2><a name="c5"></a>Conclusion</h2>
<p>The idea of a virus carrying (or calculating) a relocation table is great for virus writers. It allows them to write the code in a high-level language, and use all of the high-level APIs that exist, without having to perform tricks with position dependence or having to use Assembler to ﬁddle with the bits. Best of all, it doesn’t make any difference to anti-virus vendors, because whether it’s high level or low level, we can still detect it without any trouble.</p>
 
[<a style="" href="/lib/?lang=EN&amp;index=AN#apf58">Back to index</a>] [<a href="/lib/apf58.html#disqus_thread">Comments</a>]<br/> <div id="disqus_thread"></div>
<script type="text/rocketscript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'vxheaven'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="/agreement.php">Terms of Use</a>!</small> <small>vxheaven.org aka vx.netlux.org</small></div>
<div style="margin-top: 2px; float: left;" class="adsapeu">
<script type="text/rocketscript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script>
</div>
<script data-rocketsrc="http://www.google-analytics.com/urchin.js" type="text/rocketscript"></script><script type="text/rocketscript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="/lib/index.php?lang=de&amp;id=apf58">de</a><a href="/lib/index.php?lang=en&amp;id=apf58">en</a><a href="/lib/index.php?lang=es&amp;id=apf58">es</a><a href="/lib/index.php?lang=it&amp;id=apf58">it</a><a href="/lib/index.php?lang=fr&amp;id=apf58">fr</a><a href="/lib/index.php?lang=pl&amp;id=apf58">pl</a><a href="/lib/index.php?lang=ru&amp;id=apf58">ru</a><a href="/lib/index.php?lang=ua&amp;id=apf58">ua</a></div>
</body>
</html>
