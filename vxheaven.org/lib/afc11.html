<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Fred Cohen 'A Formal Definition of Computer Worms and Some Related Results' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Author" content="Fred Cohen"/>
<meta name="KeyWords" lang="en" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, Cohen, Fred,Formal Definition of Computer Worms and Some Related Results, remote, system, computer, calm, theorem, definition, time, network, mapsto, cohen, caln, boxempty, sigma, viruses, leftrightarrow"/>
<meta name="Description" content="In this paper, we propose a formal definition of &quot;computer worms&quot; and discuss some of their properties. We begin by reviewing the formal definition of &quot;computer viruses&quot;, and their properties. We then define &quot;computer worms&quot; as a subclass of viruses, and show that many of the interesting ptoperties derived for viruses hold for worms. Finally, we summarize results, draw conclusions, and propose further work."/>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"047a5bcbf67431883fc9ed25fba33612",petok:"72f46f0c0017ec89cdb9e430c3d941fe2a15fa13-1498756284-1800",zone:"vxheaven.org",rocket:"a",apps:{}}];document.write('<script type="text/javascript" src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=85b614c0f6/cloudflare.min.js"><'+'\/script>');}}catch(e){};
//]]>
</script>
<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="/style.css"/><link rel="canonical" href="http://vxheaven.org/lib/afc11.html"/>
<script type="text/rocketscript" data-rocketsrc="https://apis.google.com/js/plusone.js">{"parsetags": "explicit"}</script>
</head>
<body bgcolor="#dbc8a0" text="#302000" link="#225599" vlink="#113366">
<div class="s1">
<div style="float:right;"><a href="/lib/index.php?tbs=1"><img src="/img/max.gif" alt="Maximize"/></a></div> <form id="lf" style="margin: 0; float: right;" method="get" action="/index.php"><input type="hidden" name="action" value="set"/><select name="lang" onchange="javascript:document.getElementById('lf').submit();"><option value="ru">Русский</option><option selected="selected" value="en">English</option><option value="ua">Українська</option><option value="de">Deutsch</option><option value="es">Español</option><option value="fr">Fran&ccedil;ais</option><option value="it">Italiano</option><option value="pl">Polski</option></select></form>
<div style="float: right;"><div id="plusone"></div></div>
<script type="text/rocketscript">gapi.plusone.render("plusone", {"size":"small","count":"true"});</script>
<div style="float: right;" class="addthis_toolbox addthis_default_style">
<script type="text/rocketscript">var addthis_config = { ui_click: true }</script>
<a style="text-decoration: none; font-size: 10pt;" href="/?action=addthis" class="addthis_button_compact">Bookmark</a>
<script type="text/rocketscript" data-rocketsrc="http://s7.addthis.com/js/250/addthis_widget.js#username=herm1t"></script>
</div>
<div style="float: right;">
<script type="text/rocketscript" data-rocketsrc="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<form action="/search.php" id="cse-search-box">
<input type="hidden" name="cx" value="002577580816726040001:z9_irkorydo"/>
<input type="hidden" name="cof" value="FORID:10"/>
<input type="hidden" name="ie" value="UTF-8"/>
<input type="text" name="q" size="12" value=" "/>
<input type="submit" name="sa" value="Search"/>
</form>
</div><h1><a href="/" style="text-decoration: none; color: #000000;">VX Heaven</a></h1>
<span class="nav"><a href="/lib/">Library</a> <a href="/vl.php">Collection</a> <a href="/src.php">Sources</a> <a href="/vx.php?id=eidx">Engines</a> <a href="/vx.php?id=tidx">Constructors</a> <a href="/vx.php?id=sidx">Simulators</a> <a href="/vx.php?id=uidx">Utilities</a> <a href="/links.php">Links</a> <a href="/donate.php" style="color: #706020" id="donate">Donate</a> <a href="/forum" style="text-decoration: underline;">Forum</a> </span><br clear="all"/>
</div>
<div class="s2"><h1>A Formal Definition of Computer Worms and Some Related Results</h1><p><a href="/lib/?lang=en&amp;author=Cohen%2C%20Fred">Fred Cohen</a><br/> <em>Computers &amp; Security, 7(11) (1992), pp.641-652</em><br/> <em>ISSN 0167-4048</em><br/> <em> 1992</em></p><script type="text/rocketscript">var disqus_url = 'http://vxheaven.org/lib/afc11.html';</script><div class="ci"><a href="/lib/?ci=afc11">4</a></div><img src="/img/pdf.gif" alt="PDF"/><a href="/lib/pdf/A%20Formal%20Definition%20of%20Computer%20Worms%20and%20Some%20Related%20Results.pdf">Download</a> PDF (1.12Mb) (You need to be registered on <a href="/forum">forum</a>)<br/>[<a style="" href="/lib/?lang=EN&amp;index=TH#afc11">Back to index</a>] [<a href="/lib/afc11.html#disqus_thread">Comments</a>]<br/> <form method="post" action="">
<img src="/img/cache/0b9fd596a90421f9f1f68a9760275737.gif" alt="\text{T_EX size}" valign="middle"/>
<select name="TeX_size"><option value="-2">-2</option><option value="-1">-1</option><option value="0" selected="selected">0</option><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option> </select>
<input type="submit" value="Scale"/>
</form><form method="post" action=""><input type="hidden" name="pages" value="1"/><input type="submit" value="Turn on page numbers"/></form>
<address>
F. B. Cohen<sup>*</sup><br/>
ASP, P.O. Box 81270, Pittsburgh, PA15217, USA
</address>
<p><small>* Funded by ASP, P.O. Box 81270. Pittsburgh, PA15217, USA.</small></p>
<p>In this paper, we propose a formal definition of "computer worms" and discuss some of their properties. We begin by reviewing the formal definition of "computer viruses", and their properties. We then define "computer worms" as a subclass of viruses, and show that many of the interesting ptoperties derived for viruses hold for worms. Finally, we summarize results, draw conclusions, and propose further work.</p>
<p>Keywords: Computer viruses, Computer worms.</p>
<h2>1. Background</h2>
<p>An informal definition of "computer viruses" was first published in 1984 by Cohen [1], and was soon followed by his formal definition first published in 1985 [2] based on Turing's model of computation [3]. An alternative formal definition was proposed by Adleman [4] in 1989 based on set theory. In each of these cases, detection of viruses was shown to be undecidable, and several other results were derived.</p>
<p>These definitions were quite general in scope, and covered a broad range of replicating programs, possibly including the as yet only poorly defined, but widely used term "worm". Unfortunately, the lack of an adequate and standard definition of worms has created numerous misinterpretations and wasted time, and few of the results on worms have gone beyond the speculative phase. In this paper, we address this problem.</p>
<p>We begin here with an informal discussion by presenting a pseudo-code example of a very simple virus:</p>
<p>V:=[F=RANDOM-FILE-NAME; COPY V TO F;]</p>
<p>This virus simply replicates into files with random names, and is unlikely to be successful in any current computing environment because the chances are very poor that any of the replicas will ever be run. Even if they were run, they would not perform the functions the programs they replaced performed prior to replication, and thus would be rapidly detected. Since these replicas are of no practical value, they would likely be destroyed. More purposeful viruses, both malicious and benevolent, have been shown to be quite powerful, primarily due to their prodigious reliability and ability to spread. Viruses have also caused quite a problem in some environments.</p>
<p>The first published scientific references to computer worms that we are aware of came from
 
Shoch and Hupp [5], who described several experiments with programs which replicated segments of themselves or parallel processing over a network. Unfortunately, no formal definition followed, and no sample code was provided. This left an unfilled void, and a host of informal but widely varying discussions using the poorly defined term followed in the literature.</p>
<p>Recently, the term "worm" has been widely used to describe programs that automatically replicate and initialize interpretation of their replicas.<sup><a href="#f1" name="b1">1</a></sup> By contrast, the definition of viruses covers all self-replicating programs but does not address the manner in which replicas may be actuated. Here is a pseudo-code example of a simple worm:</p>
<p>W:=[F=RANDOM-FILE-NAME;COPY W TO F;RUN F;]</p>
<p>With the ability to replicate comes a host of other issues. The most obvious issue is that a replicating program might exhaust all of the available resources in a system, thus causing a system failure. In the case of this worm in a uniprocessing environment, the system eternally runs replicas of the worm, and no other processing can take place while the worm runs. In a multiprocessing environment, well-designed worms may be able to coexist safely with other programs if they are limited in their replication and evolution so as not to seriously impact performance.</p>
<p>Another important aspect of viruses is their ability to "carry" additional code with them. For example, in the 1984 paper [1], pseudo-code was provided for a compression virus, a denial of services virus, and other examples. The early worm experiments [5] solved large problems by including subprobems in replicas, thus allowing them to solve parts of the problem using remote resources. More commonly used viruses include the "diskcopy" program provided with the DOS operating system, which, in certain environments, replicates and carries along the contents of the entire disk on which it resides; product installation programs, which replicate as part of their installation process; and backup programs which make copies of themselves and other programs on other media to improve system reliability.</p>
<p>Another interesting feature of self-replicating programs is their resilience. In environments where non-replicating programs often fail or are destroyed through errors or omissions, viruses seem to thrive. This is because of the natural redundancy provided by replication. In this environment, viruses seem to be more fit than non-viral programs.</p>
<p>From a protection standpoint, viruses offer unique problems. Their resilience makes then very hard to remove from an operating environment, while their transitive spread bypasses most modern protection methods. General-purpose detection is undecidable [1,2,4], while special-purpose methods are not cost effective [9]. There are many other interesting properties of self-replicating programs. We refer the interested reader to some of the recent literature in this area [6].</p>
<p>In the remainder of this paper, we will formalize the notion of worms, describe how that formalism leads very quickly to a series of conclusions about worm properties, show how these results impact multiprocessing and multiprocessor environments, discuss some of the potentials for both malicious and benevolent worms, describe a number of historical incidents, summarize results, draw conclusions, and propose further work.</p>
<h2>2. Some Formalities</h2>
<p>Cohen [2] presents "Viral Sets" in terms of a set of "histories" with respect to a given machine. A viral set is a set of symbol sequences which, when interpreted, causes one or more elements of the viral set to be written elsewhere on the machine in all of the histories following the interpretation. We include here some o the relevant definitions
 
required for the remainder of the paper, starting with the definition of a set of Turing-like [3] computing machines "<img src="/img/cache/6de7f59e8221730d1f224bcb46c85967.gif" alt="\calM" valign="middle"/>" as in Box 1.</p>
<div align="center">
<img src="/img/cache/d71cbcf676285c4439ca51c095a7204f.gif" alt="
\fbox{
	\forall M [M \in \calM] \Leftrightarrow\\
	\ \ M:(S_M,I_M,O_M:S_M\times I_M\mapsto I_M,N_M:S_M\times I_M\mapsto S_M,D_M:S_M\times I_M\mapsto d)\\
	\ \ \ \ \begin{array}{ll}
			\hspace{250}\\
			\calN=\{0\dots\infty\} &amp; \text{(the \quot{natural}\quot\ numbers)}\\
			\calJ=\{1\dots\infty\} &amp; \text{(the positive \quot{integers}\quot)}\\
			S_M=\{s_0,\dots,s_n\},n\in\calJ &amp; \text{(\calM\ states)}\\
			I_M=\{i_0,\dots,i_j\},j\in\calJ &amp; \text{(\calM\ tape symbols)}
		\end{array}\\
	\text{where}\\
	\ \ \ \ \begin{array}{ll}
			\hspace{250}\\
			d=\{-1,0,+1\} &amp; \text{\calM\ head motions)}\\
			\not{S}:\calN\mapsto S_M &amp; \text{(\calM\ state over time)}\\
			\boxempty_M:\calN\times\calN\mapsto I_M &amp; \text{(\calM\ tape contents over time)}\\
			P_M:\calN\mapsto\calN &amp; \text{(current \calM\ cell at each time)}
		\end{array}\\
	{\text{Box 1}}
}\\
\fbox{
	\forall M\forall V (M,V)\in\calV\Leftrightarrow\\
	\ \ \ \ [V\subset I^*] and [M \in \calM] and \forall v\in V \forall H \forall t,j \in \calN\\
	\ \ \ \ [P_t=j] and [S_t=S_0] and (\boxempty_{t,j},\dots,\boxempty_{i,j+|v|-1}) = v \Rightarrow\\
	\ \ \exists v'\in V, \exists t',t'',j'\in\calN\ and\ t'&gt;t\\
	\ \ \ \ (1)\ [[(j'+|v'|\le j] or [(j+|v|)\le j']] and\\
	\ \ \ \ (2)\ [(\boxempty_{t',j'},\dots,\boxempty_{t',j'+|v'|-1}) = v'\ and\\
	\ \ \ \ (3)\ [\exists t''[t\lt t''\lt t'] and [P_{t''}\in j',\dots,j'+|v'|-1]]\\
	\text{Box 2}
}
" valign="middle"/></div>
<p>The "history" of the machine <img src="/img/cache/8f7cdd901a777b5b32a7f9ecfb531bb5.gif" alt="H_M" valign="middle"/> is given by <img src="/img/cache/f5c93a76d2bff2c9cd1d9e076e0c7fa3.gif" alt="(\not{S},\boxempty,P)" valign="middle"/><sup><a href="#f2" name="b2">2</a></sup> the "initial state" is described by <img src="/img/cache/eb49d82221b692a238db43c1c4712c07.gif" alt="(\not{S}_0,\boxempty_0,P_0)" valign="middle"/>, and the set of possible <img src="/img/cache/6de7f59e8221730d1f224bcb46c85967.gif" alt="\calM" valign="middle"/> tape subsequences is designated by <img src="/img/cache/667b417d65156212dcfe27bd869c778a.gif" alt="I^*" valign="middle"/>. We say that; <img src="/img/cache/69691c7bdcc3ce6d5d8a1361f22d04ac.gif" alt="M" valign="middle"/> is halted at time <img src="/img/cache/2d31e09c672e26b5cd31dc4bf9739f9a.gif" alt="t\Leftrightarrow\forall t'&gt;t, H_t= H_{t'}, (t,t'\in\calN)" valign="middle"/>; that <img src="/img/cache/d42c2debfb08a9ff9dc27b1685a03568.gif" alt="M\text{ halts }\Leftrightarrow\exists t\in\calN" valign="middle"/>, <img src="/img/cache/69691c7bdcc3ce6d5d8a1361f22d04ac.gif" alt="M" valign="middle"/> is halted at time <img src="/img/cache/e358efa489f58062f10dd7316b65649e.gif" alt="t" valign="middle"/>; that <img src="/img/cache/83878c91171338902e0fe0fb97a8c47a.gif" alt="p" valign="middle"/> "runs" at time <img src="/img/cache/18bd3b01fae6144eac32a76a871a6cbd.gif" alt="t\Leftrightarrow" valign="middle"/> the "initial state" occurs when <img src="/img/cache/5b7c5aa2a2a15bd892afe579eef0906e.gif" alt="P_0" valign="middle"/>, is such that <img src="/img/cache/83878c91171338902e0fe0fb97a8c47a.gif" alt="p" valign="middle"/> appears at <img src="/img/cache/816ad48d6e877201f699576ea9926219.gif" alt="\boxempty_{0,P_0}" valign="middle"/>; and that <img src="/img/cache/83878c91171338902e0fe0fb97a8c47a.gif" alt="p" valign="middle"/> runs <img src="/img/cache/5c80704b4646059c59084fb1ecf31824.gif" alt="\Leftrightarrow\exists t\in\calN" valign="middle"/>, <img src="/img/cache/83878c91171338902e0fe0fb97a8c47a.gif" alt="p" valign="middle"/> runs at time <img src="/img/cache/e358efa489f58062f10dd7316b65649e.gif" alt="t" valign="middle"/>. The formal definition of the viral set (<img src="/img/cache/29cc90a646c8da85f429a91e3add589d.gif" alt="\calV" valign="middle"/>) is given in Box 2.</p>
<p>The interested reader is referred to [2] for details.</p>
 
<h2>3. Definition of Computer Worms</h2>
<p>We define a "Worm Set" <img src="/img/cache/1f5c98c45275858579f581216341c106.gif" alt="\calW" valign="middle"/> as a viral set in which any worm (<img src="/img/cache/f1290186a5d0b1ceab27f4e77c0c5d68.gif" alt="w" valign="middle"/>) that is run at some move <img src="/img/cache/865c0c0b4ab0e063e5caa3387c1a8741.gif" alt="i" valign="middle"/> results in a worm <img src="/img/cache/8624c3694bf8d786aba4c979661866b2.gif" alt="w'" valign="middle"/> being run at some subsequent time <img src="/img/cache/47dff5405744818bd472bd3c1675cc42.gif" alt="i'" valign="middle"/> (Box 3).</p>
<div align="center"><img src="/img/cache/830e77c7ea26fb7aa8a8784c7005a71c.gif" alt="
\fbox{
	\forall M \forall W (M,W) \in\calW \Leftrightarrow\\
	\ \ \ \ [W\subset I^*] and [M \in \calM] and \forall w \in W \forall H \forall t,j \in \calN\\
	\ \ \ \ [[P_t = j] and [S_t = S_0] and (\boxempty_{t,j},\dots,\boxempty_{t,j+|w|-1})=w] \Rightarrow\\
	\ \ \exists w' \in W \exists t',t'',t''',j' \in \calN, t'&gt;t\\
	\ \ \ \ (1)\ [[(j'+|w'|\le j] or [(j+|w|)\le j']] and\\
	\ \ \ \ (2)\ [(\boxempty_{t',j'},\dots,\boxempty_{t',j'+|w'|-1})=w'] and\\
	\ \ \ \ (3)\ \exists t''[t\lt t'' \lt t'] and [P_{t''}\in j',\dots,j'+|w'|-1] and\\
	\ \ \ \ (4)\ \exists t'''[t' \lt t'''] and [P_{t'''}=j'] and [S_{t'''} = S_0]\\
	\text{Box 3}
}
" valign="middle"/></div>
<p>Translated into English, this means (approximately):</p>
<ul style="list-style:none;">
<li><img src="/img/cache/f58854e16cb3f5302aab71eedc3553a6.gif" alt="(M, W)" valign="middle"/> is a "worm set" if and only if:
<ul style="list-style:none;">
<li>all worms in <img src="/img/cache/61e9c06ea9a85a5088a499df6458d276.gif" alt="W" valign="middle"/> are <img src="/img/cache/6de7f59e8221730d1f224bcb46c85967.gif" alt="\calM" valign="middle"/> sequences -and- <img src="/img/cache/69691c7bdcc3ce6d5d8a1361f22d04ac.gif" alt="M" valign="middle"/> is a <img src="/img/cache/6de7f59e8221730d1f224bcb46c85967.gif" alt="\calM" valign="middle"/> -and-
<ul style="list-style:none;">
<li>for each worm <img src="/img/cache/f1290186a5d0b1ceab27f4e77c0c5d68.gif" alt="w" valign="middle"/> in <img src="/img/cache/61e9c06ea9a85a5088a499df6458d276.gif" alt="W" valign="middle"/>, for all histories of <img src="/img/cache/69691c7bdcc3ce6d5d8a1361f22d04ac.gif" alt="M" valign="middle"/>,</li>
<li>for all times <img src="/img/cache/e358efa489f58062f10dd7316b65649e.gif" alt="t" valign="middle"/> and cells <img src="/img/cache/363b122c528f54df4a0446b6bab05515.gif" alt="j" valign="middle"/></li>
</ul></li>
<li>if the tape head is in front of cell <img src="/img/cache/363b122c528f54df4a0446b6bab05515.gif" alt="j" valign="middle"/> at time <img src="/img/cache/e358efa489f58062f10dd7316b65649e.gif" alt="t" valign="middle"/> -and-
<ul style="list-style:none;">
<li><img src="/img/cache/6de7f59e8221730d1f224bcb46c85967.gif" alt="\calM" valign="middle"/> is in its initial state at time <img src="/img/cache/e358efa489f58062f10dd7316b65649e.gif" alt="t" valign="middle"/> -and-</li>
<li>the tape cells starting at <img src="/img/cache/363b122c528f54df4a0446b6bab05515.gif" alt="j" valign="middle"/> hold the worm <img src="/img/cache/f1290186a5d0b1ceab27f4e77c0c5d68.gif" alt="w" valign="middle"/> -then-</li>
</ul></li>
<li>there is a worm <img src="/img/cache/8624c3694bf8d786aba4c979661866b2.gif" alt="w'" valign="middle"/> in <img src="/img/cache/61e9c06ea9a85a5088a499df6458d276.gif" alt="W" valign="middle"/>, a time <img src="/img/cache/314d0119a905bd061ebfae327efbce2f.gif" alt="t'&gt;t" valign="middle"/>, and place <img src="/img/cache/e791243cf0d230e7f49105130aeb078f.gif" alt="j'" valign="middle"/> such that
<ol>
<li>at a place <img src="/img/cache/e791243cf0d230e7f49105130aeb078f.gif" alt="j'" valign="middle"/> not overlapping worm <img src="/img/cache/f1290186a5d0b1ceab27f4e77c0c5d68.gif" alt="w" valign="middle"/></li>
<li>the tape cells starting at cell <img src="/img/cache/e791243cf0d230e7f49105130aeb078f.gif" alt="j'" valign="middle"/> hold worm <img src="/img/cache/8624c3694bf8d786aba4c979661866b2.gif" alt="w'" valign="middle"/> -and-</li>
<li>at time <img src="/img/cache/eff9ec111ac240c3184120138ebd2899.gif" alt="t''" valign="middle"/> between <img src="/img/cache/e358efa489f58062f10dd7316b65649e.gif" alt="t" valign="middle"/> and <img src="/img/cache/3b11da5ab8568206a5e1184fbf7f2005.gif" alt="t'" valign="middle"/>, worm <img src="/img/cache/8624c3694bf8d786aba4c979661866b2.gif" alt="w'" valign="middle"/> is written by <img src="/img/cache/69691c7bdcc3ce6d5d8a1361f22d04ac.gif" alt="M" valign="middle"/> -and-</li>
<li>at some later time <img src="/img/cache/a86f635c815340ff260f1c6ac37a7d8b.gif" alt="t'''" valign="middle"/>, worm <img src="/img/cache/8624c3694bf8d786aba4c979661866b2.gif" alt="w'" valign="middle"/> is run by <img src="/img/cache/69691c7bdcc3ce6d5d8a1361f22d04ac.gif" alt="M" valign="middle"/></li>
</ol></li>
</ul></li>
</ul>
<p>The definition of <img src="/img/cache/1f5c98c45275858579f581216341c106.gif" alt="\calW" valign="middle"/> is different from that of <img src="/img/cache/29cc90a646c8da85f429a91e3add589d.gif" alt="\calV" valign="middle"/> only in condition 4 being added, and because this term is an "and" on the right side of an implication, <img src="/img/cache/00fd2ed8c5e4cf41cced18f7d8255154.gif" alt="\calW\subset \calV" valign="middle"/>. We normally refer to elements of <img src="/img/cache/7dd0317924389575359edf239e1efe48.gif" alt="V,(M,V)\in\calV" valign="middle"/> for a given machine M as "viruses" on M, and in the same parlance we will refer to members of <img src="/img/cache/b31677ce80849db13c03e0f8ed38f162.gif" alt="W,(M,W)\in\calW" valign="middle"/> for a given machine M as "worms" on M. We typically drop the "on M" when we are referring to a particular M, and make statements like "all worms are viruses".</p>
<p>It turns out that most of the examples used for proofs about viruses [2] were not only viruses but also worms by the present definition, and thus the proofs apply directly. The remaining proofs do not depend on the lack of condition 4 above, and thus most of them arc also true for worms. For the purpose of brevity, we list some of the useful results for viruses that also hold for worms, along with page numbers from the cited work:<sup><a href="#f3" name="b3">3</a></sup></p>
 
<ul style="list-style:none;">
<li>P12 Theorem 1 A union of <img src="/img/cache/1f5c98c45275858579f581216341c106.gif" alt="\calW" valign="middle"/>s is <img src="/img/cache/1f5c98c45275858579f581216341c106.gif" alt="\calW" valign="middle"/>.</li>
<li>P13 Lemma 1.1 <img src="/img/cache/32ff223f4b9214ce44a3f7cac5abe8bf.gif" alt="\exists" valign="middle"/> "largest" <img src="/img/cache/1f5c98c45275858579f581216341c106.gif" alt="\calW" valign="middle"/> for any machine M.</li>
<li>P14 Theorem 2 <img src="/img/cache/32ff223f4b9214ce44a3f7cac5abe8bf.gif" alt="\exists" valign="middle"/> "smallest" <img src="/img/cache/cbbffec8000ba37b1f909daf485071ca.gif" alt="\cal{W}s(\calW_{min})" valign="middle"/> for some M.</li>
<li>P14 Theorem 3 <img src="/img/cache/32ff223f4b9214ce44a3f7cac5abe8bf.gif" alt="\exists" valign="middle"/> <img src="/img/cache/8456a8fa4498b084154940d9dcb2401d.gif" alt="\calW_{min}" valign="middle"/> of every size <img src="/img/cache/61e0143356dfdc0594c3fc846136a806.gif" alt="i\in\calJ" valign="middle"/> for a universal <img src="/img/cache/6de7f59e8221730d1f224bcb46c85967.gif" alt="\calM" valign="middle"/>.</li>
<li>P19 Theorem 4 There are uncountable <img src="/img/cache/805910bc2c8d7244e7a7f6ee90a8b406.gif" alt="\cal{W}s" valign="middle"/> for some M.</li>
<li>P21 Theorem 5 Every sequence of symbols is a worm on some M.</li>
<li>P23 Theorem 6 Worm detection is undecidable.</li>
<li>P25 Lemma 6.1 Detecting evolutions of a known worm is undecidable.</li>
<li>P26 Theorem 7 Worm evolution is as general as <img src="/img/cache/6de7f59e8221730d1f224bcb46c85967.gif" alt="\calM" valign="middle"/> computation.</li>
</ul>
<p>Another interesting result of this definition is that once a worm runs, M can never halt! More formally:<sup><a href="#f4" name="b4">4</a></sup></p>
<p>Theorem A:</p>
<p><img src="/img/cache/efb92169b8f19b1e8c717731d5ca2df0.gif" alt="\forall w \in W,(M, W)\subset\calW" valign="middle"/>, w runs <img src="/img/cache/055889aaee38b7c53f994c5e42a40994.gif" alt="\Rightarrow" valign="middle"/> M never halts.</p>
<p>This is because at all times after w runs, there is always another <img src="/img/cache/37d8aa1a8e8c41d98593e6f061d59a14.gif" alt="w \in W" valign="middle"/> that must run at a subsequent time. More formally, assume <img src="/img/cache/ad4f41580945892660c97274320161c1.gif" alt="\exists w \in W,(M,W)\subset\calW" valign="middle"/> and w is run at time t. Then by condition 4 in the definition:</p>
<p><img src="/img/cache/569f286709929e865f6109407a758d0b.gif" alt="\exists t'''&gt;t:[P_{t'''}=j'] and [S_{t'''} = S_0]" valign="middle"/></p>
<p>and by condition 2 of the definition:</p>
<p><img src="/img/cache/122d753d0592179a79dba8f021a68130.gif" alt="(\boxempty_{t''',j'},\dots,\boxempty_{t''',j'+|w'|-1})=w'" valign="middle"/></p>
<p>Thus <img src="/img/cache/8624c3694bf8d786aba4c979661866b2.gif" alt="w'" valign="middle"/> is run at time <img src="/img/cache/a86f635c815340ff260f1c6ac37a7d8b.gif" alt="t'''" valign="middle"/>! But if any <img src="/img/cache/37d8aa1a8e8c41d98593e6f061d59a14.gif" alt="w \in W" valign="middle"/> is run at any time t (specifically, <img src="/img/cache/8624c3694bf8d786aba4c979661866b2.gif" alt="w'" valign="middle"/> at time <img src="/img/cache/a86f635c815340ff260f1c6ac37a7d8b.gif" alt="t'''" valign="middle"/>), we return to the previous situation. By the induction theorem, if a condition is true at some time 1 and if being true at time t implies it is true at time t + 1, it is true for all time <img src="/img/cache/784cb234842e1f852ec8aefe7a5fbd04.gif" alt="t' &gt; t" valign="middle"/>. By condition 3 of the definition:</p>
<p><img src="/img/cache/1890b151b700460129fdee0927b74d82.gif" alt="\forall t \in \calN, \exists t'''&gt;t : [S_{t'''}=S_0]\text{ and }\exists t''&gt;t : P_{t''} != P_t" valign="middle"/></p>
<p>so by definition, <img src="/img/cache/e6c83152ce08a9845c3022368b3728ab.gif" alt="\forall H,M" valign="middle"/> is not halted at time t, or in other words, M never halts. Thus a system running a worm has the "liveliness" property.</p>
<p>Lemma A.1:</p>
<p><img src="/img/cache/12d739b702e9d13cac74430af4919031.gif" alt="\forall w \in W,(M,W)\in\calW" valign="middle"/>, M halts <img src="/img/cache/895d8ced7a79e679eb22a05f2656402e.gif" alt="\Rightarrow\not\exists t\in\calN" valign="middle"/>, w runs at time t.</p>
<h2>4. Multiprocessing Environments</h2>
<p>In a multiprocessing environment, worms are quite different than in a uniprocessing environment. For example, in a multiprocessing environment, a worm need not dominate processing. With proper controls on replication, a stable system can be put in place to attain desirable levels of worm activity. Here is a simple example in which a system function <img src="/img/cache/202bf91a04dcc5cfb0018c947234387f.gif" alt="\sigma_k" valign="middle"/> returns the number of currently active <img src="/img/cache/062d41268eaebed7f369b10257c567ba.gif" alt="W_k" valign="middle"/> worms:</p>
<pre>
	<img src="/img/cache/062d41268eaebed7f369b10257c567ba.gif" alt="W_k" valign="middle"/> := [WHILE TRUE DO [F=RANDOM-FILE-NAME;WHILE[<img src="/img/cache/0f49d7367353fcded0406d7fe9642bd6.gif" alt="\sigma_k&gt;k" valign="middle"/>]WAIT];
		COPY <img src="/img/cache/062d41268eaebed7f369b10257c567ba.gif" alt="W_k" valign="middle"/> TO F;RUN F;IF[<img src="/img/cache/0f49d7367353fcded0406d7fe9642bd6.gif" alt="\sigma_k&gt;k" valign="middle"/>]EXIT;]]
</pre>
 
<p>In this case k limits the number of worms in the system. Each worm will replicate until k total worms are in the system. From that point on, each worm will wait until there are k or fewer worms in the system, replicate, and then exit. Assuming we have a fair scheduler and an accurate <img src="/img/cache/202bf91a04dcc5cfb0018c947234387f.gif" alt="\sigma_k" valign="middle"/> we get a relatively stable population of worms.</p>
<p>The <img src="/img/cache/062d41268eaebed7f369b10257c567ba.gif" alt="W_k" valign="middle"/>, worms could implement <img src="/img/cache/202bf91a04dcc5cfb0018c947234387f.gif" alt="\sigma_k" valign="middle"/> by updating a commonly accessible integer, by using unique process names in the process table, by associating themselves with files stored in a particular area, or by any other interprocess communication method available on the system.</p>
<p>In order to model this sort of environment and show properties of worms, we require additional structure, but we don't want to abandon the mathematics associated with Turing machines in the process. This model extension is provided by the "Universal Protection Machine" [2] (<img src="/img/cache/1de3af6d030b90c9d333be8a2de8dde8.gif" alt="\calP" valign="middle"/>), which is implemented on a universal <img src="/img/cache/c99e92bc413d9a402cf1f42620d65f6d.gif" alt="\calM (M)" valign="middle"/>, and processes moves from each of a finite set of <img src="/img/cache/6de7f59e8221730d1f224bcb46c85967.gif" alt="\calM" valign="middle"/>s simulated on M by using a "scheduler" and a "special state" which implements "system calls". This machine is defined as:</p>
<p><img src="/img/cache/55277bb492df9435870c361e0f1d9a14.gif" alt="\calP:(M,S,O,R,f:S \times O \mapsto R,\calR)" valign="middle"/></p>
<p>where:</p>
<p><img src="/img/cache/d16466b335bc1c57b028cc526a7958ab.gif" alt="M\in\calM" valign="middle"/> an "interpretation unit"</p>
<p><img src="/img/cache/05ecbefe276160943543370607cf9db2.gif" alt="S=(s_0,\dots,s_i),i\in\calJ" valign="middle"/> a set of "subjects"</p>
<p><img src="/img/cache/40c1b1dec726d9df9fa2132d156f903e.gif" alt="O=(o_0,\dots,o_j),j\in\calJ" valign="middle"/> a set of "objects"</p>
<p><img src="/img/cache/fab7f9cf0483d3e405fc9f31cb483a03.gif" alt="R=(r_0,\dots,r_k),k\in\calJ" valign="middle"/> a set of "rights" of <img src="/img/cache/5dbc98dcc983a70728bd082d1a47546e.gif" alt="S" valign="middle"/>s over <img src="/img/cache/f186217753c37b9b9f958d906208506e.gif" alt="O" valign="middle"/>s</p>
<p><img src="/img/cache/0d59d6e3c46d12f0708369c11b70463e.gif" alt="f : (S \times O \mapsto R)" valign="middle"/> a protection matrix [8]</p>
<p><img src="/img/cache/d28a280e7293efe5586bd03acd5187a6.gif" alt="\calR=((s,o)_0,\dots,(s,o)_l),l\in\calJ" valign="middle"/> a "run sequence" of subjects "running" objects</p>
<p>When a subject interprets an object (i.e., <img src="/img/cache/d25b51d677b9d0377c4130e3a343a7bf.gif" alt="(s,o)\in\calR)" valign="middle"/>, M uses the rights of s for the duration of the interpretation of o. We are particularly interested in the rights "read" (r) and "write" (w), because these translate into the flow (f) of information between subjects. (i.e., <img src="/img/cache/0164f897adadf4bfb224f54b36b9daa7.gif" alt="s_wo_a\ and\ s_y ro_a \Rightarrow s_xfs_y)" valign="middle"/> [10]. This is alternatively expressed as:</p>
<p><img src="/img/cache/2596c9012c7bf26ce25cb22f54487fb1.gif" alt="(s_x,o_a)\in w\ and\ (s_y,o_a)\in r \Rightarrow (s_x,s_y) \in f" valign="middle"/></p>
<p>Information flow is transitive (i.e., <img src="/img/cache/22c788d8ba0ef9e2c1dd40792ad02bae.gif" alt="s_xfs_y\ and\ s_yfs_z\Rightarrow s_xfs_z" valign="middle"/>) when M is a universal <img src="/img/cache/6de7f59e8221730d1f224bcb46c85967.gif" alt="\calM" valign="middle"/> [2], and using this model a vital result that viruses can spread to the transitive closure of information flow from the source subject was derived.<sup><a href="#f5" name="b5">5</a></sup> This is because <img src="/img/cache/500524a5f9ad02d3b100df1dd50efbdd.gif" alt="\exists\calR" valign="middle"/> in which each subject in the transitive closure of information flow, in turn, interprets an object modified by the virus interpreted by a subject previously in the information flow from the original virus source.</p>
<p>In any "fair" scheduler with unbounded work to be done and assuming that all accessible programs are run with some non-zero frequency, such an <img src="/img/cache/0bbff11c428eb92ed802aac93a141369.gif" alt="\calR" valign="middle"/> will eventually be realized because there will always be a partial subsequence of <img src="/img/cache/0bbff11c428eb92ed802aac93a141369.gif" alt="\calR" valign="middle"/> in which each of the necessary objects will be interpreted in sequence [2].</p>
<p>It turns out that the same result is, in general, true for worms, but transitivity doesn't result simply from running replicas. That is, if no object is modified by subjects running the worm, and if we ignore all other causal factors (e.g., a progenitor of a worm is run by some other user independent of the actions of the worm under consideration), only subjects with direct access to the worm can run it. Mathematically:</p>
<p><img src="/img/cache/6c6e956c8cfcbdd7c1bf0719e6c84a2b.gif" alt="(M,W)\in\calW,\ \forall a \in W,\ \forall b \not\in W,\ \forall\calR,\ \forall s \in S" valign="middle"/></p>
<p><img src="/img/cache/cd36793a55743b3b04c1edf66bc2c26a.gif" alt="\not\exists(s,b)\in\calR\ and \ \forall(s,a)\in\calR,\ (s,b) \not\in w \Rightarrow \not\exists H_M : b \in W" valign="middle"/></p>
<p>We will call worms that do not output to any objects "pure worms" (<img src="/img/cache/39f2bbacbeed18ba0793f32f607d6e6c.gif" alt="\calW_p" valign="middle"/>).By definition,
 
s runs <img src="/img/cache/e0759825a200af80bd96fdfd4a17d608.gif" alt="a\Rightarrow(s,a) \in r" valign="middle"/>,</p>
<p>so</p>
<p>Theorem B:</p>
<p><img src="/img/cache/abbe97fe4993931b0a84078d751e5fc2.gif" alt="\forall a\in\calW_p \forall s \in S:(s,a) \not\in r \Rightarrow \not\exists H:s\text{ runs }a" valign="middle"/></p>
<p>This implicitly assumes that R is static with respect to s and a over the period of the operation of the worm. If this is not the case, the situation may be far more complex because, in general, it is undecidable whether at some future time, <img src="/img/cache/f074ec1f07a3f13b31d14f2240327ba9.gif" alt="(s,a) \in r" valign="middle"/> will be true [8]. This does not seem to be important in the short term; however, over the long term, there are often cases where momentary lapses in protection parameters could cause the undesired extension of rights. Once extended, of course, such rights cannot necessarily be revoked from a pure worm because the worm is operating with the authority of the subject that invoked it. Even though the right to invoke the worm may have been removed, all of the operating instances of replicas of the worm cannot necessarily be terminated without massive denial of service. This situation is partially covered by the "time transitivity" analysis used for viruses [10].</p>
<p>We anthropomorphize objects containing worms by sayin that a worm (w) has been granted the rights of a subject <img src="/img/cache/ffb0df479b2e1db10d9291e9812b2ee9.gif" alt="(s)\Leftrightarrow s" valign="middle"/> runs <img src="/img/cache/4f4651f039ce211dc9e9be6be57af0ea.gif" alt="w \in W,(M,W)\in\calW" valign="middle"/>, and we express this as <img src="/img/cache/610979c411cd930d8067d48bc7a962d9.gif" alt="w\leftarrow s" valign="middle"/> (read w gets s). If only the creator of a pure worm has direct access to it, it follows that the rights of all replicas will be limited to the rights of the originator, since only the originator can run it and, by definition, rights are only extended to objects by virtue of the subjects that interpret them. More generally, a pure worm only gets the subjects who run it:</p>
<p>Lemma B.1:</p>
<p><img src="/img/cache/b18b66e4da6e1d68a120bc12b8a93a62.gif" alt="\forall w\in\calW_p,\ w \leftarrow s \Leftrightarrow s\text{ runs }w." valign="middle"/></p>
<p>In the case of pure worms, evaluating the worst case impact of time variations on the protection state is trivial. Every subject that is ever granted direct access to w is potentially impacted, and all other subjects are completely safe from its direct impact. This model ignores performance impacts because the Turing machine model of computation generally assumes that moves take no time, and is used primarily to analyze the possibilities rather than the practicalities of any particular situation. A more realistic impact assessment is to assume that all users operating on all machines where there is an impacted user are impacted because of the performance degradation effects of the worm on those machines. This is an area for further research.</p>
<p>In a uniprocessing environment, because worms always run their replica, they are a bit harder to intentionally control than non-worm viruses because there is no obvious way to reduce the population. For viruses, however, this is not the case. For example, the following virus (<img src="/img/cache/ac9b957f663e46224b0c2f455fc33984.gif" alt="v_r" valign="middle"/>) limits itself through the use of a name space:</p>
<pre><img src="/img/cache/ac9b957f663e46224b0c2f455fc33984.gif" alt="v_r" valign="middle"/>:=[F=RANDOM-DIGIT;COPY <img src="/img/cache/ac9b957f663e46224b0c2f455fc33984.gif" alt="v_r" valign="middle"/> TO F;]</pre>
<p>Since the digits consist only of (0...9), the total number of copies of <img src="/img/cache/ac9b957f663e46224b0c2f455fc33984.gif" alt="v_r" valign="middle"/> is limited (i.e., they overwrite each other). We can trivially extend this result to any finite-sized name space. Even a virus which optionally runs replicas can be controlled by a semaphore mechanism to adapt to the requirements of the environment. For example, the following viral variant (<img src="/img/cache/1df181eaa1bb40a0067c06ead197170d.gif" alt="v_i" valign="middle"/>) on the previous worm:</p>
<pre><img src="/img/cache/1df181eaa1bb40a0067c06ead197170d.gif" alt="v_i" valign="middle"/>:=[WHILE TRUE DO [F,F',F"=RANDOM-FILE-NAMES;IF[<img src="/img/cache/96e0460b51e877ca22ffe2c91fbf162f.gif" alt="\sigma_i&gt;k" valign="middle"/>]EXIT;
IF[<img src="/img/cache/aae171cb24c4cdfcf29fb0d41f9268de.gif" alt="\sigma_i \lt k/2" valign="middle"/>][COPY <img src="/img/cache/1df181eaa1bb40a0067c06ead197170d.gif" alt="v_i" valign="middle"/> TO F AND F';RUN F AND F';];COPY <img src="/img/cache/1df181eaa1bb40a0067c06ead197170d.gif" alt="v_i" valign="middle"/> TO F";RUN F";]]
</pre>
<p>In this case, <img src="/img/cache/1df181eaa1bb40a0067c06ead197170d.gif" alt="v_i" valign="middle"/> exists without replication while there are more than k replicas operating, and replicates at a higher rate if less than k/2 replicas are present. Thus, there is a stronger drive for replication when the population is low, while death becomes prominent when population is high. This too can be generalized to provide varying drives for survival of the species as a function of population.</p>
 
<p>Most multiprocessing environments have mechanisms whereby one process can force another process to stop processing. These can be used by worms as a means of population control. For example, a pair of worms (<img src="/img/cache/8a05791ab51622f4ad5ab310bcdfc16c.gif" alt="w_1,w_2" valign="middle"/>) could be used to form a stable population ratio by spending some portion of their time forcing the other to halt (i.e., "kill" another process):</p>
<pre><img src="/img/cache/db007d6a923c2909d42c4292bffca5f0.gif" alt="w_1" valign="middle"/>:=[WHILE[<img src="/img/cache/16f461c4d621306c93a94bb85048185d.gif" alt="\sigma_2&gt;k_2" valign="middle"/>], KILL A <img src="/img/cache/c172e309535f6ff639b845bddf5e5319.gif" alt="w_2" valign="middle"/>; PAUSE; REPLICATE;]
<img src="/img/cache/c172e309535f6ff639b845bddf5e5319.gif" alt="w_2" valign="middle"/>:=[WHILE[<img src="/img/cache/2f4fd05d167420da5bf081d043a9601e.gif" alt="\sigma_1&gt;k_1" valign="middle"/>], KILL A <img src="/img/cache/db007d6a923c2909d42c4292bffca5f0.gif" alt="w_1" valign="middle"/>; PAUSE; REPLICATE;]
</pre>
<p>As long as at least one of each <img src="/img/cache/db007d6a923c2909d42c4292bffca5f0.gif" alt="w_1" valign="middle"/> and <img src="/img/cache/c172e309535f6ff639b845bddf5e5319.gif" alt="w_2" valign="middle"/> are active, and finding and killing processes takes far less than the duration of a "pause", the system will regain a balance at <img src="/img/cache/5816a3210bbbab1d8dc57a0850a78101.gif" alt="k_1" valign="middle"/> and <img src="/img/cache/598f2d188e13c994d3ca15cec7cb87bc.gif" alt="k_2" valign="middle"/> respectively of <img src="/img/cache/db007d6a923c2909d42c4292bffca5f0.gif" alt="w_1" valign="middle"/> and <img src="/img/cache/c172e309535f6ff639b845bddf5e5319.gif" alt="w_2" valign="middle"/>. If instead of simply waiting, each worm performed some useful functions requiring relatively little time, we would have a useful worm computation environment. We can call this a 2-worm system, and it is simple to extend the principle to an <em>n</em>-worm system as follows:</p>
<pre><img src="/img/cache/7e8ba1cc821800452bb3a71d10b1ce1c.gif" alt="w_m" valign="middle"/>:=[<img src="/img/cache/0cd5020208a2885453c4696e7518337e.gif" alt="\forall i \lt n" valign="middle"/> [WHILE [<img src="/img/cache/05f7e206f37a2290e1d7a4856df54011.gif" alt="\sigma_i&gt;k_i" valign="middle"/>], KILL A <img src="/img/cache/aa38f107289d4d73d516190581397349.gif" alt="w_i" valign="middle"/>;];
	PAUSE; REPLICATE;]</pre>
<p>By making an <em>n</em>-worm system for large <em>n</em>, we may dramatically improve overall system reliability. In one experimental implementation, we used an <em>n</em>-worm to perform regular maintenance tasks on a Unix&trade; system. In this case, the worms deleted old temporary files and "core" files, regenerated databases, killed errant processes, and performed other regular maintenance functions. The result was an "ecosystem" in which almost no systems administration was required for continued operation over a four-year period.</p>
<p>Despite the potential practicality of worms in multiprocessing environments, we have encountered more destructive worms than practical ones in the global multiprocessing environment, and early experiments with practical worms have occasionally resulted in problems. In 1985, an experimental worm in a Unix&trade; environment replicated until the maximum number of processes available to the user were consumed. At that point, all of the replicas were forced into a wait state because they could not create new replicas until some other replica failed. It turned out that in this case there was no way to stop the worm except through a system reboot, because we couldn't kill all of the processes simultaneously, and as soon as one was killed, another replica was created. The inherent priorities of the scheduler made the problem unresolvable. This worm did no serious harm, because all of the replicas were in wait states, and consumed no critical resource.</p>
<p>Another worm which impacts multiprocessing environments is commonly called a "paging monster". A paging monster simply copies itself into each of a series of pages in memory, cycling through memory periodically. In most paged virtual memory systems, this worm forces the system paging program to page out other processes at a very high rate, and thus forces the system to thrash. By combining the Unix&trade; worm described above with the paging monster, the situation can become far more damaging, because you cannot eliminate the paging monsters by simply killing processes.</p>
<p>We return for a moment to Lemma B.1. In each of the examples given above, the worms were pure worms run by a single user, and although they had an impact on the system, in each case, no rights were extended to them beyond those granted to the user who created them. By directly limiting the impact of a single user on system behavior and prudent use of standard access controls, we can protect users in a multiprocessing environment from severe damage due to pure worms. We don't have to worry about the transitive closure of rights in this case.</p>
<p>There is a temptation to try to extend Lemma B.1 to cover non-pure worms whose modifications to other objects don't cause those objects to include worms, but this doesn't work for two reasons. The
 
first reason is that any modification could be interpreted by some M' simulated by interpreting some third object so as to make the modification introduce a worm for machine M'. For any universal <img src="/img/cache/6de7f59e8221730d1f224bcb46c85967.gif" alt="\calM" valign="middle"/>, there always exists such an M'. The second reason is that we would have to exclude all modifications that might eventually result in the generation of a worm. For example, multiple separate and independent modifications, none of which introduces a worm for some machine M, could generate a worm through their combined action. The only cases where we may be able to extend Lemma B.1 are cases where M is not a universal <img src="/img/cache/6de7f59e8221730d1f224bcb46c85967.gif" alt="\calM" valign="middle"/>, which is of relatively little interest in most modern computing environments; and the case where information flow is closed under transitivity.</p>
<h2>5. Multiprocessor Environments</h2>
<p>Just as multiprocessing environments provide unique opportunities for worms and viruses to perform useful or malicious functions, multiprocessor environments have features that impact the effectiveness of worms and viruses. There are several important cases in the modern environment to consider because of their large numbers. They are (loosely):</p>
<ul>
<li><em>Tightly coupled systems</em> where processors effectively share all non-processing resources for improved performance.</li>
<li><em>Shared file sysfems</em> where multiple processors effectively share a file system either directly or through networking.</li>
<li><em>Remote procedure calls</em> where processes on remote processors can invoke local processes.</li>
<li><em>Remote logins</em> where remote users can run programs on local machines by logging in and invoking commands.</li>
<li><em>File transfer and forward systems</em> where remote users can send files to or through local machines.</li>
</ul>
<p>We don't yet know a great deal about protection from worms and viruses on these systems other than the general results previously published on viruses. There are, however, some interesting points to be made and some possible areas of research to be explored.</p>
<p>In tightly coupled systems, processors are essentially not distinguishable from a protection standpoint, and thus they can be treated as a single system. At the other extreme, in file transfer and forward systems, remote processors have limited functionality, and while they can be impacted by large numbers of network requests, livelock, and deadlock of the network, etc., with nominal protection in the form of setting low priorities for remote file transfers and limited function interfaces for incoming files, almost all impact from remote systems can be eliminated.</p>
<p>Systems allowing remote logins dominate in the timesharing arena, with almost every timesharing system now providing remote login over modems, and networked systems allowing remote login through explicit "remote shell" and "remote login" network calls. In much of the modern computing environment, remote login is permitted to known users without additional authentication, and in cases where this is not typical it is common to provide login scripts for accessing remote systems using known user identities and passwords. The increased standardization of this process makes the extension of rights from machine to machine very simple.</p>
<p>For example, it is simple to write a worm program that attempts remote logins to hosts which are allowed to login to the current host (since reciprocity is the norm in the modem computing environment). Assuming this has some success, the worm can replicate into the new system and operate from there, attempting to extend privileges to a new machine. By combining this mechanism with known attacks, the worm may attempt to attain increased privilege. Once increased privilege is attained, the worm has more candidates available
 
for remote access and thus mechanism to extend privilege still further. A simple that guesses passwords on remote machines once access is attained works quite well because, typically, password protection is relatively minimal and a list of user identities and limited information on the users is commonly available. A lack of audit trails against this sort of attack also helps keep the attack simple and effective.</p>
<p>The mechanism of remote procedure calls is often used to implement multiprocessor operations in networks where special services exist in special machines. For example, a local mail server may store all of incoming mail and keep desired mailing lists available so that the information doesn't have to be duplicated throughout the network, and it is common to provide remote printer access so that expensive that don't have to be duplicated can be shared. The key here is that the remote operation is made very automatic and transparent so that user convenience is maximized. This in turn provides capabilities on remote processors for local processing power, file storage, and other system resources. To the extent that the implementation is less than ideal, this grants possibilities for worm and viral exploitation.</p>
<p>A shared file system provides a means by which a user can make a worm available to a multitude of users with great transparency. For example, by planting a worm in a program called "ls"<sup><a href="#f6" name="b6">6</a></sup> and offering users access to another program in the same directory, many users may be fooled into changing to that directory and running "ls". When they do that, and assuming their search path<sup><a href="#f7" name="b7">7</a></sup> is set up as most Unix users' search are set up, the local "ls" will be run, which will invoke the worm. If the designer a bit clever, the "ls" worm will first delete or rename itself, then perform the system's "ls" command, and then replace itself, thus keeping its presence hidden to the casual observer.</p>
<p>The effect of the shared file system is to make this sort of access far more likely and casual. In most shared file system environments, this mechanism can be used to effectively impact all of the machines in the environment. A shared file system, even if most of it is read-only to any given user, provides a very high bandwidth and easy-to-exploit environment for worms and viruses. It facilitates the execution of programs by remote processors under conditions that grant the program access to the remote user's privileges instantly and with no additional authentication required. Even a pure worm can spread throughout such a system with relative ease, and a virus that "infects" files should typically be able to take over the entire network of shared file system machines in very short order. Based on the timesharing experiments with viruses [1], it would not be surprising to see the vast majority of the network fall to attack in under an hour.</p>
<p>The current trend in distributed computing environments is toward the shared file system situation, and without some substantial effort to provide protection in this environment this is a disaster waiting to happen. The current protection techniques, which effectively allow a systems administrator to prevent read or write access to a file system or on a directory or file basis restrict access to particular areas of a file system, are completely inadequate for protection against viruses and worms. In the current environment, each site protects itself only against intrusion caused by outside agents, whereas in the case of worms and viruses the intrusion comes from inside agents (i.e., the users on the impacted system running external programs).</p>
<h2>6. Some More Specific Examples</h2>
<p>Remote process invocation makes the problem of malicious worm control in a multiprocessor environment far more difficult. As examples, the Unix&trade; remote procedure call facility, the Novelle
 
NetWare&trade; add-on packages that allow remote command execution on workstations, and the DecNet&trade; remote command interface, each provide rich environments for uncontrolled worm spread.</p>
<p>Even though these systems may limit the authorized remote users who may invoke these facilities, this is ineffective against worms because they spread transitively. Thus, unless the transitive closure of machines with users authorized for remote process invocation is a closed subset of the systems or none of the users ever runs a worm, all of the members of the environment are susceptible. Here we see that in the case of worms in a remote process invocation environment, just as in the case of viruses in general, transitive spread results in a partially ordered set of infectable users from any given source, and just as in the case of viruses, nearly all of the networked computers in the world today are susceptible.</p>
<p>Even very simple worms in the environment today wreak widespread havoc, and just as viruses may evolve in a very general fashion thus making eradication very difficult, worms may evolve with the same generality. In the case of worms, the problem is particularly unnerving because of the requirement for concerted action throughout a distributed network.</p>
<p>For example, the Internet worm [6], which did not evolve, required concerted action, but this action was made easy because the attack depended on a "bug" which was easily repaired, and because all of the replicas were essentially identical. If this worm had evolved during replication in a substantial manner, and had not depended on a "bug", but rather on the legitimate rcmotc procedure call capability of Unix&trade;, the eradication problem would have been far more severe. The worm experiments that went awry at Xerox [5] required a concerted network-wide reboot and the Unix&trade; worm described earlier required a system reboot.</p>
<p>Returning again to Lemma B.1, even in the casts of these relatively severe network worms no extension of privileges was achieved. In other words, the systems extended the privileges exploited by these worms to their originator, either by design or implementation error. The worms did not gain privileges by being run unknowingly by users with special rights, they were granted system rights by exploiting flaws in the systems they attacked.</p>
<h2>7. Summary and Further Work</h2>
<p>We have provided a mathematical definition of "computer worms" that we feel reflects the current usage and reconciles many of the inconsistencies in recent literature. We have listed several important properties of worms and systems containing worms, and derived several new results that are specific to specific sorts of worms. We have shown several methods by which self-controlled worms and viruses can coexist with other programs in multiprocessin and multiprocessor environments, and that wea L esses exist in current multiprocessing environments which facilitate uncontrolled worm spread.</p>
<p>In future papers, we hope to present theoretically sound defenses for specific subclasses of worms and criteria for the safe coexistence of some viruses and non-viral programs. A number of other subclasses of viruses also appear to be of interest, and we believe that theoretical results may guide us toward improved defenses against many subclasses of viruses currently exploited by attackers.</p>
<p>We encourage other researchers to examine and challenge our definition with mathematical alternatives. As we stated earlier, the lack of a mathematical definition has caused numerous problems in this area, and we hope that this presentation of one will lead to substantial progress.</p>
<h2>References</h2>
<ol>
<li>F. Cohen, <a href="/lib/afc01.html">Computer viruses: theory and experiments</a>, <em>DOD/NBS 7th Conference on Computer Securiry</em>, originally appearing in IFIP-sec 84 (1984), also appearing as invited paper in IFIP-TC11, <em>Comput Secur.</em>, 6 (January 1987). 22-35, and other publications in several languages.</li>
 
<li>F. Cohen, <em>Computer Viruses</em>, ASP Press, Pittsburgh, 1985, subsequently approved as a dissertation at the University of Southern California, 1986.</li>
<li>A. Turing, On computable numbers, with an application to the Entscheidungsproblem, <em>London Math. Soc. Ser. 2</em>, 1936.</li>
<li>L. Adleman, <a href="/lib/ala01.html">An abstract theory of computer viruses</a>, <em>Crypro-89</em>.</li>
<li>J. Shoch and J. Hupp, <a href="/lib/ajm01.html">The "worm" programs: early experience with a distributed computation</a>. <em>CACM</em> (March 1982). 172-180.</li>
<li>C. Langton (ed.), <em>Artificial Life</em>, Addison-Wesley, Reading, MA, 1989.</li>
<li>J. Rochlis and M. Eichin, With microscope and tweezers: the worm from MIT's perspective, <em>CACM</em>, 32 (June 1989).</li>
<li>M. Harrison, W. Ruzzo and J. Ullman, Protection in operating sysrems, <em>CACM</em>, 19 (August 1976), 461-471.</li>
<li>F. Cohen, <a href="/lib/afc15.html">A cost analysis of typical computer viruses and defenses</a>, IFIP-TC11, <em>Comput. Secur.</em>, 10 (1991) 239.</li>
<li>F. Cohen, Protection and administration of information networks under partial orderings, IFIP-TC11, <em>Comput. Secur.</em>, 6 (1987), 118-128.</li>
</ol>
<p><strong>Fred Cohen</strong> received a B.S. in Electrical Engineering from Carnegie-Mellon University in 1977, an M.S. in Information Science from the University of Pittsburgh in 1981, and a Ph.D. in Electrical Engineering from the University of Southern California in 1986. He was a professor of Computer Science and Electrical Engineering at Lehigh University from January 1985 through April 1987, and a professor of Electrical and Computer Engineering at The University of Cincinnati from September of 1987 through Dccembcr of 1988. He is currently the President of ASP in Pittsburgh, PA, U.S.A.</p>
<p>Dr. Cohen has published over 20 refereed papers and over 20 other professional articles, has written several graduate level texts, and has designed and implemented numerous devices and systems for information protection. He is most well known for his ground-breaking work in compurcr viruses. where he did the first in-depth mathematical analysis, performed many startling experiments which have since been widely confirmed. and developed the first protection mechanisms, many of which are now in widespread use. His current rcscarch interests are concentrated in high integrity systems.</p>
 
<hr/>
<p><a name="f1" href="#b1">1</a> This idea was first brought to my attention in a paper published in <em>Computers and Security</em> in which Thomas A. Longstaff and E. Eugene Schultz describe several "worms".</p>
<p><a name="f2" href="#b2">2</a> "For convenience, we drop the M subscript when we are dealing with a single machine except at the first definition of each term.</p>
<p><a name="f3" href="#b3">3</a> Some of these require a trivial modification to the sample M so that instead of halting after replicarion, M moves the tape head to rhe start of the replica and changes to state <img src="/img/cache/db44989cb3b83bb387aedb1f12738a00.gif" alt="S_0" valign="middle"/>.</p>
<p><a name="f4" href="#b4">4</a> We use letters for theorems and lemmas herein to avoid conflicts with the theorem numbering from cited works.</p>
<p><a name="f5" href="#b5">5</a> Page 35 [2].</p>
<p><a name="f6" href="#b6">6</a> "ls" is the name of the Unix directory program used by most users to see what files are in a directory. "ls" is also the most frequently run program under Unix according to statistics taken in the first virus experiments in 1984.</p>
<p><a name="f7" href="#b7">7</a> The scqucncc of places the command interpreter looks to find a program.</p>
[<a style="" href="/lib/?lang=EN&amp;index=TH#afc11">Back to index</a>] [<a href="/lib/afc11.html#disqus_thread">Comments</a>]<br/> <div id="disqus_thread"></div>
<script type="text/rocketscript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'vxheaven'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="/agreement.php">Terms of Use</a>!</small> <small>vxheaven.org aka vx.netlux.org</small></div>
<div style="margin-top: 2px; float: left;" class="adsapeu">
<script type="text/rocketscript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script>
</div>
<script data-rocketsrc="http://www.google-analytics.com/urchin.js" type="text/rocketscript"></script><script type="text/rocketscript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="/lib/index.php?lang=de&amp;id=afc11">de</a><a href="/lib/index.php?lang=en&amp;id=afc11">en</a><a href="/lib/index.php?lang=es&amp;id=afc11">es</a><a href="/lib/index.php?lang=it&amp;id=afc11">it</a><a href="/lib/index.php?lang=fr&amp;id=afc11">fr</a><a href="/lib/index.php?lang=pl&amp;id=afc11">pl</a><a href="/lib/index.php?lang=ru&amp;id=afc11">ru</a><a href="/lib/index.php?lang=ua&amp;id=afc11">ua</a></div>
</body>
</html>
