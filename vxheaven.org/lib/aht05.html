<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Peter Ladkin, Harold Thimbleby 'Comments on a paper by Voas, Payne & Cohen: “A model for detecting the existence of software corruption in real time”' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Author" content="Peter Ladkin, Harold Thimbleby"/>
<meta name="KeyWords" lang="en" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, Ladkin, Peter; Thimbleby, Harold,Comments on a paper by Voas, Payne &amp; Cohen: “A model for detecting the existence of software corruption in real time”, problem, state, states, real, corruption, system, large, discrepancy, ﬁnite, processes, store, consensus, size, suggest, software"/>
<meta name="Description" content="We discuss a procedure proposed by Voas, Payne &amp;amp; Cohen [6] for detecting the existence of software corruption in real time. In particular, we discuss problems posed by the concurrent execution of programs. In the cases where the proposed method may work, corruption is unlikely to be a problem; and where corruption by viruses and Trojans are a problem, major problems with the method remain."/>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"047a5bcbf67431883fc9ed25fba33612",petok:"bf51a6872332cc787265116f1a9374cd0adb5fc9-1498755779-1800",zone:"vxheaven.org",rocket:"a",apps:{}}];document.write('<script type="text/javascript" src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=85b614c0f6/cloudflare.min.js"><'+'\/script>');}}catch(e){};
//]]>
</script>
<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="/style.css"/><link rel="canonical" href="http://vxheaven.org/lib/aht05.html"/>
<script type="text/rocketscript" data-rocketsrc="https://apis.google.com/js/plusone.js">{"parsetags": "explicit"}</script>
</head>
<body bgcolor="#dbc8a0" text="#302000" link="#225599" vlink="#113366">
<div class="s1">
<div style="float:right;"><a href="/lib/index.php?tbs=1"><img src="/img/max.gif" alt="Maximize"/></a></div> <form id="lf" style="margin: 0; float: right;" method="get" action="/index.php"><input type="hidden" name="action" value="set"/><select name="lang" onchange="javascript:document.getElementById('lf').submit();"><option value="ru">Русский</option><option selected="selected" value="en">English</option><option value="ua">Українська</option><option value="de">Deutsch</option><option value="es">Español</option><option value="fr">Fran&ccedil;ais</option><option value="it">Italiano</option><option value="pl">Polski</option></select></form>
<div style="float: right;"><div id="plusone"></div></div>
<script type="text/rocketscript">gapi.plusone.render("plusone", {"size":"small","count":"true"});</script>
<div style="float: right;" class="addthis_toolbox addthis_default_style">
<script type="text/rocketscript">var addthis_config = { ui_click: true }</script>
<a style="text-decoration: none; font-size: 10pt;" href="/?action=addthis" class="addthis_button_compact">Bookmark</a>
<script type="text/rocketscript" data-rocketsrc="http://s7.addthis.com/js/250/addthis_widget.js#username=herm1t"></script>
</div>
<div style="float: right;">
<script type="text/rocketscript" data-rocketsrc="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<form action="/search.php" id="cse-search-box">
<input type="hidden" name="cx" value="002577580816726040001:z9_irkorydo"/>
<input type="hidden" name="cof" value="FORID:10"/>
<input type="hidden" name="ie" value="UTF-8"/>
<input type="text" name="q" size="12" value=" "/>
<input type="submit" name="sa" value="Search"/>
</form>
</div><h1><a href="/" style="text-decoration: none; color: #000000;">VX Heaven</a></h1>
<span class="nav"><a href="/lib/">Library</a> <a href="/vl.php">Collection</a> <a href="/src.php">Sources</a> <a href="/vx.php?id=eidx">Engines</a> <a href="/vx.php?id=tidx">Constructors</a> <a href="/vx.php?id=sidx">Simulators</a> <a href="/vx.php?id=uidx">Utilities</a> <a href="/links.php">Links</a> <a href="/donate.php" style="color: #706020" id="donate">Donate</a> <a href="/forum" style="text-decoration: underline;">Forum</a> </span><br clear="all"/>
</div>
<div class="s2"><h1>Comments on a paper by Voas, Payne & Cohen: “A model for detecting the existence of software corruption in real time”</h1><p><a href="/lib/?lang=en&amp;author=Ladkin%2C%20Peter">Peter Ladkin</a>, <a href="/lib/?lang=en&amp;author=Thimbleby%2C%20Harold">Harold Thimbleby</a><br/> <em>Computers & Security, 13(6), pp527–531, 1994.</em><br/> <em>ISSN 0167-4048</em><br/> <em> 1994</em></p><script type="text/rocketscript">var disqus_url = 'http://vxheaven.org/lib/aht05.html';</script><div class="ci"><a href="/lib/?ci=aht05">1</a></div><img src="/img/pdf.gif" alt="PDF"/><a href="/lib/pdf/Comments%20on%20a%20paper%20by%20Voas%2C%20Payne%20%26%20Cohen%3A%20%E2%80%9CA%20model%20for%20detecting%20the%20existence%20of%20software%20corruption%20in%20real%20time%E2%80%9D.pdf">Download</a> PDF (217.51Kb) (You need to be registered on <a href="/forum">forum</a>)<br/>[<a style="" href="/lib/?lang=EN&amp;index=AV#aht05">Back to index</a>] [<a href="/lib/aht05.html#disqus_thread">Comments</a>]<br/> <form method="post" action="">
<img src="/img/cache/0b9fd596a90421f9f1f68a9760275737.gif" alt="\text{T_EX size}" valign="middle"/>
<select name="TeX_size"><option value="-2">-2</option><option value="-1">-1</option><option value="0" selected="selected">0</option><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option> </select>
<input type="submit" value="Scale"/>
</form>
<address>
<p>Peter Ladkin<br/>
Department of Computing Science, University of Stirling,<br/>
STIRLING, FK9 4LA, Scotland: <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="cfbfada38faca0a2bfbcaca6e1bcbba6bda3a6a1a8e1aeace1baa4">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script></p>
<p>Harold Thimbleby<br/>
Department of Psychology, University of Stirling:<br/>
<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="f29a8586b2919d9f8281919bdc81869b809e9b9c95dc9391dc8799dc">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script></p>
</address>
<h2>Abstract</h2>
<p>We discuss a procedure proposed by Voas, Payne &amp; Cohen [6] for detecting the existence of software corruption in real time. In particular, we discuss problems posed by the concurrent execution of programs. In the cases where the proposed method may work, corruption is unlikely to be a problem; and where corruption by viruses and Trojans are a problem, major problems with the method remain.</p>
<p><strong>Keywords:</strong> integrity protection, concurrency, consensus problem</p>
<p>In their recent paper “A model for detecting the existence of software corruption in real time” Voas <em>et al</em>. (writing in this journal) suggest a method of providing an alarm to warn against software corruption in real-time [6]. Their motivation is to detect Trojan Horses and/or computer virus infection. Their method rests on the claim that real programs have, in fact, a ﬁnite number of possible states, and therefore in principle are equivalent to a ﬁnite-state machine (FSM). They suggest building an equivalent FSM, and running it in parallel with the original program on the same input. If there is a discrepancy between the program and the FSM simulator, they suggest that one may conclude that there is software corruption. They suggest that the FSM and the original program can be comparable in terms of speed. Voas <em>et al</em>. invited further commentary on their proposal: “This research is still in a very early stage [. . . ] A great deal of further work will be required to determine the feasibility of this line of defense in practical environments.” This note accepts their invitation.</p>
<p>A practical point about viruses is as follows. To survive, a computer virus (or a biological virus) must have a large enough pool of susceptible hosts. In the case of computer viruses, this certainly happens given the size of (for example) the DOS population. But DOS and other common operating systems are unsuitable for Voas <em>et al.</em>’s proposed approach, as we argue below. If, however, the authors propose modifying the operating system to be amenable to their approach, then viruses and other forms of attack would be less likely, purely on epidemiological grounds. Of course, this is a desirable consequence of their approach, or any other approach that runs on a sparsely-distributed operating system. Such an approach, using a far simpler counter-viral strategy, has been investigated in [5].</p>
<p>While Voas <em>et al.</em> achieved one of their goals — to make their readers think about a potential solution to corruption problems — there remain a number of major issues to be addressed before their method can be considered for practical use.</p>
<p>The authors use an argument with roughly the following form:</p>
<p><strong>Premiss 1:</strong> Programs are functions from their inputs to their outputs;</p>
<p><strong>Premiss 2:</strong> Real programs are ﬁnite-state; therefore</p>
<p><strong>Conclusion 1:</strong> The I/O behavior of the program is what is important about the program; and therefore</p>
<p><strong>Conclusion 2:</strong> The program is equivalent to a ﬁnite-state machine.</p>
<p>They suggest that one may build such a ﬁnite state machine explicitly in software, and run it in parallel, with an alarm sounding when there is a discrepancy on outputs for a given input.</p>
<h2>(1)</h2>
<p>Many programs nowadays, including those running in operating systems as simple as DOS, are <em>reactive</em>. Reactive programs are those that run continuously, accepting input and transforming it, maybe passing it on to other programs. The behavior of many reactive programs are described, not by ﬁnite-state machines, but by ﬁnite-state transducers, ﬁnite-state I/O automata, B¨uchi automata, or by a number of other abstract machines, whose behavior may not simply be described as a set of input-output pairs.</p>
<p>Furthermore, reactive programs, especially those in an operating system, are usually multiprogrammed, if not actually concurrently running. We are unaware of any successful approach to the description of such systems of programs that describes their behavior simply as a set of input/output values for each program. Reactive programs often communicate information or signals to each other (as in an operating system such as Unix) through a channel or through shared memory. In these cases, where communication is <em>asynchronous</em> (the reading process may read at a later time than when the writing process produces the information), even a system of two communicating ﬁnite-state transducers may have inﬁnitely many states. So, although each individual component has ﬁnitely many states, their interaction does not. Furthermore, if the data passed between these two ﬁnite-state devices may be structured, it is common knowledge that the two devices along with their channel acquire Turing-complete computational power [2].</p>
<p>So, one may doubt whether the assumption of ﬁnitely many states is valid, and this must itself be clearly distinguished from the assumption that every program may be simulated by a ﬁnite-state device.</p>
<h2>(2)</h2>
<p>But, the authors may wish to argue, it is unrealistic to assume a channel of inﬁnite capacity. If a system of processes uses a ﬁnite amount of memory, then one can include each process, the states of the channel, the message store, and still have only ﬁnitely many states, therefore in principle the system still forms a ﬁnite state device.</p>
<p>However, this approach is not without diﬃculties. Cooperating programs may misbehave in certain unstructured ways, in ways that do not ﬁt this model of encapsulated processes communicating via encapsulated memory or channels.</p>
<p>Consider a pair of privileged programs, as may be found in an operating system kernel. They could overwrite a (bounded) message store in the course of their normal operation, <em>while nevertheless remaining uncorrupted</em>. They may be badly programmed, yes — but not necessarily corrupt. If we follow the authors’ suggestion, then in order to tell what is happening with the programs we must ascertain that this bad behavior happens <em>in exactly the same way</em>. Consider a pair of communicating programs overwriting a buﬀer, which corrupts some partition used by a completely diﬀerent program. We must now ascertain that the FSM simulation of the pair corrupts the partition in that same way, and with the same unreadable data. So, to use the authors’ method for a pair of communicating reactive programs <img src="/img/cache/20868fa29dfc38ac154b8ef762766b41.gif" alt="P_1" valign="middle"/> and <img src="/img/cache/2d70da379b3ffb56bd104b348ba21c55.gif" alt="P_2" valign="middle"/>, one must be prepared to examine the behavior of other, logically completely unrelated, programs for evidence not just of corruption, but of corruption identical in every respect. (One then has to decide whether the corruption observed in these other programs is corruption due to a virus, or due rather to the improper but uncorrupted behavior of <img src="/img/cache/20868fa29dfc38ac154b8ef762766b41.gif" alt="P_1" valign="middle"/> and <img src="/img/cache/2d70da379b3ffb56bd104b348ba21c55.gif" alt="P_2" valign="middle"/>.) If one focusses on building the FSM for <img src="/img/cache/20868fa29dfc38ac154b8ef762766b41.gif" alt="P_1" valign="middle"/> and <img src="/img/cache/2d70da379b3ffb56bd104b348ba21c55.gif" alt="P_2" valign="middle"/> alone, including the bounded message store, one fails to capture the behavior that inﬂuences the execution of other processes. So the suggestion to build a simulating FSM fails, unless one builds an FSM for the system as a whole, single entity, with a precise description of the memory partitioning. This would seem not to be practical (even for non-standard operating systems).</p>
<p>The ﬁnite-state assumption requires more careful justiﬁcation than the authors have given it to assure the successful application of their method to even simple reactive programs.</p>
<h2>(3)</h2>
<p>The authors do not give suﬃcient explanation on how one may discover which FSM a program might be input-output equivalent to (if it is). The authors suggest that factoring the states into control states and data states may reduce the complexity of description of the FSM, which is indeed true <em>when one has the FSM already</em>. However, it may be that to discover the FSM in the ﬁrst place may take time proportional to <em>the total number of states</em> of that FSM. Unfortunately the total number of states of an FSM may be a huge function of the initial program size. It is currently feasible to generate and check roughly <img src="/img/cache/5ec50b955ecad90dea17349b07b7602f.gif" alt="10^14" valign="middle"/> states [3] (when one chooses to simulate communicating state machines by a single global-state FSM) but such a state space can easily be created by trivial programs with fewer than 42 branch points in total. To help cope with the state explosion, there are various techniques, such as the ‘supertrace’ method, for trading-oﬀ the size of the state space against the accuracy of the enumeration of states [4].</p>
<p>Since the interaction of two communicating FSMs with data is Turing-complete, Voas <em>et al.</em> may want to suggest that this FSM-discovery process must be factored into discovering the control-state FSM and separately a data-state simulator, whence the discovery process would be tractable in the size of the control-state FSM, at least. If so, there needs to be a construction that demonstrates this feature.</p>
<h2>(4)</h2>
<p>Voas <em>et al.</em> seem to claim that two replicated versions of a program are suﬃcient to detect corruption. Given how hard it is to design and build correct software, and the vast number of states of the replicating FSM, one immediately asks how the authors propose to ensure that any discrepancy is caused by corruption — rather than by the faulty design and construction of the FSM? They are also concerned with speed problems and suggest some complex optimisations, which in themselves increase the diﬃculty of constructing a correct FSM. How do they suggest we may we move from the observation of a discrepancy to the conclusion that corruption is the cause of it, rather than that our programming of the FSM is at fault? Of course, discovering a discrepancy may be a useful indication of poor software quality, but this decision issue must be settled before concluding that the method suﬃces for its stated purpose.</p>
<h2>(5)</h2>
<p>In the case of computer virus infection, the authors’ method cannot determine with certainty that both programs have not been corrupted. Suppose both programs are corrupted, and yield identical but incorrect output behavior. The authors’ method would not detect this corruption. In certain environments, with certain implementations of the method, this situation may be less likely than the case where one program and not the other is corrupted. Equally, in other environments with diﬀerent implementations of the method, it may be more likely. Since the method is not complete (i.e., there are corruptions it cannot detect), what then exactly is the scope of the authors’ method?</p>
<h2>(6)</h2>
<p>One reason why viruses and Trojan Horses are a practical problem is that users do not know in advance what programs they wish to run. If the collection of programs they wish to run was a ﬁxed and known set, as for example in embedded systems, then these programs and all software related to them could be consigned to hardware, and they would no longer be susceptible to the sort of interference that concern the authors. Indeed, this technique is used in many embedded systems, such as ﬂight control computers. If, on the other hand, users wish to run programs taken from a large (and generally non-local) repertoire of software, then in order to use the authors’ method, either a general procedure is needed for translating (reactive and interacting) programs written in some Turing-complete language (such as C or Pascal) into FSMs, or each program must be translated on an <em>ad hoc</em> basis. Given that it is regarded in the industry as currently infeasible to determine the exact I/O relations of related programs in a large set, one wonders how the authors may conclude that this is practical in their case?</p>
<h2>(7)</h2>
<p>Finally, there is a large literature on the basic problem that the authors will need to solve to have a workable method, namely the Consensus Problem, otherwise know as the Byzantine Generals Problem (see [1] for a survey).</p>
<p>The Consensus Problem may be brieﬂy stated as follows. Suppose one has a number of concurrently running processes that compare their output for identity. If there are discrepancies: how do you tell which is at fault; whether the fault is in the process output or the discrepancy-testing-and-reporting algorithm; whether the discrepancy-reporting algorithm itself is accurate, and reports no discrepancy when there is one, or reports one when there is none? Algorithms that solve these problems are presently cumbersome and impractical: this complexity is inherent in many cases in the problem itself.</p>
<p>Voas <em>et al.</em> assume the identity test between two programs is a trusted piece of software: it certainly cannot be when it is implemented in a system some components of which may themselves be suspect (consider the earlier example of two badly-programmed but uncorrupted processes trashing the store — the store they trash might be associated with the discrepancy-reporting algorithm). Besides, <em>two</em> voting processes, as in the authors’ method, is not a number that permits any solution to a non-trivial Byzantine agreement problem, therefore the authors cannot hope to elaborate their method to solve the correctness problems that we have raised. One needs more processes.</p>
<h2>References</h2>
<ol>
<li>M. Barborak, M. Malek &amp; A. Dahbura, “The Consensus Problem in Fault-Tolerant Computing,” <em>ACM Computing Surveys</em>, 25(2), pp. 171–220, 1993.</li>
<li>D. Brand &amp; P. Zaﬁropulo, “On Communicating Finite-State Machines,” <em>Journal of the ACM</em>, 30(2), pp. 323–342, 1983.</li>
<li>D. Cohen &amp; N. Dorn, “An Experiment in Analysing Switch Recovery Procedures,” in <em>Formal Description Techniques</em>, V, ed. M. Diaz &amp; R. Groz, North-Holland, pp. 23–34, 1993.</li>
<li>G. J. Holzmann, <em>The Design and Validation of Computer Protocols</em>, Prentice-Hall International, 1991.</li>
<li>H. W. Thimbleby, <a href="/lib/aht03.html">“An Organisational Solution to Computer Viruses,”</a> <em>Journal of Systems and Software</em>, in press, 1994.</li>
<li>J. M. Voas, J. E. Payne &amp; F. B. Cohen, “A model for detecting the existence of software corruption in real time,” <em>Computers &amp; Security</em>, 12(3), pp. 275–283, 1993.</li>
</ol>
[<a style="" href="/lib/?lang=EN&amp;index=AV#aht05">Back to index</a>] [<a href="/lib/aht05.html#disqus_thread">Comments</a>]<br/> <div id="disqus_thread"></div>
<script type="text/rocketscript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'vxheaven'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="/agreement.php">Terms of Use</a>!</small> <small>vxheaven.org aka vx.netlux.org</small></div>
<div style="margin-top: 2px; float: left;" class="adsapeu">
<script type="text/rocketscript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script>
</div>
<script data-rocketsrc="http://www.google-analytics.com/urchin.js" type="text/rocketscript"></script><script type="text/rocketscript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="/lib/index.php?lang=de&amp;id=aht05">de</a><a href="/lib/index.php?lang=en&amp;id=aht05">en</a><a href="/lib/index.php?lang=es&amp;id=aht05">es</a><a href="/lib/index.php?lang=it&amp;id=aht05">it</a><a href="/lib/index.php?lang=fr&amp;id=aht05">fr</a><a href="/lib/index.php?lang=pl&amp;id=aht05">pl</a><a href="/lib/index.php?lang=ru&amp;id=aht05">ru</a><a href="/lib/index.php?lang=ua&amp;id=aht05">ua</a></div>
</body>
</html>
