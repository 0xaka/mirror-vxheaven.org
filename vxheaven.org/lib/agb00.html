<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Guillaume Bonfante, Matthieu Kaczmarek, Jean-Yves Marion 'Toward an abstract computer virology' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Author" content="Guillaume Bonfante, Matthieu Kaczmarek, Jean-Yves Marion"/>
<meta name="KeyWords" lang="en" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, Bonfante, Guillaume; Kaczmarek, Matthieu; Marion, Jean-Yves,Toward an abstract computer virology, mathbf, fname, varphi, calb, virus, computer, complexity, function, polymorphic, hspace, programming, echo, adleman, computable, theory"/>
<meta name="Description" content="We are concerned with theoretical aspects of computer viruses. For this, we suggest a new definition of viruses which is clearly based on the iteration theorem and above all on Kleene's recursion theorem. We show that we capture in a natural way previous definitions, and in particular the one of Adleman. We establish generic constructions in order to construct viruses, and we illustrate them by various examples. We discuss about the relationship between information theory and virus and we propose a defense against some kind of viral propagation. Lastly, we show that virus detection is &amp;prod;02-complete. However, since we are able to deal with system vulnerability, we exhibit another defense based on controlling system access."/>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"047a5bcbf67431883fc9ed25fba33612",petok:"d8421db00d1cc948fce078ef52811ef5c002e64f-1498757313-1800",zone:"vxheaven.org",rocket:"a",apps:{}}];document.write('<script type="text/javascript" src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=85b614c0f6/cloudflare.min.js"><'+'\/script>');}}catch(e){};
//]]>
</script>
<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="/style.css"/><link rel="canonical" href="http://vxheaven.org/lib/agb00.html"/>
<script type="text/rocketscript" data-rocketsrc="https://apis.google.com/js/plusone.js">{"parsetags": "explicit"}</script>
</head>
<body bgcolor="#dbc8a0" text="#302000" link="#225599" vlink="#113366">
<div class="s1">
<div style="float:right;"><a href="/lib/index.php?tbs=1"><img src="/img/max.gif" alt="Maximize"/></a></div> <form id="lf" style="margin: 0; float: right;" method="get" action="/index.php"><input type="hidden" name="action" value="set"/><select name="lang" onchange="javascript:document.getElementById('lf').submit();"><option value="ru">Русский</option><option selected="selected" value="en">English</option><option value="ua">Українська</option><option value="de">Deutsch</option><option value="es">Español</option><option value="fr">Fran&ccedil;ais</option><option value="it">Italiano</option><option value="pl">Polski</option></select></form>
<div style="float: right;"><div id="plusone"></div></div>
<script type="text/rocketscript">gapi.plusone.render("plusone", {"size":"small","count":"true"});</script>
<div style="float: right;" class="addthis_toolbox addthis_default_style">
<script type="text/rocketscript">var addthis_config = { ui_click: true }</script>
<a style="text-decoration: none; font-size: 10pt;" href="/?action=addthis" class="addthis_button_compact">Bookmark</a>
<script type="text/rocketscript" data-rocketsrc="http://s7.addthis.com/js/250/addthis_widget.js#username=herm1t"></script>
</div>
<div style="float: right;">
<script type="text/rocketscript" data-rocketsrc="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<form action="/search.php" id="cse-search-box">
<input type="hidden" name="cx" value="002577580816726040001:z9_irkorydo"/>
<input type="hidden" name="cof" value="FORID:10"/>
<input type="hidden" name="ie" value="UTF-8"/>
<input type="text" name="q" size="12" value=" "/>
<input type="submit" name="sa" value="Search"/>
</form>
</div><h1><a href="/" style="text-decoration: none; color: #000000;">VX Heaven</a></h1>
<span class="nav"><a href="/lib/">Library</a> <a href="/vl.php">Collection</a> <a href="/src.php">Sources</a> <a href="/vx.php?id=eidx">Engines</a> <a href="/vx.php?id=tidx">Constructors</a> <a href="/vx.php?id=sidx">Simulators</a> <a href="/vx.php?id=uidx">Utilities</a> <a href="/links.php">Links</a> <a href="/donate.php" style="color: #706020" id="donate">Donate</a> <a href="/forum" style="text-decoration: underline;">Forum</a> </span><br clear="all"/>
</div>
<div class="s2"><h1>Toward an abstract computer virology</h1><p><a href="/lib/?lang=en&amp;author=Bonfante%2C%20Guillaume">Guillaume Bonfante</a>, <a href="/lib/?lang=en&amp;author=Kaczmarek%2C%20Matthieu">Matthieu Kaczmarek</a>, <a href="/lib/?lang=en&amp;author=Marion%2C%20Jean-Yves">Jean-Yves Marion</a><br/> <em>Lecture Notes in Computer Science, volume 3722, pp.579-593. Springer, Oct 2005.</em><br/> <em>October 2005</em></p><script type="text/rocketscript">var disqus_url = 'http://vxheaven.org/lib/agb00.html';</script><div class="ci"><a href="/lib/?ci=agb00">1</a></div><img src="/img/pdf.gif" alt="PDF"/><a href="/lib/pdf/Toward%20an%20abstract%20computer%20virology.pdf">Download</a> PDF (188.83Kb) (You need to be registered on <a href="/forum">forum</a>)<br/>[<a style="" href="/lib/?lang=EN&amp;index=TH#agb00">Back to index</a>] [<a href="/lib/agb00.html#disqus_thread">Comments</a>]<br/> <form method="post" action="">
<img src="/img/cache/0b9fd596a90421f9f1f68a9760275737.gif" alt="\text{T_EX size}" valign="middle"/>
<select name="TeX_size"><option value="-2">-2</option><option value="-1">-1</option><option value="0" selected="selected">0</option><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option> </select>
<input type="submit" value="Scale"/>
</form>
<address>
Loria, Calligramme project,
B.P. 239, 54506 Vandoeuvre-l&egrave;s-Nancy C&eacute;dex, France, and<br/>
&Eacute;cole Nationale Sup&eacute;rieure des Mines de Nancy, INPL, France.
</address>
<h2>Abstract.</h2>
<p>We are concerned with theoretical aspects of computer viruses. For this, we suggest a new definition of viruses which is clearly based on the iteration theorem and above all on Kleene's recursion theorem. We show that we capture in a natural way previous definitions, and in particular the one of Adleman. We establish generic constructions in order to construct viruses, and we illustrate them by various examples. We discuss about the relationship between information theory and virus and we propose a defense against some kind of viral propagation. Lastly, we show that virus detection is <img src="/img/cache/2ca64bd745fa48c1755b5d6223770220.gif" alt="\prod{}^0_2" valign="middle"/>-complete. However, since we are able to deal with system vulnerability, we exhibit another defense based on controlling system access.</p>
<h2>1 Introduction</h2>
<p>Computer viruses seem to be an omnipresent issue of information technology; there is a lot of books, see [13] or [16], discussing practical issues. But, as far as we know, there are only a few theoretical studies. This situation is even more amazing because the word "computer virus" comes from the seminal theoretical works of Cohen [4 - 6] and Adleman [1] in the mid-1980's. We do think that theoretical point of view on computer viruses may bring some new insights to the area, as it is also advocated for example by Filiol [8], an expert on computer viruses and cryptology. Indeed, a deep comprehension of mechanisms of computer viruses is from our point of view a promising way to suggest new directions on virus detection and defence against attacks. On theoretical approach to virology, there is an interesting survey of Bishop [2] and we aware of the paper of Thimbleby, Anderson and Cairns [10] and of Chess and White paper [3].</p>
<p>This being said, the first question is what is a virus? In his Phd-thesis [4], Cohen defines viruses with respect to Turing Machines. Roughly speaking, a virus is a word on a Turing machine tape such that when it is activated, it duplicates or mutates on the tape. Adleman took a more abstract formulation of computer viruses based on recursive function in order to have a definition independent from computation models. A recent article of Zuo and Zhou [21] completes Aldemans work, in particular in formalizing polymorphic viruses. In both approaches, a virus is a self-replicating device. So, a virus has the capacity to act on a description of itself. That is why Kleene's recursion theorem is central in the description of the viral mechanism.</p>
<p>This paper is an attempt to use computability and information theory as a vantage point from which to understand viruses. We suggest a definition which embeds Adelman's as well as Zuo and Zhou's definitions in a natural way.</p>
<p>A virus is a program <img src="/img/cache/fb16e3e3f18c15edc61e1f2c0fa972ba.gif" alt="\mathbf{v}" valign="middle"/> which is solution of the fixed point equation</p>
<div class="N5"><img src="/img/cache/dff17f78350c640904695148d9307ba4.gif" alt="
	\varphi_v(\mathbf{p}, x) = \varphi_{\cal{B}(v,p)}(x)
	\hspace{150}(1)
" valign="middle"/></div>
<p>where <img src="/img/cache/70d9ff405d8f4c3001f214bf0eb4c43c.gif" alt="\calB" valign="middle"/> is a function which describes the propagation and mutation of the virus in the system. This approach has at least three advantages compared with others mentioned above. First, a virus is a program and not a function. Thus, we switch from a purely functional point of view to a more programming perspective one.</p>
<p>Second, we consider the propagation function, unlike others. So, we are able to have another look at virus replications. All the more so since <img src="/img/cache/70d9ff405d8f4c3001f214bf0eb4c43c.gif" alt="\calB" valign="middle"/> corresponds also to a system vulnerability. Lastly, since the definition is clearly based on recursion theorem, we are able to describe a lot of kind of virus smoothly. To illustrate our words, we establish a general construction of trigger virus in Section 3.3.</p>
<p>The results and the organization of the paper is the following. Section 2 presents the theoretical tools needed to define viruses. We will focus in particular in the s-m-n theorem and the recursion theorem. In section 3, we propose a virus definition and we pursue by a first approach to self-duplication. Section 4 is devoted to Adlemans virus definition. Then, we explore another duplication methods by mutations. We compare our work with Zuo and Zhou definition of polymorphic viruses. Lastly, Section 6 ends with a discussion on the relation with information theory. From that, we deduce an original defense against some particular kind of viruses, see 6.3. The last Section is about virus search complexity which turns out to <img src="/img/cache/2ca64bd745fa48c1755b5d6223770220.gif" alt="\prod{}^0_2" valign="middle"/>-complete. It is worth to mention that we conclude the paper on some research direction to study system flaws, see Theorem 14.</p>
<h2>2 Iteration and Recursion Theorems</h2>
<h3>2.1 Programming Languages</h3>
<p>We are not taking a particular programming language but we are rather considering an abstract, and so simplified, definition of a programming language. However, we shall illustrate all along the theoretical constructions by bash programs. The examples and analogies that we shall present are there to help the reader having a better understanding of the main ideas but also to show that the theoretical constructions are applicable to any programming language.</p>
<p>We briefly present the necessary definitions to study programming languages in an independent way from a particular computational model. We refer to the book of Davis [7], of Rogers [15] and of Odifreddi [14].</p>
<p>Throughout, we consider that we are given a set <img src="/img/cache/8f24373a2599e7588fa8fd398b592df9.gif" alt="\calD" valign="middle"/>, the domain of the computation. As it is convenient, we take <img src="/img/cache/8f24373a2599e7588fa8fd398b592df9.gif" alt="\calD" valign="middle"/> to be the set of words over some fixed alphabet. But we could also have taken natural numbers or any free algebra as domains. The size <img src="/img/cache/4042ebf545a82194deedbc4477fb9c87.gif" alt="|u|" valign="middle"/> of a word <img src="/img/cache/7b774effe4a349c6dd82ad4f4f21d34c.gif" alt="u" valign="middle"/> is the number of letters in <img src="/img/cache/7b774effe4a349c6dd82ad4f4f21d34c.gif" alt="u" valign="middle"/>.</p>
<p>A programming language is a mapping <img src="/img/cache/87567e37a1fe699fe1c5d3a79325da6f.gif" alt="\varphi" valign="middle"/> from <img src="/img/cache/6015c2312cd3feb33d993ecb741e150a.gif" alt="\calD \rightarrow (\calD \rightarrow \calD)" valign="middle"/> such that for each program <img src="/img/cache/725cf120c39561ea216d22ae0fce9b35.gif" alt="\mathbf{p}, \varphi(p) : \calD \rightarrow \calD" valign="middle"/> is the partial function computed by <img src="/img/cache/ba0d8bb3a7b9d14aa7496d59f463efb7.gif" alt="\mathbf{p}" valign="middle"/>. Following the convention used in calculability theory, we write <img src="/img/cache/e52d14c400f15c250b13b88fbb4ac0dd.gif" alt="\varphi_{\mathbf{p}}" valign="middle"/> instead of <img src="/img/cache/c6a63c8664d6b6deda57663653981742.gif" alt="\varphi(\mathbf{p})" valign="middle"/>. Notice that there is no distinction between programs and data.</p>
<p>We write <img src="/img/cache/0c5ac033023f12586ef43a2662a663ff.gif" alt="f \approx g" valign="middle"/> to say that for each <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/>, either <img src="/img/cache/50bbd36e1fd2333108437a2ca378be62.gif" alt="f(x)" valign="middle"/> and <img src="/img/cache/e84fec1e074026d6fa8e3155482c35c3.gif" alt="g(x)" valign="middle"/> are defined and <img src="/img/cache/137f9e1b88d1237068c00cd7d0355863.gif" alt="f(x) = g(x)" valign="middle"/> or both are undefined on <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/>.</p>
<p>A total function <img src="/img/cache/8fa14cdd754f91cc6554c9e71929cce7.gif" alt="f" valign="middle"/> is computable wrt <img src="/img/cache/87567e37a1fe699fe1c5d3a79325da6f.gif" alt="\varphi" valign="middle"/> if there is a program <img src="/img/cache/ba0d8bb3a7b9d14aa7496d59f463efb7.gif" alt="\mathbf{p}" valign="middle"/> such that <img src="/img/cache/e90c84c3dc66bdf34653f34d7bc095ae.gif" alt="f \approx \varphi_{\mathbf{p}}" valign="middle"/>. If <img src="/img/cache/8fa14cdd754f91cc6554c9e71929cce7.gif" alt="f" valign="middle"/> is a partial function, we shall say that <img src="/img/cache/8fa14cdd754f91cc6554c9e71929cce7.gif" alt="f" valign="middle"/> is semi-computable. Similarly, a set is computable (resp. semi-computable) if its characteristic function is computable (semi-computable).</p>
<p>We also assume that there is a pairing computable function (_,_) such that from two words <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/> and <img src="/img/cache/415290769594460e2e485922904f345d.gif" alt="y" valign="middle"/> of <img src="/img/cache/8f24373a2599e7588fa8fd398b592df9.gif" alt="\calD" valign="middle"/>, we form a pair <img src="/img/cache/1d4947570a86bbd609e9c17f5f01de28.gif" alt="(x, y) \in \calD" valign="middle"/>. A pair <img src="/img/cache/49b311da0ed4baee4da4dd66e37ef59c.gif" alt="(x, y)" valign="middle"/> can be decomposed uniquely into <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/> and <img src="/img/cache/415290769594460e2e485922904f345d.gif" alt="y" valign="middle"/> by two computable projection functions. Next, a finite sequence <img src="/img/cache/3cfe043b046cc1e2eac335fd04e0cf9a.gif" alt="(x_1, \dots , x_n)" valign="middle"/> of words is built by repeatedly applying the pairing function, that is <img src="/img/cache/db541e687e61e74d806a2d6aead37d68.gif" alt="(x_1, \dots , x_n) = (x_1, (x_2, (\dots, x_n)\dots))" valign="middle"/>.</p>
<p>So, we won't make any longer the distinction between a <em>n</em>-uple and its encoding. Every function is formally considered unary even if we have in mind a binary one. The context will always be clear.</p>
<p>It is worth to mention that the pairing function may be seen as an encryption function and the projections as decryption function.</p>
<p>Following Uspenski [19] and Rogers [15], a programming language <img src="/img/cache/87567e37a1fe699fe1c5d3a79325da6f.gif" alt="\varphi" valign="middle"/> is acceptable if</p>
<ol>
<li>For each semi-computable function <img src="/img/cache/8fa14cdd754f91cc6554c9e71929cce7.gif" alt="f" valign="middle"/>, there is a program <img src="/img/cache/a5f044366ff734ab7694ca0098e5b7a6.gif" alt="\mathbf{p} \in \calD" valign="middle"/> such that <img src="/img/cache/25205406898f0a10df32838e417cb0c4.gif" alt="\varphi_{\mathbf{p}} \approx f" valign="middle"/>.</li>
<li>There is an universal program <img src="/img/cache/7a52b64bc3b6fc5b02ec5112e4bd6b8a.gif" alt="\mathbf{u}" valign="middle"/> which satisfies that for each program <img src="/img/cache/20c5fbb02264844f0c8100930310a0d2.gif" alt="\mathbf{p} \in \calD, \varphi_{\mathbf{u}}(\mathbf{p}, x) \approx \varphi_{\mathbf{p}}(x)" valign="middle"/>.</li>
<li>There is a program <img src="/img/cache/4eca1f27137609136f5ea96540020356.gif" alt="\mathbf{s}" valign="middle"/> such that
<div class="N5"><img src="/img/cache/2429b102335ea20a60e04d21c4cd5709.gif" alt="
		\forall{\mathbf{p}, x, y} \in \calD \hspace{50} \varphi_{\mathbf{p}}(x, y) \approx \varphi_{\varphi_{\mathbf{s}}(\mathbf{p},x)}(y)
	" valign="middle"/></div></li>
</ol>
<p>Of course, the function <img src="/img/cache/bcfb0dcc187178ef877b723fa9d391ac.gif" alt="\varphi_{\mathbf{s}}" valign="middle"/> is the well-known s-m-n function written <img src="/img/cache/5dbc98dcc983a70728bd082d1a47546e.gif" alt="S" valign="middle"/>.</p>
<p>The existence of an acceptable programming language was demonstrated by Turing [18].</p>
<p>Kleene's Iteration Theorem yields a function <img src="/img/cache/5dbc98dcc983a70728bd082d1a47546e.gif" alt="S" valign="middle"/> which specializes an argument in a program. The self-application that is <img src="/img/cache/7c1adf41c27470769bf943ee593d192f.gif" alt="S(\mathbf{p, p})" valign="middle"/> corresponds to the construction of a program which can read its own code <img src="/img/cache/ba0d8bb3a7b9d14aa7496d59f463efb7.gif" alt="\mathbf{p}" valign="middle"/>. By analogy with bash programs, it means that the variable <code>$0</code> is assigned to the text, that is <img src="/img/cache/ba0d8bb3a7b9d14aa7496d59f463efb7.gif" alt="\mathbf{p}" valign="middle"/>, of the executed bash file.</p>
<p>We present now a version of the second recursion theorem which is due to Kleene. This theorem is one of the deepest result in theory of recursive function. It is the cornerstone of the paper that is why we write the proof. We could also have presented Rogers's recursion theorem but we have preferred to focus on only one recursion theorem in order not to introduce any extra difficulties. It is worth also to cite the paper [11] in which the s-m-n function and the recursion theorem are experimented;</p>
<p><strong>Theorem 1 (Kleene's second recursion Theorem).</strong> <em>If <img src="/img/cache/b2f5ff47436671b6e533d8dc3614845d.gif" alt="g" valign="middle"/> is a semicomputable function, then there is a program <img src="/img/cache/83a9c5737d7ce81e9ea5a58c9b993c56.gif" alt="\mathbf{e}" valign="middle"/> such that</em></p>
<div class="N5"><img src="/img/cache/2b2baa1244cf93e4403aea9ef69cea08.gif" alt="
	\varphi_e(x) = g(\mathbf{e}, x)\hspace{100}(2)
" valign="middle"/></div>
<p><em>Proof.</em> Let <img src="/img/cache/ba0d8bb3a7b9d14aa7496d59f463efb7.gif" alt="\mathbf{p}" valign="middle"/> be a program of the semi-computable function <img src="/img/cache/3266c32757602cc1d85639256c92af3a.gif" alt="g(S(y, y), x)" valign="middle"/>. We have</p>
<div class="N5"><img src="/img/cache/1732b727fec45df23044561fb1fe8679.gif" alt="
	\begin{eqnarray}
		g(S(y, y), x)	&amp;=&amp; \varphi_{\mathbf{p}}(y, x)	&amp;&amp;	\hspace{100}(3)\\
				&amp;=&amp; \varphi_{S(\mathbf{p},y)}(x)	&amp;&amp;	\hspace{100}(4)
	\end{eqnarray}
" valign="middle"/></div>
<p>By setting <img src="/img/cache/e9b7b783280531dc766267e5e7bc2f17.gif" alt="\mathbf{e} = S(\mathbf{p}, \mathbf{p})" valign="middle"/>, we have</p>
<div class="N5"><img src="/img/cache/f8935c7a0b25bcdb150bd3c03393f66c.gif" alt="
	\begin{eqnarray}
		g(e, x) &amp;=&amp; g(S(\mathbf{p}, \mathbf{p}), x)		&amp;&amp;	\hspace{100}(5)\\
			&amp;=&amp; \varphi_{S(\mathbf{p}, \mathbf{p})}(x)	&amp;&amp;	\hspace{100}(6)\\
			&amp;=&amp; \varphi_{\mathbf{e}}(x)		&amp;&amp;	\hspace{100}(7)
	\end{eqnarray}
" valign="middle"/></div>
<h2>3 The viral mechanism</h2>
<h3>3.1 A virus definition</h3>
<p>A virus may be thought of as a program which reproduces, and executes some actions. Hence, a virus is a program whose propagation mechanism is described by a computable function <img src="/img/cache/70d9ff405d8f4c3001f214bf0eb4c43c.gif" alt="\calB" valign="middle"/>. The propagation function <img src="/img/cache/70d9ff405d8f4c3001f214bf0eb4c43c.gif" alt="\calB" valign="middle"/> searches and selects a sequence of programs <img src="/img/cache/8f4ed5345df8f022614335e24d5fac2f.gif" alt="\mathbf{p} = (\mathbf{p}_1, \dots , \mathbf{p}_n)" valign="middle"/> among inputs <img src="/img/cache/a071b437bdf1a01bcbf241b32daa2e25.gif" alt="(\mathbf{p}, x)" valign="middle"/>. Then, <img src="/img/cache/70d9ff405d8f4c3001f214bf0eb4c43c.gif" alt="\calB" valign="middle"/> replicates the virus inside <img src="/img/cache/ba0d8bb3a7b9d14aa7496d59f463efb7.gif" alt="\mathbf{p}" valign="middle"/>. In other words, <img src="/img/cache/70d9ff405d8f4c3001f214bf0eb4c43c.gif" alt="\calB" valign="middle"/> is the vector which carries and transmits the virus to a program. On the other hand, the function <img src="/img/cache/70d9ff405d8f4c3001f214bf0eb4c43c.gif" alt="\calB" valign="middle"/> can be also seen as a flaw in the programming environment. Indeed, <img src="/img/cache/70d9ff405d8f4c3001f214bf0eb4c43c.gif" alt="\calB" valign="middle"/> is a functional property of the programming language <img src="/img/cache/87567e37a1fe699fe1c5d3a79325da6f.gif" alt="\varphi" valign="middle"/> which is used by a virus <img src="/img/cache/fb16e3e3f18c15edc61e1f2c0fa972ba.gif" alt="\mathbf{v}" valign="middle"/> to enter and propagate into the system. We suggest below an abstract formalization of viruses which reflects the picture that we have described above.</p>
<p><strong>Definition 2.</strong> <em>Assume that <img src="/img/cache/70d9ff405d8f4c3001f214bf0eb4c43c.gif" alt="\calB" valign="middle"/> is a semi-computable function. A virus wrt <img src="/img/cache/70d9ff405d8f4c3001f214bf0eb4c43c.gif" alt="\calB" valign="middle"/> is a program <img src="/img/cache/fb16e3e3f18c15edc61e1f2c0fa972ba.gif" alt="\mathbf{v}" valign="middle"/> such that for each <img src="/img/cache/ba0d8bb3a7b9d14aa7496d59f463efb7.gif" alt="\mathbf{p}" valign="middle"/> and <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/> in <img src="/img/cache/8f24373a2599e7588fa8fd398b592df9.gif" alt="\calD" valign="middle"/>,</em></p>
<div class="N5"><img src="/img/cache/dd6e1fdfffaa583009741e1eff9e508d.gif" alt="
	\varphi_{\mathbf{v}}(\mathbf{p}, x) = \varphi_{\calB(\mathbf{v},\mathbf{p})}(x)	\hspace{100}(8)
" valign="middle"/></div>
<p><em>The function <img src="/img/cache/70d9ff405d8f4c3001f214bf0eb4c43c.gif" alt="\calB" valign="middle"/> is called the propagation function of the virus <img src="/img/cache/fb16e3e3f18c15edc61e1f2c0fa972ba.gif" alt="\mathbf{v}" valign="middle"/>.</em></p>
<p>Throughout, we call <em>virus</em> a program, which satisfies the above definition.</p>
<p>As we have said above, we make no distinction between programs and data. However we write in bold face words of <img src="/img/cache/8f24373a2599e7588fa8fd398b592df9.gif" alt="\calD" valign="middle"/>, like <img src="/img/cache/fcf281ab33b3ce0613a7426248176928.gif" alt="\mathbf{p, v}" valign="middle"/>, which denote programs. On the other hand, the argument <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/> does not necessarily denote a data. Nevertheless, in both cases, <img src="/img/cache/ba0d8bb3a7b9d14aa7496d59f463efb7.gif" alt="\mathbf{p}" valign="middle"/> or <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/> refer either to a single word or a sequence of words. (For example <img src="/img/cache/7d7941a4f08b6f135441a41791cb63b4.gif" alt="x = (x_1,\dots, x_n)" valign="middle"/>.)</p>
<h3>3.2 Self-reproduction</h3>
<p>A distinctive feature of viruses is the self-reproduction property. This has been well developed for cellular automata from the work of von Neumann [20]. Hence, Cohen [4] demonstrated how a virus reproduces in the context of Turing machines.</p>
<p>We show next that a virus can copy itself in several ways. We present some typical examples which in particular illustrate the key role of the recursion Theorem.</p>
<p>We give a first definition of self-reproduction. (A second direction will be discussed in Section 5.) A duplication function <img src="/img/cache/120be0bc58aa2e541a3be4d16b19d828.gif" alt="Dup" valign="middle"/> is a total computable function such that <img src="/img/cache/336c16f6fb39c0066f646c8facf83f2f.gif" alt="Dup(\mathbf{v, p})" valign="middle"/> is a word which contains at least an occurrence of <img src="/img/cache/fb16e3e3f18c15edc61e1f2c0fa972ba.gif" alt="\mathbf{v}" valign="middle"/>. A duplicating virus is a virus, which satisfies <img src="/img/cache/5980b7e880203e4395d27bc22b71105c.gif" alt="\varphi_{\mathbf{v}}(\mathbf{p}, x) = Dup(\mathbf{v, p})" valign="middle"/>. The existence of duplicating viruses is a consequence of the following Theorem by setting <img src="/img/cache/272acd0a0083971ffe2228879b1b1d05.gif" alt="f = Dup" valign="middle"/>.</p>
<p><strong>Theorem 3.</strong> <em>Given a semi-computable function <img src="/img/cache/8fa14cdd754f91cc6554c9e71929cce7.gif" alt="f" valign="middle"/>, there is a virus <img src="/img/cache/fb16e3e3f18c15edc61e1f2c0fa972ba.gif" alt="\mathbf{v}" valign="middle"/> such that <img src="/img/cache/2e4c991b2a6ba37b15784cc9286f43f1.gif" alt="\varphi_{\mathbf{v}}(\mathbf{p}, x) = f(\mathbf{v, p})" valign="middle"/></em></p>
<p><em>Proof.</em> For set <img src="/img/cache/ea423806dc92668d7e94d178f141d9e1.gif" alt="g(y, \mathbf{p}, x) = f(y, \mathbf{p})" valign="middle"/>. Recursion Theorem implies that the semi-computable function <img src="/img/cache/b2f5ff47436671b6e533d8dc3614845d.gif" alt="g" valign="middle"/> has a fixed point that we call <img src="/img/cache/fb16e3e3f18c15edc61e1f2c0fa972ba.gif" alt="\mathbf{v}" valign="middle"/>. We have <img src="/img/cache/5cd730c26b9735535ea60f651cb2926f.gif" alt="\varphi_{\mathbf{v}}(\mathbf{p}, x) = g(\mathbf{v, p}, x) = f(\mathbf{v, p})" valign="middle"/>.</p>
<p>Next, let <img src="/img/cache/83a9c5737d7ce81e9ea5a58c9b993c56.gif" alt="\mathbf{e}" valign="middle"/> be a code of <img src="/img/cache/b2f5ff47436671b6e533d8dc3614845d.gif" alt="g" valign="middle"/>, that is <img src="/img/cache/7c9f98c2ba0e7e43c55cad11b3871975.gif" alt="g \approx \varphi_{\mathbf{e}}" valign="middle"/>. The propagation function <img src="/img/cache/70d9ff405d8f4c3001f214bf0eb4c43c.gif" alt="\calB" valign="middle"/> induced by <img src="/img/cache/fb16e3e3f18c15edc61e1f2c0fa972ba.gif" alt="\mathbf{v}" valign="middle"/> is defined by <img src="/img/cache/70b619876134165dd24d9745e0b2b299.gif" alt="\calB(\mathbf{v, p}) = S(\mathbf{e, v, p})" valign="middle"/>, since</p>
<div class="N5"><img src="/img/cache/3ef01dfed3de7cb8bd8970af18fb055d.gif" alt="
	\begin{eqnarray}
		\varphi_{\calB(\mathbf{v,p})}(x)&amp;=&amp; \varphi_{S(\mathbf{e,v,p})}(x)	&amp;&amp;	\hspace{100} (9)\\
						&amp;=&amp; g(\mathbf{v, p}, x) = \varphi_{\mathbf{v}}(\mathbf{p}, x)	&amp;&amp;	\hspace{100} (10)
	\end{eqnarray}
" valign="middle"/></div>
<p>It is worth to say that the propagation function lies on the s-m-n <img src="/img/cache/5dbc98dcc983a70728bd082d1a47546e.gif" alt="S" valign="middle"/> function. The s-m-n <img src="/img/cache/5dbc98dcc983a70728bd082d1a47546e.gif" alt="S" valign="middle"/> function specializes the program <img src="/img/cache/83a9c5737d7ce81e9ea5a58c9b993c56.gif" alt="\mathbf{e}" valign="middle"/> to <img src="/img/cache/fb16e3e3f18c15edc61e1f2c0fa972ba.gif" alt="\mathbf{v}" valign="middle"/> and <img src="/img/cache/ba0d8bb3a7b9d14aa7496d59f463efb7.gif" alt="\mathbf{p}" valign="middle"/>, and thus it drops the virus in the system and propagates it. So, in some sense, the s-m-n <img src="/img/cache/5dbc98dcc983a70728bd082d1a47546e.gif" alt="S" valign="middle"/> function should be be considered as a flaw, which is inherent to each acceptable programming language.</p>
<p>To illustrate behaviors of duplicating viruses, we consider several examples, which correspond to known computer viruses.</p>
<h4>Crushing</h4>
<p>A duplication function <img src="/img/cache/120be0bc58aa2e541a3be4d16b19d828.gif" alt="Dup" valign="middle"/> is a crushing if <img src="/img/cache/17b6507206b57dc22db470d5ed7a81d1.gif" alt="Dup(\mathbf{v, p}) = \mathbf{v}" valign="middle"/>.</p>
<p>This basic idea is in fact the starting point of a lot of computer viruses. Most of the email worms use this methods, copying their script to many directories. The e-mail worm "loveletter" copies itself as "<tt>MSKernel32.vbs</tt>". Lastly, here is a tiny bash program which copies itself.</p>
<div class="bash" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #c20cb9; font-weight: bold;">cat</span> <span style="color: #007800;">$0</span> <span style="color: #000000; font-weight: bold;">&gt;</span> <span style="color: #007800;">$0</span> . copy<br/>
&nbsp;</div>
<h4>Cloning</h4>
<p>Suppose that <img src="/img/cache/403bad95dca9b6f7394103ada5c65a5f.gif" alt="\mathbf{p} = (\mathbf{p_1},\dots,\mathbf{p_n})" valign="middle"/>. Then, a virus is cloning wrt <img src="/img/cache/120be0bc58aa2e541a3be4d16b19d828.gif" alt="Dup" valign="middle"/>, if <img src="/img/cache/637f8f3038ad33eab9a1529380723440.gif" alt="Dup(\mathbf{v, p}) = (d(\mathbf{v, p_1}),\dots, d(\mathbf{v, p_n}))" valign="middle"/> where <img src="/img/cache/8277e0910d750195b448797616e091ad.gif" alt="d" valign="middle"/> is a duplication function. A cloning virus keeps the structure of the program environment but copies itself into some parts. For example, we can think that <img src="/img/cache/ba0d8bb3a7b9d14aa7496d59f463efb7.gif" alt="\mathbf{p}" valign="middle"/> is a directory and <img src="/img/cache/c540edc69fabaf9f691824d0081d80dd.gif" alt="(\mathbf{p_1,\dots,p_n})" valign="middle"/> are the file inside. So a cloning virus infects some files in the directory.</p>
<p>Moreover, a cloning virus should also verify that <img src="/img/cache/40eb14890695f7d5f3813ee6d43fa53b.gif" alt="|d(\mathbf{v, p_i})| \le  |p_i|" valign="middle"/>. Then, the virus does not increase the program size, and so the detection of such non-size increasing virus is harder.</p>
<p>A cloning virus is usually quite malicious, because it overwrites existing program. A concrete example is the virus named "4870 Overwriting". The next bash program illustrates of a cloning virus.</p>
<div class="bash" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #000000; font-weight: bold;">for</span> FName <span style="color: #000000; font-weight: bold;">in</span> $<span style="color: black;">&#40;</span><span style="color: #c20cb9; font-weight: bold;">ls</span> <span style="color: #000000; font-weight: bold;">*</span>.infect.sh<span style="color: black;">&#41;</span> ; <span style="color: #000000; font-weight: bold;">do</span><br/>
&nbsp; <span style="color: #007800;">LENGTH</span>=<span style="color: #000000; font-weight: bold;">`</span><span style="color: #c20cb9; font-weight: bold;">wc</span> <span style="color: #660033;">-m</span> .<span style="color: #000000; font-weight: bold;">/</span><span style="color: #007800;">$FName</span><span style="color: #000000; font-weight: bold;">`</span><br/>
&nbsp; <span style="color: #000000; font-weight: bold;">if</span> <span style="color: black;">&#91;</span> .<span style="color: #000000; font-weight: bold;">/</span><span style="color: #007800;">$FName</span> <span style="color: #000000; font-weight: bold;">!</span>= <span style="color: #007800;">$0</span> <span style="color: #660033;">-a</span> <span style="color: #ff0000;">&quot;193&quot;</span> <span style="color: #660033;">-le</span> <span style="color: #ff0000;">&quot;<span style="color: #007800;">${LENGTH%*./$FName}</span>&quot;</span> <span style="color: black;">&#93;</span> ; <span style="color: #000000; font-weight: bold;">then</span><br/>
&nbsp; &nbsp; <span style="color: #7a0874; font-weight: bold;">echo</span> <span style="color: black;">&#91;</span> <span style="color: #007800;">$0</span> infect .<span style="color: #000000; font-weight: bold;">/</span><span style="color: #007800;">$FName</span> <span style="color: black;">&#93;</span><br/>
&nbsp; &nbsp; <span style="color: #c20cb9; font-weight: bold;">cat</span> <span style="color: #007800;">$0</span> <span style="color: #000000; font-weight: bold;">&gt;</span> .<span style="color: #000000; font-weight: bold;">/</span><span style="color: #007800;">$FName</span><br/>
&nbsp; <span style="color: #000000; font-weight: bold;">fi</span><br/>
<span style="color: #000000; font-weight: bold;">done</span><br/>
&nbsp;</div>
<h4>Ecto-symbiosis</h4>
<p>A virus is an ecto-symbiote if it lives on the body surface of the program <img src="/img/cache/fb16e3e3f18c15edc61e1f2c0fa972ba.gif" alt="\mathbf{v}" valign="middle"/>. For example, <img src="/img/cache/cc7361ae6aa580a9fb57eae2bc1f9456.gif" alt="Dup(\mathbf{v, p}) = \mathbf{v \cdot p}" valign="middle"/> where <img src="/img/cache/571ca3d7c7a5d375a429ff5a90bc5099.gif" alt="\cdot" valign="middle"/> is the word concatenation.</p>
<p>The following bash code adds its own code at the end of every file.</p>
<div class="bash" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #000000; font-weight: bold;">for</span> FName <span style="color: #000000; font-weight: bold;">in</span> $<span style="color: black;">&#40;</span><span style="color: #c20cb9; font-weight: bold;">ls</span> .infect.sh <span style="color: black;">&#41;</span> ; <span style="color: #000000; font-weight: bold;">do</span><br/>
&nbsp; <span style="color: #000000; font-weight: bold;">if</span> <span style="color: black;">&#91;</span> .<span style="color: #000000; font-weight: bold;">/</span><span style="color: #007800;">$FName</span> <span style="color: #000000; font-weight: bold;">!</span>= <span style="color: #007800;">$0</span> <span style="color: black;">&#93;</span> ; <span style="color: #000000; font-weight: bold;">then</span><br/>
&nbsp; &nbsp; <span style="color: #7a0874; font-weight: bold;">echo</span> <span style="color: black;">&#91;</span> <span style="color: #007800;">$0</span> infect .<span style="color: #000000; font-weight: bold;">/</span><span style="color: #007800;">$FName</span> <span style="color: black;">&#93;</span><br/>
&nbsp; &nbsp; <span style="color: #c20cb9; font-weight: bold;">tail</span> <span style="color: #007800;">$0</span> <span style="color: #660033;">-n</span> <span style="color: #000000;">6</span> <span style="color: #000000; font-weight: bold;">|</span> <span style="color: #c20cb9; font-weight: bold;">cat</span> <span style="color: #000000; font-weight: bold;">&gt;&gt;</span> .<span style="color: #000000; font-weight: bold;">/</span><span style="color: #007800;">$FName</span><br/>
&nbsp; <span style="color: #000000; font-weight: bold;">fi</span><br/>
<span style="color: #000000; font-weight: bold;">done</span><br/>
&nbsp;</div>
<p>The computer virus "Jerusalem" is an ecto-symbiote since it copies itself to executable file (that is, ".COM" or ".EXE" files).</p>
<h3>3.3 Implicit viruses</h3>
<p>We establish a result which constructs a virus which performs several actions depending on some conditions on its arguments. This construction of trigger viruses is very general and embeds a lot of practical cases.</p>
<p><strong>Theorem 4.</strong> <em>Let <img src="/img/cache/c6958f99caca48e82dc851c5eb0b8f2e.gif" alt="C_1,\dots,C_k" valign="middle"/> be <img src="/img/cache/8ce4b16b22b58894aa86c421e8759df3.gif" alt="k" valign="middle"/> semi-computable disjoint subsets of <img src="/img/cache/8f24373a2599e7588fa8fd398b592df9.gif" alt="\calD" valign="middle"/> and <img src="/img/cache/e836637f4a1887d4479885f7f21dca4d.gif" alt="V_1,\dots,V_k" valign="middle"/> be <img src="/img/cache/8ce4b16b22b58894aa86c421e8759df3.gif" alt="k" valign="middle"/> semi-computable functions There is a virus <img src="/img/cache/fb16e3e3f18c15edc61e1f2c0fa972ba.gif" alt="\mathbf{v}" valign="middle"/> which satisfies for all <img src="/img/cache/ba0d8bb3a7b9d14aa7496d59f463efb7.gif" alt="\mathbf{p}" valign="middle"/> and <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/>, the equation</em></p>
<div class="N5"><img src="/img/cache/73f2ac7a544a262617751551144d2249.gif" alt="
\varphi_{\mathbf{v}}(\mathbf{p}, x) = \{
	V_1(\mathbf{v, p}, x) \hspace{20} (\mathbf{p}, x) \in C_1 \\
	\vdots\\
	V_k(\mathbf{v, p}, x) \hspace{20} (\mathbf{p}, x) \in C_k	\hspace{100}(11)
" valign="middle"/></div>
<p><em>Proof.</em> Define</p>
<div class="N5"><img src="/img/cache/62b8c2a5f5fd4c19b66480b849a3e3db.gif" alt="
F(y, \mathbf{p}, x) = \{
	V1(y, \mathbf{p}, x) \hspace{20} (\mathbf{p}, x) \in C_1\\
	\vdots\\
	Vk(y, \mathbf{p}, x) \hspace{20} (\mathbf{p}, x) \in C_k	\hspace{100}(12)
" valign="middle"/></div>
<p>The function <img src="/img/cache/800618943025315f869e4e1f09471012.gif" alt="F" valign="middle"/> is computable and has a code <img src="/img/cache/83a9c5737d7ce81e9ea5a58c9b993c56.gif" alt="\mathbf{e}" valign="middle"/> such that <img src="/img/cache/c74cd779c168e65649eb2a30852b4103.gif" alt="F \approx \varphi_{\mathbf{e}}" valign="middle"/>. Again, recursion Theorem yields a fixed point <img src="/img/cache/fb16e3e3f18c15edc61e1f2c0fa972ba.gif" alt="\mathbf{v}" valign="middle"/> of <img src="/img/cache/800618943025315f869e4e1f09471012.gif" alt="F" valign="middle"/> which satisfies the Theorem equation. The induced propagation function is <img src="/img/cache/d6434c4596e43ca476be6ed73c16602b.gif" alt="V(\mathbf{v, p}) = S(\mathbf{e, v, p})" valign="middle"/></p>
<h2>4 Comparison with Adleman's virus</h2>
<p>Adleman's modeling is based on the following scenario. For every program, there is an "infected" form of the program.</p>
<p>The virus is a computable function from programs to "infected" programs. An infected program has several behaviors which depend on the input <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/>. Adleman lists three actions. In the first (13) the infected program ignores the intended task and executes some "destroying" code. So it is why it is called <em>injure</em>. In the second (14), the infected program infects the others, that is it performs the intended task of the original, a priori sane, program, and then it contaminates other programs. In the third and last one (15), the infected program imitates the original program and stays quiescent.</p>
<p>We translate Adleman's original definition into our formalism.</p>
<p><strong>Definition 5 (Adleman's viruses).</strong> <em>A total computable function <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/> is said to be a <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/>-viral function (virus in the sense of Adleman) if for each <img src="/img/cache/64bac4178e136b7dba780be0f3151279.gif" alt="x \in \calD" valign="middle"/> one of the three following properties holds:</em></p>
<dl>
<dt><strong>Injure</strong></dt>
<dd><div class="N5"><img src="/img/cache/1beee0d1ceb8d360e03e21023ccd2418.gif" alt="
		\forall\mathbf{p, q} \in \calD \hspace{20} \varphi_{A(\mathbf{p})}(x) = \varphi_{A(\mathbf{q})}(x)	\hspace{100}(13)
	" valign="middle"/></div>
<p><em>This first kind of behavior corresponds to the execution of some viral functions independently from the infected program.</em></p>
</dd>
<dt><strong>Infect</strong></dt>
<dd><div class="N5"><img src="/img/cache/d9580c4620d957fda003e42371fc075c.gif" alt="
		\forall\mathbf{p, q} \in \calD \hspace{20} \varphi_{A(\mathbf{p})}(x) = A(\varphi_{\mathbf{p}}(x))	\hspace{100}(14)
	" valign="middle"/></div>
<p><em>The second item corresponds to the case of infection. One sees that ny part of <img src="/img/cache/de4bbdab31c3ca34f7af3d40180cc41b.gif" alt="\varphi_{\mathbf{p}}(x)" valign="middle"/> is rewritten according to <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/>.</em></p>
</dd>
<dt><strong>Imitate</strong></dt>
<dd><div class="N5"><img src="/img/cache/7cc3a37b11948e044ae5d18d66b4305b.gif" alt="
		\forall\mathbf{p, q} \in \calD \hspace{20} \varphi_{A(\mathbf{p})}(x) = \varphi_{\mathbf{p}}(x)		\hspace{100}(15)
	" valign="middle"/></div>
<p><em>The last item corresponds to mimic the original program.</em></p>
</dd>
</dl>
<p>Our definition respects Adleman's idea and implies easily the original infection definition. In Adleman's paper, the infection definition is very closed to the crushing virus as they have defined previously. However, our definition of the infect case is slightly stronger. Indeed, there is no condition or restriction on the application of the A-viral function to <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/> to <img src="/img/cache/de4bbdab31c3ca34f7af3d40180cc41b.gif" alt="\varphi_{\mathbf{p}}(x)" valign="middle"/> unlike Adleman's definition. Indeed, he assumes that <img src="/img/cache/c61fed0b5065f3614e69b55bdf31316b.gif" alt="\varphi_{\mathbf{p}}(x) = (\mathbf{d,p_1,\dots,p_n)" valign="middle"/> and that <img src="/img/cache/fda9c35fd7b88a5abf6f681541b01733.gif" alt="A(\varphi_{\mathbf{p}}(x)) = (\mathbf{d},a(\mathbf{p_1}),\dots,a(\mathbf{p_n}))" valign="middle"/> where <img src="/img/cache/0cc175b9c0f1b6a831c399e269772661.gif" alt="a" valign="middle"/> is a computable function which depends on A.</p>
<p><strong>Theorem 6.</strong> <em>Assume that <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/> is a A-virus. Then there is a virus which performs the same actions that <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/>.</em></p>
<p><em>Proof.</em> Let <img src="/img/cache/83a9c5737d7ce81e9ea5a58c9b993c56.gif" alt="\mathbf{e}" valign="middle"/> be the code of <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/>, that is <img src="/img/cache/070ee5a50eeaec28ad88de5f26e893e2.gif" alt="\varphi_{\mathbf{e}} \approx A" valign="middle"/>. There is a semi-computable function <img src="/img/cache/ac863f346e618f9a959b5c95d5d28941.gif" alt="App" valign="middle"/> such that <img src="/img/cache/c5540d3c2066695171bb3fc05a6ea9e8.gif" alt="App(x, y, z) = \varphi_{\varphi_x(y)}(z)" valign="middle"/>. Suppose that <img src="/img/cache/f7a0cb4a478010e6d3f9adbc28eeedf1.gif" alt="\mathbf{q}" valign="middle"/> is the code of <img src="/img/cache/ac863f346e618f9a959b5c95d5d28941.gif" alt="App" valign="middle"/>. Take <img src="/img/cache/64ff0c8760ec8822f38ba92f1770b0fa.gif" alt="\mathbf{v} = S(\mathbf{q, e})" valign="middle"/>. We have</p>
<div class="N5"><img src="/img/cache/da7e2b682bf08cb5f70dc9ea595767fc.gif" alt="
	\begin{eqnarray}
		\varphi_{A(\mathbf{p})}(x)	&amp;=&amp; \varphi_{\varphi_{\mathbf{e}}(p)}(x)	\\
						&amp;=&amp; App(\mathbf{e, p}, x)	\\
						&amp;=&amp; \varphi_{\mathbf{q}}(\mathbf{e, p}, x)	\\
						&amp;=&amp; \varphi_{S(\mathbf{q,e})}(\mathbf{p}, x)	\\
						&amp;=&amp; \varphi_{\mathbf{v}}(\mathbf{p}, x)
	\end{eqnarray}
" valign="middle"/></div>
<p>We conclude that the propagation function is <img src="/img/cache/e8d822450974da90a2821b2ee1119966.gif" alt="\calB(\mathbf{v, p}) = A(\mathbf{p})" valign="middle"/></p>
<h2>5 Polymorphic viruses</h2>
<p>Until now, we have considered viruses which duplicate themselves without modifying their code. Now, we consider viruses which mutate when they duplicate. Such viruses are called polymorphic; they are common computer viruses. The appendix gives more "practical informations" about them.</p>
<p>This suggests a second definition of self-reproduction. A mutation function <img src="/img/cache/ebb87a770abac0e394d963d20ed574b7.gif" alt="Mut" valign="middle"/> is a total computable function such that <img src="/img/cache/600b0d16436e965458d226bcfd335bd4.gif" alt="Mut(\mathbf{v, p})" valign="middle"/> is a word which contains at least an occurrence of a virus <img src="/img/cache/2ca07f439607ce0d2b20c0be2b9eae2a.gif" alt="\mathbf{v'}" valign="middle"/> . The difference with the previous definition of duplication function in Subsection 3.2 is that <img src="/img/cache/2ca07f439607ce0d2b20c0be2b9eae2a.gif" alt="\mathbf{v'}" valign="middle"/> is a mutated version of <img src="/img/cache/fb16e3e3f18c15edc61e1f2c0fa972ba.gif" alt="\mathbf{v}" valign="middle"/> wrt <img src="/img/cache/ba0d8bb3a7b9d14aa7496d59f463efb7.gif" alt="\mathbf{p}" valign="middle"/>.</p>
<h3>5.1 On polymorphic generators</h3>
<p>Theorem 3, and the implicit virus Theorem 4, shows that a virus is essentially a fixed point of a semi-computable function. In other word, a virus is obtained by solving the equation: <img src="/img/cache/c97c75baa402b0c0aece2630c761bab8.gif" alt="\varphi_{\mathbf{v}}(\mathbf{p}, x) = f(\mathbf{v, p}, x)" valign="middle"/>. And solutions are fixed points of <img src="/img/cache/8fa14cdd754f91cc6554c9e71929cce7.gif" alt="f" valign="middle"/>. Rogers [15] established that a computable function has an infinite number of fixed points. So, a first mutation strategy could be to enumerate fixed points of <img src="/img/cache/8fa14cdd754f91cc6554c9e71929cce7.gif" alt="f" valign="middle"/>. However, the set of fixed points of a computable function is <img src="/img/cache/c6eed69669de0991d1e2069f6096497e.gif" alt="\prod{}_2^0" valign="middle"/>, and worst it is <img src="/img/cache/c6eed69669de0991d1e2069f6096497e.gif" alt="\prod{}_2^0" valign="middle"/>-complete for constant functions.</p>
<p>So we can not enumerate all fixed points because it is not a semicomputable set. But, we can generate an infinite number of fixed points.</p>
<p>To illustrate it, we suggest to use a classical padding function <img src="/img/cache/de43468adaf6acb2c38ebc0c1176f82f.gif" alt="Pad" valign="middle"/> which satisfies</p>
<ol>
<li><img src="/img/cache/de43468adaf6acb2c38ebc0c1176f82f.gif" alt="Pad" valign="middle"/> is a bijective function.</li>
<li>For each program <img src="/img/cache/f7a0cb4a478010e6d3f9adbc28eeedf1.gif" alt="\mathbf{q}" valign="middle"/> and each <img src="/img/cache/415290769594460e2e485922904f345d.gif" alt="y" valign="middle"/>, <img src="/img/cache/4e50bc48a83496ab179639daf5164969.gif" alt="\varphi_{\mathbf{q}} \approx \varphi_{Pad(\mathbf{q},y)}" valign="middle"/>.</li>
</ol>
<p><strong>Lemma 7.</strong> <em>There is a computable padding function <img src="/img/cache/de43468adaf6acb2c38ebc0c1176f82f.gif" alt="Pad" valign="middle"/>.</em></p>
<p><em>Proof.</em> Take <img src="/img/cache/5552f6118abb09337b7d4f8c74ecee31.gif" alt="T : D \times D \rightarrow D" valign="middle"/> as a computable bijective encoding of pairs. Let <img src="/img/cache/4d50b474c7a8b790bdd18aa1ee199f42.gif" alt="\pi_1" valign="middle"/> be first projection function of <img src="/img/cache/b9ece18c950afbfa6b0fdbfa4ff731d3.gif" alt="T" valign="middle"/>. Define <img src="/img/cache/c8e4274df9ea90301c33dec987e93967.gif" alt="Pad(\mathbf{q}, y)" valign="middle"/> as the code of <img src="/img/cache/26b46afd98deb37048767491c4596f0b.gif" alt="\pi_1(T(\mathbf{q}, y))" valign="middle"/>.</p>
<p><strong>Theorem 8.</strong> <em>Let <img src="/img/cache/8fa14cdd754f91cc6554c9e71929cce7.gif" alt="f" valign="middle"/> be a computable function. Then there is a computable function <img src="/img/cache/4804dc3c133b11589338a62893ae614c.gif" alt="Gen" valign="middle"/> such that</em></p>
<div class="N5"><img src="/img/cache/d5904780c8397d8614333dc7b2eb6123.gif" alt="
	\begin{align}
		Gen(i) \mbox{ is a virus}		&amp;	\hspace{100} (16)	\\
		\forall i \ne j, Gen(i) \ne Gen(j) 	&amp;	\hspace{100} (17)	\\
		\varphi_{Gen(i)}(\mathbf{p}, x) = f(Gen(i), \mathbf{p})	&amp; \hspace{100} (18)
	\end{align}
" valign="middle"/></div>
<p><em>Proof.</em> In fact, <img src="/img/cache/2b07f6dfd1fa749cdc282af90cd8de3c.gif" alt="Gen(i)" valign="middle"/> is the ith fixed point of <img src="/img/cache/8fa14cdd754f91cc6554c9e71929cce7.gif" alt="f" valign="middle"/> wrt to a fixed point enumeration procedure. A construction of a fixed point enumeration procedure is made by padding Kleene's fixed point given by the proof of the recursion Theorem.</p>
<p>For this, suppose that <img src="/img/cache/ba0d8bb3a7b9d14aa7496d59f463efb7.gif" alt="\mathbf{p}" valign="middle"/> is a program of the semi-computable function <img src="/img/cache/3266c32757602cc1d85639256c92af3a.gif" alt="g(S(y, y), x)" valign="middle"/>. We have</p>
<div class="N5"><img src="/img/cache/6ea13ba2c80f6886421c4daa88e92e75.gif" alt="
	g(S(y, y), x) = \varphi_{\mathbf{p}}(y, x)	\hspace{100}(19)
" valign="middle"/></div>
<p>By setting <img src="/img/cache/e5aad62949ad568e30f07006ad86ccbe.gif" alt="Gen(i) = S(Pad(\mathbf{p}, i), Pad(\mathbf{p}, i))" valign="middle"/>, we have</p>
<div class="N5"><img src="/img/cache/9b9d88b0132443e51bd4dadd1e60767a.gif" alt="
	\begin{eqnarray}
		g(S(Pad(\mathbf{p}, i), Pad(\mathbf{p}, i)), x)
			&amp;=&amp; \varphi_{\mathbf{p}}(Pad(\mathbf{p}, i), x)						&amp; \hspace{100} (20)\\
			&amp;=&amp; \varphi_{Pad(\mathbf{p},i)}(Pad(\mathbf{p}, i), x) \mbox{  } Pad's\mbox{ dfn}	&amp; \hspace{100} (21)\\
			&amp;=&amp; \varphi_{S(Pad(\mathbf{p},i),Pad(\mathbf{p},i))}(x)					&amp; \hspace{100} (22)
	\end{eqnarray}
" valign="middle"/></div>
<p><em>Remark 9.</em> For a virus writer, a mutation function is a polymorphic engine, such as the well known "Dark Avenger". A polymorphic engine is a module which gives de ability to look different on replication most of them are encryptor, decryptor functions.</p>
<h3>5.2 Zuo and Zhou's viral function</h3>
<p>Polymorphic viruses were foreseen by Cohen and Adleman. As far as we know, Zuo and Zhou's are the first in [21] to propose a formal definition of the virus mutation process. They discuss on viruses that evolve into at most n forms, and then they consider polymorphism with an infinite numbers of possible mutations.</p>
<p><strong>Definition 10 (Zuo and Zhou viruses).</strong> <em>Assume that <img src="/img/cache/b9ece18c950afbfa6b0fdbfa4ff731d3.gif" alt="T" valign="middle"/> and <img src="/img/cache/dd7536794b63bf90eccfd37f9b147d7f.gif" alt="I" valign="middle"/> are two disjoint computable sets. A total computable function <img src="/img/cache/dc18d83abfd9f87d396e8fd6b6ac0fe1.gif" alt="ZZ" valign="middle"/> is a ZZ-viral polymorphic function if for all n and <img src="/img/cache/f7a0cb4a478010e6d3f9adbc28eeedf1.gif" alt="\mathbf{q}" valign="middle"/>,</em></p>
<div class="N5"><img src="/img/cache/33ad544c40be9d7d0fcfa8b1596adef9.gif" alt="
	\varphi_{ZZ(n,\mathbf{q})}(x) = \{
	\begin{align}
		&amp;&amp;D(x)					&amp; x \in T 	&amp; Injure\\
		&amp;&amp;ZZ(n + 1, \varphi_{\mathbf{q}}(x))	&amp; x \in I	&amp; Infect\\
		&amp;&amp;\varphi_{\mathbf{q}}(x)			&amp;	&amp; Imitate
	\end{align}\hspace{100} (23)
" valign="middle"/></div>
<p>This definition is closed to the one of Adleman, where <img src="/img/cache/b9ece18c950afbfa6b0fdbfa4ff731d3.gif" alt="T" valign="middle"/> corresponds to a set of arguments for which the virus injures and <img src="/img/cache/dd7536794b63bf90eccfd37f9b147d7f.gif" alt="I" valign="middle"/> is a set of arguments for which the virus infects. The last case corresponds to the imitation behavior of a virus. So, the difference stands on the argument n which is used to mutate the virus in the infect case. Hence, a given program <img src="/img/cache/f7a0cb4a478010e6d3f9adbc28eeedf1.gif" alt="\mathbf{q}" valign="middle"/> has an infinite set of infected forms which are <img src="/img/cache/982a53290208d9a080f264bbe4a12502.gif" alt="\{ZZ(\mathbf{q}, n) | n \in \calD\}" valign="middle"/>. (Technically, <img src="/img/cache/7b8b965ad4bca0e41ab51de7b31363a1.gif" alt="n" valign="middle"/> is an encoding of natural numbers into <img src="/img/cache/8f24373a2599e7588fa8fd398b592df9.gif" alt="\calD" valign="middle"/>.)</p>
<p><strong>Theorem 11.</strong> <em>Assume that <img src="/img/cache/dc18d83abfd9f87d396e8fd6b6ac0fe1.gif" alt="ZZ" valign="middle"/> is a ZZ-viral polymorphic function. Then there is a virus which performs the same actions that ZZ wrt a propagation function.</em></p>
<p><em>Proof.</em> The proof is a direct consequence of implicit virus Theorem 4 by setting <img src="/img/cache/365f0748a504c482de58ce2c4bba287c.gif" alt="\mathbf{p} = (n, \mathbf{q})" valign="middle"/>.</p>
<h2>6 Information Theory</h2>
<p>There are various way to define a mutation function. A crucial feature of a virus is to be as small as possible. Thus, it is much harder to detect it. We now revisit clone and symbiote virus definitions.</p>
<h3>6.1 Compressed clones</h3>
<p>A compressed clone is a mutated virus <img src="/img/cache/600b0d16436e965458d226bcfd335bd4.gif" alt="Mut(\mathbf{v, p})" valign="middle"/> such that <img src="/img/cache/5379b30bdf3d00abc2699b39ff2dfd16.gif" alt="|Mut(\mathbf{v, p})| \lt |v|" valign="middle"/>. A compression may use informations inside the program <img src="/img/cache/ba0d8bb3a7b9d14aa7496d59f463efb7.gif" alt="\mathbf{p}" valign="middle"/>. There are several compression algorithms which perform such replications.</p>
<h3>6.2 Endo-Symbiosis</h3>
<p>An endo-symbiote is a virus which hides (and lives) in a program. A spyware is a kind of endo-symbiote. For this, it suffices that</p>
<ol>
<li>We can retrieve <img src="/img/cache/fb16e3e3f18c15edc61e1f2c0fa972ba.gif" alt="\mathbf{v}" valign="middle"/> and <img src="/img/cache/ba0d8bb3a7b9d14aa7496d59f463efb7.gif" alt="\mathbf{p}" valign="middle"/> from <img src="/img/cache/600b0d16436e965458d226bcfd335bd4.gif" alt="Mut(\mathbf{v, p})" valign="middle"/>. That is, there are two inverse functions <img src="/img/cache/5206560a306a2e085a437fd258eb57ce.gif" alt="V" valign="middle"/> and <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/> such that <img src="/img/cache/70bb750c94f65182f554351da444a8d3.gif" alt="\varphi_{V(Mut(\mathbf{v,p}))} \approx \varphi_{\mathbf{v}}" valign="middle"/> and <img src="/img/cache/a52490df8e33b912c3c4c28cb1539823.gif" alt="\varphi_{P(Mut(\mathbf{v,p}))} \approx \varphi_{mathbf{p}}" valign="middle"/></li>
<li>To avoid an easy detection of viruses, we impose that <img src="/img/cache/009e5a74a7f46930bb48c4cf62d5b62b.gif" alt="|Mut(\mathbf{v, p})| \le |\mathbf{p}|" valign="middle"/></li>
<li>We suppose furthermore that
<div class="N5"><img src="/img/cache/682d625fe9e03ee0d45dbb5948fb0764.gif" alt="|V(Mut(\mathbf{v, p}))| + |P(Mut(\mathbf{v, p}))| \le |Mut(\mathbf{v, p})|" valign="middle"/></div></li>
</ol>
<p>Both examples above show an interesting relationship with complexity information Theory. For this, we refer to the book of Li and Vit&aacute;nyi [12]. Complexity information theory leans on Kolmogorov complexity. The Kolmogorov complexity of a word <img src="/img/cache/64bac4178e136b7dba780be0f3151279.gif" alt="x \in \calD" valign="middle"/> wrt <img src="/img/cache/6ecfe2300b694de57238b84d230277f4.gif" alt="\varphi_{\mathbf{e}}" valign="middle"/> and knowing <img src="/img/cache/415290769594460e2e485922904f345d.gif" alt="y" valign="middle"/> is <img src="/img/cache/490b0e24d8af1e8bdbbaaedcc136554f.gif" alt="K_{\varphi_{\mathbf{e}}} (x|y) = min\{|q| : \varphi_{\mathbf{e}}(\mathbf{q}, y) = x\}" valign="middle"/>. The fundamental Theorem of Kolmogorov complexity theory yields: There is universal program <img src="/img/cache/7a52b64bc3b6fc5b02ec5112e4bd6b8a.gif" alt="\mathbf{u}" valign="middle"/> such that for any program <img src="/img/cache/83a9c5737d7ce81e9ea5a58c9b993c56.gif" alt="\mathbf{e}" valign="middle"/>, we have <img src="/img/cache/26e417b66d0331aa511b14383841243b.gif" alt="K_{\varphi_{\mathbf{u}}}(x|y) \le K_{\varphi_{\mathbf{e}}}(x|y)+c" valign="middle"/> where <img src="/img/cache/4a8a08f09d37b73795649038408b5f33.gif" alt="c" valign="middle"/> is some constant. This means that the minimal size of a program which computes a word <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/> wrt <img src="/img/cache/415290769594460e2e485922904f345d.gif" alt="y" valign="middle"/> is <img src="/img/cache/f018d6ae97a5c0df303d2f65401a94e0.gif" alt="K_{\varphi_{\mathbf{u}}}(x|y)" valign="middle"/>, up to an additive constant.</p>
<p>Now, suppose that the virus <img src="/img/cache/fb16e3e3f18c15edc61e1f2c0fa972ba.gif" alt="\mathbf{v}" valign="middle"/> mutates to <img src="/img/cache/2ca07f439607ce0d2b20c0be2b9eae2a.gif" alt="\mathbf{v'}" valign="middle"/> from <img src="/img/cache/ba0d8bb3a7b9d14aa7496d59f463efb7.gif" alt="\mathbf{p}" valign="middle"/>. That is <img src="/img/cache/15e94b96cdfaf60ce8c877e936dcd293.gif" alt="Mut(\mathbf{v, p}) = \mathbf{v'}" valign="middle"/>. An interesting question is then to determine the amount of information which is needed to produce the virus <img src="/img/cache/2ca07f439607ce0d2b20c0be2b9eae2a.gif" alt="\mathbf{v'}" valign="middle"/>. The answer is <img src="/img/cache/2a89101c40e5023fc712efbc8a269def.gif" alt="K_{\varphi_{\mathbf{u}}}(\mathbf{v'}|(\mathbf{v, p}))" valign="middle"/> bits, up to an additive constant.</p>
<p>The demonstration of the fundamental Theorem implies that the shortest description of a word <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/> is made of two parts. The first part <img src="/img/cache/83a9c5737d7ce81e9ea5a58c9b993c56.gif" alt="\mathbf{e}" valign="middle"/> encodes the word regularity and the second part <img src="/img/cache/f7a0cb4a478010e6d3f9adbc28eeedf1.gif" alt="\mathbf{q}" valign="middle"/> represents the "randomness" side of <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/>. And, we have <img src="/img/cache/15241a31855ae5779ccc7dc4fa010e79.gif" alt="\varphi_{\mathbf{e}}(\mathbf{q}, y) = x" valign="middle"/>. Here, the program <img src="/img/cache/83a9c5737d7ce81e9ea5a58c9b993c56.gif" alt="\mathbf{e}" valign="middle"/> plays the role of an interpreter which executes <img src="/img/cache/f7a0cb4a478010e6d3f9adbc28eeedf1.gif" alt="\mathbf{q}" valign="middle"/> in order to print <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/>. Now, let us decompose <img src="/img/cache/2ca07f439607ce0d2b20c0be2b9eae2a.gif" alt="\mathbf{v'}" valign="middle"/> into two parts (i) an interpreter <img src="/img/cache/83a9c5737d7ce81e9ea5a58c9b993c56.gif" alt="\mathbf{e}" valign="middle"/> and (ii) a random data part <img src="/img/cache/f7a0cb4a478010e6d3f9adbc28eeedf1.gif" alt="\mathbf{q}" valign="middle"/> such that <img src="/img/cache/100853030730ce43becc6e02ece6afea.gif" alt="\varphi_{\mathbf{v'}} = \varphi_{\varphi_{\mathbf{e}}(\mathbf{q,v,p})}" valign="middle"/>. In this construction, the virus introduces an interpreter for hiding itself. This is justified by the fundamental Theorem which says that it is an efficient way to compress a virus. In [9], Goel and Bush use Kolmogorov complexity to make a comparison and establish results between biological and computer viruses.</p>
<h3>6.3 Defense against endo-symbiotes</h3>
<p>We suggest an original defense (as far as we know) against some viruses based on information Theory. We use the notations introduced in Section 6 about endo-symbiosis and Kolmogorov complexity.</p>
<p>Our defense prevents the system to be infected by endo-symbiote. Suppose that the programming environment is composed of an interpreter <img src="/img/cache/7a52b64bc3b6fc5b02ec5112e4bd6b8a.gif" alt="\mathbf{u}" valign="middle"/> which is a universal program. We modify it to construct <img src="/img/cache/81c8ff0d683b549923da39b475411d4b.gif" alt="\mathbf{u'}" valign="middle"/> in such way that <img src="/img/cache/5e20a6a0eec9eed6e9fafea5d7a681c6.gif" alt="\varphi_{\mathbf{u'}}(\mathbf{p}, x) = \varphi_{\varphi_{\mathbf{u}}(\mathbf{p})}(x)" valign="middle"/>. Hence, intuitively a program for <img src="/img/cache/708e8c1cfc20ccd8b3f590232e44c113.gif" alt="\varphi_{\mathbf{u'}}" valign="middle"/> is a description of a program wrt <img src="/img/cache/a0e8f3f74fc8e9c5068e54b0f583f5e7.gif" alt="\varphi_{\mathbf{u}}" valign="middle"/>.</p>
<p>Given a constant <img src="/img/cache/4a8a08f09d37b73795649038408b5f33.gif" alt="c" valign="middle"/>, we define a <img src="/img/cache/4a8a08f09d37b73795649038408b5f33.gif" alt="c" valign="middle"/>-compression of a program <img src="/img/cache/ba0d8bb3a7b9d14aa7496d59f463efb7.gif" alt="\mathbf{p}" valign="middle"/> as a program <img src="/img/cache/2e561266ec5138e9d751b9d1c19ad488.gif" alt="\mathbf{p'}" valign="middle"/> such that <img src="/img/cache/0783782e44a9fc8b8c6d942cdfb39d2a.gif" alt="\varphi_{\mathbf{u}}(\mathbf{p'}) = \mathbf{p}" valign="middle"/> and <img src="/img/cache/8ea741253243b9c51e1748ca003f1417.gif" alt="|\mathbf{p'}| \le K_{\varphi_{\mathbf{u}}}(\mathbf{p}) + c" valign="middle"/>. Observe that <img src="/img/cache/3fcc12e0abadce84e4ad59808c294266.gif" alt="\varphi_{\mathbf{u'}}(\mathbf{p'}, x) = \varphi_{\mathbf{p}}(x)" valign="middle"/>.</p>
<p>Now, suppose that <img src="/img/cache/fb16e3e3f18c15edc61e1f2c0fa972ba.gif" alt="\mathbf{v}" valign="middle"/> is an endo-symbiote. So, there is a mutation function <img src="/img/cache/ebb87a770abac0e394d963d20ed574b7.gif" alt="Mut" valign="middle"/> and two associated projections <img src="/img/cache/5206560a306a2e085a437fd258eb57ce.gif" alt="V" valign="middle"/> et <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/>. We have by definition of endo-symbiotes that <img src="/img/cache/8713f79e31f446a471539b3cc6952f3b.gif" alt="|V (Mut(\mathbf{v, p'}))|+|P(Mut(\mathbf{v, p'}))| \le |Mut(\mathbf{v, p'})| \le |\mathbf{p'}|" valign="middle"/>. By definition of <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/>, we have <img src="/img/cache/ec56c8c77e1e4a924abc90f4fabee30d.gif" alt="\varphi_{\mathbf{p'}} = \varphi_{P(Mut(\mathbf{v,p'}))}" valign="middle"/>. As a consequence, <img src="/img/cache/2b3f9a17d4f0b9e92d8395b05327c3d6.gif" alt="\varphi_{\mathbf{u}}(\mathbf{p'}) = \varphi_{\mathbf{u}}(P(Mut(\mathbf{v, p'}))) = \mathbf{p}" valign="middle"/>. So, <img src="/img/cache/4caf47818a070c8155c510c986b8b8b1.gif" alt="|P(Mut(\mathbf{v, p'}))| \ge K_{\varphi_{\mathbf{u}}}(\mathbf{p})" valign="middle"/>. Finally, the space <img src="/img/cache/947319e2c388c6679e12f6c7c8dcfc42.gif" alt="|V(Mut(\mathbf{v, p'}))|" valign="middle"/> to encode the virus is bounded by <img src="/img/cache/4a8a08f09d37b73795649038408b5f33.gif" alt="c" valign="middle"/>. Notice that it is not difficult to forbid <img src="/img/cache/708e8c1cfc20ccd8b3f590232e44c113.gif" alt="\varphi_{\mathbf{u'}}" valign="middle"/> to execute programs which have less than <img src="/img/cache/4a8a08f09d37b73795649038408b5f33.gif" alt="c" valign="middle"/> bits. In this case, no endo-symbiote can infect <img src="/img/cache/2e561266ec5138e9d751b9d1c19ad488.gif" alt="\mathbf{p'}" valign="middle"/>. Therefore, <img src="/img/cache/4a8a08f09d37b73795649038408b5f33.gif" alt="c" valign="middle"/>-compressed programs are safe from attack by endo-symbiotes.</p>
<p>Of course, this defense strategy is infeasible because there is no way to approximate the Kolmogorov complexity by mean of a computable function. In consequence, we can not produce <img src="/img/cache/4a8a08f09d37b73795649038408b5f33.gif" alt="c" valign="middle"/>-compressed programs. However, we do think this kind of idea shed some light on self-defense programming systems.</p>
<h2>7 Detection of viruses</h2>
<p>Let us first consider the set of viruses wrt a function <img src="/img/cache/70d9ff405d8f4c3001f214bf0eb4c43c.gif" alt="\calB" valign="middle"/>. It is formally given by <img src="/img/cache/5bf8dac7e33088dfa8247644ee172567.gif" alt="V_{\calB} = \{\mathbf{v} | \forall\mathbf{p}, x : \exists y : \varphi_{\mathbf{v}}(\mathbf{p}, x) = y \wedge \varphi_{\calB(\mathbf{v,p})}(x) = y\}" valign="middle"/>. As the formulation of <img src="/img/cache/dff23bd698cbec0376e37afe65aa624c.gif" alt="V_{\calB}" valign="middle"/> shows it, we have:</p>
<p><strong>Proposition 12.</strong> <em>Given a recursive function <img src="/img/cache/806de1ce3147721a9cf424ee0c6c7a00.gif" alt="\calB, V_{\calB}" valign="middle"/> is <img src="/img/cache/c6eed69669de0991d1e2069f6096497e.gif" alt="\prod{}_2^0" valign="middle"/>.</em></p>
<p><strong>Theorem 13.</strong> <em>There are some functions <img src="/img/cache/70d9ff405d8f4c3001f214bf0eb4c43c.gif" alt="\calB" valign="middle"/> for which <img src="/img/cache/dff23bd698cbec0376e37afe65aa624c.gif" alt="V_{\calB}" valign="middle"/> is <img src="/img/cache/c6eed69669de0991d1e2069f6096497e.gif" alt="\prod{}_2^0" valign="middle"/>-complete.</em></p>
<p><em>Proof.</em> Suppose now given a computable function <img src="/img/cache/e358efa489f58062f10dd7316b65649e.gif" alt="t" valign="middle"/>, it has an index <img src="/img/cache/f7a0cb4a478010e6d3f9adbc28eeedf1.gif" alt="\mathbf{q}" valign="middle"/>. It is well known that the set <img src="/img/cache/051d02f816d711772cb7cc414eea0369.gif" alt="T = \{i | \varphi_i = t\}" valign="middle"/> is <img src="/img/cache/c092b7daa73baafd26c210aec4174dcc.gif" alt="\prod{}_2" valign="middle"/>-complete. Define now <img src="/img/cache/6908998a2b270a560aded6b518bddcf7.gif" alt="\calB(y, p) = S(\mathbf{q}, p)" valign="middle"/>. Observe that a virus <img src="/img/cache/fb16e3e3f18c15edc61e1f2c0fa972ba.gif" alt="\mathbf{v}" valign="middle"/> verify: <img src="/img/cache/aaa9bce2e801f6d03aace418cb891d51.gif" alt="\forall\mathbf{p}, x : \varphi_{\mathbf{v}}(\mathbf{p}, x) = t(\mathbf{p}, x)" valign="middle"/>. The pairing procedure being surjective, <img src="/img/cache/fb16e3e3f18c15edc61e1f2c0fa972ba.gif" alt="\mathbf{v}" valign="middle"/> is an index of <img src="/img/cache/e358efa489f58062f10dd7316b65649e.gif" alt="t" valign="middle"/>. Conversly, suppose that <img src="/img/cache/83a9c5737d7ce81e9ea5a58c9b993c56.gif" alt="\mathbf{e}" valign="middle"/> is not a virus. In that case, there is some <img src="/img/cache/1ff3478f86aa60ac8454b145d4223738.gif" alt="\mathbf{p}, x" valign="middle"/> for which <img src="/img/cache/697072a754f7f80023188142283b9097.gif" alt="\varphi_{\mathbf{e}}(\mathbf{p}, x) \ne \varphi_{\calB(\mathbf{e,p})}(x) = t(\mathbf{p}, x)" valign="middle"/>. As a consequence, it is not an index of <img src="/img/cache/e358efa489f58062f10dd7316b65649e.gif" alt="t" valign="middle"/>. So, <img src="/img/cache/bf80d12d49eeb3f87f30ed74ed4e0275.gif" alt="V_{\calB} = T" valign="middle"/>.</p>
<p><strong>Theorem 14.</strong> <em>There are some functions <img src="/img/cache/70d9ff405d8f4c3001f214bf0eb4c43c.gif" alt="\calB" valign="middle"/> for which it is decidable whether <img src="/img/cache/ba0d8bb3a7b9d14aa7496d59f463efb7.gif" alt="\mathbf{p}" valign="middle"/> is a virus or not.</em></p>
<p><em>Proof.</em> Let us define <img src="/img/cache/e26521c70852b4cf8040d7e462b11b61.gif" alt="f(y, \mathbf{p}, x) = \varphi_y(\mathbf{p}, x)" valign="middle"/>. Being recursive, it has a code, say <img src="/img/cache/f7a0cb4a478010e6d3f9adbc28eeedf1.gif" alt="\mathbf{q}" valign="middle"/>. Application of s-m-n Theorem provides <img src="/img/cache/92b4c32157a3d6f6d90d1b4d26ffe4bc.gif" alt="S(\mathbf{q}, y, \mathbf{p})" valign="middle"/> such that for all <img src="/img/cache/cf1cc2020ea5f2a32b324582176675d7.gif" alt="y, \mathbf{p}, x" valign="middle"/>, we have <img src="/img/cache/cf4c2a219b08dc2314950a2b82564ec8.gif" alt="\varphi_{S(\mathbf{q,y,p})}(x) = f(y, \mathbf{p}, x)" valign="middle"/>. Let us define <img src="/img/cache/7d409bd1fde3b57c6c3248a3ecea2a1c.gif" alt="\calB(y, \mathbf{p}) = S(\mathbf{q}, y, \mathbf{p})" valign="middle"/>. It is routine to check that for all <img src="/img/cache/9fc5df2ed2dc9320803bea0ba0f34bdf.gif" alt="\mathbf{d}" valign="middle"/>, <img src="/img/cache/9fc5df2ed2dc9320803bea0ba0f34bdf.gif" alt="\mathbf{d}" valign="middle"/> is a virus for <img src="/img/cache/70d9ff405d8f4c3001f214bf0eb4c43c.gif" alt="\calB" valign="middle"/>. So, in that case, any index is a virus.</p>
<p>A consequence of this is that there are some weakness for which it is decidable whether a code is a virus or not. This is again, as far as we know, one of the first positive results concerning the detection of viruses.</p>
<h2>References</h2>
<ol>
<li>L. Adleman. <a href="/lib/ala01.html">An abstract theory of computer viruses</a>. In Advances in Cryptology -- CRYPTO'88, volume 403. Lecture Notes in Computer Science, 1988.</li>
<li>M. Bishop. <a href="/lib/amb01.html">An overview of computer viruses in a research environment</a>. Technical report, Hanover, NH, USA, 1991.</li>
<li>D. Chess and S. White. <a href="/lib/adc06.html">An undetectable computer virus</a>.</li>
<li>F. Cohen. Computer Viruses. PhD thesis, University of Southern California, January 1986.</li>
<li>F. Cohen. <a href="/lib/afc01.html">Computer viruses: theory and experiments</a>. Comput. Secur., 6(1):22 - 35, 1987.</li>
<li>F. Cohen. <a href="/lib/afc07.html">Models of practical defenses against computer viruses: theory and experiments</a>. Comput. Secur., 6(1), 1987.</li>
<li>M. Davis. Computability and unsolvability. McGraw-Hill, 1958.</li>
<li>E. Filiol. Les virus informatiques: th´eorie, pratique et applications. Springer-Verlag France, 2004.</li>
<li>S. Goel and S. Bush. <a href="/lib/asg13.html">Kolmogorov complexity estimates for detection of viruses in biologically inspired security systems: a comparison with traditional approaches</a>. Complex., 9(2):54 - 73, 2003.</li>
<li>S. Anderson H. Thimbleby and P. Cairns. A framework for medelling trojans and computer virus infection. Comput. J., 41:444 - 458, 1999.</li>
<li>N. Jones. Computer implementation and applications of kleene's S-m-n and recursive theorems. In Y. N. Moschovakis, editor, Lecture Notes in Mathematics, Logic From Computer Science, pages 243 - 263. 1991.</li>
<li>M. Li and P. Vit&aacute;nyi. An Introduction to Kolmogorov Complexity and its Application. Springer, 1997. (Second edition).</li>
<li>M. Ludwig. <a href="/lib/vml01.html">The Giant Black Book of Computer Viruses</a>. American Eagle Publications, 1998.</li>
<li>P. Odiffredi. Classical recursion theory. North-Holland, 1989.</li>
<li>H. Rogers. Theory of Recursive Functions and Effective Computability. McGraw Hill, New York, 1967.</li>
<li>P. Szor. <a href="/lib/aps00.html">The Art of Computer Virus Research and Defense</a>. Addison-Wesley Professional, 2005.</li>
<li>A. Turing and J.-Y. Girard. La machine de Turing. Seuil, 1995.</li>
<li>A. M. Turing. On computable numbers with an application to the entscheidungsproblem. Proc. London Mathematical Society, 42(2):230 - 265, 1936. Traduction [17].</li>
<li>V.A. Uspenskii. Enumeration operators ans the concept of program. Uspekhi Matematicheskikh Nauk, 11, 1956.</li>
<li>J. von Neumann and A. W. Burks. Theory of self-reproducing automata. University of Illinois Press, Champaign, IL, 1966.</li>
<li>Z. Zuo and M. Zhou. Some further theorical results about computer viruses. In The Computer Journal, 2004.</li>
</ol>
<h2>A Polymorphic Viruses</h2>
<p>A method widely used for virus detection is file scanning. It uses short strings, refered as signatures, resulting from reverse engineering of viral codes. Those signatures only match the considered virus and not healthy programs. Thus, using a search engine, if a signature is found a virus is detected.</p>
<p>To avoid this detection, one could consider and old virus and change some instructions in order to fool the signature recognition. As an illustration, consider the following signature of a viral bash code</p>
<div class="bash" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #000000; font-weight: bold;">for</span> FName <span style="color: #000000; font-weight: bold;">in</span> $<span style="color: black;">&#40;</span><span style="color: #c20cb9; font-weight: bold;">ls</span> <span style="color: #000000; font-weight: bold;">*</span>.infect.sh<span style="color: black;">&#41;</span>; <span style="color: #000000; font-weight: bold;">do</span><br/>
&nbsp; <span style="color: #000000; font-weight: bold;">if</span> <span style="color: black;">&#91;</span> .<span style="color: #000000; font-weight: bold;">/</span><span style="color: #007800;">$FName</span> <span style="color: #000000; font-weight: bold;">!</span>= <span style="color: #007800;">$0</span> <span style="color: black;">&#93;</span>; <span style="color: #000000; font-weight: bold;">then</span><br/>
&nbsp; &nbsp; <span style="color: #c20cb9; font-weight: bold;">cat</span> <span style="color: #007800;">$0</span> <span style="color: #000000; font-weight: bold;">&gt;</span> .<span style="color: #000000; font-weight: bold;">/</span><span style="color: #007800;">$FName</span><br/>
&nbsp; <span style="color: #000000; font-weight: bold;">fi</span><br/>
<span style="color: #000000; font-weight: bold;">done</span><br/>
&nbsp;</div>
<p>The following code denotes the same program but with an other signature</p>
<div class="bash" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #007800;">OUT</span>=<span style="color: #c20cb9; font-weight: bold;">cat</span><br/>
<span style="color: #000000; font-weight: bold;">for</span> FName <span style="color: #000000; font-weight: bold;">in</span> $<span style="color: black;">&#40;</span><span style="color: #c20cb9; font-weight: bold;">ls</span> <span style="color: #000000; font-weight: bold;">*</span>.infect.sh<span style="color: black;">&#41;</span>; <span style="color: #000000; font-weight: bold;">do</span><br/>
&nbsp; <span style="color: #000000; font-weight: bold;">if</span> <span style="color: black;">&#91;</span> .<span style="color: #000000; font-weight: bold;">/</span><span style="color: #007800;">$FName</span> <span style="color: #000000; font-weight: bold;">!</span>= <span style="color: #007800;">$0</span> <span style="color: black;">&#93;</span>; <span style="color: #000000; font-weight: bold;">then</span><br/>
&nbsp; &nbsp; <span style="color: #007800;">$OUT</span> <span style="color: #007800;">$0</span> <span style="color: #000000; font-weight: bold;">&gt;</span> .<span style="color: #000000; font-weight: bold;">/</span><span style="color: #007800;">$FName</span><br/>
&nbsp; <span style="color: #000000; font-weight: bold;">fi</span><br/>
<span style="color: #000000; font-weight: bold;">done</span><br/>
&nbsp;</div>
<p>Polymorphic viruses use this idea, when it replicates, such a virus changes some parts of its code to look different.</p>
<p>Virus writers began experimenting with such techniques in the early nineties and it achieved with the creation of mutation engines. Historically the first one was "Dark Avenger". Nowadays, many mutation engines have been released, most of them use encryption, decryption functions. The idea, is to break the code into two parts, the first one is a decryptor responsible for decrypting the second part and passing the control to it. Then the second part generates a new decryptor, encrypts itself and links both parts to create a new version of the virus.</p>
<p>A polymorphic virus could be illustrated by the following bash code, it is a simple virus which use as polymorphic engine a swap of two characters.</p>
<div class="bash" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #007800;">SPCHAR</span>=007<br/>
<span style="color: #007800;">LENGTH</span>=<span style="color: #000000;">17</span><br/>
<span style="color: #007800;">ALPHA</span>=azertyuiopqsdfghjklmwxcvbnAZERTYUIOPQSDFGHJKLMWXCVBN<br/>
<span style="color: #007800;">CHAR1</span>=<span style="color: black; font-style: italic;">${ALPHA: `expr $RANDOM % 52`:1}</span><br/>
<span style="color: #007800;">CHAR2</span>=<span style="color: black; font-style: italic;">${ALPHA: `expr $RANDOM % 52`:1}</span><br/>
<span style="color: #666666; font-style: italic;">#add the decryptor</span><br/>
<span style="color: #7a0874; font-weight: bold;">echo</span> <span style="color: #ff0000;">&quot;SPCHAR=007&quot;</span> <span style="color: #000000; font-weight: bold;">&gt;</span> .<span style="color: #000000; font-weight: bold;">/</span>tmp<br/>
<span style="color: #7a0874; font-weight: bold;">echo</span> <span style="color: #ff0000;">&quot;tail -n <span style="color: #007800;">$LENGTH</span> <span style="color: #000099; font-weight: bold;">\$</span>0 | sed -e <span style="color: #000099; font-weight: bold;">\&quot;</span>s/<span style="color: #007800;">$CHAR1</span>/<span style="color: #000099; font-weight: bold;">\<br/>
</span>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #007800;">$SPCHAR</span>/g<span style="color: #000099; font-weight: bold;">\&quot;</span> -e <span style="color: #000099; font-weight: bold;">\&quot;</span>s/<span style="color: #007800;">$CHAR2</span>/<span style="color: #007800;">$CHAR1</span>/g<span style="color: #000099; font-weight: bold;">\&quot;</span> -e <span style="color: #000099; font-weight: bold;">\&quot;</span>s/<span style="color: #000099; font-weight: bold;">\<br/>
</span>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #007800;">$SPCHAR</span>/<span style="color: #007800;">$CHAR2</span>/g<span style="color: #000099; font-weight: bold;">\&quot;</span> -e <span style="color: #000099; font-weight: bold;">\&quot;</span>s/SPCHAR=<span style="color: #007800;">$CHAR2</span>/SPCHAR=<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #007800;">$SPCHAR</span>/g<span style="color: #000099; font-weight: bold;">\&quot;</span>&gt; ./ vx&quot;</span> <span style="color: #000000; font-weight: bold;">&gt;&gt;</span> .<span style="color: #000000; font-weight: bold;">/</span>tmp<br/>
<span style="color: #7a0874; font-weight: bold;">echo</span> <span style="color: #ff0000;">&quot;./ vx&quot;</span> <span style="color: #000000; font-weight: bold;">&gt;&gt;</span> .<span style="color: #000000; font-weight: bold;">/</span>tmp<br/>
<span style="color: #7a0874; font-weight: bold;">echo</span> <span style="color: #ff0000;">&quot;exit 0&quot;</span> <span style="color: #000000; font-weight: bold;">&gt;&gt;</span> .<span style="color: #000000; font-weight: bold;">/</span>tmp<br/>
<span style="color: #666666; font-style: italic;">#encrypt and add v i r a l code</span><br/>
<span style="color: #c20cb9; font-weight: bold;">cat</span> <span style="color: #007800;">$0</span> <span style="color: #000000; font-weight: bold;">|</span> <span style="color: #c20cb9; font-weight: bold;">sed</span> <span style="color: #660033;">-e</span> <span style="color: #ff0000;">&quot;s/<span style="color: #007800;">$CHAR1</span>/<span style="color: #007800;">$SPCHAR</span>/g&quot;</span> <span style="color: #660033;">-e</span> <span style="color: #ff0000;">&quot;s/<span style="color: #007800;">$CHAR2</span>/<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #007800;">$CHAR1</span>/g&quot;</span> <span style="color: #660033;">-e</span> <span style="color: #ff0000;">&quot;s/<span style="color: #007800;">$SPCHAR</span>/<span style="color: #007800;">$CHAR2</span>/g&quot;</span> <span style="color: #660033;">-e</span> <span style="color: #ff0000;">&quot;s/SPCHAR=<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #007800;">$CHAR2</span>/SPCHAR=<span style="color: #007800;">$SPCHAR</span>/g&quot;</span> <span style="color: #000000; font-weight: bold;">&gt;&gt;</span> .<span style="color: #000000; font-weight: bold;">/</span>tmp<br/>
<span style="color: #666666; font-style: italic;">#infect</span><br/>
<span style="color: #000000; font-weight: bold;">for</span> FName <span style="color: #000000; font-weight: bold;">in</span> $ <span style="color: black;">&#40;</span><span style="color: #c20cb9; font-weight: bold;">ls</span> <span style="color: #000000; font-weight: bold;">*</span>.infect.sh<span style="color: black;">&#41;</span> ; <span style="color: #000000; font-weight: bold;">do</span><br/>
&nbsp; <span style="color: #c20cb9; font-weight: bold;">cat</span> .<span style="color: #000000; font-weight: bold;">/</span>tmp <span style="color: #000000; font-weight: bold;">&gt;&gt;</span> .<span style="color: #000000; font-weight: bold;">/</span><span style="color: #007800;">$FName</span><br/>
<span style="color: #000000; font-weight: bold;">done</span><br/>
<span style="color: #c20cb9; font-weight: bold;">rm</span> <span style="color: #660033;">-f</span> .<span style="color: #000000; font-weight: bold;">/</span>tmp<br/>
&nbsp;</div>
<h2>B Metamorphic viruses</h2>
<p>To detect polymorphic computer viruses, anti virus editors have used code emulation techniques and static analysers. The idea of emulation, is to execute programs in a controled fake environment. Thus an encrypted virus will decrypt itself in this environment and some signature detection can be done. Concerning static analysers, they are improved signature maching engines which are able to recognize simple code variation.</p>
<p>To thward those methods, since 2001 virus writers has investigated metamorphism. This is an enhanced morphism technique. Where polymorphic engines generate a variable encryptor, a metamorhic engine generates a whole variable code using some obfuscation functions. Moreover, to fool emulation methods metamorphic viruses can alter their behavior if they detect a controled environment.</p>
<p>When it is executed, a metamorphic virus desassembles its own code, reverse engineers it and transforms it using its environment. If it detects that his environment is controled, it transforms itself into a healthy program, else it recreates a new whole viral code using reverse ingineered information, in order to generate a replication semantically indentical but programmatically different.</p>
<p>Such a virus is really difficult to analyse, thus it could take a long period to understand its behavior. During this period, it replicates freely.</p>
<p>Intuitively, polymorphic viruses mutates without concidering their environment whereas metamophic viruses spawn their next generation using new information. As a matter of fact, to capture this notion, one must consider the equation <img src="/img/cache/c97c75baa402b0c0aece2630c761bab8.gif" alt="\varphi_{\mathbf{v}}(\mathbf{p}, x) = f(\mathbf{v, p}, x)" valign="middle"/> in its entirety.</p>
[<a style="" href="/lib/?lang=EN&amp;index=TH#agb00">Back to index</a>] [<a href="/lib/agb00.html#disqus_thread">Comments</a>]<br/> <div id="disqus_thread"></div>
<script type="text/rocketscript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'vxheaven'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="/agreement.php">Terms of Use</a>!</small> <small>vxheaven.org aka vx.netlux.org</small></div>
<div style="margin-top: 2px; float: left;" class="adsapeu">
<script type="text/rocketscript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script>
</div>
<script data-rocketsrc="http://www.google-analytics.com/urchin.js" type="text/rocketscript"></script><script type="text/rocketscript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="/lib/index.php?lang=de&amp;id=agb00">de</a><a href="/lib/index.php?lang=en&amp;id=agb00">en</a><a href="/lib/index.php?lang=es&amp;id=agb00">es</a><a href="/lib/index.php?lang=it&amp;id=agb00">it</a><a href="/lib/index.php?lang=fr&amp;id=agb00">fr</a><a href="/lib/index.php?lang=pl&amp;id=agb00">pl</a><a href="/lib/index.php?lang=ru&amp;id=agb00">ru</a><a href="/lib/index.php?lang=ua&amp;id=agb00">ua</a></div>
</body>
</html>
