<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Eric Filiol 'Metamorphism, Formal Grammars and Undecidable Code Mutation' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Author" content="Eric Filiol"/>
<meta name="KeyWords" lang="en" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, Filiol, Eric,Metamorphism, Formal Grammars and Undecidable Code Mutation, rightarrow, automaton, viruses, grammars, dots, class, polymorphic, system, sigma, filiol, language, metamorphic, problem, undecidable, computer"/>
<meta name="Description" content="This paper presents a formalisation of the different existing code mutation techniques (polymorphism and metamorphism) by means of formal grammars. While very few theoretical results are known about the detection complexity of viral mutation techniques, we exhaustively address this critical issue by considering the Chomsky classification of formal grammars. This enables us to determine which family of code mutation techniques are likely to be detected or on the contrary are bound to remain undetected. As an illustration we then present, on a formal basis, a proof-of-concept metamorphic mutation engine denoted PB MOT, whose detection has been proven to be undecidable."/>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"047a5bcbf67431883fc9ed25fba33612",petok:"2baf7e19dc6aa43f82c20b7243b8906e66c50cb5-1498756769-1800",zone:"vxheaven.org",rocket:"a",apps:{}}];document.write('<script type="text/javascript" src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=85b614c0f6/cloudflare.min.js"><'+'\/script>');}}catch(e){};
//]]>
</script>
<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="/style.css"/><link rel="canonical" href="http://vxheaven.org/lib/aef04.html"/>
<script type="text/rocketscript" data-rocketsrc="https://apis.google.com/js/plusone.js">{"parsetags": "explicit"}</script>
</head>
<body bgcolor="#dbc8a0" text="#302000" link="#225599" vlink="#113366">
<div class="s1">
<div style="float:right;"><a href="/lib/index.php?tbs=1"><img src="/img/max.gif" alt="Maximize"/></a></div> <form id="lf" style="margin: 0; float: right;" method="get" action="/index.php"><input type="hidden" name="action" value="set"/><select name="lang" onchange="javascript:document.getElementById('lf').submit();"><option value="ru">Русский</option><option selected="selected" value="en">English</option><option value="ua">Українська</option><option value="de">Deutsch</option><option value="es">Español</option><option value="fr">Fran&ccedil;ais</option><option value="it">Italiano</option><option value="pl">Polski</option></select></form>
<div style="float: right;"><div id="plusone"></div></div>
<script type="text/rocketscript">gapi.plusone.render("plusone", {"size":"small","count":"true"});</script>
<div style="float: right;" class="addthis_toolbox addthis_default_style">
<script type="text/rocketscript">var addthis_config = { ui_click: true }</script>
<a style="text-decoration: none; font-size: 10pt;" href="/?action=addthis" class="addthis_button_compact">Bookmark</a>
<script type="text/rocketscript" data-rocketsrc="http://s7.addthis.com/js/250/addthis_widget.js#username=herm1t"></script>
</div>
<div style="float: right;">
<script type="text/rocketscript" data-rocketsrc="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<form action="/search.php" id="cse-search-box">
<input type="hidden" name="cx" value="002577580816726040001:z9_irkorydo"/>
<input type="hidden" name="cof" value="FORID:10"/>
<input type="hidden" name="ie" value="UTF-8"/>
<input type="text" name="q" size="12" value=" "/>
<input type="submit" name="sa" value="Search"/>
</form>
</div><h1><a href="/" style="text-decoration: none; color: #000000;">VX Heaven</a></h1>
<span class="nav"><a href="/lib/">Library</a> <a href="/vl.php">Collection</a> <a href="/src.php">Sources</a> <a href="/vx.php?id=eidx">Engines</a> <a href="/vx.php?id=tidx">Constructors</a> <a href="/vx.php?id=sidx">Simulators</a> <a href="/vx.php?id=uidx">Utilities</a> <a href="/links.php">Links</a> <a href="/donate.php" style="color: #706020" id="donate">Donate</a> <a href="/forum" style="text-decoration: underline;">Forum</a> </span><br clear="all"/>
</div>
<div class="s2"><h1>Metamorphism, Formal Grammars and Undecidable Code Mutation</h1><p><a href="/lib/?lang=en&amp;author=Filiol%2C%20Eric">Eric Filiol</a><br/> <em>International Journal of Computer Science, vol. 2, number 1, 2007, pp. 70-75</em><br/> <em>ISSN 1306-4428</em><br/> <em>April 2007</em></p><script type="text/rocketscript">var disqus_url = 'http://vxheaven.org/lib/aef04.html';</script><div class="ci"><a href="/lib/?ci=aef04">4</a></div><img src="/img/pdf.gif" alt="PDF"/><a href="/lib/pdf/Metamorphism%2C%20Formal%20Grammars%20and%20Undecidable%20Code%20Mutation.pdf">Download</a> PDF (369.41Kb) (You need to be registered on <a href="/forum">forum</a>)<br/>[<a style="" href="/lib/?lang=EN&amp;index=TH#aef04">Back to index</a>] [<a href="/lib/aef04.html#disqus_thread">Comments</a>]<br/> <form method="post" action="">
<img src="/img/cache/0b9fd596a90421f9f1f68a9760275737.gif" alt="\text{T_EX size}" valign="middle"/>
<select name="TeX_size"><option value="-2">-2</option><option value="-1">-1</option><option value="0" selected="selected">0</option><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option> </select>
<input type="submit" value="Scale"/>
</form><form method="post" action=""><input type="hidden" name="pages" value="1"/><input type="submit" value="Turn on page numbers"/></form>
<address>
Also Associate Senior Professor at ESIEA - Laval <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="b8ded1d4d1d7d4f8ddcbd1ddd996deca">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script><br/>
E. Filiol is with the Lab. of Virology and Cryptology, ESAT, Rennes (France)<br/>
Email: <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="d8bdaab1bbf6beb1b4b1b7b498bdabb9acf6acbdaaaabdf6bcbdbebdb6abbdf6bfb7adaef6beaa">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>
</address>
<h2>Abstract</h2>
<p>This paper presents a formalisation of the different existing code mutation techniques (polymorphism and metamorphism) by means of formal grammars. While very few theoretical results are known about the detection complexity of viral mutation techniques, we exhaustively address this critical issue by considering the Chomsky classification of formal grammars. This enables us to determine which family of code mutation techniques are likely to be detected or on the contrary are bound to remain undetected. As an illustration we then present, on a formal basis, a proof-of-concept metamorphic mutation engine denoted PB MOT, whose detection has been proven to be undecidable.</p>
<p><strong>Keywords</strong> Polymorphism, Metamorphism, Formal Grammars, Formal Languages, Language Decision, Code Mutation, Word Problem.</p>
<h2>I. Introduction</h2>
<p>Polymorphism and metamorphism are the two techniques dedicated to hinder sequence-based antiviral detection. The principle is to cancel as much as possible any potential fixed element in a malware code that would represent a potential detection pattern. Polymorphism has formerly been introduced by Fred Cohen [5] with the concept of <em>Largest Viral Set</em> while metamorphism has appeared in the early 2000s as a response to the polymorphism's inherent limitations.</p>
<p>From a theoretical point of view [20], [21], the core of a polymorphic malware is its kernel which is made up of an infection trigger condition<sup><a href="#f1" name="b1">1</a></sup> <img src="/img/cache/5354f3368b049ed7a919de8181ca462e.gif" alt="I(d, p)" valign="middle"/>, a payload routine <img src="/img/cache/1d1e4261a7ac80044ab2ff3245548fb4.gif" alt="D(d, p)" valign="middle"/>, the corresponding payload trigger condition <img src="/img/cache/73935fb4b5311cef1414a3954cf6c0c5.gif" alt="T(d, p)" valign="middle"/> and a selection function <img src="/img/cache/be81fe0f3d9275a189495781bf2f49b8.gif" alt="S(p)" valign="middle"/> (of target programs to infect). It is precisely the latter function which is in charge of the code mutation.</p>
<p>Metamorphic viruses differ from polymorphic viruses since their respective selection function are different. While all polymorphic forms of a virus share the same kernel, the metamorphic forms of a virus have a completely different kernel. Consequently, if detection remains tractable for some classes of polymorphism - the kernel does not change during the mutation process and thus can be used as a detection pattern -, it becomes far different as far as metamorphism is concerned.</p>
<p>There are very few theoretical results concerning the detection complexity of code mutation techniques. This problem has been addressed very recently only. D. Spinellis has proved [17] that detection of bounded-length polymorphic viruses is an NP-complete problem. Zuo and Zhou [20] have then proved that the set <img src="/img/cache/a1384aa3ea4e1d4ca4707ed950caee26.gif" alt="D_i" valign="middle"/> of polymorphic viruses with an infinite number of forms is a <img src="/img/cache/9d60405a6eb677304d17a8029570a1ad.gif" alt="\Sigma_3" valign="middle"/>-complete set. Unfortunately, no results is known for other classes of polymorphic viruses and for the general case of metamorphism. Many open problems still remain.</p>
<p>Up to now, only very few examples of metamorphic codes are known to exist. The most sophisticated one is the <em>MetaPHOR</em> engine whose essential feature is a certain amount of non-determinism. Experiments in our laboratory showed that existing antivirus software can be very easily defeated by <em>MetaPHOR</em>-like technology. However, the analysis of this engine [9, Chap. 4] has proved that its metamorphic techniques still belong to trivial classes.</p>
<p>Our research thus focused on the formalisation of metamorphism by means of formal grammar and languages. We aimed at identifying the different possible classes of possible code mutation techniques. The first results, which are presented in this paper, enable to assert that detection complexity of code mutation techniques can be far higher that NP-complete and that for some well-chosen classes, detection is an undecidable problem.</p>
<p>The links between polymorphism and formal grammars has been introduced in [16] for the first time. Unfortunately, the author did touch on this issue only. Metamorphism is not addressed at all. Some aspects are dealt with in a very naive way and we will prove in this paper that some of its conclusions are totally wrong.</p>
<p>This paper is organised as follows. Section II presents the main theoretical tools of computability theory we use throughout this paper. Section III then explains how code mutation techniques can be modelled by formal grammars and how their detection can be reduced to the problem of deciding a language. Section IV will then presents our proof-of-concept metamorphic engine, denoted POC PBMOT we have designed in order to validate our theoretical model. In particular, we will show that detecting this engine is an undecidable problem. Section V finally concludes and present some future work.</p>
<h2>II. Formal grammars and rewriting systems</h2>
<p>Let us first recall basic notation and concepts we will use throughout this paper. We consider a finite set <img src="/img/cache/55d43d50bc656d9afcce848c99b6dca9.gif" alt="\Sigma=\{a_1,a_2,\dots,a_n\}" valign="middle"/> as an alphabet whose elements are called <em>symbols</em>. A sequence of symbols of <img src="/img/cache/025b3f94d79319f2067156076bf05243.gif" alt="\Sigma" valign="middle"/> is called a chain <img src="/img/cache/ce32fbdb4053db42c8ba27107e2817f1.gif" alt="b_1b_2b_3\dots b_m" valign="middle"/> with <img src="/img/cache/cf4ef15c2d207d7c95a5683d53275f69.gif" alt="b_i\in\Sigma" valign="middle"/> and <img src="/img/cache/646b7382394f363f9d6d4337e2f36b9c.gif" alt="m\ge0" valign="middle"/>. The concatenation of two chains <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/> and <img src="/img/cache/415290769594460e2e485922904f345d.gif" alt="y" valign="middle"/> is the chain <img src="/img/cache/6b97625d6efb0a68295e132cbd8aaa65.gif" alt="xy=b_1b_2\dots b_mc_1c_2\dots c_n" valign="middle"/>. Let <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/> and <img src="/img/cache/9d5ed678fe57bcca610140957afab571.gif" alt="B" valign="middle"/> two sets of chains defined over <img src="/img/cache/025b3f94d79319f2067156076bf05243.gif" alt="\Sigma" valign="middle"/>. Then we can
 
define the following sets:</p>
<img src="/img/cache/e134cdc9b2b4a3f4578396ac1dd040b6.gif" alt="
\begin{eqnarray}
	AB	&amp;=&amp; \{xy|x \in A, y \in B\},\\
	A^*	&amp;=&amp; \{x_1x_2\dots x_n|n\ge0, x_1,x_2,\dots, x_n \in A\},\\
	A^+	&amp;=&amp; \{x_1x_2\dots x_n|n\ge1, x_1,x_2,\dots, x_n \in A\}.\\
\end{eqnarray}
" valign="middle"/>
<p>This notation enables us to introduce the concept of <em>formal grammar</em>.</p>
<p><em>Definition 1:</em> [14] A <em>formal grammar</em> <img src="/img/cache/dfcf28d0734569a6a693bc8194de62bf.gif" alt="G" valign="middle"/> is the 4-tuple <img src="/img/cache/b9b0dbdbb9993c8ca56b37cb14649528.gif" alt="G = (N, T, S, R)" valign="middle"/> where:</p>
<ul>
<li><img src="/img/cache/8d9c307cb7f3c4a32822a51922d1ceaa.gif" alt="N" valign="middle"/> is a set of non-terminal symbols;</li>
<li><img src="/img/cache/b9ece18c950afbfa6b0fdbfa4ff731d3.gif" alt="T" valign="middle"/> is an alphabet of terminal symbols with <img src="/img/cache/2cf700c5f62a4b1e3ac2077858ff1000.gif" alt="N \cap T = \empty" valign="middle"/>;</li>
<li><img src="/img/cache/456d8795d36843124cf2ed825cad32a2.gif" alt="S \in N" valign="middle"/> is the start symbol;</li>
<li><img src="/img/cache/e1e1d3d40573127e9ee0480caf1283d6.gif" alt="R" valign="middle"/> is a rewriting system, that is to say a finite set of rules <img src="/img/cache/4e564a94dbabcbca873a7d508992df8e.gif" alt="R \subseteq (T \cup N)^* \times (T \cup N)^*" valign="middle"/>, such that <img src="/img/cache/383aba6cf3fbe1a88ca93020d3cd8532.gif" alt="(u, v) \in R \Rightarrow u \not\in T^*" valign="middle"/> (we cannot rewrite chains which contain only terminal symbols).</li>
</ul>
<p>The rewriting system (still known as <em>semi-Thue system</em>) over <img src="/img/cache/025b3f94d79319f2067156076bf05243.gif" alt="\Sigma" valign="middle"/> is in fact a finite subset of <img src="/img/cache/0658a69f1756b82e457bf4dd27cea51f.gif" alt="\Sigma^*\times\Sigma^*" valign="middle"/>. In other words, it is the set <img src="/img/cache/bf04a3ae1861f9f49a3460d88c8018ad.gif" alt="R=\{(u_1,v_1),\dots,(u_n,v_n)\}" valign="middle"/>. A pair <img src="/img/cache/fe988e33e5ebfde593352e1ccc6bc3df.gif" alt="(u,v)\in R" valign="middle"/> is a rewriting rule or <em>production</em>. It is denoted <img src="/img/cache/48f0dd69047cec4fe7855f902fb1c5e5.gif" alt="u::=v" valign="middle"/> for short (instead of <img src="/img/cache/32b8cb320da17c2f1c37d60cced2f000.gif" alt="(u,v) \in R" valign="middle"/>).</p>
<p>A rewriting system R enables to define a rewriting relation, denoted <img src="/img/cache/256272eb23724456a5eb3ba60318c23a.gif" alt="\Rightarrow{}_R" valign="middle"/> which is defined as:</p>
<p><img src="/img/cache/b34cb21a51b75b2645d63578fb7ee1e2.gif" alt="rus \Rightarrow rvs" valign="middle"/> if and only if <img src="/img/cache/fe988e33e5ebfde593352e1ccc6bc3df.gif" alt="(u,v)\in R" valign="middle"/> and <img src="/img/cache/68fe49bcb82b3176897c2421ca01a53f.gif" alt="(r,s)\in\Sigma^*\times\Sigma^*" valign="middle"/>.</p>
<p>This means that we can build the chain <img src="/img/cache/089d933c6704f0412f6ae2e48078b97b.gif" alt="rvs\in\Sigma^*" valign="middle"/> directly (e.g. in one step) from the chain <img src="/img/cache/783396da8a60191372d2e90b48a23ebe.gif" alt="rus\in\Sigma^*" valign="middle"/>.</p>
<p><em>Example 1:</em> [12] Let us consider <img src="/img/cache/4bb161603825edd5da4db3b62651c20d.gif" alt="\Sigma=\{A,a,b,c\}" valign="middle"/> and <img src="/img/cache/c2ae67b3347ec4455aaa0222a6ae4944.gif" alt="R=\{(A,aAa),(A,bAb),(A,c),(A,aca)\}" valign="middle"/>.</p>
<img src="/img/cache/d3a2f0e0c50e63e8db4fa0254fcc931f.gif" alt="
\begin{eqnarray}
	A	&amp;\Rightarrow{}_R&amp; aAa\\
	aAa	&amp;\Rightarrow{}_R&amp;	aaAaa\\
	aaAaa	&amp;\Rightarrow{}_R&amp;	aacaa\\
\end{eqnarray}
" valign="middle"/>
<p>This relation allows to define a reflexive and transitive closure for the relation <img src="/img/cache/055889aaee38b7c53f994c5e42a40994.gif" alt="\Rightarrow" valign="middle"/>. We will denote it <img src="/img/cache/06aab08e8ec4e0dbcc96b11e587d89ce.gif" alt="\Rightarrow{}^*_R" valign="middle"/>. This relation is defined, for every <img src="/img/cache/0491e1715566dae0698ce6f739c6842d.gif" alt="r,g,h" valign="middle"/> in <img src="/img/cache/c43403a72cac252deca347b8a80593e2.gif" alt="\Sigma^*" valign="middle"/> by:</p>
<ol>
<li>if <img src="/img/cache/995dab34a1d926a304e4399441ef5bdf.gif" alt="g\Rightarrow{}_R h" valign="middle"/> then <img src="/img/cache/66410564d979ca0972cbad13f645fa5e.gif" alt="g\Rightarrow{}^*_R h" valign="middle"/></li>
<li><img src="/img/cache/b2fc2e64e099c28e05ed856f9d209723.gif" alt="g\Rightarrow{}^*_R g" valign="middle"/></li>
<li>if <img src="/img/cache/032e4aec234a40cf8c88a398accf3fe6.gif" alt="g\Rightarrow{}^*_R r" valign="middle"/> and <img src="/img/cache/2692893c2315a5189e0596bf6cd201d3.gif" alt="r\Rightarrow{}^*_R h" valign="middle"/> then <img src="/img/cache/66410564d979ca0972cbad13f645fa5e.gif" alt="g\Rightarrow{}^*_R h" valign="middle"/>.</li>
</ol>
<p>Equivalently, two words are related with respect to this relation, if and only if one can be produced from the another. As an example, in the previous example, we can replace the symbol <img src="/img/cache/256272eb23724456a5eb3ba60318c23a.gif" alt="\Rightarrow{}_R" valign="middle"/> by <img src="/img/cache/06aab08e8ec4e0dbcc96b11e587d89ce.gif" alt="\Rightarrow{}^*_R" valign="middle"/>.</p>
<p>A Thue system is a semi-Thue system in which the relation <img src="/img/cache/06aab08e8ec4e0dbcc96b11e587d89ce.gif" alt="\Rightarrow{}^*_R" valign="middle"/> is symmetric. It is consequently denoted <img src="/img/cache/abe55442af07af8b5a508984d170e8e0.gif" alt="\Leftrightarrow{}^*_R" valign="middle"/>. Let us consider the following example.</p>
<p><em>Example 2:</em> Let us consider the grammar <img src="/img/cache/fa3c4726e563e879fa5dcd65202a12ea.gif" alt="G=(N,T,S,R)" valign="middle"/> with <img src="/img/cache/d9eb4983c02d85e75d2705788ca34cd1.gif" alt="T=\Sigma=\{0,1\}\cup\{\epsilon\},\ N=\{S,X,Y\}" valign="middle"/> and <img src="/img/cache/e1e1d3d40573127e9ee0480caf1283d6.gif" alt="R" valign="middle"/> defined by:</p>
<img src="/img/cache/95592557ecb2429906f221876bfebb3a.gif" alt="
\begin{eqnarray}
	S &amp;::=&amp; 1S|0S|X\\
	X &amp;::=&amp; 0Y\\
	Y &amp;::=&amp; 1Y|0Y|Z\\
	Z &amp;::=&amp; \epsilon
\end{eqnarray}
" valign="middle"/>
<p>This grammar builds every chain containing at least one zero.</p>
<p>A <em>formal language</em> is finally defined by the set <img src="/img/cache/6a7716ae80d8b87775ff92a8ca9eed9a.gif" alt="L(G)=\{x\in\Sigma^*|S\Rightarrow{}^* x\}" valign="middle"/> with respect to the grammar <img src="/img/cache/fa3c4726e563e879fa5dcd65202a12ea.gif" alt="G=(N,T,S,R)" valign="middle"/>. It is nothing more than the "words" (or chains) generated with respect to this grammar. From this point of view, natural languages and programming languages are just instances of a wider concept.</p>
<p>A huge classification work of formal grammars has been done by Noam Chomsky [3], [4]. This author has identified four different classes.</p>
<ul>
<li>Class 0 grammars (or <em>free grammars</em>). They are all grammars whose productions may be freely written as <img src="/img/cache/6719369765c07b338185acadc09c7fc4.gif" alt="x::=y" valign="middle"/> where <img src="/img/cache/415290769594460e2e485922904f345d.gif" alt="y" valign="middle"/> is an arbitrary chain of symbols taken in <img src="/img/cache/09fe283449c127ccbf480d35e10101e8.gif" alt="N\cup T" valign="middle"/>. These grammars all generate languages that can be decided by Turing machines. Equivalently, the languages they generate are recursively enumerable (see [6, Chap. 2]);</li>
<li>Class 1 grammars (or <em>context-sensitive grammars</em>). The unique constraint on the production lies in the fact that the size of words cannot decrease. Consequently, the only possible productions are in the form of <img src="/img/cache/6719369765c07b338185acadc09c7fc4.gif" alt="x::=y" valign="middle"/> as long as <img src="/img/cache/b12f729bb30e81aba878d8e43c13cbca.gif" alt="|y|\ge|x|" valign="middle"/>. This class contains all natural languages.</li>
<li>Class 2 grammars <em>context-free grammars</em>. They are all grammars whose productions are in the form of <img src="/img/cache/598db9b4dbf3c2e7a0297926b5f5fe99.gif" alt="X::=y" valign="middle"/> where <img src="/img/cache/02129bb861061d1a052c592e2dc6b383.gif" alt="X" valign="middle"/> is a unique nonterminal symbol and where <img src="/img/cache/415290769594460e2e485922904f345d.gif" alt="y" valign="middle"/> is an element of <img src="/img/cache/f65f8f418538d934c9364865f2a4e163.gif" alt="(N\cup T)^*" valign="middle"/>. The term <img src="/img/cache/02129bb861061d1a052c592e2dc6b383.gif" alt="X" valign="middle"/> can be rewritten independently from its context contrary to class 1 grammars. Subsets of class 2 grammars are commonly used to implement programming languages.</li>
<li>Class 3 grammars (or <em>regular grammars</em>). They are all grammars whose productions are in the form of <img src="/img/cache/914a9ecce9cd947b1153df658b38c433.gif" alt="X::=x" valign="middle"/> or <img src="/img/cache/3c28ba717afac445758b68361a69d1ed.gif" alt="X::=xY" valign="middle"/> with <img src="/img/cache/0d713a677596cc53ff785041bd0e1316.gif" alt="(X,Y)\in N^2" valign="middle"/> and <img src="/img/cache/dbaf93e52e2a8b99f4fa08db17630640.gif" alt="x\in T^*" valign="middle"/>.</li>
</ul>
<h2>III. Polymorphism, metamorphism and formal grammars</h2>
<p>In this section, we will first formalise code mutation in term of rewriting techniques. We will then be able to exhaustively address the complexity of code mutation detection according to the class of the grammar in use.</p>
<h3>A. Code mutation and Formal Languages</h3>
<p>Let us consider the set of x86 instructions as our working alphabet. These instructions may be combined according to (rewriting) rules that completely define every compiler. This set of rules can be defined as a class 2 formal grammar indeed. The assembly language is then the language which is generated by this grammar.</p>
<p>Implementing a polymorphic engine - in particular the garbage generator which is its most important part - consists in generating a formal language, denoted <em>polymorphic language</em>, with its own grammar.</p>
<p>Let us consider a polymorphic engine generated by the grammar (the example is derived from [16]).</p>
<img src="/img/cache/2548a93a8adbcbf60d426795f0cfe75a.gif" alt="G=\{\{A,B\},\{a,b,c,d,x,y\},S,R\}." valign="middle"/>
<p>Instructions <img src="/img/cache/a44c56c8177e32d3613988f4dba7962e.gif" alt="a,b,c" valign="middle"/> and <img src="/img/cache/8277e0910d750195b448797616e091ad.gif" alt="d" valign="middle"/> represent garbage code while instructions <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/> and <img src="/img/cache/415290769594460e2e485922904f345d.gif" alt="y" valign="middle"/> are the decryptor's instructions (e.g. <em>x</em>=<code>XOR [EDI],AL</code>,
 
and <em>y</em>=<code>INC EDI</code>). The rewriting system <img src="/img/cache/e1e1d3d40573127e9ee0480caf1283d6.gif" alt="R" valign="middle"/> can be defined as:</p>
<img src="/img/cache/b1b9a7daf7fffebacddad8a319e88f60.gif" alt="
\begin{eqnarray}
	S &amp;::=&amp; aS|bS|cS|xA\\
	A &amp;::=&amp; aA|bA|cA|dA|yB\\
	B &amp;::=&amp; aB|bB|cB|dB|\epsilon
\end{eqnarray}
" valign="middle"/>
<p>Consequently, our polymorphic language is made up of every word in the form of</p>
<img src="/img/cache/6645c23d1f431d43a209218908dda95e.gif" alt="\{a,b,c,d\}^* x\{a,b,c,d\}^* y\{a,b,c,d\}^*." valign="middle"/>
<p>Every of these words corresponds to a mutated variant of the initial decryptor. It is thus "easy" (e.g for an antivirus software) to determine that the word <code>abcddxd</code> is not in this language with respect to <img src="/img/cache/dfcf28d0734569a6a693bc8194de62bf.gif" alt="G" valign="middle"/>, contrary to the word <code>adcbxaddbydab</code>. Other examples of less trivial polymorphic grammars are presented in [9, Chap. 6].</p>
<p>All this being defined, the essential issue for any antivirus is to have an algorithm which is able to determine whether a "word" (a mutated form) belongs to a polymorphic language or not. But as soon as we consider sophisticated polymorphic techniques, this ability is very difficult to evaluate. That is precisely the interest of modelling code mutation with formal grammars. According to the grammar class, we can get a more accurate insight of the detection complexity.</p>
<h3>B. Antiviral Detection and Language Decision</h3>
<p>In order to set up our model, let us consider the following definition.</p>
<p><em>Definition 2:</em> [12] Let <img src="/img/cache/fa3c4726e563e879fa5dcd65202a12ea.gif" alt="G=(N,T,S,R)" valign="middle"/> be a grammar and <img src="/img/cache/dbaf93e52e2a8b99f4fa08db17630640.gif" alt="x\in T^*" valign="middle"/> a chain with respect to <img src="/img/cache/dfcf28d0734569a6a693bc8194de62bf.gif" alt="G" valign="middle"/>. The <em>language decision problem</em> with respect to <img src="/img/cache/dfcf28d0734569a6a693bc8194de62bf.gif" alt="G" valign="middle"/> consists in determining whether <img src="/img/cache/80ccb8e12ce35997e04b47e76f9f5541.gif" alt="x\in L(G)" valign="middle"/> or not. The <em>language completeness problem</em> is that which aims at deciding whether <img src="/img/cache/580581288addf5c56a96ce83eb11ad82.gif" alt="L(G)=T^*" valign="middle"/> or not.</p>
<p>The first problem models the detection problem of polymorphism (once the relevant grammar is known). The second one models the concepts of non detection and false positive.</p>
<p>In order to address the detection problem, let us just recall the existing algorithmic tools we have at our disposal's. They will thus enable us to give complexity results with the different instances of this problem. A detailed description of these tools can be found in any computability handbook (e.g [12]). The generic tool is a finite automaton. Two different kinds of automata are to be considered.</p>
<ul>
<li><em>Deterministic Finite Automata</em> (DFA). It is the most simple form of automaton. It may be represented by a directed graph, whose nodes are the possible states of the automaton and the arcs joining nodes are labelled by symbols of the alphabet. The symbols in fact deterministically define the transition condition from one state to another state.</li>
<li><em>Non deterministic Finite Automaton</em> (NFA). It is a generalised automaton. The essential difference with a DFA comes from the fact that more than one arc with the same label can start from a node. This means that from one given state, a condition can result in different effects. As a result we got a far higher number of evolving capabilities but also a far higher computing complexity. Moreover, NFAs allow transitions on the empty strings.</li>
</ul>
<p>We can now formalise the action of any antivirus with respect to code mutation detection. Without loss of generality, we will consider NFAs only (in fact it is possible to reduce a NFA to a DFA, up to an exponential increase of the number of states [14]).</p>
<p><em>Definition 3:</em> [12] We say that a chain <img src="/img/cache/04c39988924f78b827f7dbafa01902ad.gif" alt="x=x_1x_2\dots x_n" valign="middle"/> with <img src="/img/cache/b7a35a039219b15d0f5653c635f3449c.gif" alt="x_i\in\Sigma" valign="middle"/> is decided by an automaton<sup><a href="#f2" name="b2">2</a></sup> <img src="/img/cache/4107309c79cf14f03e79a3cce1b828b3.gif" alt="A=(Q,\Sigma,\tau,q_0,F)" valign="middle"/> if there exist a state sequence <img src="/img/cache/a27a72cb0505db39f9e50bbc1510660c.gif" alt="q_1,q_2,\dots,q_{n+1}" valign="middle"/> of <img src="/img/cache/f09564c9ca56850d4cd6b3319e541aee.gif" alt="Q" valign="middle"/> and a symbol sequence <img src="/img/cache/555cd1621a55204bccb1729027075f5b.gif" alt="x_1,x_2,\dots,x_n" valign="middle"/> of <img src="/img/cache/e3a0cc6ceb67575578d1bab8317797a4.gif" alt="|Sigma\cup\{\epsilon\}" valign="middle"/> such that <img src="/img/cache/01b80e0d9ed67f6f39e000ad41a1ed05.gif" alt="q_{i+1}\in \tau(q_i,x_i)" valign="middle"/> for every <img src="/img/cache/859b52095f24e72d1f9d297bb4f9d21c.gif" alt="i\in\{1,2,\dots,n\}" valign="middle"/> with <img src="/img/cache/9b3f59bd020159e720ae9248a55a7aea.gif" alt="q_0=q_1" valign="middle"/>. Then we note <img src="/img/cache/0dd431587e81bc100334b3d78d532a54.gif" alt="L(A)" valign="middle"/> the set of any chain detected by <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/>. It is the language decided by <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/>. In other words, <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/> decides whether <img src="/img/cache/00a8e746a54f3080ef4f37fb99887826.gif" alt="L(A)=L(G)" valign="middle"/> or not. Consequently, the automaton <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/> is a solution of the language decision problem with respect to the grammar <img src="/img/cache/dfcf28d0734569a6a693bc8194de62bf.gif" alt="G" valign="middle"/>.</p>
<p>This definition describes the fact that as soon as an antivirus software embeds an automaton <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/> which is able to solve the (polymorphic) decision problem with respect to a given polymorphic grammar, then it is able to detect any of its "polymorphic words" (e.g mutated forms). Two critical issues are then to be considered:</p>
<ul>
<li>the relevant complexity of the automaton,</li>
<li>every time the polymorphic grammar is changing (e.g. the polymorphic engine is a new one), the antivirus software must be upgraded with a new automaton which decides the new polymorphic language.</li>
</ul>
<p>The last points underlines the essential interest of metamorphic techniques compared to polymorphic ones. That is the reason why antivirus software are bound to be defeated by metamorphism. Indeed every new metamorphic mutation aims at producing a new grammar and a new word generated by the latter at the same time. Consequently, we define metamorphism as a grammar whose words are themselves a set of productions with respect to a grammar. This may be sound as a naive assumption about antivirus software. Unfortunately, it is not. It has been proved in [7], [8] that these software still heavily relies on first- or second generation scanning techniques contrary to what is claimed by the antivirus vendors.</p>
<p>Let us now consider our formal definition of metamorphism.</p>
<p><em>Definition 4:</em> (Metamorphic Virus) Let <img src="/img/cache/4d5350f983c5c39f95036d561df5768e.gif" alt="G_1=(N,T,S,R)" valign="middle"/> and <img src="/img/cache/af6e7c37b685df5ce7ab3f0b020e72e4.gif" alt="G_2=(N',T',S',R')" valign="middle"/> be grammars where <img src="/img/cache/6f3357ae1d6de5c7df30cf8503177f87.gif" alt="T'" valign="middle"/> is a set of formal grammars, <img src="/img/cache/00226656ea0692401f9834fe6994da11.gif" alt="S'" valign="middle"/> is the (starting) grammar <img src="/img/cache/b57eb533b3d9c18d104bb0b9a5a80bbe.gif" alt="G_1" valign="middle"/> and <img src="/img/cache/e7df32a1c68b30bea84a21f5867910b5.gif" alt="R'" valign="middle"/> a rewriting system with respect <img src="/img/cache/1e9aa4debb0c51867cdb9212210d1492.gif" alt="(N'\cup T')^*" valign="middle"/>. A metamorphic virus is thus described by <img src="/img/cache/ade318cc7367b7f1b4127eddc5f4899f.gif" alt="G_2" valign="middle"/> and every of its mutated form is a word in <img src="/img/cache/b4de55bcdf7d5d2534357a053bb999b1.gif" alt="L(L(G_2))" valign="middle"/>.</p>
<p>The notation <img src="/img/cache/b4de55bcdf7d5d2534357a053bb999b1.gif" alt="L(L(G_2))" valign="middle"/> which is more practical, stands for <img src="/img/cache/2054ddef5ff1df5a5e8c1d50a812fefe.gif" alt="L(x)" valign="middle"/> for some <img src="/img/cache/41d47ff0cefc13eaf755a416fc5d1c6d.gif" alt="x\in L(G_2)" valign="middle"/> where <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/> is a grammar. This definition describes the fact that from one metamorphic form to another, the virus kernel is changing: the virus is mutating and change the mutation rules at the same time. Section IV will present a proof-of-concept of this formalisation. Definition 4 in fact somehow relates to <em>two-level grammars</em> (or Van
 
Wijngaarden grammars; 2VW grammars for short) [19], [10] in which grammar <img src="/img/cache/ade318cc7367b7f1b4127eddc5f4899f.gif" alt="G_2" valign="middle"/> can be compared to some extent to the 2VW metagrammar. It is an open problem, at the moment, to determine whether our construction of Definition 4 is a particular case of 2VW grammars or not.</p>
<p>As a first consequence, managing metamorphism implies to have suitable automata at our disposal's in order to solve the language decision problem with respect to <img src="/img/cache/ade318cc7367b7f1b4127eddc5f4899f.gif" alt="G_2" valign="middle"/>-like grammars.</p>
<p>We now can give complexity results for this problem, according to the existing grammar classes:</p>
<p><em>Proposition 1:</em> The language decision problem:</p>
<ul>
<li>is undecidable for class 0 grammars;</li>
<li>has NP-complexity for class 1 and class 2 grammars;</li>
<li>has polynomial complexity for class 3 grammars.</li>
</ul>
<p><em>Proof:</em> This proof has been established by summarizing results given in [11], [14]. As far as class 0 grammars are concerned, we show that they generate recursively enumerable languages (their productions simulate Turing machines). Consequently, deciding whether <img src="/img/cache/80ccb8e12ce35997e04b47e76f9f5541.gif" alt="x\in L(G)" valign="middle"/> or not for given <img src="/img/cache/dfcf28d0734569a6a693bc8194de62bf.gif" alt="G" valign="middle"/> and <img src="/img/cache/af2bbcf619f9b6706ddfd472712d48b3.gif" alt="x\in\Sigma" valign="middle"/> reduces the Halting problem.</p>
<p>For class 2, the language decision problem can be solved with non deterministic pushdown automata while class 1 grammars, it is solved with linear-bounded non deterministic Turing machines. Lastly, class 3 grammars are solved by deterministic ones. Hence the results.</p>
<p>Proposition 1 stresses on the fact that the choice of underlying grammar is essential when designing a polymorphic engine. It has a direct impact on its resistance against its potential detection. Quite all known polymorphic engines refer to class 3 grammars. That is the reason why they can be successfully detected. But contrary to claims in [16] about systematic detection capabilities, intractability (classes 2 and 1) or even worse impossibility (class 0) rule out the practical detection when considering the cases of code mutation engines with respect to higher classes of grammars. From a practical point of view, no antivirus can monopolize computer resources for minutes or even hours to solve some rather computable instances of a NP problem. Nowadays, our saving grace is that malware writers still seem to neglect or ignore what are the "good" grammars (or the "worst" ones from the defense point of view). This statement of course only holds for already detected or detectable malware.</p>
<p>There exist a huge number of theoretical results in the field of formal languages [2] that can be used to build code mutation techniques that are untractable or even impossible to detect. From a general point of view, the approach consists in considering the undecidability status for some known problem. In this respect, we may consider the Rice's Theorem. Let us consider a trivial property <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/> about a language; in other words, there exists at least one recursively enumerable language (class 0) <img src="/img/cache/d20caec3b48a1eef164cb4ca81ba2587.gif" alt="L" valign="middle"/> for which <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/> holds and at least one recursively enumerable language <img src="/img/cache/ea431f3fbe364c2fea2e24bd33a7abc5.gif" alt="L'" valign="middle"/> for which <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/> does not.</p>
<p><em>Theorem 1:</em> (Rice's Theorem [12]) For any non trivial property <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/> with respect of languages, the problem of determining whether <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/> holds for a language <img src="/img/cache/329217273a850d7c697ffe9d5a1e4fd4.gif" alt="L(M)" valign="middle"/> of a Turing machine <img src="/img/cache/69691c7bdcc3ce6d5d8a1361f22d04ac.gif" alt="M" valign="middle"/>, in undecidable.</p>
<p>This theorem is essential since it clearly indicates in which context to look at in order to systematically defeat antivirus.</p>
<p>We will consider this in Section IV.</p>
<p>To end with formal grammars, it is worth giving the following results, whose proof will be found in [12, &sect;10.4].</p>
<p><em>Theorem 2:</em> Let <img src="/img/cache/80d906bee198388d9acf1c2ff286412a.gif" alt="G_i=(N_i,T_i,S_i,R_i)" valign="middle"/> with <img src="/img/cache/d24da99f976bd259b127a9bec9f3c4f8.gif" alt="i=1,2" valign="middle"/> two context-free grammars. Deciding whether <img src="/img/cache/766657b3066b49303191f678ede87bdb.gif" alt="L(G_1)\cap L(G_2)=\empty" valign="middle"/> or not is an undecidable problem. Determining whether <img src="/img/cache/aa2d6ff6ad849a67f62d2ec21c21de76.gif" alt="L(G_i)=T^*_i" valign="middle"/> or not is undecidable as well.</p>
<p>These two results, in the special context of context-free grammars illustrates the concepts of false positive (grammar <img src="/img/cache/b57eb533b3d9c18d104bb0b9a5a80bbe.gif" alt="G_1" valign="middle"/> is not a viral one while grammar indeed is a viral one) and of non detection, as far as antiviral detection is concerned [9, Chap. 2 and 4].</p>
<h2>IV. Undecidable mutation techniques</h2>
<h3>A. The Word Problem</h3>
<p>The <em>word problem</em> has been introduced and formalised by E. Post in 1950 [15]. Aside the Turing's Halting problem, it is one of the most famous problem which is known to be undecidable. This problem consists in deciding whether two finite words <img src="/img/cache/4b43b0aee35624cd95b910189b3dc231.gif" alt="r" valign="middle"/> and <img src="/img/cache/03c7c0ace395d80182db07ae2c30f034.gif" alt="s" valign="middle"/> over an alphabet <img src="/img/cache/025b3f94d79319f2067156076bf05243.gif" alt="\Sigma" valign="middle"/> are equivalent or not, up to a rewriting system <img src="/img/cache/e1e1d3d40573127e9ee0480caf1283d6.gif" alt="R" valign="middle"/>. In other words, it consists in deciding whether <img src="/img/cache/d510711236046fb82e1614c95ac9325b.gif" alt="r\Rightarrow{}^*_R s" valign="middle"/> or not.</p>
<p><em>Theorem 3:</em> [15] The word problem with respect to a semi-Thue system is undecidable.</p>
<p>The proof consists in reducing the word problem to the Halting problem which is itself undecidable.</p>
<p><em>Example 3:</em> (Tzeitzin semi-Thue Systems) Let the rewriting system <img src="/img/cache/e1e1d3d40573127e9ee0480caf1283d6.gif" alt="R" valign="middle"/> defined over the alphabet <img src="/img/cache/d52c06397c30b9c5094dd4e83d7025ec.gif" alt="\Sigma=\{a,b,c,d,e\}" valign="middle"/>.</p>
<img src="/img/cache/431bad2f269848d44b60f4582e182b8e.gif" alt="
\begin{align}
	(ac, ca),	&amp;\text{commutation}\\
	(ad, da),	&amp;\\
	(bc, cb),	&amp;\\
	(bd, db),	&amp;\\
	(eca, ce),	&amp;\\
	(edb, de),	&amp;\\
	(cca, ccae)	&amp;\text{deletion/insertion}
\end{align}
" valign="middle"/>
<p>This semi-Thue system is called <em>Tzeitsin system</em> [18]. It is the smallest semi-Thue system which is known to be undecidable. We will denote it <img src="/img/cache/ab4ffa55f688360e0c12aef543c18351.gif" alt="T_0" valign="middle"/>. As a consequence, any semi-Thue system which contains <img src="/img/cache/ab4ffa55f688360e0c12aef543c18351.gif" alt="T_0" valign="middle"/> is itself undecidable. There exist many other undecidable Thue systems. We will use in the rest of the paper the Tzeitsin system <img src="/img/cache/2452fee413f58bb9509e88d80d4b9f8d.gif" alt="T_1" valign="middle"/> defined by:</p>
<img src="/img/cache/1e202237ed582fc79d735cee71391b85.gif" alt="
\begin{align}
	(ac, ca),&amp;\\
	(ad, da),&amp;\\
	(bc, cb),&amp;\\
	(bd, db),&amp;\\
	(eca, ce),&amp;\\
	(edb, de),&amp;\\
	(cdca, cdcae),&amp;\\
	(caaa, aaa),&amp;\\
	(daaa, aaa)&amp;\\
\end{align}
" valign="middle"/>
 
<h3>B. Code Mutation Based on The Word Problem: the PBMOT engine</h3>
<p>The central principle is to use formal grammars whose rewriting system is a Thue system which itself contains a Tzeitsin system or any other system which is known to be undecidable. From a general point of view, this implies that the code mutation engine based on such grammars will be undecidable as well. The core approach to design such an engine is to practically implement the concept of Definition 4. In other words, the engine's rewriting rules (namely the mutation rules) will change from mutation to mutation. For that purpose, two main constraints are to be satisfied:</p>
<ul>
<li>the rewriting system of <img src="/img/cache/ade318cc7367b7f1b4127eddc5f4899f.gif" alt="G_2" valign="middle"/> contains an undecidable Thue system;</li>
<li>every word (hence a grammar) in <img src="/img/cache/3032c2e1a73405d40a1db3911d5d7efa.gif" alt="L_i(G_2)" valign="middle"/>, during the <em>i</em>-th mutation step, contains an undecidable Thue system as well.</li>
</ul>
<p>From an implementation point of view, the central approach consists in coding the rewriting system of <img src="/img/cache/3032c2e1a73405d40a1db3911d5d7efa.gif" alt="L_i(G_2)" valign="middle"/> grammars as words on the alphabet <img src="/img/cache/21630fc90118a84bcdd77dbd7aae4a67.gif" alt="(N \cup T)^*" valign="middle"/> where the sets <img src="/img/cache/b9ece18c950afbfa6b0fdbfa4ff731d3.gif" alt="T" valign="middle"/> and <img src="/img/cache/8d9c307cb7f3c4a32822a51922d1ceaa.gif" alt="N" valign="middle"/> are those of grammars <img src="/img/cache/90a9fbcd9e6f45b9ff63f0d730694a0d.gif" alt="G^i_1" valign="middle"/>. In other words the set <img src="/img/cache/e1e1d3d40573127e9ee0480caf1283d6.gif" alt="R" valign="middle"/> of rules (with respect to grammar <img src="/img/cache/90a9fbcd9e6f45b9ff63f0d730694a0d.gif" alt="G^i_1" valign="middle"/>):</p>
<img src="/img/cache/0857559224a44b4b2197fd5e32f9106b.gif" alt="R=\{(u_1,v_1),(u_2,v_2),\dots,(u_n,v_n)\}" valign="middle"/>
<p>is coded as the following word:</p>
<img src="/img/cache/c6d7d05a8ca6ece677c38d8e7fd13568.gif" alt="u_1v_1u_2v_2\dots u_{n-1}v_{n-1}u_nv_n,\hspace{100}(1)" valign="middle"/>
<p>made of terminal and non terminal symbols.</p>
<p>The other essential point is to design a grammar <img src="/img/cache/ade318cc7367b7f1b4127eddc5f4899f.gif" alt="G_2" valign="middle"/> which is able to manipulate such "grammar-words". The set <img src="/img/cache/6f3357ae1d6de5c7df30cf8503177f87.gif" alt="T'" valign="middle"/> contains words build on <img src="/img/cache/21630fc90118a84bcdd77dbd7aae4a67.gif" alt="(N \cup T)^*" valign="middle"/> (Equation 1). As for the set <img src="/img/cache/ec8122992f75ff07b4c27581836f6269.gif" alt="N'" valign="middle"/>, it contains symbols which are specific to the grammar <img src="/img/cache/ade318cc7367b7f1b4127eddc5f4899f.gif" alt="G_2" valign="middle"/> but it can also contains symbols in <img src="/img/cache/8d9c307cb7f3c4a32822a51922d1ceaa.gif" alt="N" valign="middle"/>. The starting element is a word in <img src="/img/cache/f8f4bd15d9bcb93a5fe9ed871e972de1.gif" alt="(N'\cup T)^*" valign="middle"/>. We just have to deal with the rewriting system <img src="/img/cache/e7df32a1c68b30bea84a21f5867910b5.gif" alt="R'" valign="middle"/> on words of <img src="/img/cache/21630fc90118a84bcdd77dbd7aae4a67.gif" alt="(N \cup T)^*" valign="middle"/> with the constraint that <img src="/img/cache/0eb25e47eb1461e8b37680f115885a87.gif" alt="R \supset T_0" valign="middle"/> or <img src="/img/cache/51c227ac26ad6b0e8e435b0e8861d03e.gif" alt="R' \supset T_1" valign="middle"/>.</p>
<p>If the general principle ruling the design of grammar <img src="/img/cache/ade318cc7367b7f1b4127eddc5f4899f.gif" alt="G_2" valign="middle"/> is simple to grasp, on the other hand its practical construction is technically far more complex. We will not present here due to lack of space - it would require tens of pages - but also not to give ready-to-use techniques that could be misused. We will give the two core principles of this practical construction only:</p>
<ul>
<li>the final code must be envisaged in functional terms and not in terms of code (assembly instructions). This point is critical since it is not the form of the different instructions but their interactions which is the most important aspect. If the rewriting rules are not trivial ones, the code mutation, in terms of opcodes, will work in a straightforward and "natural" way. From a technical point of view, this means that the rewriting rules have to deeply modify in words <img src="/img/cache/f0347d1ad77f78fb060e21a04bd62577.gif" alt="u_1v_1u_2v_2\dots u_{n-1}v_{n-1}u_nv_n" valign="middle"/>, both the order of the <img src="/img/cache/8a2885a17eb26a7b2c9ad0069f2b274e.gif" alt="u_iv_i" valign="middle"/> and the pairs <img src="/img/cache/98fda5c4b7dc5b53d1a85dc79249e320.gif" alt="(u_i,v_i)" valign="middle"/> themselves at the same level;</li>
<li>the whole code must be organised in terms of procedures (or blocks of codes) even if the coding itself is not structured in this way.</li>
</ul>
<p>The deep nature of the chosen rules as well as their more or less sophisticated level will have a direct impact on the detectability of the engine which embeds them.</p>
<p>As far as our POC_PBMOT is concerned, the <em>MetaPHOR</em> engine code has been considered as a starting point. The design steps are hereafter presented.</p>
<ol>
<li>the different modules of the <em>MetaPHOR</em> engine have been analysed in depth[9, Chap. 4]. The set <img src="/img/cache/b9ece18c950afbfa6b0fdbfa4ff731d3.gif" alt="T" valign="middle"/> has then been built accordingly: it corresponds, up to some minor differences, to the different possible instructions;</li>
<li>in a second step, our analysis aimed at indentifying the main functionalities involved in the code mutation. A proto-rewriting (embryonic) system <img src="/img/cache/55958e88ca536f52b44d0f5670cd292a.gif" alt="R'_0" valign="middle"/> has been first designed, in such way that it includes the <img src="/img/cache/ab4ffa55f688360e0c12aef543c18351.gif" alt="T_0" valign="middle"/> system. The system <img src="/img/cache/55958e88ca536f52b44d0f5670cd292a.gif" alt="R'_0" valign="middle"/> is a framework whose essential role is to perform code mutation itself. In other words, the rewriting takes the pairs <img src="/img/cache/98fda5c4b7dc5b53d1a85dc79249e320.gif" alt="(u_i,v_i)" valign="middle"/> in words <img src="/img/cache/f0347d1ad77f78fb060e21a04bd62577.gif" alt="u_1v_1u_2v_2\dots u_{n-1}v_{n-1}u_nv_n" valign="middle"/> into consideration. At this early stage, the set <img src="/img/cache/8d9c307cb7f3c4a32822a51922d1ceaa.gif" alt="N" valign="middle"/> is not defined yet;</li>
<li>the analysis was then concerned with modifying the functions involved in the code transformation at a metalevel (the central point in metamorphism). This part has enabled to choose the set <img src="/img/cache/8d9c307cb7f3c4a32822a51922d1ceaa.gif" alt="N" valign="middle"/> of non terminal symbols in a first step. These symbols are essential since they are directly implied in the structure of the words in the form of <img src="/img/cache/f0347d1ad77f78fb060e21a04bd62577.gif" alt="u_1v_1u_2v_2\dots u_{n-1}v_{n-1}u_nv_n" valign="middle"/> at a macro-level. In a second step, the proto-system <img src="/img/cache/55958e88ca536f52b44d0f5670cd292a.gif" alt="R'_0" valign="middle"/> has been modified and tuned up in order to achieve the final rewriting system <img src="/img/cache/e7df32a1c68b30bea84a21f5867910b5.gif" alt="R'" valign="middle"/> which includes the <img src="/img/cache/2452fee413f58bb9509e88d80d4b9f8d.gif" alt="T_1" valign="middle"/> system.</li>
</ol>
<p>The critical point lies in the mutation of a word in the form of</p>
<img src="/img/cache/f0347d1ad77f78fb060e21a04bd62577.gif" alt="u_1v_1u_2v_2\dots u_{n-1}v_{n-1}u_nv_n" valign="middle"/>
<p>into a system</p>
<img src="/img/cache/84f02f225fdd510ec651bc4a24e217df.gif" alt="R=\{(u_1,v_1),(u_2,v_2),\dots,(u_n,v_n)\}." valign="middle"/>
<p>Indeed, the successive rewriting steps may induce variations of size in subwords <img src="/img/cache/eb00a04135562ae6f74786f084f54327.gif" alt="u_i" valign="middle"/> and <img src="/img/cache/1df181eaa1bb40a0067c06ead197170d.gif" alt="v_i" valign="middle"/>. It is thus necessary to record and update all these variations. In the same or equivalent way as the <em>MetaPHOR</em> engine does, the rewriting management must take the conditional or not jumps into account.</p>
<p>We now can state the following result.</p>
<p><em>Proposition 2:</em> The detection of POC_PBMOT-based metamorphic codes is an undecidable problem.</p>
<p><em>Sketch of Proof.</em></p>
<p>Every mutated form <img src="/img/cache/8fcc648a777765ea6e3142751c9ec5ea.gif" alt="\nu_i" valign="middle"/> is a word in the form of</p>
<img src="/img/cache/06ecb6d48821cfd50e73a94eb4407572.gif" alt="L(L_i(G_2)) = L(u^i_1v^i_1u^i_2v^i_2\dots u^i_{n-1}v^i_{n-1}u^i_nv^i_n)." valign="middle"/>
<p>Detecting such a code consists in deciding whether two words</p>
<img src="/img/cache/067c80bee86acc9bc320144295344496.gif" alt="\nu_i = u^i_1v^i_1u^i_2v^i_2\dots u^i_{n-1}v^i_{n-1}u^i_nv^i_n" valign="middle"/>
<p>and</p>
<img src="/img/cache/3a8195577030e669749b8b8f26e9ef59.gif" alt="\nu_j = u^j_1v^j_1u^j_2v^j_2\dots u^j_{n-1}v^j_{n-1}u^j_nv^j_n" valign="middle"/>
 
<p>with <img src="/img/cache/3e2c2aaa4cdba2784fb9282a642322ff.gif" alt="j\gt i" valign="middle"/>, are such that <img src="/img/cache/b22d886dae71d9b6886406369c19b6d9.gif" alt="\nu_i\Leftrightarrow{}^*_{G_2} \nu_j" valign="middle"/>. Grammar <img src="/img/cache/ade318cc7367b7f1b4127eddc5f4899f.gif" alt="G_2" valign="middle"/> contains <img src="/img/cache/ab4ffa55f688360e0c12aef543c18351.gif" alt="T_0" valign="middle"/> and <img src="/img/cache/2452fee413f58bb9509e88d80d4b9f8d.gif" alt="T_1" valign="middle"/> systems, which are undecidable systems. Hence the result.</p>
<div align="right"><img src="/img/cache/09cfa2435552d2f8a90d85e99701606a.gif" alt="\boxempty" valign="middle"/></div>
<p><em>Remark.</em> Proposition 2 refers to sequence based detection, in other words not in an execution context. In particular, it implies that potential successful detection is bound to consider another approach like behaviour monitoring. In this latter case, it not sure that antivirus software would be more efficient at detecting a PB_MOT-like metamorphic engine [8].</p>
<h3>C. Discussion</h3>
<p>In [13], it has been suggested that metamorphic viruses are ultimately constrained in complexity. To quote the authors <em>"...a metamorphic must be able to disassemble and reverse itself. Thus a metamorphic virus cannot utilize [...] techniques that make it harder or impossible for its code to be disassembled or reverse engineered by itself."</em> So what about the detection of PB_MOT metamorphic codes? Two different aspects are to be considered:</p>
<ul>
<li>any sequence-based detection will fail since mutation is based on indecidable problems as stated by Proposition 2;</li>
<li>in an execution context, indeed the code has to disassembly itself into a code that the processor is able to run in order the virus operates. That means that once the code is unprotected, it may be analysed. From a theoretical point of view, this is true but antivirus and virus are not bound to play the same game. As shown in [1], [9] with <img src="/img/cache/a6f317b268ae825d94f832f970af607c.gif" alt="\tau" valign="middle"/>-obfuscation, a metamorphic malware can delay its own disassembly more than the antivirus can accept. While indeed ultimately constrained in complexity, any metamorphic malware can reverse engineer itself in an arbitrary time <img src="/img/cache/a6f317b268ae825d94f832f970af607c.gif" alt="\tau" valign="middle"/> contrary to any antivirus, which is a commercial product before anything else.</li>
</ul>
<h2>V. Future work and conclusion</h2>
<p>Mutation code techniques are very efficient at practically hindering or even forbidding antiviral detection. But those techniques must be efficient enough. The theoretical approach with formal grammars is a new, promising way to systematically distinguish efficient techniques from non trivial or unefficient ones. Until now, known (theoretically detected) metamorphic codes refer to rather naive or trivial instances for which detection remains "easy".</p>
<p>Existing mutation code techniques, by definition, aim at preventing sequence-based detection, in a broader meaning of the term. On the other hand, some behaviours may represent useful invariant that could be considered by antivirus in the future. Consequently, the next step is likely to be behavioural polymorphism/metamorphism: code behaviours both at the micro- and the macro level would change from replication to replication. Current work in our laboratory already shows that this approach is not only powerful but also very worrying in terms of antiviral detection and protection.</p>
<p>It is nothing but very likely that if technical solutions to detect metamorphic codes exist, they would be non suitable for commercially-viable antivirus software. This is essentially due to the intrinsic algorithmic complexity of the detection algorithms. On the other hand, grammar-based formalisation should help antivirus programmers to identify and choose more powerful detectors to better manage existing code mutation techniques. Second generation scanners do not explore all the might of deterministic and non deterministic automata. As a consequence, existing antivirus can still be defeated by classical code mutation techniques.</p>
<h2>References</h2>
<ol>
<li>Beaucamps P., Filiol E. (2006), On the possibility of practically obfuscating programs - Towards a unified perspective of code protection, <em>Journal in Computer Virology</em>, (2)-4, WTCV'06 Special Issue, G. Bonfante &amp; J.-Y. Marion eds.</li>
<li>Carton O. (2006), <em>Langages formels, calculabilit&eacute; et complexit&eacute;</em>, Cours de l'&Eacute;cole Normale Sup&eacute;rieure. Available on http://www.jussieu.fr/~carton/Enseignement/Complexite/ENS/Support/</li>
<li>Chomsky N. (1956), Three models for the description of languages, <em>IRE Transactions on Information Theory</em>, 2, pp. 113-124.</li>
<li>Chomsky N. (1969), On certain formal properties of grammars, <em>Information and Control</em>, 2, pp. 137-167.</li>
<li>Cohen F. (1986), <em>Computer viruses</em>, Ph. D thesis, University of Southern California, January 1986.</li>
<li>Filiol E. (2005), <em>Computer viruses: from theory to applications</em>, IRIS International Series, Springer Verlag France, ISBN 2-287-23939-1.</li>
<li>Filiol E. (2006), Malware Pattern Scanning Schemes Secure Against Black-box Analysis. In: <em>Proceedings of the 15th EICAR Conference</em>. The extended version has been published in <em>Journal in Computer Virology</em>, EICAR 2006 Special Issue, Vol. 2, Nr. 1, pp. 35-50.</li>
<li>Filiol E., Jacob G. et Le Liard M. (2006), Evaluation Methodology and Theoretical Model for Antiviral Behavioural Detection Strategies, <em>Journal in Computer Virology</em>, (3)-1, WTCV'06 Special Issue, G. Bonfante &amp; J.-Y. Marion eds.</li>
<li>Filiol E. (2007), <em>Techniques virales avanc&eacute;es</em>, Collection IRIS, Springer Verlag France. An English translation is pending and will be in print in mid 2007.</li>
<li>Grune D. (1984), How to Produce All Sentences From a Two-level Grammar, <em>Information Processing Letters</em>, 19, pp. 181-185.</li>
<li>Hopcroft J. E., Motwani R. and Ullman J. D. (2006), <em>Introduction to Automata Theory, Languages and Computation</em>, 3rd ed., Addison Wesley.</li>
<li>Jones N. D. (1997), <em>Computability and Complexity</em>, MIT Press.</li>
<li>Lakhotia A., Kapoor A and Kumar E. U. (2004), Are Metamorphic Viruses Really Invicible? Part1, <em>Virus Bulletin</em>, 12, pp. 5-7.</li>
<li>Papadimitriou C. H. (1995), <em>Computational Complexity</em>, Addison Wesley, ISBN 0-201-53082-1.</li>
<li>Post E. (1947), Recursive unsolvability of a problem of Thue, <em>Journal of Symbolic Logic</em>, 12, pp. 1-11.</li>
<li>Qozah (1999), <a href="/lib/vwm00.html">Polymorphism and grammars</a>, <em>29A E-zine</em>, 4, http://www.29a.net/.</li>
<li>Spinellis D. (2003), <a href="/lib/ads03.html">Reliable Identification of Bounded-length Viruses is NP-complete</a>, <em>IEEE Transactions in Information Theory</em>, Vol. 49, No. 1, pp. 280-284.</li>
<li>Tzeitzin G.C (1958), Associative calculus with an unsolvable calculus problem, <em>Tr. Math. Inst. Steklov Akad. Nauk SSSR</em>, 52, pp. 172-189.</li>
<li>van Wijngaarden A., Mailloux B.J., Peck J.E.L., Koster C.H.A., Sintzoff M., Lindsey C.H., Meertens L.G. and Fisker R.G. (1975), Revised Report on the Algoithmic language ALGOL 68, <em>Acta Informatica</em>, 5, pp. 1-236.</li>
<li>Zuo Z. et Zhou M. (2004), <a href="/lib/mzz00.html">Some further theoretical results about computer viruses</a>, <em>The Computer Journal</em>, Vol. 47, No. 6.</li>
<li>Zuo Z, Zhou M. (2005), <a href="/lib/mzz01.html">On the Time Complexity of Computer Viruses</a>, <em>IEEE Transactions in Information Theory</em>, (51), 8.</li>
</ol>
 
<p><a name="f1" href="#b1">1</a> The running environment <img src="/img/cache/e9bd8422573abf98550035828bcd91f6.gif" alt="(d, p)" valign="middle"/> is made up of <em>data</em> (<img src="/img/cache/8277e0910d750195b448797616e091ad.gif" alt="d" valign="middle"/>) and <em>programs</em> (<img src="/img/cache/83878c91171338902e0fe0fb97a8c47a.gif" alt="p" valign="middle"/>).</p>
<p><a name="f2" href="#b2">2</a> The sets <img src="/img/cache/9dd76ca13dfd8092625fa88dc1a8d786.gif" alt="Q,\Sigma" valign="middle"/> and <img src="/img/cache/800618943025315f869e4e1f09471012.gif" alt="F" valign="middle"/> are the set of the automaton's possible states, a finite alphabet and a subset of states that can accepted by the automatom respectively. The state <img src="/img/cache/2bc93f29a61194efd82beabc2b528867.gif" alt="q_0" valign="middle"/> denotes the initial state whereas <img src="/img/cache/a6f317b268ae825d94f832f970af607c.gif" alt="\tau" valign="middle"/> is the transition function <img src="/img/cache/9134f150fbfffa41e97e5275837bbdd0.gif" alt="\tau: Q \times \Sigma \rightarrow Q" valign="middle"/> which maps a state and a symbol to a state.</p>
[<a style="" href="/lib/?lang=EN&amp;index=TH#aef04">Back to index</a>] [<a href="/lib/aef04.html#disqus_thread">Comments</a>]<br/> <div id="disqus_thread"></div>
<script type="text/rocketscript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'vxheaven'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="/agreement.php">Terms of Use</a>!</small> <small>vxheaven.org aka vx.netlux.org</small></div>
<div style="margin-top: 2px; float: left;" class="adsapeu">
<script type="text/rocketscript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script>
</div>
<script data-rocketsrc="http://www.google-analytics.com/urchin.js" type="text/rocketscript"></script><script type="text/rocketscript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="/lib/index.php?lang=de&amp;id=aef04">de</a><a href="/lib/index.php?lang=en&amp;id=aef04">en</a><a href="/lib/index.php?lang=es&amp;id=aef04">es</a><a href="/lib/index.php?lang=it&amp;id=aef04">it</a><a href="/lib/index.php?lang=fr&amp;id=aef04">fr</a><a href="/lib/index.php?lang=pl&amp;id=aef04">pl</a><a href="/lib/index.php?lang=ru&amp;id=aef04">ru</a><a href="/lib/index.php?lang=ua&amp;id=aef04">ua</a></div>
</body>
</html>
