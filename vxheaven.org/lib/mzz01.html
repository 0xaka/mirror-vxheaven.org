<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Zhihong Zuo, Mingtian Zhou, Qing-xin Zhu 'On the Time Complexity of Computer Viruses' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Author" content="Zhihong Zuo, Mingtian Zhou, Qing-xin Zhu"/>
<meta name="KeyWords" lang="en" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, Zuo, Zhihong; Zhou, Mingtian; Zhu, Qing-xin,On the Time Complexity of Computer Viruses, text, rangle, langle, dots, viruses, mathbf, polymorphic, computer, forms, metamorphic, minimal, align, time, computational, virus"/>
<meta name="Description" content="Computer viruses can disable computer systems not only by destroying data or modifying a system's configuration, but also by consuming most of the computing resources such as CPU time and storage. The latter effects are related to the computational complexity of computer viruses. In this correspondence, we investigate some issues concerning the time complexity of computer viruses, and prove some known experimental results mathematically. We prove that there exist computer viruses with arbitrarily long running time, not only in the infecting procedure but in the executing procedure. Moreover, we prove that there are computer viruses with arbitrarily large time complexity in the detecting procedure, and there are undecidable computer viruses that have no &quot;minimal&quot; detecting procedure."/>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"047a5bcbf67431883fc9ed25fba33612",petok:"bcfcf5fa0f992354af1c64e7858696fb8a5ccbda-1498756879-1800",zone:"vxheaven.org",rocket:"a",apps:{}}];document.write('<script type="text/javascript" src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=85b614c0f6/cloudflare.min.js"><'+'\/script>');}}catch(e){};
//]]>
</script>
<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="/style.css"/><link rel="canonical" href="http://vxheaven.org/lib/mzz01.html"/>
<script type="text/rocketscript" data-rocketsrc="https://apis.google.com/js/plusone.js">{"parsetags": "explicit"}</script>
</head>
<body bgcolor="#dbc8a0" text="#302000" link="#225599" vlink="#113366">
<div class="s1">
<div style="float:right;"><a href="/lib/index.php?tbs=1"><img src="/img/max.gif" alt="Maximize"/></a></div> <form id="lf" style="margin: 0; float: right;" method="get" action="/index.php"><input type="hidden" name="action" value="set"/><select name="lang" onchange="javascript:document.getElementById('lf').submit();"><option value="ru">Русский</option><option selected="selected" value="en">English</option><option value="ua">Українська</option><option value="de">Deutsch</option><option value="es">Español</option><option value="fr">Fran&ccedil;ais</option><option value="it">Italiano</option><option value="pl">Polski</option></select></form>
<div style="float: right;"><div id="plusone"></div></div>
<script type="text/rocketscript">gapi.plusone.render("plusone", {"size":"small","count":"true"});</script>
<div style="float: right;" class="addthis_toolbox addthis_default_style">
<script type="text/rocketscript">var addthis_config = { ui_click: true }</script>
<a style="text-decoration: none; font-size: 10pt;" href="/?action=addthis" class="addthis_button_compact">Bookmark</a>
<script type="text/rocketscript" data-rocketsrc="http://s7.addthis.com/js/250/addthis_widget.js#username=herm1t"></script>
</div>
<div style="float: right;">
<script type="text/rocketscript" data-rocketsrc="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<form action="/search.php" id="cse-search-box">
<input type="hidden" name="cx" value="002577580816726040001:z9_irkorydo"/>
<input type="hidden" name="cof" value="FORID:10"/>
<input type="hidden" name="ie" value="UTF-8"/>
<input type="text" name="q" size="12" value=" "/>
<input type="submit" name="sa" value="Search"/>
</form>
</div><h1><a href="/" style="text-decoration: none; color: #000000;">VX Heaven</a></h1>
<span class="nav"><a href="/lib/">Library</a> <a href="/vl.php">Collection</a> <a href="/src.php">Sources</a> <a href="/vx.php?id=eidx">Engines</a> <a href="/vx.php?id=tidx">Constructors</a> <a href="/vx.php?id=sidx">Simulators</a> <a href="/vx.php?id=uidx">Utilities</a> <a href="/links.php">Links</a> <a href="/donate.php" style="color: #706020" id="donate">Donate</a> <a href="/forum" style="text-decoration: underline;">Forum</a> </span><br clear="all"/>
</div>
<div class="s2"><h1>On the Time Complexity of Computer Viruses</h1><p><a href="/lib/?lang=en&amp;author=Zuo%2C%20Zhihong">Zhihong Zuo</a>, <a href="/lib/?lang=en&amp;author=Zhou%2C%20Mingtian">Mingtian Zhou</a>, <a href="/lib/?lang=en&amp;author=Zhu%2C%20Qing-xin">Qing-xin Zhu</a><br/> <em>IEEE Transactions on Information Theory, Vol. 51, No. 8</em><br/> <em>ISSN 0018-9448</em><br/> <em>August 2005</em></p><script type="text/rocketscript">var disqus_url = 'http://vxheaven.org/lib/mzz01.html';</script><div class="ci"><a href="/lib/?ci=mzz01">3</a></div><img src="/img/pdf.gif" alt="PDF"/><a href="/lib/pdf/On%20the%20Time%20Complexity%20of%20Computer%20Viruses.pdf">Download</a> PDF (205.62Kb) (You need to be registered on <a href="/forum">forum</a>)<br/>[<a style="" href="/lib/?lang=EN&amp;index=TH#mzz01">Back to index</a>] [<a href="/lib/mzz01.html#disqus_thread">Comments</a>]<br/> <form method="post" action="">
<img src="/img/cache/0b9fd596a90421f9f1f68a9760275737.gif" alt="\text{T_EX size}" valign="middle"/>
<select name="TeX_size"><option value="-2">-2</option><option value="-1">-1</option><option value="0" selected="selected">0</option><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option> </select>
<input type="submit" value="Scale"/>
</form><form method="post" action=""><input type="hidden" name="pages" value="1"/><input type="submit" value="Turn on page numbers"/></form>
<p><small>Manuscript received July 13, 2004; revised December 26, 2004.<br/>
The authors are with the College of Computer Science and Engineering,<br/>
University of Electronic Science and Technology of China, Chengdu, Sichuan,<br/>
610054 China (e-mail: <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="c5bfadbfb0aa85b0a0b6b1a6eba0a1b0eba6ab">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>;<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="e2939a988a97a29787919681cc878697cc818c">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>; <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="f9948d8391968cb98c9c8a8d9ad79c9d8cd79a97">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>).<br/>
Communicated by T. Johansson, Associate Editor for Complexity and Cryptography.<br/>
Digital Object Identifier 10.1109/TIT.2005.851780</small></p>
<h2>Abstract</h2>
<p>Computer viruses can disable computer systems not only by destroying data or modifying a system's configuration, but also by consuming most of the computing resources such as CPU time and storage. The latter effects are related to the computational complexity of computer viruses. In this correspondence, we investigate some issues concerning the time complexity of computer viruses, and prove some known experimental results mathematically. We prove that there exist computer viruses with arbitrarily long running time, not only in the infecting procedure but in the executing procedure. Moreover, we prove that there are computer viruses with arbitrarily large time complexity in the detecting procedure, and there are undecidable computer viruses that have no "minimal" detecting procedure.</p>
<p><em>Index Terms</em></p>
<p>Computational complexity, computer viruses, detection, infection, time complexity.</p>
<h2>I. Introduction</h2>
<p>The first abstract theory of computer viruses is the viral set theory given by Cohen, based on the Turing machine [1], [2]. A viral set is defined by <img src="/img/cache/a68d675c477064e9adccbffee0fef3a2.gif" alt="(M, V)" valign="middle"/> where <img src="/img/cache/69691c7bdcc3ce6d5d8a1361f22d04ac.gif" alt="M" valign="middle"/> is a Turing machine and <img src="/img/cache/5206560a306a2e085a437fd258eb57ce.gif" alt="V" valign="middle"/> is a nonempty set of programs on the Turing machine. Each <img src="/img/cache/489f07bffe8b7e18a6112f5022b09410.gif" alt="v \in V" valign="middle"/> is called a computer virus and satisfies the following condition: if it is contained in the tape at time <img src="/img/cache/e358efa489f58062f10dd7316b65649e.gif" alt="t" valign="middle"/>, then there exist a time <img src="/img/cache/3b11da5ab8568206a5e1184fbf7f2005.gif" alt="t'" valign="middle"/> and a <img src="/img/cache/68c0403d08fefde2fd7c9c6a680e79dd.gif" alt="v' \in V" valign="middle"/> such that <img src="/img/cache/b3afdc4dc7644ad636e084509b04ddab.gif" alt="v'" valign="middle"/> is not contained in the tape at time <img src="/img/cache/e358efa489f58062f10dd7316b65649e.gif" alt="t" valign="middle"/>, but contained in the tape at time <img src="/img/cache/3b11da5ab8568206a5e1184fbf7f2005.gif" alt="t'" valign="middle"/>. The most important one of Cohen's theorems is about the undecidability of computer viruses [1], [2].</p>
<p>In a different approach, Adleman developed an abstract theory of computer viruses based on recursive functions [3]. In his definition, a virus is a total recursive function v which applies to all programs <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/> (the G&ouml;del numberings of programs), such that <img src="/img/cache/6668cae114cc8d4dc991ac6152f99da5.gif" alt="v(x)" valign="middle"/> has characteristic behaviors of computer viruses such as injury, infection, and imitation. Furthermore, Adleman proved that the set of computer viruses is <img src="/img/cache/c092b7daa73baafd26c210aec4174dcc.gif" alt="\prod{}_2" valign="middle"/>-complete [3].</p>
<p>Although several abstract theories about computer viruses were established and many important results were derived from these theories, we know little about the computational complexity of computer viruses. Very little research has been done so far in this respect. Adleman [3] discussed some problems but failed to give any conclusion. Spinellis [4] proved that to reliably identify the bounded-length of computer viruses is NP-complete. To our best knowledge, there is no more results on computational complexity of computer viruses.</p>
<p>In the following, we investigate some issues on the time complexity of computer viruses. We focus on two kinds of time complexity: the time complexity of computer viruses in their computational environment, and the time complexity of detecting computer viruses. It is well known that there exist arbitrarily complex recursive functions [5], [6], but we cannot apply this fact to computer viruses directly, because computer viruses are some "fixpoints" of recursive operations [3]. On the other hand, theoretical results about the time complexity of detecting computer viruses are very important to antivirus practice.</p>
<p>The structure of the correspondence is as follows: In Section II, we introduce some notations; in Section III, we give definitions of computer viruses based on recursive functions. In Section IV, we prove some auxiliary lemmas and then derive main results about time complexity of computer viruses. In Section V, we give a brief summary and some suggestions for future research.</p>
<h2>II. Preliminaries</h2>
<p>We describe some notations below.</p>
<p>Let <img src="/img/cache/9b3ecd4f5f0cc174717f19cec0743fcd.gif" alt="\mathbb{N}" valign="middle"/> be the set of all natural numbers and <img src="/img/cache/5dbc98dcc983a70728bd082d1a47546e.gif" alt="S" valign="middle"/> be the set of all finite sequences of natural numbers. For <img src="/img/cache/cff496013eaed9693f268f95d9d42b4f.gif" alt="s_1,s_2,\dots,s_n \in S" valign="middle"/>, let <img src="/img/cache/3c23584ce41f1989f95f77f8f59c5f6b.gif" alt="\langle s_1,s_2,\dots,s_n\rangle" valign="middle"/> denote a computable injective function from <img src="/img/cache/f74115260830faf5178589e98c061a4e.gif" alt="S^n" valign="middle"/> to <img src="/img/cache/9b3ecd4f5f0cc174717f19cec0743fcd.gif" alt="\mathbb{N}" valign="middle"/> and its inverse is also computable. If <img src="/img/cache/d214a20258d418f87c3a4b7a1f65d813.gif" alt="f : \mathbb{N}\rightarrow\mathbb{N}" valign="middle"/> is a partial function, for <img src="/img/cache/cff496013eaed9693f268f95d9d42b4f.gif" alt="s_1,s_2,\dots,s_n \in S" valign="middle"/>, we write <img src="/img/cache/4ab1c83022b75a52471afd60106ec9ab.gif" alt="f(s_1,s_2,\dots,s_n)" valign="middle"/> instead of <img src="/img/cache/b8b9676c25444ad4193e901a4e3f41ca.gif" alt="f(\langle s_1,s_2,\dots,s_n\rangle)" valign="middle"/>. Similarly, for <img src="/img/cache/1ef67978aab28a18ffa48f185994af68.gif" alt="i_1,i_2,\dots,i_n \in \mathbb{N} , let &lt;tex&gt;\langle i_1,i_2,\dots,i_n\rangle" valign="middle"/> denote a computable injective function from <img src="/img/cache/8b0949f1187bf26ef34c58fa019e816b.gif" alt="\mathbb{N}^n" valign="middle"/> to <img src="/img/cache/9b3ecd4f5f0cc174717f19cec0743fcd.gif" alt="\mathbb{N}" valign="middle"/>, satisfying <img src="/img/cache/cf641a489fcc1f97ac95270c19b114a9.gif" alt="\langle i_1,i_2,\dots,i_n\rangle \ge i_m" valign="middle"/> for all <img src="/img/cache/3ffa6002d50fa720622c5d1b6ef0fcc2.gif" alt="1 \le m \le n" valign="middle"/>, and its inverse is also computable. For a partial function <img src="/img/cache/ffdf7af446228cf8a7979a273dc00880.gif" alt="f : \mathbb{N}^n \rightarrow \mathbb{N}" valign="middle"/>, let <img src="/img/cache/00c6c293cb2e69f1c3b6eab5c0cc6c41.gif" alt="f(i_1,i_2,\dots,i_n)" valign="middle"/> represent <img src="/img/cache/de6c6503105eaa94cbf3a2f7f2a4b02e.gif" alt="f(\langle i_1,i_2,\dots,i_n \rangle)" valign="middle"/>.</p>
<p>For a sequence <img src="/img/cache/77fa14a408e7d6d75c76c84006a21099.gif" alt="p = (i_1,i_2,\dots,i_k,\dots,i_n) \in S" valign="middle"/>, let <img src="/img/cache/ebc839e31a15dfcc11f16d4d142a17e4.gif" alt="(p)_k" valign="middle"/> denote its <img src="/img/cache/8ce4b16b22b58894aa86c421e8759df3.gif" alt="k" valign="middle"/>th element, and <img src="/img/cache/cf1a631ae36fae0aa721e4b795d21237.gif" alt="p[j_k/i_k]" valign="middle"/> denote the sequence obtained by replacing <img src="/img/cache/f0807c8c623bbafb36dbdb9e24cdfc4d.gif" alt="i_k" valign="middle"/> with <img src="/img/cache/a1cba1f93521e19e4c6b36a35c5959cc.gif" alt="j_k" valign="middle"/> in <img src="/img/cache/83878c91171338902e0fe0fb97a8c47a.gif" alt="p" valign="middle"/>, that is,</p>
<div class="N5"><img src="/img/cache/fca02ab695fed5b41e628c7468c43951.gif" alt="p[j_k/i_k] = (i_1,i_2,\dots,j_k,\dots,i_n)." valign="middle"/></div>
<p>If <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> is a computable function, <img src="/img/cache/5c7fdbc1cc3b3e3593f6937902ff8d6d.gif" alt="p[v(i_k)/i_k]" valign="middle"/> is simply written as <img src="/img/cache/54cc5e04ec19a1e8aa695bc844d97a55.gif" alt="p[v(\underline{i_k})]" valign="middle"/>. If more than one elements in p are replaced or evaluated by some computable functions, we write the result as</p>
<img src="/img/cache/b86feb4c5c342d7c3683b649f14ef0aa.gif" alt="p[j_{k_1}/i_{k_1},j_{k_2}/i_{k_2},\dots,j_{k_l}/i_{k_l}]\text{ or }p[v_1(\underline{i_{k_1}}),v_2(\underline{i_{k_2}}),\dots,v_l(\underline{i_{k_l}})]" valign="middle"/>
<p>respectively.</p>
<p>Adopting Adleman's notations [3], let <img src="/img/cache/7db4d8d77961ae04ad43de0cdc0a24a2.gif" alt="\phi_P(d, p)" valign="middle"/> denote a function computed by a computer program <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/> in the running environment <img src="/img/cache/e9bd8422573abf98550035828bcd91f6.gif" alt="(d, p)" valign="middle"/> where <img src="/img/cache/8277e0910d750195b448797616e091ad.gif" alt="d" valign="middle"/> represents <em>data</em> (including clock, spaces of diskettes, and so on) and <img src="/img/cache/83878c91171338902e0fe0fb97a8c47a.gif" alt="p" valign="middle"/> represents <em>programs</em> (including operating systems) stored on computers. If the index (the G&ouml;del numbering) of <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/> is <img src="/img/cache/e1671797c52e15f763380b45e841ec32.gif" alt="e" valign="middle"/>, the function is also denoted by <img src="/img/cache/3740a1ba03a661f77da99a6604f007dc.gif" alt="\phi_e(d, p)" valign="middle"/>.The domain and range are denoted by <img src="/img/cache/534a2fde5e31a892dc035f6f50282d30.gif" alt="W_e" valign="middle"/> and <img src="/img/cache/15c12465c0c4ff1ec7413404cbf6ce34.gif" alt="E_e" valign="middle"/>, respectively. If <img src="/img/cache/2510c39011c5be704182423e3a695e91.gif" alt="h" valign="middle"/> is a recursive function, we also use the symbols <img src="/img/cache/9ed4343f2b3bf4b5edb500f877223c18.gif" alt="W_h" valign="middle"/> and <img src="/img/cache/cbf7813c1ed53709229b2810992aeae0.gif" alt="E_h" valign="middle"/> for its domain and range. It is worth noting that there is no essential distinction between <img src="/img/cache/8277e0910d750195b448797616e091ad.gif" alt="d" valign="middle"/> and <img src="/img/cache/83878c91171338902e0fe0fb97a8c47a.gif" alt="p" valign="middle"/>, as in the case of Von Neumann machine. In this correspondence, we use the symbol <img src="/img/cache/e9bd8422573abf98550035828bcd91f6.gif" alt="(d, p)" valign="middle"/> just for easy understanding.</p>
<p>For any program <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/>, let <img src="/img/cache/5c7227f4cf9758825ed38c7ef52d6226.gif" alt="t_P" valign="middle"/> be the function defined as follows:</p>
<img src="/img/cache/db24c32ec94216bc6cc61d4a423f9a24.gif" alt="
\begin{eqnarray}
	t_P (d, p) &amp;=&amp; \{
	\begin{align}
		&amp;&amp; \text{number of steps taken}\\
		&amp;&amp; \text{by }P\text{ to compute }\phi_P(d,p),	&amp;&amp;&amp; \text{if }\phi_P(d, p)\text{ is defined}\\
		&amp;&amp; \text{undefined},				&amp;&amp;&amp; \text{otherwise}
	\end{align}\\
	&amp;=&amp; \mu t(P(d,p)\text{ stops in }t\text{ steps}.\hspace{300}(1)
\end{eqnarray}
" valign="middle"/>
<p>If <img src="/img/cache/e1671797c52e15f763380b45e841ec32.gif" alt="e" valign="middle"/> is an index of <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/>, we write <img src="/img/cache/eb65c9295452fd985390b20c8c6108ef.gif" alt="t_e(d, p)" valign="middle"/> for <img src="/img/cache/6ee715420c823d1d108d2b19665748df.gif" alt="t_P(d, p)" valign="middle"/>. It is obvious that <img src="/img/cache/a35137428a88a9294526273615674218.gif" alt="Dom(t_e) = Dom(\phi_e)" valign="middle"/> for all <img src="/img/cache/e1671797c52e15f763380b45e841ec32.gif" alt="e" valign="middle"/>, and the predicate <img src="/img/cache/22a71570fa4b430b5312d70ca6dba021.gif" alt="\mathbf{M}(e, \langle d,p \rangle, y)" valign="middle"/> defined by <img src="/img/cache/b91dac5131f434612a74be14d6392c63.gif" alt="\mathbf{M}(e, \langle d,p \rangle, y) \equiv \quote{t_e(d,p) \simeq y}\quote\text{ is decidable}" valign="middle"/> [6].</p>
<p>We say that a predicate <img src="/img/cache/82aba45bc896ea025e864530e83e5aa0.gif" alt="\mathbf{Q}(n)" valign="middle"/> holds for almost all <img src="/img/cache/7b8b965ad4bca0e41ab51de7b31363a1.gif" alt="n" valign="middle"/>, if <img src="/img/cache/82aba45bc896ea025e864530e83e5aa0.gif" alt="\mathbf{Q}(n)" valign="middle"/> holds for all <img src="/img/cache/7b8b965ad4bca0e41ab51de7b31363a1.gif" alt="n" valign="middle"/> but finitely many numbers <img src="/img/cache/7b8b965ad4bca0e41ab51de7b31363a1.gif" alt="n" valign="middle"/>. Equivalently, there is a number <img src="/img/cache/9f29abde1bb7db037da9d05ea02015db.gif" alt="n_0" valign="middle"/> such that <img src="/img/cache/82aba45bc896ea025e864530e83e5aa0.gif" alt="\mathbf{Q}(n)" valign="middle"/> holds for all <img src="/img/cache/368b4ae0bf4d106cc3cf845e4d60b69d.gif" alt="n \ge n_0" valign="middle"/>. This property is simply denoted by <img src="/img/cache/82aba45bc896ea025e864530e83e5aa0.gif" alt="\mathbf{Q}(n)" valign="middle"/> a.e.(almost everywhere).</p>
<h2>III. Definitions of computer viruses</h2>
<p>In this section, we extend Adleman's definitions about computer viruses [3] to comply with common understanding of computer viruses [7].</p>
 
<p><em>Defintion 3.1 (Nonresident Virus):</em> A total recursive function <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> is called a nonresident virus if for all <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/>, <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> satisfies the following</p>
<ol type="a">
<li><img src="/img/cache/4539ab8bd62d86d68ae62bc934095786.gif" alt="
	\phi_{v(x)}(d, p) = \{
	\begin{align}
		&amp;&amp; D(d,p),				&amp;&amp;&amp;\text{if }T(d,p)	&amp;(i)\\
		&amp;&amp; \phi_x(d,p[v(\underline{S(p)})]),	&amp;&amp;&amp;\text{if }I(d,p)	&amp;(ii)\\
		&amp;&amp; \phi_x(d,p),				&amp;&amp;&amp;\text{otherwise}	&amp;(iii)
	\end{align}\hspace{100}(2)" valign="middle"/></li>
<li><img src="/img/cache/ffa6b7a3dd5e43b97129ff0ecc3ff472.gif" alt="D(d,p)" valign="middle"/> and <img src="/img/cache/be81fe0f3d9275a189495781bf2f49b8.gif" alt="S(p)" valign="middle"/> are two recursive functions. <img src="/img/cache/11b4dcf414ef856f32f9f99682dc7303.gif" alt="T(d,p)" valign="middle"/> and <img src="/img/cache/5caa66b6ccdc510a758bd4c55669e363.gif" alt="I(d,p)" valign="middle"/> are two recursive predicates such that there is at least one pair of <img src="/img/cache/b730c58ea30c7e7aca62e2bcd86b0a99.gif" alt="(d,p)" valign="middle"/> in which <img src="/img/cache/5caa66b6ccdc510a758bd4c55669e363.gif" alt="I(d,p)" valign="middle"/> holds, and that there is no <img src="/img/cache/b730c58ea30c7e7aca62e2bcd86b0a99.gif" alt="(d,p)" valign="middle"/> in which both <img src="/img/cache/11b4dcf414ef856f32f9f99682dc7303.gif" alt="T(d,p)" valign="middle"/> and <img src="/img/cache/5caa66b6ccdc510a758bd4c55669e363.gif" alt="I(d,p)" valign="middle"/> hold simultaneously.</li>
<li>The set <img src="/img/cache/1379124ad90a4fc26d8be1481a0efc5f.gif" alt="\{(d,p):\neg(T(d,p)\vee I(d,p))\}" valign="middle"/> is infinite.</li>
</ol>
<p><img src="/img/cache/11b4dcf414ef856f32f9f99682dc7303.gif" alt="T(d,p)" valign="middle"/> and <img src="/img/cache/5caa66b6ccdc510a758bd4c55669e363.gif" alt="I(d,p)" valign="middle"/> are called <em>injury</em> condition (trigger) and <em>infection</em> condition, respectively. When <img src="/img/cache/11b4dcf414ef856f32f9f99682dc7303.gif" alt="T(d,p)" valign="middle"/> holds, the virus executes the <em>injury</em> function <img src="/img/cache/ffa6b7a3dd5e43b97129ff0ecc3ff472.gif" alt="D(d,p)" valign="middle"/>, and when <img src="/img/cache/5caa66b6ccdc510a758bd4c55669e363.gif" alt="I(d,p)" valign="middle"/> holds, the virus chooses a program by <em>selection</em> function <img src="/img/cache/be81fe0f3d9275a189495781bf2f49b8.gif" alt="S(p)" valign="middle"/>, infects it first, then executes the original program <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/>. Conditions <img src="/img/cache/11b4dcf414ef856f32f9f99682dc7303.gif" alt="T(d,p)" valign="middle"/> and <img src="/img/cache/5caa66b6ccdc510a758bd4c55669e363.gif" alt="I(d,p)" valign="middle"/> together with functions <img src="/img/cache/ffa6b7a3dd5e43b97129ff0ecc3ff472.gif" alt="D(d,p)" valign="middle"/> and <img src="/img/cache/be81fe0f3d9275a189495781bf2f49b8.gif" alt="S(p)" valign="middle"/> are called the <em>kernel</em> of a nonresident virus in the rest of this correspondence, because they determine a nonresident virus uniquely.</p>
<p>In definition 3.1, formula (i), (ii), and (iii) describe three typical types of behavior of computer viruses, namely, <em>injury</em>, <em>infection</em>, and <em>imitation</em>. Condition b) guarantees that an infected program would infect at least one other program, and the infection and injury action cannot be completed simultaneously. In other words, infectivity is an indispensable attribute of computer viruses. Condition c) requires that an infected program <em>imitates</em> the original program at infinitely many points. It is a quite strong condition and necessary for the important property that the set of one type of computer viruses with same kernel is <img src="/img/cache/c092b7daa73baafd26c210aec4174dcc.gif" alt="\prod{}_2" valign="middle"/>-complete [7]. However, it is not needed in investigating time complexity about computer viruses.</p>
<p>We may define almost all kinds of computer viruses in this way. For example, we can give similar definitions for other kinds of computer viruses which are both important and interesting, theoretically and practically. In these definitions, we no longer list conditions b) and c) as in Definition 3.1, but assume they are included in all of these definitions.</p>
<p><em>Defintion 3.2 (Polymorphic Virus With Two Forms):</em> The pair <img src="/img/cache/3a045f4fcf78849b91a8ea7f38549366.gif" alt="(v,v')" valign="middle"/> of two different total recursive functions <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> and <img src="/img/cache/b3afdc4dc7644ad636e084509b04ddab.gif" alt="v'" valign="middle"/> is called a polymorphic virus with two forms if for all <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/>, <img src="/img/cache/3a045f4fcf78849b91a8ea7f38549366.gif" alt="(v,v')" valign="middle"/> satisfies</p>
<img src="/img/cache/2453e1728f5b8b898987ac874e2d594c.gif" alt="
	\phi_{v(x)}(d,p) = { \{
	\begin{align}
		&amp;&amp;D(d,p),	&amp;&amp;&amp;\text{if }T(d,p)\\
		&amp;&amp;\phi_x(d,p[v'(\underline{S(p)})]),&amp;&amp;&amp;\text{if }I(d,p)\\
		&amp;&amp;\phi_x(d,p),	&amp;&amp;&amp;\text{otherwise}
	\end{align}\hspace{100}(3)
	} \\
	\text{and}\\
	\phi_{v'(x)}(d,p) = { \{
	\begin{align}
		&amp;&amp;D(d,p),	&amp;&amp;&amp;\text{if }T(d,p)\\
		&amp;&amp;\phi_x(d,p[v(\underline{S(p)})]),&amp;&amp;&amp;\text{if }I(d,p)\\
		&amp;&amp;\phi_x(d,p),	&amp;&amp;&amp;\text{otherwise}
	\end{align}\hspace{100}(4)
	}
" valign="middle"/>
<p>Polymorphic viruses with <img src="/img/cache/7b8b965ad4bca0e41ab51de7b31363a1.gif" alt="n" valign="middle"/> forms can be defined as an <img src="/img/cache/7b8b965ad4bca0e41ab51de7b31363a1.gif" alt="n" valign="middle"/>-tuple <img src="/img/cache/3c2c90d0ffcd5b84908fa350a4e93907.gif" alt="(v_1,v_2,\dots,v_n)" valign="middle"/> of <img src="/img/cache/7b8b965ad4bca0e41ab51de7b31363a1.gif" alt="n" valign="middle"/> different total recursive functions, under similar conditions as in Definition 3.2. Polymorphic viruses have spread widely in the last ten years and caused a lot of trouble as they are very hard to detect. Polymorphic viruses have billions of forms and in general any two forms do not have three consecutive bytes in common. However, polymorphic viruses are not the hardest viruses to detect. Two other kinds of viruses, the polymorphic viruses with infinite forms and metamorphic viruses [8] are a real challenge.</p>
<p><em>Defintion 3.3 (Polymorphic Virus With Infinite Forms):</em> A total recursive function <img src="/img/cache/2b3850ab5273ae460fd875c88ecffb68.gif" alt="v(m,x)" valign="middle"/> is called a polymorphic virus with infinite forms if for all <img src="/img/cache/6f8f57715090da2632453988d9a1501b.gif" alt="m" valign="middle"/> and <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/>, <img src="/img/cache/2b3850ab5273ae460fd875c88ecffb68.gif" alt="v(m,x)" valign="middle"/> satisfies</p>
<img src="/img/cache/8a92f10ca81d62aa735a42f43d0251d3.gif" alt="
	\phi_{v(m,x)}(d,p) = \{
	\begin{align}
		&amp;&amp; D(d,p),	&amp;&amp;&amp;\text{if }T(d,p)\\
		&amp;&amp; \phi_x(d,p[v(m+1,\underline{S(p)})]),&amp;&amp;&amp;\text{if }I(d,p)\\
		&amp;&amp; \phi_x(d,p),	&amp;&amp;&amp;\text{otherwise}
	\end{align}\hspace{100}(5)
" valign="middle"/>
<p>and for all <img src="/img/cache/8b78e8d0e42d41bb1e20e7035b7999dd.gif" alt="m \ne n" valign="middle"/>, <img src="/img/cache/9ec2d259a7d4a3513ac2417f3e30dd25.gif" alt="v(m,x) \ne v(n,x)" valign="middle"/>.</p>
<p>Up to now polymorphic viruses with infinite forms have not been found in the real world, but their existence can be proved by the recursion theorem of [7] just like ordinary computer viruses.</p>
<p><em>Defintion 3.4 (Metamorphic Virus):</em> The pair <img src="/img/cache/3a045f4fcf78849b91a8ea7f38549366.gif" alt="(v,v')" valign="middle"/> of two different total recursive functions <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> and <img src="/img/cache/b3afdc4dc7644ad636e084509b04ddab.gif" alt="v'" valign="middle"/> is called a metamorphic virus if for all <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/>, <img src="/img/cache/3a045f4fcf78849b91a8ea7f38549366.gif" alt="(v,v')" valign="middle"/> satisfies</p>
<img src="/img/cache/cf5b8fa47d17d4b6b1f47b5373c6fd6b.gif" alt="
	\phi_{v(x)}(d,p) = { \{
	\begin{align}
		&amp;&amp; D(d,p),	&amp;&amp;&amp;\text{if }T(d,p)\\
		&amp;&amp; \phi_x(d,p[v'(\underline{S(p)})]),&amp;&amp;&amp;\text{if }I(d,p)\\
		&amp;&amp; \phi_x(d,p),	&amp;&amp;&amp;\text{otherwise}
	\end{align} }\hspace{100}(6)\\
	and\\
	\phi_{v'(x)}(d,p) = { \{
	\begin{align}
		&amp;&amp; D'(d,p),	&amp;&amp;&amp;\text{if }T'(d,p)\\
		&amp;&amp; \phi_x(d,p[v'(\underline{S'(p)})]),&amp;&amp;&amp;\text{if }I'(d,p)\\
		&amp;&amp; \phi_x(d,p),	&amp;&amp;&amp;\text{otherwise}
	\end{align} }\hspace{100}(7)
" valign="middle"/>
<p>where <img src="/img/cache/11b4dcf414ef856f32f9f99682dc7303.gif" alt="T(d,p)" valign="middle"/> (resp., <img src="/img/cache/e5e74008d20781dd719e13705b437590.gif" alt="I(d,p),D(d,p),S(p)" valign="middle"/>)is different from <img src="/img/cache/11b4dcf414ef856f32f9f99682dc7303.gif" alt="T(d,p)" valign="middle"/> (resp., <img src="/img/cache/aed61fb7e521e416f2a6cdae6a1ff43b.gif" alt="I'(d,p),D'(d,p),S'(p)" valign="middle"/>).</p>
<p>A metamorphic virus <img src="/img/cache/3a045f4fcf78849b91a8ea7f38549366.gif" alt="(v,v')" valign="middle"/> seems to combine two different computer viruses <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> and <img src="/img/cache/b3afdc4dc7644ad636e084509b04ddab.gif" alt="v'" valign="middle"/>. But, there is a crucial distinction between a metamorphic virus and a pair of two viruses, that is, when <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> infects a program, the program is indeed infected by <img src="/img/cache/b3afdc4dc7644ad636e084509b04ddab.gif" alt="v'" valign="middle"/> (not <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/>), and <em>vice versa</em>. The metamorphic virus <img src="/img/cache/3c2c90d0ffcd5b84908fa350a4e93907.gif" alt="(v_1,v_2,\dots,v_n)" valign="middle"/> can be defined in the similar way. The main difference between a metamorphic virus and a polymorphic virus is that each form of a polymorphic virus has the same kernel, but each component <img src="/img/cache/b17d30899a9047efcf74e562297dea22.gif" alt="v_n" valign="middle"/> of a metamorphic virus has its own kernel [8].</p>
<p>More discussions about computer viruses can be found in [7].</p>
<h2>IV. Main results</h2>
<p>In this section, we prove the main results of this correspondence, using the traditional notations and symbols in recursive function theory([9], [10]).</p>
<p><em>Lemma 4.1:</em> Let <img src="/img/cache/e1e1d3d40573127e9ee0480caf1283d6.gif" alt="R" valign="middle"/> be an infinite recursive set and <img src="/img/cache/0db4b0393eae168851671b28e5f03c5f.gif" alt="b(x)" valign="middle"/> be a total recursive function. Then there exists a recursive subset <img src="/img/cache/98395032dafb4dbef9c3d1e2457c63ec.gif" alt="A \subseteq R" valign="middle"/> such that <img src="/img/cache/5055b55ad673e8781702e903666a7943.gif" alt="t_e(x) \gt b(x)" valign="middle"/> a.e., where <img src="/img/cache/e1671797c52e15f763380b45e841ec32.gif" alt="e" valign="middle"/> is any index of the characteristic function of A.</p>
<p><em>Proof:</em> Let <img src="/img/cache/b2f5ff47436671b6e533d8dc3614845d.gif" alt="g" valign="middle"/> be an increasing total recursive function with <img src="/img/cache/5492bcc6543aadffa3ce49551c1def9c.gif" alt="E_g = R" valign="middle"/>. Define</p>
<img src="/img/cache/4ae8a4197a07fa01da403f8a6ad533b6.gif" alt="
	i_{g(y)} = \{
	\begin{align}
		&amp;&amp; \mu i[i \le y\text{ and }i\text{ differs from}	&amp;&amp;&amp; \\
		&amp;&amp; \text{all previously defined }i_k	&amp;&amp;&amp; \text{if such an }i\text{ exists}\\
		&amp;&amp; \text{and }t_i(y) \le b(y)],		&amp;&amp;&amp; \\
		&amp;&amp; \text{undefined},			&amp;&amp;&amp; \text{otherwise}
	\end{align}\hspace{100}(8)
" valign="middle"/>
<p>Since</p>
<img src="/img/cache/b821930051c80012770abaf8ffe1e183.gif" alt="t_i(y)\le b(y)\Leftrightarrow\exist z\le b(y)(t_i(y)\simeq z)\hspace{100}(9)" valign="middle"/>
<p>and <img src="/img/cache/670343de01a30cc8d278181ebfb24d2f.gif" alt="\quot t_i(y) \simeq z\quot" valign="middle"/> is a recursive predicate, there is an effective procedure to decide whether <img src="/img/cache/8cd6c023a04e67bab95c3c8a96f4ab90.gif" alt="_{ig(y)}" valign="middle"/> is defined, and to compute its value when it is defined. Consider the function</p>
<img src="/img/cache/2ffa1603b9c8d659442ba3ec21830512.gif" alt="
	f(x) = \{
	\begin{align}
		&amp;&amp; 1,	&amp;&amp;&amp;\text{if }x = g(y)\text{ for some }y,\\
		&amp;&amp;	&amp;&amp;&amp;i_{g(y)}\text{ is defined and }\phi_{i_g(y)} = 0\\
		&amp;&amp; 0,	&amp;&amp;&amp;\text{otherwise}
	\end{align}\hspace{100}(10)
" valign="middle"/>
 
<p>Since <img src="/img/cache/e1e1d3d40573127e9ee0480caf1283d6.gif" alt="R" valign="middle"/> is an recursive set, <img src="/img/cache/50bbd36e1fd2333108437a2ca378be62.gif" alt="f(x)" valign="middle"/> is a well-defined total recursive function. Let <img src="/img/cache/f0429ac6ea396aa9c587cf3ad0f97608.gif" alt="\phi_e = f" valign="middle"/>, by diagonal construction of <img src="/img/cache/50bbd36e1fd2333108437a2ca378be62.gif" alt="f(x)" valign="middle"/>, <img src="/img/cache/83acef0dae30180bcd6aef67726ffcfb.gif" alt="e \ne i_{g(x)}" valign="middle"/> whenever <img src="/img/cache/ffa0804c3ab46d1570549ca94199b31d.gif" alt="i_{g(x)}" valign="middle"/> is defined.</p>
<p>Now, for any <img src="/img/cache/4a8a08f09d37b73795649038408b5f33.gif" alt="c" valign="middle"/> such that <img src="/img/cache/c4408a0334d47bdd55cfdb7de35b8712.gif" alt="t_c(x) \le b(x)" valign="middle"/> for infinitely many <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/>, let</p>
<div class="N5"><img src="/img/cache/56e8ac13dafe92c0b186f9c92f2c7cd7.gif" alt="
	s = 1 + max \{ m : i_{g(m)}\text{ is defined and }i_{g(m)} \lt c\}
" valign="middle"/></div>
<p>(<img src="/img/cache/d1a3fa1aba369e7b2a03ad68c55a05dc.gif" alt="s = 0" valign="middle"/> if <img src="/img/cache/6f8f57715090da2632453988d9a1501b.gif" alt="m" valign="middle"/> does not exist). Choose <img src="/img/cache/83878c91171338902e0fe0fb97a8c47a.gif" alt="p" valign="middle"/> such that <img src="/img/cache/9ca1fd93c10e7a0d01d189d6ea3b725e.gif" alt="p \ge max\{c,s\}" valign="middle"/> and <img src="/img/cache/98925e649814be04d668ca3b1e68ddcf.gif" alt="t_c(p) \le b(p)" valign="middle"/>. If <img src="/img/cache/b302c71978e6ce730aa736b708b35c6b.gif" alt="c = i_{g(m)}" valign="middle"/> for some <img src="/img/cache/3af9f1655d81f2478112208c906a35a2.gif" alt="m \lt p" valign="middle"/>, there is nothing to prove. Assuming <img src="/img/cache/4255178d486a9c68ebbc52b572b2a87f.gif" alt="c \ne i_{g(m)}" valign="middle"/> for all <img src="/img/cache/3af9f1655d81f2478112208c906a35a2.gif" alt="m \lt p" valign="middle"/>, we have</p>
<img src="/img/cache/173df84895c542713a1cade92d19753b.gif" alt="c \le p\text{ and }c\text{ differs from all previously defined }i_m
\text{ and }t_c(p) \le b(p).\hspace{100}(11)" valign="middle"/>
<p>Hence, <img src="/img/cache/4a8a08f09d37b73795649038408b5f33.gif" alt="c" valign="middle"/> is the least index satisfying (11). From the definition (8) we know that <img src="/img/cache/05c4ff09c45a99d2dab9c2902997161c.gif" alt="i_{g(p)}" valign="middle"/> is defined and equals <img src="/img/cache/4a8a08f09d37b73795649038408b5f33.gif" alt="c" valign="middle"/>. Thus, we have obtained that for any <img src="/img/cache/4a8a08f09d37b73795649038408b5f33.gif" alt="c" valign="middle"/> satisfying <img src="/img/cache/c4408a0334d47bdd55cfdb7de35b8712.gif" alt="t_c(x) \le b(x)" valign="middle"/>, for infinitely many <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/>, there exists a <img src="/img/cache/415290769594460e2e485922904f345d.gif" alt="y" valign="middle"/> such that <img src="/img/cache/4bd1d5cc9cb9a9c0044f19a5c99aa32d.gif" alt="c = i_{g(y)}" valign="middle"/>. Since <img src="/img/cache/e22f4ed7b51775b15fae5e323929699c.gif" alt="e \ne i_{g(y)}" valign="middle"/> whenever <img src="/img/cache/b763b1ba59c27e8dccc7c5470931f2df.gif" alt="i_{g(y)}" valign="middle"/> is defined, it follows that <img src="/img/cache/5055b55ad673e8781702e903666a7943.gif" alt="t_e(x) \gt b(x)" valign="middle"/> a.e.</p>
<p>Let <img src="/img/cache/2fcd23d5d206a51e19eaed56235d75ba.gif" alt="A = \{x : f(x) = 1\}" valign="middle"/>. <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/> is a recursive set, and <img src="/img/cache/98395032dafb4dbef9c3d1e2457c63ec.gif" alt="A \subseteq R" valign="middle"/>.</p>
<div align="right"><img src="/img/cache/09cfa2435552d2f8a90d85e99701606a.gif" alt="\boxempty" valign="middle"/></div>
<p>Roughly speaking, Lemma 4.1 implies that for any infinite recursive set, there exists a recursive subset whose decision procedures have arbitrarily large time complexity.</p>
<p><em>Corollary 4.1:</em> For any total recursive function <img src="/img/cache/0db4b0393eae168851671b28e5f03c5f.gif" alt="b(x)" valign="middle"/>, there exists a recursive set <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/> such that <img src="/img/cache/5055b55ad673e8781702e903666a7943.gif" alt="t_e(x) \gt b(x)" valign="middle"/> a.e., where <img src="/img/cache/e1671797c52e15f763380b45e841ec32.gif" alt="e" valign="middle"/> is any index of characteristic function defined by</p>
<img src="/img/cache/8ad906a485bf333d37b10c758a752814.gif" alt="f(x) = { \{ 1, x \in A\\0, x \not\in A. }\hspace{100}(12)" valign="middle"/>
<p><em>Proof:</em> Let <img src="/img/cache/b785133757592f2f06c74b71e7b80683.gif" alt="R = \mathbb{N}" valign="middle"/>, by Lemma 4.1 we have the conclusion.</p>
<div align="right"><img src="/img/cache/09cfa2435552d2f8a90d85e99701606a.gif" alt="\boxempty" valign="middle"/></div>
<p><em>Corollary 4.2:</em> Let <img src="/img/cache/0db4b0393eae168851671b28e5f03c5f.gif" alt="b(x)" valign="middle"/> be a total recursive function and <img src="/img/cache/e1e1d3d40573127e9ee0480caf1283d6.gif" alt="R" valign="middle"/> be recursively enumerable but not a simple set. Then there exists a recursive set <img src="/img/cache/e9e3a7cfe69f0cfdbe77d8698ff7e614.gif" alt="C \supseteq R" valign="middle"/> such that <img src="/img/cache/fd7d35ca0d1fcfb3c3d9252b702f4763.gif" alt="t_e(x)\gt b(x)" valign="middle"/> a.e., where <img src="/img/cache/e1671797c52e15f763380b45e841ec32.gif" alt="e" valign="middle"/> is any index of characteristic function of <img src="/img/cache/0d61f8370cad1d412f80b84d143e1257.gif" alt="C" valign="middle"/>.</p>
<p><em>Proof:</em> Since <img src="/img/cache/e1e1d3d40573127e9ee0480caf1283d6.gif" alt="R" valign="middle"/> is recursively enumerable and not simple, its complement <img src="/img/cache/91831c7dcee18f70c1be0a75ba446874.gif" alt="\overline{R}" valign="middle"/> contains an infinite recursively enumerable set <img src="/img/cache/9d5ed678fe57bcca610140957afab571.gif" alt="B" valign="middle"/> that again has an infinite recursive subset <img src="/img/cache/511f90342424097709853ee70b80ecd8.gif" alt="B'" valign="middle"/>. Applying Lemma 4.1 to <img src="/img/cache/511f90342424097709853ee70b80ecd8.gif" alt="B'" valign="middle"/>, there is a recursive subset <img src="/img/cache/e204f44c141be90b07f085a7b5a699bd.gif" alt="A, A \subseteq B' \subseteq B \subseteq\overline{R}" valign="middle"/> such that <img src="/img/cache/5055b55ad673e8781702e903666a7943.gif" alt="t_e(x) \gt b(x)" valign="middle"/> a.e., where <img src="/img/cache/e1671797c52e15f763380b45e841ec32.gif" alt="e" valign="middle"/> is any index of characteristic function of <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/>. Let <img src="/img/cache/5929e1c7635238eb9854fc288491b49b.gif" alt="C=\overline{A}" valign="middle"/>, then <img src="/img/cache/0d61f8370cad1d412f80b84d143e1257.gif" alt="C" valign="middle"/> is the set required.</p>
<div align="right"><img src="/img/cache/09cfa2435552d2f8a90d85e99701606a.gif" alt="\boxempty" valign="middle"/></div>
<p><em>Lemma 4.2:</em> Let <img src="/img/cache/0db4b0393eae168851671b28e5f03c5f.gif" alt="b(x)" valign="middle"/> be a total recursive function. For any recursive function <img src="/img/cache/c371b24a22d52e04298fb57724beea2c.gif" alt="f(x,y,z)" valign="middle"/>, there exists a total recursive function <img src="/img/cache/0c391f027d714c7fa900015106f2f04f.gif" alt="k(x,y)" valign="middle"/> such that <img src="/img/cache/f3267884b518723fb7f2ac983d7f4c32.gif" alt="\phi_{k(x,y)}(z) = f(x,y,z)" valign="middle"/> and <img src="/img/cache/a7301950d4b8c112f1a7a100edb1b024.gif" alt="t_e(x,y)\gt b(x)" valign="middle"/> a.e. for all <img src="/img/cache/415290769594460e2e485922904f345d.gif" alt="y" valign="middle"/>, where <img src="/img/cache/e1671797c52e15f763380b45e841ec32.gif" alt="e" valign="middle"/> is any index of <img src="/img/cache/0c391f027d714c7fa900015106f2f04f.gif" alt="k(x,y)" valign="middle"/>.</p>
<p><em>Proof:</em> By the <em>s-m-n</em> theorem, there is a total recursive function <img src="/img/cache/4b43b0aee35624cd95b910189b3dc231.gif" alt="r" valign="middle"/> such that</p>
<img src="/img/cache/8d3bc4c3c29fd7ae5543ac883b4b9ae6.gif" alt="c\phi_{r(x,y,s)}(z) = 1(s)f(x,y,z)\hspace{100}(13)" valign="middle"/>
<p>and <img src="/img/cache/b404379976052ff3d14bca54acd88999.gif" alt="r(x,y,s)" valign="middle"/> satisfies <img src="/img/cache/e55a13d350a53241e6eec8da7db59059.gif" alt="r(x,y,s_1)\ne r(x,y,s_2)" valign="middle"/> (if <img src="/img/cache/76970afe3183d87da321f0df23bad379.gif" alt="s_1\ne s_2" valign="middle"/>) [6].</p>
<p>Define</p>
<img src="/img/cache/ee28e5143544fa1260bed40883f02846.gif" alt="
	k(x,y) = \{
	\begin{align}
		&amp;&amp; r(x,y,1),	&amp;&amp;&amp;\text{if }i_x\text{ is defined}\\
		&amp;&amp;		&amp;&amp;&amp;\text{and }\phi_{i_x}(x) = r(x, y, 0)\\
		&amp;&amp; r(x,y,0),	&amp;&amp;&amp;\text{otherwise
	\end{align}\hspace{100}(14)
" valign="middle"/>
<p>where <img src="/img/cache/e3f21d4067454ed4fd433a852420d048.gif" alt="i_x" valign="middle"/> is given by (8) for <img src="/img/cache/bffcb4027e0819caa88b49a099143087.gif" alt="R=\mathbb{N}" valign="middle"/> and <img src="/img/cache/a7ffed744e9cbf6e34575b9bbb881092.gif" alt="g(y) = y" valign="middle"/>. From the proof of Lemma 4.1, <img src="/img/cache/0c391f027d714c7fa900015106f2f04f.gif" alt="k(x,y)" valign="middle"/> is a total recursive function and <img src="/img/cache/a7301950d4b8c112f1a7a100edb1b024.gif" alt="t_e(x,y)\gt b(x)" valign="middle"/> a.e. for all <img src="/img/cache/415290769594460e2e485922904f345d.gif" alt="y" valign="middle"/>, where <img src="/img/cache/e1671797c52e15f763380b45e841ec32.gif" alt="e" valign="middle"/> is any index of <img src="/img/cache/0c391f027d714c7fa900015106f2f04f.gif" alt="k(x,y)" valign="middle"/>.</p>
<p>Since</p>
<img src="/img/cache/4404034c69e133d838ffdefb402d6859.gif" alt="
\begin{eqnarray}
	\phi_{k(x,y)}(z) &amp;=&amp; { \{
	\begin{align}
		&amp;&amp; \phi_{r(x,y,1)}(z),	&amp;&amp;&amp;\text{if }i_x\text{ is defined}\\
		&amp;&amp;			&amp;&amp;&amp;\text{and }\phi_{i_x}(x) = r(x,y,0)\\
		&amp;&amp; \phi_{r(x,y,0)}(z),	&amp;&amp;&amp;\text{otherwise}
	\end{align} }\\
	&amp;=&amp; { \{
	\begin{align}
		&amp;&amp; \mathbf{1}(1)f(x,y,z),	&amp;&amp;&amp;\text{if }i_x\text{ is defined}\\
		&amp;&amp;				&amp;&amp;&amp;\text{and }\phi_{i_x}(x) = r(x,y,0)\\
		&amp;&amp; \mathbf{1}(0)f(x,y,z),	&amp;&amp;&amp;\text{otherwise}
	\end{align} }\\
	&amp;=&amp; f(x,y,z)\hspace{100}(15)
\end{eqnarray}
" valign="middle"/>
<p>this completes the proof of the lemma.</p>
<div align="right"><img src="/img/cache/09cfa2435552d2f8a90d85e99701606a.gif" alt="\boxempty" valign="middle"/></div>
<p>Lemma 4.2 extends the <em>s-m-n</em> theorem in the sense that the index function <img src="/img/cache/0c391f027d714c7fa900015106f2f04f.gif" alt="k(x,y)" valign="middle"/> could be any recursive function, not just the primitive recursive function as in the <em>s-m-n</em> theorem. Lemma 4.1 can be further extended as follows.</p>
<p><em>Lemma 4.3:</em> For each <img src="/img/cache/e25eca6bde69af8d9083bdcae6072493.gif" alt="m_1,m_2,n\gt1" valign="middle"/>, let <img src="/img/cache/43a0b4812cdbd0cbd6c0388aece88e2a.gif" alt="m=m_1+m_2" valign="middle"/> and <img src="/img/cache/bed7e07eb08d60e78af614e8b3b6d26f.gif" alt="b(\mathbf{x})" valign="middle"/> be a total recursive <img src="/img/cache/377b1a53b01e907138040867edc7cac2.gif" alt="m_1" valign="middle"/>-ary function. There exists a total recursive <img src="/img/cache/1cc447eedcb8021e9c0f5e99151cc822.gif" alt="(m+1)" valign="middle"/>-ary function <img src="/img/cache/e54aabb759c4aea54de3e10ecb63d12d.gif" alt="s^m_n(c,\mathbf{x,y})" valign="middle"/> such that</p>
<img src="/img/cache/8858969f5f454e3d508457242a44ea42.gif" alt="\phi_c^{(m+n)}(\mathbf{x,y,z})=\phi^{(n)}_{s^m_n(c,\mathbf{x,y})}(\mathbf{z})" valign="middle"/>
<p>and <img src="/img/cache/f60cd921e6f3d53ec94dbb303c47595d.gif" alt="t_e(\mathbf{x,y)\gt b(\mathbf{x})" valign="middle"/> a.e. for all <img src="/img/cache/971f2023c1f5f54b8bd389bb06fa6d86.gif" alt="\mathbf{y}" valign="middle"/>, where <img src="/img/cache/e1671797c52e15f763380b45e841ec32.gif" alt="e" valign="middle"/> is any index of <img src="/img/cache/e54aabb759c4aea54de3e10ecb63d12d.gif" alt="s^m_n(c,\mathbf{x,y})" valign="middle"/>.</p>
<p>Lemma 4.3 implies that for any type of computer viruses, there exists a computer virus <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> whose infecting procedure has arbitrarily large time complexity. This conclusion is formulated in the following theorem.</p>
<p><em>Theorem 4.1:</em> Let <img src="/img/cache/0db4b0393eae168851671b28e5f03c5f.gif" alt="b(x)" valign="middle"/> be a total recursive function. For any kind of computer viruses, there exists a computer virus <img src="/img/cache/6668cae114cc8d4dc991ac6152f99da5.gif" alt="v(x)" valign="middle"/> such that <img src="/img/cache/fd7d35ca0d1fcfb3c3d9252b702f4763.gif" alt="t_e(x)\gt b(x)" valign="middle"/> a.e., where <img src="/img/cache/e1671797c52e15f763380b45e841ec32.gif" alt="e" valign="middle"/> is any index of <img src="/img/cache/6668cae114cc8d4dc991ac6152f99da5.gif" alt="v(x)" valign="middle"/>.</p>
<p><em>Proof:</em> Let <img src="/img/cache/0db4b0393eae168851671b28e5f03c5f.gif" alt="b(x)" valign="middle"/> be a total recursive function. Consider</p>
<img src="/img/cache/18b64d90700081cf61a8aceaf4595ddb.gif" alt="
	f(x,k,\langle d,p \rangle) = \{
	\begin{align}
		&amp;&amp; D(d,p),	&amp;&amp;&amp;\text{if }T(d,p)\\
		&amp;&amp; \phi_x(d,p[\phi_k(\underline{S(p)})]),&amp;&amp;&amp;\text{if }I(d,p)\\
		&amp;&amp; \phi_x(d,p),	&amp;&amp;&amp;\text{otherwise.}
	\end{align}\hspace{100}(16)
" valign="middle"/>
<p>By Lemma 4.3, there is a total recursive function <img src="/img/cache/964fe29e804777bc472e15dda74a2ece.gif" alt="h(x,k)" valign="middle"/> such that</p>
<div class="N5"><img src="/img/cache/2f36627c4ee977faa604a336f3da5895.gif" alt="
	\phi_{h(x,k)}(d,p)=f(x,k,\langle d,p \rangle)\hspace{100}(17)
" valign="middle"/></div>
<p>and <img src="/img/cache/9c257f14b4b039e6350e295098026630.gif" alt="t_e(x,k)\gt b(x)" valign="middle"/> a.e. for all <img src="/img/cache/8ce4b16b22b58894aa86c421e8759df3.gif" alt="k" valign="middle"/>, where <img src="/img/cache/e1671797c52e15f763380b45e841ec32.gif" alt="e" valign="middle"/> is any index of <img src="/img/cache/964fe29e804777bc472e15dda74a2ece.gif" alt="h(x,k)" valign="middle"/>.</p>
<p>By the <em>s-m-n</em> theorem, there exists a total recursive function <img src="/img/cache/8bf4d85650409fd312ffedc89279aac1.gif" alt="r(k)" valign="middle"/> such that <img src="/img/cache/80f5d42c31410ba001eb27227d5078bc.gif" alt="\phi_{r(k)}(x)=h(x,k)" valign="middle"/>. By recursion theorem, there is an <img src="/img/cache/7b8b965ad4bca0e41ab51de7b31363a1.gif" alt="n" valign="middle"/> such that <img src="/img/cache/0d8fa9fe75972c52d0958efa1ceb2de1.gif" alt="\phi_{r(n)}=n" valign="middle"/>. Let <img src="/img/cache/4d16326c1a00dfba9dff3fa0c1e621dc.gif" alt="v(x)=h(x,n)=\phi_{r(n)}(x)=\phi_n(x)" valign="middle"/>, then</p>
<img src="/img/cache/592476e5889f7cb564f883fcfd11296c.gif" alt="
\begin{eqnarray}
\phi_{v(x)}(d,p)
	&amp;=&amp; \phi_{h(x,n)}(d,p)=f(x,n,\langle d,p \rangle)\\
	&amp;=&amp; { \{
	\begin{align}
		&amp;&amp; D(d,p),	&amp;&amp;&amp;\text{if }T(d,p)\\
		&amp;&amp; \phi_x(d,p[\phi_n(\underline{S(p)})]),&amp;&amp;&amp;\text{if }I(d,p)\\
		&amp;&amp; \phi_x(d,p),	&amp;&amp;&amp;\text{otherwise}
	\end{align} }\\
	&amp;=&amp; \{
	\begin{align}
		&amp;&amp; D(d,p),	&amp;&amp;&amp;\text{if }T(d,p)\\	
		&amp;&amp; \phi_x(d,p[v(\underline{S(p)})]),&amp;&amp;&amp;\text{if }I(d,p)\\
		&amp;&amp; \phi_x(d,p),	&amp;&amp;&amp;\text{otherwise}
	\end{align} \hspace{100}(18)
\end{eqnarray}
" valign="middle"/>
<p>By Definition 3.1, the total recursive function <img src="/img/cache/6668cae114cc8d4dc991ac6152f99da5.gif" alt="v(x)" valign="middle"/> is a nonresident virus and <img src="/img/cache/fd7d35ca0d1fcfb3c3d9252b702f4763.gif" alt="t_e(x)\gt b(x)" valign="middle"/> a.e., where <img src="/img/cache/e1671797c52e15f763380b45e841ec32.gif" alt="e" valign="middle"/> is any index of <img src="/img/cache/6668cae114cc8d4dc991ac6152f99da5.gif" alt="v(x)" valign="middle"/>. Similar results also hold for other kinds of computer viruses defined in Section III and [7]. This completes the proof of the theorem.</p>
<div align="right"><img src="/img/cache/09cfa2435552d2f8a90d85e99701606a.gif" alt="\boxempty" valign="middle"/></div>
<p>Intuitively, we can construct a virus with arbitrarily large time complexity in its infection procedure by adding time-consuming operations in the procedure. But Theorem 4.1 implies more than that. Since by our definition a virus <img src="/img/cache/6668cae114cc8d4dc991ac6152f99da5.gif" alt="v(x)" valign="middle"/> is a recursive function mapping a program <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/> into
 
its infected form <img src="/img/cache/6668cae114cc8d4dc991ac6152f99da5.gif" alt="v(x)" valign="middle"/>, Theorem 4.1 shows that for any kind of computer viruses there is a virus <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> such that any implementation of <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> can have arbitrarily large time complexity in its infection procedure.</p>
<p>It is natural to ask whether there exists a computer virus <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> such that the infected program <img src="/img/cache/6668cae114cc8d4dc991ac6152f99da5.gif" alt="v(x)" valign="middle"/> has arbitrarily large time complexity for any program <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/>. In general the answer is NO, because <img src="/img/cache/2724a23b16ca720546476383e9bc8610.gif" alt="\phi_x" valign="middle"/> may be a partial recursive function, and if so, by infinite imitation requirement (see c) in Definition 3.1) the function <img src="/img/cache/fc7b6e0867e5a0654cd3f4ef59238587.gif" alt="\phi_{v(x)}(d,p)" valign="middle"/> computed by the infected program <img src="/img/cache/6668cae114cc8d4dc991ac6152f99da5.gif" alt="v(x)" valign="middle"/> is also a partial recursive function, as well as the function <img src="/img/cache/6d054ead87c0b3b838647d884963c3e1.gif" alt="t_{v(x)}(d,p)" valign="middle"/>. Hence, the comparison with a total recursive function <img src="/img/cache/3aa3db8eed31f4425f0b54bc889d2d60.gif" alt="b(d,p)" valign="middle"/> may be meaningless at infinitely many points. But for total recursive functions we have the following result.</p>
<p><em>Theorem 4.2:</em> Let <img src="/img/cache/0db4b0393eae168851671b28e5f03c5f.gif" alt="b(x)" valign="middle"/> be a total recursive function. There exists a computer virus <img src="/img/cache/6668cae114cc8d4dc991ac6152f99da5.gif" alt="v(x)" valign="middle"/> such that <img src="/img/cache/d8814b422f7d249d8d03f8be7ec91e11.gif" alt="t_{v(x)}(d,p)\gt b(d,p)" valign="middle"/> a.e. for any total recursive function <img src="/img/cache/2724a23b16ca720546476383e9bc8610.gif" alt="\phi_x" valign="middle"/>.</p>
<p><em>Proof:</em> For each <img src="/img/cache/dae17a4c03cdf149bc2093c503502caf.gif" alt="x,k\in\mathbb{N}" valign="middle"/>, consider</p>
<img src="/img/cache/7349d64286ccad0ef2a7afdaba2e09bc.gif" alt="
	f(x,k,\langle{d,p}\rangle) = \{
	\begin{align}
		&amp;&amp;1,&amp;&amp;&amp;\text{if }i_{\langle{d,p}\rangle}\text{ is defined}\\
		&amp;&amp;  &amp;&amp;&amp;\text{and }\phi_{i_{\langle{d,p}\rangle}}(d,p) = 0\\
		&amp;&amp;0,&amp;&amp;&amp;\text{if }i_{\langle{d,p}\rangle}\text{ is defined}\\
		&amp;&amp;  &amp;&amp;&amp;\text{and }\phi_{i_{\langle{d,p}\rangle}}(d,p)\ne 0\\
		&amp;&amp; \phi_x(d,p[\phi_k(\underline{(p)_1})]),
		    &amp;&amp;&amp;\text{if }i_{\langle{d,p}\rangle}\text{ is undefined}\\
		&amp;&amp;  &amp;&amp;&amp;\text{and }(d)_1 = 0\\
		&amp;&amp; \phi_x(d,p),	&amp;&amp;&amp;\text{otherwise}
	\end{align}\hspace{100}(19)
" valign="middle"/>
<p>where <img src="/img/cache/79003bcbd4a79a3c2d6e2a163c4b8c37.gif" alt="i_{\langle{d,p}\rangle}" valign="middle"/> is defined in (8) with <img src="/img/cache/bffcb4027e0819caa88b49a099143087.gif" alt="R=\mathbb{N}" valign="middle"/> and <img src="/img/cache/3a65cff4a8be3b4952712528121df9b6.gif" alt="g(d,p)=\langle{d,p}\rangle" valign="middle"/>. By the proof of Lemma 4.1, <img src="/img/cache/c8e7e6c85375e47ae011b77feb98da7a.gif" alt="f(x,k,\langle{d,p}\rangle)" valign="middle"/> is a recursive function, and if <img src="/img/cache/2724a23b16ca720546476383e9bc8610.gif" alt="\phi_x" valign="middle"/> is a total recursive function and <img src="/img/cache/e1671797c52e15f763380b45e841ec32.gif" alt="e" valign="middle"/> is an index of <img src="/img/cache/8fa14cdd754f91cc6554c9e71929cce7.gif" alt="f" valign="middle"/>, then <img src="/img/cache/be48c4e024d68cba41fd80b46bbf2ba5.gif" alt="t_e(d,p)\gt b(d,p)" valign="middle"/> for almost all <img src="/img/cache/7b697bbacb8b13df9519174ac2209719.gif" alt="\langle d,p \rangle" valign="middle"/>.</p>
<p>From the proof of Theorem 4.1, there is a total recursive function <img src="/img/cache/6668cae114cc8d4dc991ac6152f99da5.gif" alt="v(x)" valign="middle"/> satisfying</p>
<img src="/img/cache/971fc9745503a4a4b8e6ee0c95729671.gif" alt="
	\phi_{v(x)}(d,p) = \{
	\begin{align}
		&amp;&amp;1,&amp;&amp;&amp;\text{if }i_{\langle{d,p}\rangle}\text{ is defined}\\
		&amp;&amp;  &amp;&amp;&amp;\text{and }\phi_{i_{\langle{d,p}\rangle}}(d,p) = 0 &amp; (i)\\
		&amp;&amp;0,&amp;&amp;&amp;\text{if }i_{\langle{d,p}\rangle}\text{ is defined}\\
		&amp;&amp;  &amp;&amp;&amp;\text{and }\phi_{i_{\langle{d,p}\rangle}}(d,p)\ne 0 &amp;(i')\\
		&amp;&amp; \phi_x(d,p[v(\underline{(p)_1})]),
		    &amp;&amp;&amp;\text{if }i_{\langle{d,p}\rangle}\text{ is undefined}\\
		&amp;&amp;  &amp;&amp;&amp;\text{and }(d)_1 = 0 &amp;(ii)\\
		&amp;&amp; \phi_x(d,p),	&amp;&amp;&amp;\text{otherwise}&amp;(iii)
	\end{align}\hspace{100}(20)
" valign="middle"/>
<p>By Definition 3.1, the total recursive function <img src="/img/cache/6668cae114cc8d4dc991ac6152f99da5.gif" alt="v(x)" valign="middle"/> is a nonresident virus. (In (20), condition (i) and (i'), (ii), (iii) denote injury, infection, and imitation of nonresident viruses, respectively.)</p>
<p>Since <img src="/img/cache/6668cae114cc8d4dc991ac6152f99da5.gif" alt="v(x)" valign="middle"/> is an index of the recursive function <img src="/img/cache/8fa14cdd754f91cc6554c9e71929cce7.gif" alt="f" valign="middle"/>, it follows that <img src="/img/cache/d8814b422f7d249d8d03f8be7ec91e11.gif" alt="t_{v(x)}(d,p)\gt b(d,p)" valign="middle"/> a.e. for total recursive function <img src="/img/cache/2724a23b16ca720546476383e9bc8610.gif" alt="\phi_x" valign="middle"/>.</p>
<div align="right"><img src="/img/cache/09cfa2435552d2f8a90d85e99701606a.gif" alt="\boxempty" valign="middle"/></div>
<p>Virus detection is one of the most important issues in antivirus practice. It is well known that the set of all computer viruses is undecidable [1]. Furthermore, there exists a computer virus <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> such that the set of its infected programs is undecidable [3], [11]. In other words, we can never find a procedure to pick up exactly all the programs infected by <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/>. Formally, let <img src="/img/cache/dd37bd1236d0866f307e682735b27245.gif" alt="I_v=E_v=\{v(x):x\in\mathbb{N}\}" valign="middle"/> [3], then <img src="/img/cache/7becf419ca4290e38585809f5624b28d.gif" alt="I_v" valign="middle"/> is a nonrecursive recursively enumerable set. To find all programs infected by <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/>, it is necessary to find a recursive set <img src="/img/cache/0d61f8370cad1d412f80b84d143e1257.gif" alt="C" valign="middle"/> such that <img src="/img/cache/4fb1c2d816e6e79bccdce5eb4945c713.gif" alt="I_v \subset C" valign="middle"/>. This implies that for every detecting procedure of <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/>, if it has no false negatives, then it always has false positives.</p>
<p>Although most of the computer viruses in real world are decidable, there are still two unresolved questions. 1) If <img src="/img/cache/7becf419ca4290e38585809f5624b28d.gif" alt="I_v" valign="middle"/> is decidable, what is its time complexity? 2) If <img src="/img/cache/7becf419ca4290e38585809f5624b28d.gif" alt="I_v" valign="middle"/> is undecidable, what is the time complexity of the recursive set containing <img src="/img/cache/7becf419ca4290e38585809f5624b28d.gif" alt="I_v" valign="middle"/>? The following theorem gives a partial answer to the first question.</p>
<p><em>Theorem 4.3:</em> Let <img src="/img/cache/0db4b0393eae168851671b28e5f03c5f.gif" alt="b(x)" valign="middle"/> be a total recursive function, then there exists a decidable computer virus <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> such that <img src="/img/cache/304c69f8f4f35498ee15096b9905eca0.gif" alt="t_{e(m)}\gt b(m)" valign="middle"/> for infinitely many <img src="/img/cache/6f8f57715090da2632453988d9a1501b.gif" alt="m" valign="middle"/>, where <img src="/img/cache/e1671797c52e15f763380b45e841ec32.gif" alt="e" valign="middle"/> is any index of characteristic function of <img src="/img/cache/7becf419ca4290e38585809f5624b28d.gif" alt="I_v" valign="middle"/>.</p>
<p><em>Proof:</em> Let <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/> be an infinite recursive set and <img src="/img/cache/b2f5ff47436671b6e533d8dc3614845d.gif" alt="g" valign="middle"/> be an increasing recursive function with <img src="/img/cache/947e6f3c7efc7717f4e4341c33920771.gif" alt="E_g=A" valign="middle"/>. Consider</p>
<img src="/img/cache/0c4eeebe647590b3f2af9369bd9bbe58.gif" alt="
	h(x,k,y,\langle d,p\rangle) = \{
	\begin{align}
		&amp;&amp; f(x,k,m,\langle d,p \rangle),	&amp;&amp;&amp; \exist m.y=g(m)\\
		&amp;&amp; \mathbf{Id},	&amp;&amp;&amp;\text{otherwise}
	\end{align}\hspace{100}(21)
" valign="middle"/>
<p>where <img src="/img/cache/4d395507e2a11fec4bc78fa96873ac26.gif" alt="\mathbf{Id}" valign="middle"/> is the identity function, and <img src="/img/cache/8fa14cdd754f91cc6554c9e71929cce7.gif" alt="f" valign="middle"/> is defined by</p>
<img src="/img/cache/a32a4791367e98c9f77d0e1e78d6603a.gif" alt="
	f(x,k,m,\langle d,p \rangle) = \{
	\begin{align}
		&amp;&amp; D(d,p),	&amp;&amp;&amp;\text{if }T(d,p)\\
		&amp;&amp; \phi_x(d,p[\phi_k(g(m+1),\underline{S(p)})]),&amp;&amp;&amp;\text{if }I(d,p)\\
		&amp;&amp; \phi_x(d,p),	&amp;&amp;&amp;\text{otherwise.}
	\end{align}\hspace{100}(22)
" valign="middle"/>
<p>From the proof of Theorem 4.1, there is a recursive function <img src="/img/cache/a240eac329c2d34223d106b9d0a9153b.gif" alt="s(x,y)" valign="middle"/> such that</p>
<img src="/img/cache/7486713077323b34fb8c8285b9a70ca6.gif" alt="
	\phi_{s(x,y)}(d,p) = \{
	\begin{align}
		&amp;&amp; f'(x,k,m,\langle d,p \rangle),	&amp;&amp;&amp; \exist m.y=g(m)\\
		&amp;&amp; \mathbf{Id},	&amp;&amp;&amp;\text{otherwise}
	\end{align}\hspace{100}(23)
" valign="middle"/>
<p>and</p>
<img src="/img/cache/b3c39043991a7a7eaf184c965305dd56.gif" alt="
	f'(x,k,m,\langle d,p \rangle) = \{
	\begin{align}
		&amp;&amp; D(d,p),	&amp;&amp;&amp;\text{if }T(d,p)\\
		&amp;&amp; \phi_x(d,p[s(g(m+1),\underline{S(p)})]),&amp;&amp;&amp;\text{if }I(d,p)\\
		&amp;&amp; \phi_x(d,p),	&amp;&amp;&amp;\text{otherwise.}
	\end{align}\hspace{100}(24)
" valign="middle"/>
<p>Moreover, <img src="/img/cache/a240eac329c2d34223d106b9d0a9153b.gif" alt="s(x,y)" valign="middle"/> is an increasing function [10]. Let <img src="/img/cache/39339580449861a5156e2bad5a6a9acd.gif" alt="v(m,x)=s(g(m),x)" valign="middle"/>, then</p>
<img src="/img/cache/215316f9dd83ed240e5bf5f464bf4dc2.gif" alt="
	\phi_{v(m,x)}(d,p)=\{
	\begin{align}
		&amp;&amp; D(d,p),	&amp;&amp;&amp;\text{if }T(d,p)\\
		&amp;&amp; \phi_x(d,p[v(m+1,\underline{S(p)}]),&amp;&amp;&amp;\text{if }I(d,p)\\
		&amp;&amp; \phi_x(d,p),	&amp;&amp;&amp;\text{otherwise.}
	\end{align}\hspace{100}(25)
" valign="middle"/>
<p>By Definition 3.3, <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> is a polymorphic virus with infinite forms.</p>
<p>Let <img src="/img/cache/73bf41206aa5da0e0feec4efdb2d1dfe.gif" alt="I_v=\{v(m,x)|m,x\in\mathbb{N}\}" valign="middle"/>. Since <img src="/img/cache/b2f5ff47436671b6e533d8dc3614845d.gif" alt="g" valign="middle"/> and <img src="/img/cache/03c7c0ace395d80182db07ae2c30f034.gif" alt="s" valign="middle"/> are increasing functions, <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> is also an increasing function. This implies that <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> is a decidable virus and <img src="/img/cache/7becf419ca4290e38585809f5624b28d.gif" alt="I_v" valign="middle"/> is recursive. Let <img src="/img/cache/b597c404a2bc0bec41e1532a45e88c2d.gif" alt="r(m)=v(m,n)" valign="middle"/>, then <img src="/img/cache/6103b5191bcc763a98e31887f0e52565.gif" alt="m\in A \Leftrightarrow r(m) \in I_v" valign="middle"/>. By Corollary 4.1, there is a set <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/> such that <img src="/img/cache/bc6d07e4b35bbc45b643ca084045d5ec.gif" alt="t_{e'}(x)\gt b(r(x))" valign="middle"/> a.e., where <img src="/img/cache/b3de4acf4668c2067091c166b31a1270.gif" alt="e'" valign="middle"/> is any index of the characteristic function of <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/>.</p>
<p>Now suppose <img src="/img/cache/4a8a08f09d37b73795649038408b5f33.gif" alt="c" valign="middle"/> is the characteristic function of <img src="/img/cache/7becf419ca4290e38585809f5624b28d.gif" alt="I_v" valign="middle"/> and <img src="/img/cache/e1671797c52e15f763380b45e841ec32.gif" alt="e" valign="middle"/> is one of its indices, since <img src="/img/cache/12ae92377b7d27f8cd39059bf1510426.gif" alt="c(r(x))" valign="middle"/> is the characteristic function of <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/>, <img src="/img/cache/ad16eab7652d5d2f886ba2325754a696.gif" alt="t_e(r(x) \gt b(r(x))" valign="middle"/> a.e.. Let <img src="/img/cache/117d98d47af88f57129af3b6bd0d2e21.gif" alt="m=r(x)" valign="middle"/>, this completes the proof of the theorem.</p>
<div align="right"><img src="/img/cache/09cfa2435552d2f8a90d85e99701606a.gif" alt="\boxempty" valign="middle"/></div>
<p>When <img src="/img/cache/d54c5463680e3c416faa99b718abc817.gif" alt="Iv" valign="middle"/> is undecidable, we should consider the time complexity of the recursive sets containing <img src="/img/cache/7becf419ca4290e38585809f5624b28d.gif" alt="I_v" valign="middle"/>. The following theorem shows that for any undecidable computer virus, there is one detecting procedure which has arbitrarily large time complexity.</p>
<p><em>Theorem 4.4:</em> Suppose <img src="/img/cache/6668cae114cc8d4dc991ac6152f99da5.gif" alt="v(x)" valign="middle"/> is a computer virus and <img src="/img/cache/7becf419ca4290e38585809f5624b28d.gif" alt="I_v" valign="middle"/> is a nonrecursive recursively enumerable set. For any total recursive function <img src="/img/cache/0db4b0393eae168851671b28e5f03c5f.gif" alt="b(x)" valign="middle"/> there exists a recursive set <img src="/img/cache/11e70060b41386b1ec86cacbf322470c.gif" alt="C \supseteq I_v" valign="middle"/> such that <img src="/img/cache/fd7d35ca0d1fcfb3c3d9252b702f4763.gif" alt="t_e(x)\gt b(x)" valign="middle"/> a.e., where <img src="/img/cache/e1671797c52e15f763380b45e841ec32.gif" alt="e" valign="middle"/> is any index of the characteristic function of <img src="/img/cache/0d61f8370cad1d412f80b84d143e1257.gif" alt="C" valign="middle"/>.</p>
<p><em>Proof:</em> Let <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> be a computer virus and <img src="/img/cache/4d395507e2a11fec4bc78fa96873ac26.gif" alt="\mathbf{Id}" valign="middle"/> be the identity function. By Rice's theorem, <img src="/img/cache/c059104e917e653c938ff86b64fe29fa.gif" alt="\{i|\phi_i \equiv \mathbf{Id}\}" valign="middle"/> is a recursively enumerable set. By Definition 3.1 b), <img src="/img/cache/86f5019c3bd8b964156b82bd45c1f0cf.gif" alt="\phi_{v(x)}" valign="middle"/> is not an identify function for all <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/>. This implies if <img src="/img/cache/865c0c0b4ab0e063e5caa3387c1a8741.gif" alt="i" valign="middle"/> is any index of <img src="/img/cache/4d395507e2a11fec4bc78fa96873ac26.gif" alt="\mathbf{Id}" valign="middle"/>, then <img src="/img/cache/3c6c6ad74dbade13cf490d2b19aa95ff.gif" alt="i\not\in I_v" valign="middle"/>. Hence, <img src="/img/cache/c23486b225cf8c994e37c64c58b52c09.gif" alt="\{i|\phi_i \equiv \mathbf{Id}\} \cap I_v = 0" valign="middle"/> and <img src="/img/cache/7becf419ca4290e38585809f5624b28d.gif" alt="I_v" valign="middle"/> is not a simple set. By Corollary 4.2 we have the conclusion.</p>
<div align="right"><img src="/img/cache/09cfa2435552d2f8a90d85e99701606a.gif" alt="\boxempty" valign="middle"/></div>
<p>If <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> is an undecidable computer virus, that is, <img src="/img/cache/7becf419ca4290e38585809f5624b28d.gif" alt="I_v" valign="middle"/> is a nonrecursive
recursive enumerable set, then <img src="/img/cache/3e1e28069163bfba8c8a262f749efea6.gif" alt="(C - I_v)" valign="middle"/> is infinite for any recursive set <img src="/img/cache/0d61f8370cad1d412f80b84d143e1257.gif" alt="C" valign="middle"/> containing <img src="/img/cache/7becf419ca4290e38585809f5624b28d.gif" alt="I_v" valign="middle"/>. This implies that any of its detecting procedures which can pick up all of its infected program, will make infinitely many errors (false positives). However, it is often desired to find the detecting procedure that gives "minimal" errors. In other words, we want to find
 
a minimal recursive set <img src="/img/cache/0d61f8370cad1d412f80b84d143e1257.gif" alt="C" valign="middle"/> such that <img src="/img/cache/4fb1c2d816e6e79bccdce5eb4945c713.gif" alt="I_v \subset C" valign="middle"/>. Here a recursive set <img src="/img/cache/0d61f8370cad1d412f80b84d143e1257.gif" alt="C" valign="middle"/> containing <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/> is called minimal means that for any recursive set <img src="/img/cache/9d5ed678fe57bcca610140957afab571.gif" alt="B" valign="middle"/> such that <img src="/img/cache/f79308f66113402425cd8949419f347b.gif" alt="A \subset B \subset C" valign="middle"/>, the set <img src="/img/cache/fd554b93657b57c80e0cdf6448be5035.gif" alt="(C-B)" valign="middle"/> is finite. In the following theorem, we prove that this desired minimal recursive set does not exist for some computer viruses. The proof, inspired by Adleman [3], depends on the following lemma.</p>
<p><em>Lemma 4.4:</em> Let <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/> be a creative set. Then there is no minimal recursive set containing <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/>.</p>
<p><em>Proof:</em> Let <img src="/img/cache/4130c89f2d12c3ac81aba3adbff28685.gif" alt="p(x)" valign="middle"/> be the productive function of <img src="/img/cache/44d21eb24abf5b8ce627a91fb280d7b1.gif" alt="\overline{A}" valign="middle"/>.
If <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/> satisfies <img src="/img/cache/b478eeb78241322e42a7bb30fcf12173.gif" alt="W_x \cap A = \emptyset" valign="middle"/>, then clearly <img src="/img/cache/ab4688a55f8296b12ee18cf9f1cef603.gif" alt="p(x)\not\in W_x" valign="middle"/> and <img src="/img/cache/85d15fd60db270218e17804ff0e43fda.gif" alt="p(x)\not\in A" valign="middle"/>. By the <em>s-m-n</em> theorem, let <img src="/img/cache/b2f5ff47436671b6e533d8dc3614845d.gif" alt="g" valign="middle"/> be a recursive function such that for all <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/></p>
<div class="N5"><img src="/img/cache/f2a0c922b4fb15482d8c7d45be34537c.gif" alt="
	W_{g(x)} = W_x \cup \{p(x)\}.
" valign="middle"/></div>
<p>Suppose <img src="/img/cache/0d61f8370cad1d412f80b84d143e1257.gif" alt="C" valign="middle"/> is a recursive set such that <img src="/img/cache/958ffd3bd2eb633a014975f4a1349c9a.gif" alt="A \subset C" valign="middle"/>, and let <img src="/img/cache/821bf26c791f0d2917f0f53c36df9b0a.gif" alt="D = \overline{C}" valign="middle"/>. Since <img src="/img/cache/f623e75af30e62bbd73d6df5b50bb7b5.gif" alt="D" valign="middle"/> is recursively enumerable, <img src="/img/cache/34d684dea431e400600ff3286a067114.gif" alt="D = W_e" valign="middle"/> for some <img src="/img/cache/e1671797c52e15f763380b45e841ec32.gif" alt="e" valign="middle"/>. Now let</p>
<div class="N5"><img src="/img/cache/7ea53a6e14bbe1f49a72249fcd5221cc.gif" alt="
	H = \{p(e),g(p(e)),g(g(p(e))),\dots\}.
" valign="middle"/></div>
<p>Clearly <img src="/img/cache/c1d9f50f86825a1a2302ec2449c17196.gif" alt="H" valign="middle"/> is recursively enumerable. Since <img src="/img/cache/9cc728667448d7ea6cbbbf02af18fbc5.gif" alt="p(e),g(p(e)),g(g(p(e))),\dots" valign="middle"/> are pairwise distinct, <img src="/img/cache/c1d9f50f86825a1a2302ec2449c17196.gif" alt="H" valign="middle"/> is infinite and has some infinite recursive subset <img src="/img/cache/ff44570aca8241914870afbc310cdb85.gif" alt="J" valign="middle"/>. Also, by the above properties, <img src="/img/cache/ffb5a554120d72b1c15191d1bafbd7b8.gif" alt="H \cap D = H \cap A = \emptyset" valign="middle"/>. Hence, <img src="/img/cache/8720da15e3e2178ef2a57c2450d9f58e.gif" alt="J \subseteq C" valign="middle"/> and <img src="/img/cache/f4a0aede7cd36f1be96f8d80aa3ce7a2.gif" alt="A \subseteq \overline{J}" valign="middle"/>. Let <img src="/img/cache/e373ababf5f4cb5cec49dab7aa8bbbda.gif" alt="B = C - J" valign="middle"/>, then <img src="/img/cache/9d5ed678fe57bcca610140957afab571.gif" alt="B" valign="middle"/> is recursive and <img src="/img/cache/f79308f66113402425cd8949419f347b.gif" alt="A \subset B \subset C" valign="middle"/>, but <img src="/img/cache/fd554b93657b57c80e0cdf6448be5035.gif" alt="(C-B)" valign="middle"/> is infinite.</p>
<div align="right"><img src="/img/cache/09cfa2435552d2f8a90d85e99701606a.gif" alt="\boxempty" valign="middle"/></div>
<p><em>Theorem 4.5:</em> There exists computer virus <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> such that <img src="/img/cache/7becf419ca4290e38585809f5624b28d.gif" alt="I_v" valign="middle"/> is nonrecursive and there is no minimal recursive set containing it.</p>
<p><em>Proof:</em> Let <img src="/img/cache/a4b899d54f06e3fe98af933b71b6d6d6.gif" alt="j(i,y)" valign="middle"/> be an increasing padding function, i.e., for all <img src="/img/cache/865c0c0b4ab0e063e5caa3387c1a8741.gif" alt="i" valign="middle"/> and <img src="/img/cache/415290769594460e2e485922904f345d.gif" alt="y" valign="middle"/>, <img src="/img/cache/40a25288763097594ecab56d798db186.gif" alt="\phi_{j(i,y)}(x)=\phi_i(x)" valign="middle"/>. Let <img src="/img/cache/74d92a80bf2e0c88992ff70d72e9dd71.gif" alt="\mathbf{K}=\{e:e\inW_e\}" valign="middle"/> and <img src="/img/cache/b2f5ff47436671b6e533d8dc3614845d.gif" alt="g" valign="middle"/> be the total recursive function such that <img src="/img/cache/8180d64e759a11222785dce22a6fea9f.gif" alt="\mathbf{K}=E_g" valign="middle"/>. Consider the function</p>
<div class="N5"><img src="/img/cache/d75356689763614a10a3f79561827166.gif" alt="
	h(i) = \{
	\begin{align}
		&amp;&amp; j(1,g(y)),	&amp;&amp;&amp; i = j(1,y)\\
		&amp;&amp; j(i,g(0)),	&amp;&amp;&amp; \text{otherwise.}
	\end{align}\hspace{100}(26)
" valign="middle"/></div>
<p>It is clear that <img src="/img/cache/89352fdedd4bba1db84480b900dfcf2a.gif" alt="\phi_{h(i)}(x)=\phi_i(x)" valign="middle"/>. Let <img src="/img/cache/e6c177c70bac57a20b3f4b5d3a085b7f.gif" alt="c(y)=j(1,y)" valign="middle"/>, since <img src="/img/cache/363b122c528f54df4a0446b6bab05515.gif" alt="j" valign="middle"/> is a one-to-one function, it follows that</p>
<div class="N5"><img src="/img/cache/563154132e59ea56f4334b6e000b4110.gif" alt="
	y \in \mathbf{K} \Leftrightarrow c(y) \in E_h.\hspace{100}(27)
" valign="middle"/></div>
<p>Now let <img src="/img/cache/2a6eff745d715eb17abc207359729725.gif" alt="f(x,k)" valign="middle"/> be the one-to-one total recursive function such that</p>
<img src="/img/cache/7577ec0587bbffe12f1e6ce0b8db574b.gif" alt="
	\phi_{f(x,k)}(d,p)=\{
	\begin{align}
		&amp;&amp; D(d,p),	&amp;&amp;&amp; \text{if }T(d,p)\\
		&amp;&amp; \phi_x(d,p[\phi_k(h(\underline{S(p)}))]), &amp;&amp;&amp; \text{if }I(d,p)\\
		&amp;&amp; \phi_x(d,p),	&amp;&amp;&amp; \text{otherwise.}
	\end{align}\hspace{100}(28)
" valign="middle"/>
<p>From the proof of Theorem 4.1, there exits a total function <img src="/img/cache/c8680fa208df369c16fc14c68f7d5242.gif" alt="s(x)" valign="middle"/> such that</p>
<img src="/img/cache/3996391609019b1732d51dc04940ac2b.gif" alt="
	\phi_{s(x)}(d,p)=\{
	\begin{align}
		&amp;&amp; D(d,p),	&amp;&amp;&amp; \text{if }T(d,p)\\
		&amp;&amp; \phi_x(d,p[s(h(\underline{S(p)}))]), &amp;&amp;&amp; \text{if }I(d,p)\\
		&amp;&amp; \phi_x(d,p),	&amp;&amp;&amp; \text{otherwise.}
	\end{align}\hspace{100}(29)
" valign="middle"/>
<p>Substituting <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/> by <img src="/img/cache/ca8e608169b20a94570ac837e8ba0833.gif" alt="h(x)" valign="middle"/> in (29), it follows that</p>
<img src="/img/cache/67bcf9d71536c50943bcfc95f8e3d573.gif" alt="
\begin{eqnarray}
	\phi_{s(h(x))}(d,p) &amp;=&amp; { \{
	\begin{align}
		&amp;&amp; D(d,p),	&amp;&amp;&amp; \text{if }T(d,p)\\
		&amp;&amp; \phi_{h(x)}(d,p[s(h(\underline{S(p)}))]), &amp;&amp;&amp; \text{if }I(d,p)\\
		&amp;&amp; \phi_{h(x)}(d,p),	&amp;&amp;&amp; \text{otherwise.}
	\end{align}\hspace{100} }\\
	&amp;=&amp; \{
	\begin{align}
		&amp;&amp; D(d,p),	&amp;&amp;&amp; \text{if }T(d,p)\\
		&amp;&amp; \phi_x(d,p[s(h(\underline{S(p)}))]), &amp;&amp;&amp; \text{if }I(d,p)\\
		&amp;&amp; \phi_x(d,p),	&amp;&amp;&amp; \text{otherwise.}
	\end{align}\hspace{100}(30)
\end{eqnarray}
" valign="middle"/>
<p>Let <img src="/img/cache/e9636fafd8de23763d6afb0ad8b20d28.gif" alt="v = sh" valign="middle"/>, then <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> is a nonresident virus by Definition 3.1. Since <img src="/img/cache/03c7c0ace395d80182db07ae2c30f034.gif" alt="s" valign="middle"/> is a one-to-one total function, <img src="/img/cache/b0c23829479e72b8c355d5d87ce3750b.gif" alt="x \in E_h \Leftrightarrow s(x) \in I_v" valign="middle"/>. Combined with (27) we have</p>
<img src="/img/cache/c3c26ec607d88901c50ab83027f0932c.gif" alt="y \in \mathbf{K}, s(c(y)) \in I_v\hspace{100}(31)" valign="middle"/>
<p>i.e., <img src="/img/cache/50a10a2e345629a15bbd994b144050a5.gif" alt="\mathbf{K} \le{}_1 I_v" valign="middle"/>. It means <img src="/img/cache/7becf419ca4290e38585809f5624b28d.gif" alt="I_v" valign="middle"/> is 1-complete set, hence equivalently creative set. From Lemma 4.4, it follows that there is no minimal recursive set containing <img src="/img/cache/7becf419ca4290e38585809f5624b28d.gif" alt="I_v" valign="middle"/>.</p>
<div align="right"><img src="/img/cache/09cfa2435552d2f8a90d85e99701606a.gif" alt="\boxempty" valign="middle"/></div>
<h2>V. Conclusion</h2>
<p>In this correspondence, we discussed the time complexity of computer viruses. The main contributions are as follows.</p>
<ol>
<li>We proved that there are computer viruses with arbitrarily large time complexity, not only in their infecting procedures, but also in their executing procedures.</li>
<li>We proved that there are computer viruses whose detecting procedures have sufficiently large time complexity.</li>
<li>We proved that there are undecidable viruses which have no minimal detecting procedure.</li>
</ol>
<p>It is worth noting that in our discussions we used only the following two features of <img src="/img/cache/5f2717c07bc0ca68295d015a261586e5.gif" alt="t_e" valign="middle"/>:</p>
<ol>
<li><img src="/img/cache/c517accd3cde0023f747788071f007f4.gif" alt="Dom(t_e) = Dom(e)" valign="middle"/> for all <img src="/img/cache/e1671797c52e15f763380b45e841ec32.gif" alt="e" valign="middle"/>; and</li>
<li><img src="/img/cache/c8cf22baceba0c6e6ebfccb190c1c713.gif" alt="\quot t_e(x) \simeq y\quot" valign="middle"/> is decidable.</li>
</ol>
<p>If we take these two conditions as axioms (as in [5]), all of the conclusions on time complexity of computer viruses can be extended directly to other computational complexity satisfying these two assumptions, such as space complexity of computer viruses, etc.</p>
<p>Contrary to the conclusion of Theorem 4.4, in antivirus practice we are concerned more about the existence of a recursive set <img src="/img/cache/0d61f8370cad1d412f80b84d143e1257.gif" alt="C" valign="middle"/> satisfying <img src="/img/cache/8682e1ef121a6acabffad3b76bfe39c2.gif" alt="I_v \subseteq C" valign="middle"/> and the characteristic function of <img src="/img/cache/0d61f8370cad1d412f80b84d143e1257.gif" alt="C" valign="middle"/> have "low" time complexity, such as linear or polynomial time complexity. This problem is trivial when <img src="/img/cache/82087c9d5bb5ec7bb0573b95604a9388.gif" alt="C = \mthbb{N}" valign="middle"/>, but if we require that <img src="/img/cache/eb04d5b4538c80c643194ef87ee64ac2.gif" alt="(\mathbb{N} - C)" valign="middle"/> is infinite and <img src="/img/cache/0d61f8370cad1d412f80b84d143e1257.gif" alt="C" valign="middle"/> is as small as possible, it is an open problem.</p>
<p>For example, typical pattern-based virus-detection software is usually based on the Boyer-Moore string-searching algorithm [12] (or similar algorithms), and can detect most of simple computer viruses with false positives in linear time. But it is not clear whether there are linear or polynomial algorithms which can work for all kinds of computer viruses, especially for undecidable computer viruses.</p>
<h2>Acknowledgment</h2>
<p>The authors wish to thank the referees for their helpful comments that improved the correspondence greatly.</p>
<h2>References</h2>
<ol>
<li>F. Cohen, "<a href="/lib/afc10.html">Computational aspects of computer viruses</a>," <em>Computers &amp; Security</em>, vol. 8, no. 1, pp. 325-344, 1989.</li>
<li>F. Cohen, <em><a href="/lib/afc13.html">A Short Course on Computer Viruses</a>.</em> New York: Wiley, 1994.</li>
<li>L. M. Adleman, "<a href="/lib/ala01.html">An abtract theory of computer viruses</a>," in <em>Advances in Cryptology-CRYPTO'88 (Lecture Notes in Computer Science)</em>, S. Goldwasser, Ed. Berlin, Germany, 1988, vol. 403, pp. 354-374.</li>
<li>D. Spinellis, "<a href="/lib/ads03.html">Reliable identification of bounded-length viruses is NP-complete</a>," <em>IEEE Trans. Inf. Theory</em>, vol. 49, no. 1, pp. 280-284, Jan. 2003.</li>
<li>M. Blum, "A machine-independent theory of the complexity of recursive function," <em>J. ACM</em>, vol. 14, no. 2, pp. 322-336, 1967.</li>
<li>N. Cutland, <em>Computability: Introduction to Recursive Function Theory</em>. Cambridge, U.K.: Cambridge Univ. Press, 1980.</li>
<li>Z. H. Zuo and M. H. Zhou, "<a href="/lib/mzz00.html">Some further theoretical results about computer viruses</a>," <em>Comp. J.</em>, vol. 47, no. 6, pp. 625-633, 2004.</li>
<li>P. Sz&ouml;r and P. Ferrie. (2000) <a href="/lib/apf39.html">Hunting for Metamorphic</a>. [Online]. Available: http://www.virusbtn.com</li>
<li>H. J. Rogers, <em>Theory of Recursive Functions and Effective Computability.</em> New York: McGraw-Hill, 1967.</li>
<li>R. I. Soare, <em>Recursively Enumerable Sets and Degrees.</em> New York: Springer-Verlag, 1987.</li>
<li>D. M. Chess and S. R. White, <a href="/lib/adc06.html">"An undetectable computer virus,"</a> in <em>Proc. Virus Bulletin Conf.</em>, Orlando, FL, Sep. 2000.</li>
<li>R. S. Boyer and J. S. Moore, "A fast string searching algorithm," <em>Commun. ACM</em>, vol. 20, no. 10, pp. 262-272, Oct. 1977.</li>
</ol>
 
[<a style="" href="/lib/?lang=EN&amp;index=TH#mzz01">Back to index</a>] [<a href="/lib/mzz01.html#disqus_thread">Comments</a>]<br/> <div id="disqus_thread"></div>
<script type="text/rocketscript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'vxheaven'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="/agreement.php">Terms of Use</a>!</small> <small>vxheaven.org aka vx.netlux.org</small></div>
<div style="margin-top: 2px; float: left;" class="adsapeu">
<script type="text/rocketscript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script>
</div>
<script data-rocketsrc="http://www.google-analytics.com/urchin.js" type="text/rocketscript"></script><script type="text/rocketscript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="/lib/index.php?lang=de&amp;id=mzz01">de</a><a href="/lib/index.php?lang=en&amp;id=mzz01">en</a><a href="/lib/index.php?lang=es&amp;id=mzz01">es</a><a href="/lib/index.php?lang=it&amp;id=mzz01">it</a><a href="/lib/index.php?lang=fr&amp;id=mzz01">fr</a><a href="/lib/index.php?lang=pl&amp;id=mzz01">pl</a><a href="/lib/index.php?lang=ru&amp;id=mzz01">ru</a><a href="/lib/index.php?lang=ua&amp;id=mzz01">ua</a></div>
</body>
</html>
