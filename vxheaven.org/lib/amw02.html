<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Alexei Lisitsa, Matt Webster 'Supercompilation for Equivalence Testing in Metamorphic Computer Viruses Detection' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Author" content="Alexei Lisitsa, Matt Webster"/>
<meta name="KeyWords" lang="en" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, Lisitsa, Alexei; Webster, Matt,Supercompilation for Equivalence Testing in Metamorphic Computer Viruses Detection, label, zflag, program, const, specification, loop, malcolm, supercompilation, turchin, fragments, nemytykh, inputs, counter, webster, parameterized"/>
<meta name="Description" content="In this paper we present a novel approach to detection of metamorphic computer viruses by using proving program equivalence based on program transformation technique known as supercompilation [7]. Proving program equivalence is an undecidable problem in the general case; however, in specific cases we may find decidable or semi-decidable procedures that can prove that a sub-class of programs are equivalent. This is of relevance for detecting metamorphic computer viruses, which use a variety of semantics-preserving, syntax-mutating methods for code obfuscation. The main purpose of this obfuscation is to avoid detection by signature scanning. An important factor here is that semantics is preserved; therefore, if we can prove using some procedure that two different programs are equivalent, then in principle we can detect metamorphic computer viruses using this procedure."/>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"047a5bcbf67431883fc9ed25fba33612",petok:"181c3e4cb2340c1ad61119e97513167cbd20e946-1498757233-1800",zone:"vxheaven.org",rocket:"a",apps:{}}];document.write('<script type="text/javascript" src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=85b614c0f6/cloudflare.min.js"><'+'\/script>');}}catch(e){};
//]]>
</script>
<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="/style.css"/><link rel="canonical" href="http://vxheaven.org/lib/amw02.html"/>
<script type="text/rocketscript" data-rocketsrc="https://apis.google.com/js/plusone.js">{"parsetags": "explicit"}</script>
</head>
<body bgcolor="#dbc8a0" text="#302000" link="#225599" vlink="#113366">
<div class="s1">
<div style="float:right;"><a href="/lib/index.php?tbs=1"><img src="/img/max.gif" alt="Maximize"/></a></div> <form id="lf" style="margin: 0; float: right;" method="get" action="/index.php"><input type="hidden" name="action" value="set"/><select name="lang" onchange="javascript:document.getElementById('lf').submit();"><option value="ru">Русский</option><option selected="selected" value="en">English</option><option value="ua">Українська</option><option value="de">Deutsch</option><option value="es">Español</option><option value="fr">Fran&ccedil;ais</option><option value="it">Italiano</option><option value="pl">Polski</option></select></form>
<div style="float: right;"><div id="plusone"></div></div>
<script type="text/rocketscript">gapi.plusone.render("plusone", {"size":"small","count":"true"});</script>
<div style="float: right;" class="addthis_toolbox addthis_default_style">
<script type="text/rocketscript">var addthis_config = { ui_click: true }</script>
<a style="text-decoration: none; font-size: 10pt;" href="/?action=addthis" class="addthis_button_compact">Bookmark</a>
<script type="text/rocketscript" data-rocketsrc="http://s7.addthis.com/js/250/addthis_widget.js#username=herm1t"></script>
</div>
<div style="float: right;">
<script type="text/rocketscript" data-rocketsrc="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<form action="/search.php" id="cse-search-box">
<input type="hidden" name="cx" value="002577580816726040001:z9_irkorydo"/>
<input type="hidden" name="cof" value="FORID:10"/>
<input type="hidden" name="ie" value="UTF-8"/>
<input type="text" name="q" size="12" value=" "/>
<input type="submit" name="sa" value="Search"/>
</form>
</div><h1><a href="/" style="text-decoration: none; color: #000000;">VX Heaven</a></h1>
<span class="nav"><a href="/lib/">Library</a> <a href="/vl.php">Collection</a> <a href="/src.php">Sources</a> <a href="/vx.php?id=eidx">Engines</a> <a href="/vx.php?id=tidx">Constructors</a> <a href="/vx.php?id=sidx">Simulators</a> <a href="/vx.php?id=uidx">Utilities</a> <a href="/links.php">Links</a> <a href="/donate.php" style="color: #706020" id="donate">Donate</a> <a href="/forum" style="text-decoration: underline;">Forum</a> </span><br clear="all"/>
</div>
<div class="s2"><h1>Supercompilation for Equivalence Testing in Metamorphic Computer Viruses Detection</h1><p><a href="/lib/?lang=en&amp;author=Lisitsa%2C%20Alexei">Alexei Lisitsa</a>, <a href="/lib/?lang=en&amp;author=Webster%2C%20Matt">Matt Webster</a><br/> <em>A version of this paper has been presented at the Workshop on the Theory of Computer Viruses, 2008, Nancy, 15.05.2008</em><br/> <em>May 2008</em></p><script type="text/rocketscript">var disqus_url = 'http://vxheaven.org/lib/amw02.html';</script><img src="/img/pdf.gif" alt="PDF"/><a href="/lib/pdf/Supercompilation%20for%20Equivalence%20Testing%20in%20Metamorphic%20Computer%20Viruses%20Detection.pdf">Download</a> PDF (208.98Kb) (You need to be registered on <a href="/forum">forum</a>)<br/>[<a style="" href="/lib/?lang=EN&amp;index=AT#amw02">Back to index</a>] [<a href="/lib/amw02.html#disqus_thread">Comments</a>]<br/> <form method="post" action="">
<img src="/img/cache/0b9fd596a90421f9f1f68a9760275737.gif" alt="\text{T_EX size}" valign="middle"/>
<select name="TeX_size"><option value="-2">-2</option><option value="-1">-1</option><option value="0" selected="selected">0</option><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option> </select>
<input type="submit" value="Scale"/>
</form><form method="post" action=""><input type="hidden" name="pages" value="1"/><input type="submit" value="Turn on page numbers"/></form>
<address>
Alexei P. Lisitsa and Matt Webster<br/>
Department of Computer Science, The University of Liverpool<br/>
{A.Lisitsa,<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="c78ae997e990a2a5b4b3a2b5ba87a4b4a4e9abaeb1e9a6a4e9b2ac">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>
</address>
<p><em>A version of this paper has been presented at the Workshop on the Theory of Computer Viruses, 2008, Nancy, 15.05.2008</em></p>
<ul>
<li><a href="#c1">1 Introduction</a></li>
<li><a href="#c2">2 Supercompilation for Detection</a></li>
<li><a href="#c3">3 Conclusion</a></li>
<li><a href="#c4">References</a></li>
<li><a href="#c5">4 Appendix. An interpreter of a subset of Intel 64 instruction set in Refal</a></li>
</ul>
<h2><a name="c1"></a>1 Introduction</h2>
<p>In this paper we present a novel approach to detection of metamorphic computer viruses by using proving program equivalence based on program transformation technique known as supercompilation [7]. Proving program equivalence is an undecidable problem in the general case; however, in specific cases we may find decidable or semi-decidable procedures that can prove that a sub-class of programs are equivalent. This is of relevance for detecting metamorphic computer viruses, which use a variety of semantics-preserving, syntax-mutating methods for code obfuscation. The main purpose of this obfuscation is to avoid detection by signature scanning. An important factor here is that semantics is preserved; therefore, if we can prove using some procedure that two different programs are equivalent, then in principle we can detect metamorphic computer viruses using this procedure.</p>
<p>The supercompilation<sup><a href="#f1" name="b1">1</a></sup> is a semantic based program transformation technique [7] for functional programming languages proposed by V. Turchin in the early 1970s. A variant of symbolic execution is used for the transformation: the program is executed with a partially defined input and that leads to the <em>unfolding</em> a potentially infinite tree of all possible computations of the parameterized program. In the process the tree of configurations is analysed and <em>folded</em> into the finite graph of parameterized configurations and posible transitions between them. To make folding possible a <em>generalization</em> procedure can be used. Finally, the supercompiler analyses the graph and builds the definition of output program based on that. Thus, a supercompiler implements the mapping <img src="/img/cache/37c203bcb0b834a86ace25ba328cb996.gif" alt="\langle P, e \rangle\mapsto\langle P', e'\rangle" valign="middle"/>, where <img src="/img/cache/df007276c413135efd42fd9fa6f8cdc5.gif" alt="P, P'" valign="middle"/> are programs and <img src="/img/cache/e15b27d73d48160a4198d04b829a5266.gif" alt="e, e'" valign="middle"/> are their corresponding parameterized entry points. The result of supercompilation, in general, implements an <em>extension</em> of the (partial) function implemented by the original program, i.e. <img src="/img/cache/4af9cb7140eff406f917e3b6d2ad8bb3.gif" alt="P'" valign="middle"/> produces the same outputs on the inputs for which <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/> terminates, but may terminate on some inputs for which <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/> does not. The primary purpose of supercompilation is for specialization and optimization of the programs. In Lisitsa &amp; Nemytykh [3] it has been shown that it can be used for verification as well.</p>
 
<p>Here we notice that due to the fact that resulting program is produced from a behavioural graph of possible computations (without referring to the original syntax) supercompilation can be seen also as, <em>behavior-based normalization procedure</em><sup><a href="#f2" name="b2">2</a></sup>, potentially applicable for the equivalence testing.</p>
<p>Development of supercompilation have been done mainly in the context of functional programming language Refal of Turchin [8] and SCP4 of Nemytykh &amp; Turchin [5,6] is the most advanced supercompiler for Refal.</p>
<p>There are many methods of detecting metamorphic computer viruses in the literature. Our approach bears some similarity to the work of Webster &amp; Malcolm [10,9] on detection of metamorphic computer viruses using algebraic specification, in which a specification of Intel 64 was given using Maude. The two approaches are similar in that the specification of Webster &amp; Malcolm and the interpreter here use a notion of stores in the definitions of the semantics of the Intel 64 language. The approaches differ, however, in that the algebraic specification of Webster &amp; Malcolm is based on a formal syntax and semantics of Intel 64, and the values of various variables are queried using rewriting, whereas the semantics of Intel 64 is specified informally in our work, and the supercompiler is used to optimise the evaluation function parameterised by a specific program.</p>
<p>Our approach is also similar to the program rewriting/normalisation approach of Bruschi et al [1,2], as supercompilation essentially rewrites a function corresponding to the execution of a program. Although the supercompilation is not strictly a normalisation procedure, as we cannot guarantee that in all cases two equivalent programs will have the same normal form, the process resembles normalisation as two functions representing different equivalent programs may be rewritten to the same form.</p>
<h2><a name="c2"></a>2 Supercompilation for Detection</h2>
<p>Supercompilation is a program transformation process that traces possible generalized histories of a program in an attempt to reduce redundancy. As we will show, we can use the supercompilation process to produce supercompiled versions of metamorphic code fragments that are identical. This is useful for the detection of metamorphic computer viruses, which can be acheived by proving equivalence of a metamorphic computer virus signature to some suspect code fragment. We understand equivalence for two programs as equality of partial fucntions (mapping inputs to outputs, or inital states to the final states) implemented by programs.</p>
<p>Our technique uses a supercompiler for Refal called Scp4 [5]. We define the semantics of Intel 64 instructions operationally using Refal. Essentially, the result is a general-purpose interpreter for the Intel 64 instructions<sup><a href="#f3" name="b3">3</a></sup> we have defined.</p>
 
<p>Our interpreter can be found in the Appendix. If we pass a program as a parameter to the interpreter, the result is an emulation of that Intel 64 program in Refal. We can therefore apply Scp4 to the emulation in order to eliminate redundancy in the program. If two syntactically-different programs are supercompiled to the same form, we can conclude that the programs must be equivalent (under additional assumption that both programs terminate on all inputs). If programs may not terminate on some inputs then equality of residual programs provides only partial evidence for equivalence on a subset of inputs.</p>
<p><em>Example 1.</em> The following two programs have the overall effect of assigning the value 5 to the variable eax, 6 to the variable ebx and 1 (or "true") to the zero flag of the EFLAGS register:</p>
<pre class="source"><img src="/img/cache/03b632315ee5bee654b60a6bd902a249.gif" alt="p_1" valign="middle"/> = mov eax,5; move ebx,5; cmp eax,ebx; move ebx,6
<img src="/img/cache/6fe97b358b528edc477ba63d50b652af.gif" alt="p_2" valign="middle"/> = mov ecx,4; move eax,1; mov ebx,0; label 2: cmp eax,ebx;
  je 1; mov eax,5; label 1: move ebx,6; loop 2
</pre>
<p>We can imagine <img src="/img/cache/03b632315ee5bee654b60a6bd902a249.gif" alt="p_1" valign="middle"/> as part of the zeroth generation of a metamorphic computer virus, and <img src="/img/cache/6fe97b358b528edc477ba63d50b652af.gif" alt="p_2" valign="middle"/> as some obfuscated form. Applying the supercompiler to the interpreter twice, once for each program, results in the same supercompiled Refal program:</p>
<pre class="source">
$ENTRY Go {
 (e.101 )(e.102 ) (e.103 ) (e.104 ) =
 (eax 5 ) (ebx 6 ) (ecx ) (Zflag 1);
}
</pre>
<p>In each case, the supercompiler has optimised the interpreter, parameterised with programs <img src="/img/cache/03b632315ee5bee654b60a6bd902a249.gif" alt="p_1" valign="middle"/> and <img src="/img/cache/6fe97b358b528edc477ba63d50b652af.gif" alt="p_2" valign="middle"/> to the same Refal program, which simply assigns the values 5, 6 and 1 to the variables eax, ebx and Zflag<sup><a href="#f4" name="b4">4</a></sup>. Essentially, we have translated <img src="/img/cache/03b632315ee5bee654b60a6bd902a249.gif" alt="p_1" valign="middle"/> and <img src="/img/cache/6fe97b358b528edc477ba63d50b652af.gif" alt="p_2" valign="middle"/> into Refal, and the supercompiler has then shown the translated forms to be equivalent. If one of these programs was our signature, and the other was the suspect code, then this technique could be used to detect a metamorphic computer virus. More examples can be found in [4].</p>
<h2><a name="c3"></a>3 Conclusion</h2>
<p>In a practical setting, e.g., within an anti-virus software package, we assume that code fragments for equivalence analysis will be extracted and presented before
 
supercompilation. The supercompiler will then run with the two fragments as input, and the output of the supercompiler will be analysed in order to determine whether the two fragments are equivalent. This analysis, in the ideal case, is trivial: for example, the supercompiler could simply return the value "true" iff the two fragments are found to be equivalent. In the case where one fragment is a signature of a metamorphic computer virus, and the other fragment is some suspect code, then the positive identification of equivalence will indicate infection of the suspect code by that virus. Of course, this procedure is prone to false negatives in the case where the supercompilation process has not identified equivalence.</p>
<p>Future work will include an expansion of the Intel 64 instruction subset used, and an application to the detection of real-life metamorphic computer viruses. In addition, we intend to establish the theoretical constraints on our approach.</p>
<h2><a name="c4"></a>References</h2>
<ol>
<li>Danilo Bruschi, Lorenzo Martignoni, and Mattia Monga. <a href="/lib/adb00.html">Using code normalization for fighting self-mutating malware</a>. In <em>Proceedings of the International Symposium on Secure Software Engineering</em>, 2006.</li>
<li>Danilo Bruschi, Lorenzo Martignoni, and Mattia Monga. Code normalization for self-mutating malware. <em>IEEE Security &amp; Privacy</em>, 5(2):46-54, 2007.</li>
<li>Lisitsa, A.P., Nemytykh, A.P.: Verification as a Parameterized Testing (Experiments with the SCP4 Supercompiler). Programmirovanie. No.1 (2007) (In Russian). English translation in J. Programming and Computer Software, Vol. 33, No.1 (2007) 14-23</li>
<li>A. Lisitsa, M. Webster: Detecting Metamorphic Computer Viruses using Supercompilation. In Proceedings of Workshop on Theory of Computer Viruses, 2008 (to appear), 5p</li>
<li>A. P. Nemytykh. The Supercompiler Scp4: General Structure. (Extended abstract). <em>Proceeding of the PSI'03</em>,, LNCS, vol. 2890, pp: 162-170, 2003</li>
<li>A. P. Nemytykh and V. F. Turchin. The Supercompiler Scp4: sources, on-line demonstration. http://www.botik.ru/pub/local/scp/refal5/, 2000.</li>
<li>V.F. Turchin. The concept of a supercompiler. <em>ACM Transactions on Programming Languages and Systems</em>, 8:292-325, 1986.</li>
<li>V. F. Turchin. Refal-5, Programming Guide and Reference Manual. New England Publishing Co., Holyoke, Massachusetts, 1989. (electronic version: http://www.botik.ru/pub/local/scp/refal5/ ,2000.).</li>
<li>Matt Webster and Grant Malcolm. Detection of metamorphic and virtualization-based malware using algebraic specification. In <em>Proceedings of the 17th Annual European Institute for Computer Antivirus Research (EICAR) Conference</em>. To appear.</li>
<li>Matt Webster and Grant Malcolm. Detection of metamorphic computer viruses using algebraic specification. <em>Journal in Computer Virology</em>, 2(3):149-161, December 2006. DOI: 10.1007/s11416-006-0023-z.</li>
</ol>
 
<h2><a name="c5"></a>4 Appendix. An interpreter of a subset of Intel 64 instruction set in Refal</h2>
<pre class="source">
*$MST_FROM_ENTRY;
*$STRATEGY Applicative;
*$LENGTH 3;
*$MATCING ForReapeatedSpecialization;



* A STORE is a list of variable-value pairs, e.g.
* (eax 0) (ebx 1) (ecx 2)


* entry point for the interpreter executing program p_2 from Example 1

$ENTRY Go {(e.1) (e.2)(e.3)(e.4) =
 &lt;Exec ((control)(mov ecx (const I I I))(mov eax (const 1))(mov ebx (const 0))(label 2)
	(cmp (reg eax)(reg ebx))(je 1)(mov eax (const 5))
	(label 1)(mov ebx (const 6))(loop 2))(eax e.1)(ebx e.2)(ecx e.3)(Zflag e.4)>;
}

* execute statement list

Exec {

* Execute jmp
* jump forward
(e.1 (control)(jmp e.label) e.2 (label e.label) e.3) e.store =
	&lt;Exec (e.1 (jmp e.label) e.2 (label e.label)(control) e.3) e.store>;

* jump backward

		 (e.1 (label e.label) e.2 (control)(jmp e.label) e.3 ) e.store =
&lt;Exec (e.1 (label e.label)(control) e.2 (jmp e.label) e.3) e.store>;

*Execute mov
	(e.1 (control)(mov e.2 e.3) e.4) e.store =
	&lt;Exec (e.1 (mov e.2 e.3)(control) e.4)
	&lt;mov (e.2 e.3) e.store>>;

*Execute cmp and set Zflag
	(e.1 (control)(cmp (e.2) (e.3)) e.4) e.store =
	&lt;Exec (e.1 (cmp (e.2) (e.3))(control) e.4)&lt;cmp ((e.2) (e.3)) e.store>>;

*Execute je

*If Zflag is 1, jump forward
	(e.1 (control)(je e.label) e.2 (label e.label) e.3) e.4 (Zflag 1) =
	&lt;Exec (e.1 (je e.label) e.2 (label e.label)(control) e.3) e.4 (Zflag 1)>;
*If Zflag is 1, jump backward
	(e.1 (label e.label) e.2 (control)(je e.label) e.3) e.4 (Zflag 1) =
	&lt;Exec (e.1 (label e.label)(control) e.2 (je e.label) e.3) e.4 (Zflag 1)>;

*If Zflag is 0 Skip
	(e.1 (control)(je e.label) e.2) e.3 (Zflag 0) =
	&lt;Exec (e.1 (je e.label)(control) e.2) e.3 (Zflag 0)>;

*Skip the label
	(e.1 (control)(label e.label) e.2) e.store =
	&lt;Exec (e.1 (label e.label)(control) e.2) e.store>;

* Execute "loop label1": decrement counter register ecx,
* check if counter register is 0, if
* yes go to the next instruction, if not
* go to label1.
 
* The integer value of the counter ecx is presented in the unary form II...III.
* Only positive values are correctly dealt with

* Exit the loop
	(e.1 (control)(loop e.label) e.2) e.3 (ecx I)(Zflag e.5) =
	&lt;Exec (e.1 (loop e.label)(control) e.2) e.3 (ecx)(Zflag 1)>;

* Go to the label backward
	(e.1 (label e.label) e.2 (control)(loop e.label) e.3) e.4 (ecx I I e.ecx)(Zflag e.5) =
	&lt;Exec (e.1 (label e.label)(control) e.2 (loop e.label) e.3) e.4 (ecx I e.ecx)(Zflag 0)>;

* Go to the label forward
	(e.1 (control)(loop e.label) e.2 (label e.label) e.3) e.4 (ecx I I e.ecx)(Zflag e.5) =
	&lt;Exec (e.1 (loop e.label) e.2 (label e.label)(control) e.3) e.4 (ecx I e.ecx)(Zflag 0)>;

*End of the statements list, nothing to execute
	(e.1 (control))e.store = e.store;
}

* Effects of mov execution

mov {
	(eax (const e.1))(eax e.2)(ebx e.3)(ecx e.4)(Zflag e.5) = (eax e.1)(ebx e.3)(ecx e.4)(Zflag e.5);
	(eax (reg eax))(eax e.1)(ebx e.2)(ecx e.3)(Zflag e.4) = (eax e.1)(ebx e.2)(ecx e.3)(Zflag e.4);
	(eax (reg ebx))(eax e.1)(ebx e.2)(ecx e.3)(Zflag e.4) = (eax e.2)(ebx e.2)(ecx e.3)(Zflag e.4);
	(ebx (reg eax))(eax e.1)(ebx e.2)(ecx e.3)(Zflag e.4) = (eax e.1)(ebx e.1)(ecx e.3)(Zflag e.4);
	(ebx (const e.1))(eax e.2)(ebx e.3)(ecx e.4)(Zflag e.5) = (eax e.2)(ebx e.1)(ecx e.4)(Zflag e.5);
	(ecx (const e.1))(eax e.2)(ebx e.3)(ecx e.4)(Zflag e.5) = (eax e.2)(ebx e.3)(ecx e.1)(Zflag e.5);
}

* Effects of cmp execution

cmp {
	((reg eax)(reg ebx))(eax e.1)(ebx e.1)(ecx e.2)(Zflag e.3) = (eax e.1)(ebx e.1)(ecx e.2)(Zflag 1);
	((reg eax)(reg ebx))(eax e.1)(ebx e.2)(ecx e.3)(Zflag e.4) = (eax e.1)(ebx e.2)(ecx e.3)(Zflag 0);
	((reg eax)(const e.1))(eax e.1)(ebx e.2)(ecx e.3)(Zflag e.4) = (eax e.1)(ebx e.2)(ecx e.3)(Zflag 1);
	((reg eax)(const e.1))(eax e.2)(ebx e.3)(ecx e.4)(Zflag e.5) = (eax e.2)(ebx e.3)(ecx e.4)(Zflag 0);
}
</pre>
 
<hr size="1"/>
<p><a name="f1" href="#b1"></a> from <em>super</em>vised <em>compilation</em></p>
<p><a name="f2" href="#b2"></a> At the moment we suggest this reading as semi-formal. Determining precise conditions under which supercompilation would be a normalization procedure is an interesting problem for future investigations.</p>
<p><a name="f3" href="#b3"></a> At the moment only a small subset of instructions is covered.</p>
<p><a name="f4" href="#b4"></a> For simplicity of presentation, as it is the only place where arithmetic involved at the moment, we treat the values of counter register ecx differently from other registers. In the interpreter the values of ecx are modelled by unary strings and decrement operation is defined accordingly. Under such a convention the residual program assigns the value 0 to ecx register (as expected).</p>
[<a style="" href="/lib/?lang=EN&amp;index=AT#amw02">Back to index</a>] [<a href="/lib/amw02.html#disqus_thread">Comments</a>]<br/> <div id="disqus_thread"></div>
<script type="text/rocketscript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'vxheaven'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="/agreement.php">Terms of Use</a>!</small> <small>vxheaven.org aka vx.netlux.org</small></div>
<div style="margin-top: 2px; float: left;" class="adsapeu">
<script type="text/rocketscript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script>
</div>
<script data-rocketsrc="http://www.google-analytics.com/urchin.js" type="text/rocketscript"></script><script type="text/rocketscript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="/lib/index.php?lang=de&amp;id=amw02">de</a><a href="/lib/index.php?lang=en&amp;id=amw02">en</a><a href="/lib/index.php?lang=es&amp;id=amw02">es</a><a href="/lib/index.php?lang=it&amp;id=amw02">it</a><a href="/lib/index.php?lang=fr&amp;id=amw02">fr</a><a href="/lib/index.php?lang=pl&amp;id=amw02">pl</a><a href="/lib/index.php?lang=ru&amp;id=amw02">ru</a><a href="/lib/index.php?lang=ua&amp;id=amw02">ua</a></div>
</body>
</html>
