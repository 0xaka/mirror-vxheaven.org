<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Arun Lakhotia, Moinuddin Mohammed 'Imposing Order on Program Statements to Assist Anti-Virus Scanners' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Author" content="Arun Lakhotia, Moinuddin Mohammed"/>
<meta name="KeyWords" lang="en" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, Lakhotia, Arun; Mohammed, Moinuddin,Imposing Order on Program Statements to Assist Anti-Virus Scanners, virus, node, string, representation, viruses, method, metamorphic, program, dependence, representations, statement, variants, computer, code, permutations"/>
<meta name="Description" content="A metamorphic virus applies semantics preserving transformations on itself to create a different variant before propagation. Metamorphic computer viruses thwart current anti-virus technologies that use signatures - a fixed sequence of bytes from a sample of a virus - since two variants of a metamorphic virus may not share the same signature. A method to impose an order on the statements and components of expressions of a program is presented. The method, called a &quot;zeroing transformation,&quot; reduces the number of possible variants of a program created by reordering statement, reshaping expression, and renaming variable. On a collection of C program used for evaluation, the zeroing transformation reduced the space of program variants due to statement reordering from 10^183 to 10^20. Further reduction can be expected by undoing other transformations. Anti-virus technologies may be improved by extracting signatures from zero form of a virus, and not the original version."/>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"047a5bcbf67431883fc9ed25fba33612",petok:"f8fea1452b461fb5caf3bc93e6f12ace3f7e2263-1498756481-1800",zone:"vxheaven.org",rocket:"a",apps:{}}];document.write('<script type="text/javascript" src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=85b614c0f6/cloudflare.min.js"><'+'\/script>');}}catch(e){};
//]]>
</script>
<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="/style.css"/><link rel="canonical" href="http://vxheaven.org/lib/aal01.html"/>
<script type="text/rocketscript" data-rocketsrc="https://apis.google.com/js/plusone.js">{"parsetags": "explicit"}</script>
</head>
<body bgcolor="#dbc8a0" text="#302000" link="#225599" vlink="#113366">
<div class="s1">
<div style="float:right;"><a href="/lib/index.php?tbs=1"><img src="/img/max.gif" alt="Maximize"/></a></div> <form id="lf" style="margin: 0; float: right;" method="get" action="/index.php"><input type="hidden" name="action" value="set"/><select name="lang" onchange="javascript:document.getElementById('lf').submit();"><option value="ru">Русский</option><option selected="selected" value="en">English</option><option value="ua">Українська</option><option value="de">Deutsch</option><option value="es">Español</option><option value="fr">Fran&ccedil;ais</option><option value="it">Italiano</option><option value="pl">Polski</option></select></form>
<div style="float: right;"><div id="plusone"></div></div>
<script type="text/rocketscript">gapi.plusone.render("plusone", {"size":"small","count":"true"});</script>
<div style="float: right;" class="addthis_toolbox addthis_default_style">
<script type="text/rocketscript">var addthis_config = { ui_click: true }</script>
<a style="text-decoration: none; font-size: 10pt;" href="/?action=addthis" class="addthis_button_compact">Bookmark</a>
<script type="text/rocketscript" data-rocketsrc="http://s7.addthis.com/js/250/addthis_widget.js#username=herm1t"></script>
</div>
<div style="float: right;">
<script type="text/rocketscript" data-rocketsrc="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<form action="/search.php" id="cse-search-box">
<input type="hidden" name="cx" value="002577580816726040001:z9_irkorydo"/>
<input type="hidden" name="cof" value="FORID:10"/>
<input type="hidden" name="ie" value="UTF-8"/>
<input type="text" name="q" size="12" value=" "/>
<input type="submit" name="sa" value="Search"/>
</form>
</div><h1><a href="/" style="text-decoration: none; color: #000000;">VX Heaven</a></h1>
<span class="nav"><a href="/lib/">Library</a> <a href="/vl.php">Collection</a> <a href="/src.php">Sources</a> <a href="/vx.php?id=eidx">Engines</a> <a href="/vx.php?id=tidx">Constructors</a> <a href="/vx.php?id=sidx">Simulators</a> <a href="/vx.php?id=uidx">Utilities</a> <a href="/links.php">Links</a> <a href="/donate.php" style="color: #706020" id="donate">Donate</a> <a href="/forum" style="text-decoration: underline;">Forum</a> </span><br clear="all"/>
</div>
<div class="s2"><h1>Imposing Order on Program Statements to Assist Anti-Virus Scanners</h1><p><a href="/lib/?lang=en&amp;author=Lakhotia%2C%20Arun">Arun Lakhotia</a>, <a href="/lib/?lang=en&amp;author=Mohammed%2C%20Moinuddin">Moinuddin Mohammed</a><br/> <em>In Proceedings of Eleventh Working Conference on Reverse Engineering, Delft, The Netherlands, November 2004, pp. 161-170.</em><br/> <em>ISBN 0-7695-2243-2</em><br/> <em>November 2004</em></p><script type="text/rocketscript">var disqus_url = 'http://vxheaven.org/lib/aal01.html';</script><div class="ci"><a href="/lib/?ci=aal01">2</a></div><img src="/img/pdf.gif" alt="PDF"/><a href="/lib/pdf/Imposing%20Order%20on%20Program%20Statements%20to%20Assist%20Anti-Virus%20Scanners.pdf">Download</a> PDF (303.8Kb) (You need to be registered on <a href="/forum">forum</a>)<br/>[<a style="" href="/lib/?lang=EN&amp;index=ME#aal01">Back to index</a>] [<a href="/lib/aal01.html#disqus_thread">Comments</a>]<br/> <form method="post" action=""><input type="hidden" name="pages" value="1"/><input type="submit" value="Turn on page numbers"/></form>
 
<p><em>This work has been sponsored in part by funds from Louisiana Governor's Information Technology Initiative.</em></p>
<address>
University of Louisiana at Lafayette<br/>
<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="157467607b55797a607c667c747b743b707160">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>
</address>
<h2>Abstract</h2>
<p><em>A metamorphic virus applies semantics preserving transformations on itself to create a different variant before propagation. Metamorphic computer viruses thwart current anti-virus technologies that use signatures - a fixed sequence of bytes from a sample of a virus - since two variants of a metamorphic virus may not share the same signature. A method to impose an order on the statements and components of expressions of a program is presented. The method, called a "zeroing transformation," reduces the number of possible variants of a program created by reordering statement, reshaping expression, and renaming variable. On a collection of C program used for evaluation, the zeroing transformation reduced the space of program variants due to statement reordering from 10<sup>183</sup> to 10<sup>20</sup>. Further reduction can be expected by undoing other transformations. Anti-virus technologies may be improved by extracting signatures from zero form of a virus, and not the original version.</em></p>
<h2>1. Introduction</h2>
<p>A metamorphic computer virus transforms its code before propagating it to a new host [2, 4, 17, 18]. Win32/Evol, Win32/Zperm, and Win32/Bistro are some recent metamorphic viruses. Zperm carries with it the Real Permutating Engine (RPME), a metamorphic engine that can be combined with any virus to make it metamorphic [18]. There are other similar metamorphic engines available on websites catering to hackers.</p>
<p>Metamorphic viruses can escape signature-based anti-virus scanners [3]. The emergence of metamorphic viruses calls for new methods for anti-virus (AV) scanning. An ideal AV Scanner would be capable of detecting the different possible variants of a metamorphic virus by using signature from only one known variant.</p>
<p>This investigation has been motivated by a desire to create an ideal AV scanner. In this paper we investigate the question: Is it possible to transform a program to a canonical form such that two variants of the program have the same form? If such a transformation is feasible then, instead of the original virus, signatures may be extracted from its canonical form. When scanning, a suspect program may be converted to its canonical form and then checked for the existence of signature of known viruses.</p>
<p>As a step towards the larger goal, this paper presents a set of heuristics to impose order on the statements of a C-like program. By imposing such an order, it is expected that one can undo the effect of statement/instruction reordering transformation performed by metamorphic viruses. While the viruses posing greatest challenges are usually binary, an initial step is important. Besides, it is expected that for any significant analysis a virus will be first decompiled to a higher language. Thus, the method presented should be applicable for binary viruses.</p>
<p>Using GrammaTech's CodeSurfer&trade; we have implemented the proposed method in a prototype tool, C&oplus;. Empirical analysis of the method on real-world C programs show that our method is promising. For the programs studied, after fixing order of statements using our method, the number of possible permutations of the programs was reduced by a factor of 10<sup>163</sup>. In the context of metamorphic viruses, this is the reduction in the number of signatures that may be needed if all possible reordered variants of a virus appear in the wild.</p>
<p>In this paper we summarize our method for fixing order and the results from an empirical analysis of the method. Section 2 presents some transformations used by metamorphic viruses. Section 3 outlines how to undo the transformations by mapping a program into a zero form. It presents our algorithm for imposing order on the statements of a program. Section 4 summarizes the results of an empirical evaluation of our algorithm. Section 5 contains a comparison with related works. Section 6 presents our conclusions.</p>
<h2>2. Morphing transformations</h2>
<p>A metamorphic virus carries with itself a morpher: a subprogram that transforms the structure of the virus
 
without affecting its behavior. The morphing transformations used by recent metamorphic viruses include dead or irrelevant code insertion; register renaming; expression reshaping; break &amp; join transformations; and statement reordering. Figure 1 enumerates these transformations using examples.</p>
<p>Inserting dead code (irrelevant/junk code) in a program has no effect on the results of the program. It is very effective in changing the program text. Dead code may be inserted by simply inserting the NOP instruction. There are other, more complex forms of dead code as well, such as inserting a PUSH instruction and a POP instruction at non-consecutive locations.</p>
<p>The register renaming transformation changes the register used in a computation. In order to preserve the behavior of the original virus, it is necessary that all related occurrence of the register also be renamed.</p>
<p>Break &amp; join transformations break programs into pieces, select a random order of these pieces, and use unconditional branch statements to connect these pieces such that the statements are executed in the same sequence as in the original programs.</p>
<p>Expression reshaping involves generating random permutations of operands in expressions with commutative and associative operators. This changes the structure of expressions.</p>
<p>The statement reordering transformation reorders the statements in a program such that the behavior of the program does not change. It is possible to reorder statements if and only if there are no dependences [7] between the statements being reordered. If the virus signature includes bytes corresponding to a statement from this set of reorderable statements, then application of statement reordering transformation makes the original virus signature useless for as many different variants as possible.</p>
<div align="center">
<table summary="(a) Deadcode insertion" style="width: 10em; float:left;">
<caption>(a) Deadcode insertion</caption>
<tr><td style="vertical-align: top;"><pre class="source">
mov eax, V_S - 1
add eax, ecx
xor edx, edx
div ecx
mul ecx
push eax
</pre></td><td>&rarr;</td><td style="vertical-align: top;"><pre class="source">
mov eax, V_S - 1
<strong>nop</strong>
add eax, ecx
xor edx, edx
<strong>add eax, 0</strong>
div ecx
<strong>nop</strong>
mul ecx
push eax
</pre></td></tr></table>
<table summary="(b) Variable Renaming">
<caption>(b) Variable Renaming</caption>
<tr><td style="vertical-align: top;"><pre class="source">
push edx
mov edx, ecx
mov ebx, 000Ah
add edx, ebx
pop ebx
</pre></td><td>&rarr;</td><td style="vertical-align: top;"><pre class="source">
push <strong>eax</strong>
mov  <strong>eax</strong>, <strong>ebx</strong>
mov  <strong>edx</strong>, 000Ah
add  <strong>eax</strong>, <strong>edx</strong>
pop  <strong>edx</strong>
</pre></td></tr></table>
<br clear="left"/>
<table summary="(c) Break and Join Transformation" style="width: 10em; float:left;">
<caption>(c) Break and Join Transformation</caption>
<tr><td style="vertical-align: top;"><pre class="source">
statement-1
statement-2
statement-3
statement-4
statement-5
statement-6
</pre></td><td>&rarr;</td><td style="vertical-align: top;"><pre class="source"><strong>goto L1</strong>
<strong>L3:</strong>
statement-3
<strong>goto L4</strong>
<strong>L1:</strong>
statement-1
statement-2
<strong>goto L3</strong>
<strong>L5:</strong>
statement-5
<strong>goto L6</strong>
<strong>L4:</strong>
statement-4
<strong>goto L5</strong>
<strong>L6:</strong>
statement-6
</pre></td></tr></table>
<table summary="(d) Expression Reshaping">
<caption>(d) Expression Reshaping</caption>
<tr><td style="vertical-align: top;"><pre class="source">
if (i &lt; a * b * c)
{
	a = x * 100 + 2;
	b = 10 * i;
	c = y * a + b;
	i = a + b + c;
}
</pre></td><td>&rarr;</td><td style="vertical-align: top;"><pre class="source">
if (i &lt; a * b * c)
{
	<strong>a = 2 + x * 100;</strong>
	b = 10 * i;
	<strong>c = a * y + b;</strong>
	<strong>i = b + c + a;</strong>
}
</pre></td></tr></table>
<table summary="(d) Statement Reordering">
<caption>(e) Statement Reordering</caption>
<tr><td style="vertical-align: top;"><pre class="source">
x = 25;
y = x + get_index();
z= 100;
while (i &lt; y + z)
{
	b = 200 * i;
	c = y * i;
	a = x * y + i * z;
	i = i + 1;
}
</pre></td><td>&rarr;</td><td style="vertical-align: top;"><pre class="source">
x = 25;
y = x + get_index();
z= 100;
while (i &lt; y + z)
{
	<strong>a = x * y + i * z;</strong>
	<strong>b = 200 * i;</strong>
	<strong>c = y * i;</strong>
	i = i + 1;
}
</pre></td></tr></table>
<p><strong>Figure 1 Morphing Transformations</strong></p>
</div>
 
<div align="center">
<img src="img/aal01/img2.gif" alt="Figure 2 Transforming program variants to zero form"/>
<p><strong>Figure 2 Transforming program variants to zero form</strong></p>
</div>
<h2>3. "Zeroing" transformation</h2>
<p>The effect of a morphing transformation, described above, could be removed by performing its inverse transformation, if one exists. For instance, dead-code elimination, constant propagation [1], removal of redundant computations, and elimination of spurious unconditional branch statements may be used to undo the effects of (some types of) dead code or irrelevant code insertion, expression reshaping, and break &amp; join transformations, respectively. The final outcome may depend on the specific order in which these transformations are applied. It is an open research question on how to choose an order for applying these transformations such that it yields the same canonical form for different variants.</p>
<p>The focus of our current investigation is on how to undo the effects of statement reordering, reshaping expressions, and variable renaming transformations. The inverse of these transformations have not been studied in the literature. We call our transformation the "zeroing" transformation, for its attempt to eliminate the effect of reordering, variable renaming, and expression reshaping. The program resulting from applying the zeroing transformation is called the zero form.</p>
<p>We present the zeroing transformation top-down; presenting the high level steps first, followed by a description of the lower level steps.</p>
<p>The zeroing transformation has the following steps:</p>
<ol>
<li>Create a Program Tree (PT) representation of the program.</li>
<li>Partition the PT nodes into reorderable sets, each set containing statements that may be mutually reordered without affecting the program's semantics.</li>
<li>Partition each reorderable set into a sequence of isomorphic sets, where every statement in an isomorphic set has the same `string representation.' The representation does not depend on names of the variables in the program, order of variable in commutative operators, and order of the statements in the program,</li>
<li>Assign a number to each statement. The numbering is done using a depth-first traversal of the PT. Statements in a reorderable set are visited based on the order in the sequence of isomorphic set. Statements in an isomorphic set are visited in random order.</li>
<li>Create a new program by ordering the statements as per the numbers assigned in the last step. In each expression, replace each variable name by a new
 
variable name created using the number of the statement where it is first defined.</li>
</ol>
<p>The following subsections describe the first three steps. The last two steps are self-explanatory, and are not elaborated any further.</p>
<h3>3.1.Program tree (PT) representation</h3>
<p>A program tree (PT) is a hierarchical ordering of statements in a program. While the abstract syntax tree (AST) of a program could serve as a PT, we do not use AST because its structure depends on the specific order of statements in the program. We use the control dependence sub-graph (CDG) [7] for constructing the PT. Construction of PT for structured programs, i.e., goto free programs, is straightforward. The nodes in the program tree are the statements of the program. We create an edge in the program tree from a node <em>n<sub>1</sub></em> to node <em>n<sub>2</sub></em> if there exists an edge from <em>n<sub>1</sub></em> to <em>n<sub>2</sub></em> in the corresponding CDG.</p>
<p>The PT of the code segment in Figure 2 is shown in Figure 3. For readability, we show the corresponding program statements for control predicates in the program tree. For example, in Figure 3, the control predicate <em>(A>B)</em> is shown as <em>If (A>B)</em>. The node <em>If (A>B)</em> in Figure 3 has an edge to the nodes <em>C=A+1</em>, <em>D=A+B+200</em>, <em>E=C+D+10</em> because of the control dependence relationship between the node If (A>B) and the nodes <em>C=A+1</em>, <em>D=A+B+200</em>, <em>E=C+D+10</em>.</p>
<p>In general, the control dependence graph may not be a tree. A CDG node may have multiple predecessors and the graph may have cycles. Consider the program in Figure 4(a). Its control dependence graph, shown in Figure 4(b), has a cycle. We create a PT by traversing a CDG in depth first order and terminating the traversal when a node in the ancestor list is visited again. To indicate the repetition we include a copy of that node in the tree. Figure 5 shows the PT for the CDG of Figure 4(b). Similarly, if a node in the CDG has multiple parents, we create a duplicate child node for each parent node.</p>
<p>A program tree is constructed for each procedure of the program.</p>
<h3>3.2.Partitioning PT into reorderable sets</h3>
<p>This section describes an algorithm for partitioning PT nodes into reorderable sets. The aim of this step is to find statements that may be mutually reordered without changing the semantics of the program.</p>
<p><strong>Definition:</strong> <em>Reorderable set.</em> A set of nodes in PT is reorderable if its nodes can be mutually reordered (swapped) without changing the semantics of the program represented by PT.</p>
<p>For a set of nodes to be reordered they must be siblings in the PT. A pair of sibling PT nodes can be reordered if one does not depend on the other, as per the following definition.</p>
<p><strong>Definition:</strong> <em>Tree dependence.</em> Let <em>n<sub>1</sub></em>, <em>n<sub>2</sub></em> &isin; PT be sibling nodes. Node <em>n<sub>2</sub></em> is tree-dependent on node <em>n<sub>1</sub></em> if and only if there exists a path from <em>n<sub>1</sub></em> to <em>n<sub>2</sub></em> in the control flow graph of P and (1) a node in the sub-tree of PT rooted at <em>n<sub>2</sub></em> is data dependent on a node in the sub-tree of PT rooted at <em>n<sub>1</sub></em> or (2) there exist two nodes <em>n<sub>1</sub>'</em> and <em>n<sub>2</sub>'</em> in the sub-trees of PT rooted at <em>n<sub>1</sub></em> and <em>n<sub>2</sub></em>, respectively, such that the intersection of the set of variables defined in <em>n<sub>1</sub>'</em> and <em>n<sub>2</sub>'</em> is non-empty.</p>
<p>The data-dependence relation in Condition (1), above, is as traditionally used in compilers, and in the construction of program dependence graph (PDG). This condition propagates to the parents the data dependence relation between its (transitive, reflexive) children. Condition (2) relates statements that may become data-dependent if they were swapped.</p>
<div align="center">
<img src="img/aal01/img3.gif" alt="Figure 3 Program Tree for Example 1 (of Figure 2)"/>
<p><strong>Figure 3 Program Tree for Example 1 (of Figure 2)</strong></p>
<img src="img/aal01/img4.gif" alt="Figure 4 Example 2"/>
<p><strong>Figure 4 Example 2 (a) Program (b) CDG</strong></p>
<img src="img/aal01/img5.gif" alt="Figure 5 Program Tree for Example 2"/>
<p><strong>Figure 5 Program Tree for Example 2</strong></p>
</div>
 
<p>The children of each node in the PT are partitioned into a sequence of reorderable sets. The order between the reorderable sets is fixed, but the order of the elements within a reorderable set is not fixed. Given a program (P) and its corresponding PT, the PT nodes can be partitioned into reorderable sets using the partitioning algorithm in Figure 7.</p>
<p>The partitioning algorithm traverses the PT of P in the post order to find the nodes that can be reordered. It assigns a DG-Depth (dependence graph depth) value to each node. The DG-Depth is also the number of the reorderable set in which that node is placed. The DG-Depth of all nodes is initially set to `0'. The children of a node are processed in the control flow order. For every child node <em>c</em> of <em>n</em>, the partitioning algorithm finds the node <em>c'</em>, having the maximum DG-Depth <em>m</em>, such that either <em>c</em> depends on <em>c'</em> or <em>c'</em> depends on <em>c</em>. The DG-Depth of <em>c</em> is set to <em>m+1</em> implying that the child node <em>c</em> is placed in the reorderable set number <em>m+1</em>. The use of dependence graph depth for identifying order between statements assures that after the nodes are partitioned, the dependence order of the children is preserved.</p>
<p>Consider the Node <em>main ()</em> in Figure 2. Its root has the following children <em>{A=0, B=3, If (A>B), F=A+C, G=A+B}</em>. The dependence graph for this set of children is shown in Figure 6. The edge from the node <em>A=0</em> to the node <em>If (A>B)</em> corresponds to the dependence relation from node <em>A=0</em> to the node <em>If (A>B);</em> i.e., there exists a path from the node <em>A=0</em> to the node <em>If (A>B)</em> in the control flow graph of P and a value defined by the node <em>A=0</em> is used by at least one node in the sub-tree starting with the node <em>If (A>B)</em>. Similarly, the edge from the node <em>If (A>B)</em> to the node <em>F = A+C</em> corresponds to a tree dependence relation from <em>If (A>B)</em> to <em>F=A+C</em>.</p>
<p>Figure 8 illustrates the working of the partitioning algorithm. The child nodes are processed in the control flow order. At each step, a node is picked and its DG-Depth computed. Initially, all the child nodes are given a DG-Depth of `0'. Figure 8(a) shows the processing of the child node <em>A=0</em>. The incoming/outgoing edges of the node <em>A=0</em> are directed from/to the nodes having a DG-Depths as `0'. Hence, the node <em>A=0</em> is placed in the reorderable set numbered `1'. The DG-Depth of the node <em>A=0</em> is set to `1'. In Figure 8(d), the algorithm processes the child node <em>F=A+C</em>. The DG-Depths of the nodes that have a dependence relation with <em>F=A+C</em> are {2, 1}. The maximum value in this set is 2. Hence <em>F=A+C</em> is placed in the reorderable set numbered 3. The DG-Depth of the node <em>F=A+C</em> is set to `3'.</p>
<p>After partitioning, the reorderable sets will be as follows.</p>
<ul>
<li>Reorderable set - 1: {<em>A=0, B=3</em>};</li>
<li>Reorderable set - 2: {<em>If (A>B), G=A+B</em>};</li>
<li>Reorderable set - 3: {<em>F=A+C</em>}.</li>
</ul>
<p>Figure 8(f) shows the partitioned dependence graph.</p>
<p>We apply one more transformation to undo the effect of splitting a single assignment expression into multiple assignments. This is done by identifying chains in the tree-dependence graph of siblings and abstracting the chain as a single expression. A dependence chain is defined as follows.</p>
<p><strong>Definition:</strong> <em>Dependence Chain.</em> A sequence of sibling nodes <em>n<sub>1</sub></em> to <em>n<sub>k</sub></em>, <em>k > 0</em>, form a dependence chain iff (a) for all <em>n<sub>i</sub></em>, <em>1 &le; i &lt; k</em> there is at most one node, <em>n<sub>i+1</sub></em>, tree-dependent on <em>n<sub>i</sub></em>, and (b) for all <em>n<sub>j</sub></em>, <em>1 &lt; j &le; k</em>, <em>n<sub>j</sub></em> is tree-dependent on at most one node, i.e., <em>n<sub>j-1</sub></em>.</p>
<p>Figure 9(b) shows the dependence chains formed for the dependence graph of Figure 9(a).</p>
<p>Definition of tree-dependence is extended to include dependence between chains, as follows.</p>
<p><strong>Definition:</strong> <em>Dependence between chains.</em> A dependence chain <em>c<sub>1</sub></em> is dependent on a dependence chain <em>c<sub>2</sub></em> if and only if a PT node in <em>c<sub>1</sub></em> is tree-dependent on a PT node in <em>c<sub>2</sub></em>.</p>
<div align="center">
<img src="img/aal01/img6.gif" alt="Figure 6 Tree-dependence for the children of &quot;root&quot; of Example 1"/>
<p><strong>Figure 6 Tree-dependence for the children of "root" of Example 1</strong></p>
</div>
<pre class="source"><em>Partition-PT</em> ( <em>n</em> : PT-Node ) {
  for each child <em>c</em> of <em>n</em> do
    <em>Partition-PT</em> ( <em>c</em> );
  for each child <em>c</em> of <em>n</em>
   (in control-flow order) do {
    m = 0;
    for each <em>c'</em> such that
             <em>c</em> tree-depends on <em>c'</em>
          or <em>c'</em> tree-depends on <em>c</em> do
        m = <em>max</em> ( DG-Depth(<em>c</em>), m);
  }
  // c is in reorderable set <em>m+1</em>
  DG-Depth (<em>c</em>) = m+1;
}
</pre>
<p><strong>Figure 7 Algorithm to Partition PT Siblings</strong></p>
 
<p>The partitioning algorithm treats a dependence chain like a PT node. The algorithm produces the same reorderable sets independent of statement reordering, expression reshaping, and variable renaming transformations. The next section describes a strategy to order statements in a reorderable set. The use of dependence chains instead of individual program statements improves the probability of imposing an order using the string representation of the dependence chains.</p>
<h3>3.3.Partitioning reorderable sets</h3>
<p>The statements in a reorderable set are partitioned into a sequence of isomorphic sets by associating a special string representation to each statement, sorting the statements based on the string representation, and placing the statements with identical string representation in the corresponding isomorphic set. We have experimented with six string representations, referred to as SR1 to SR6. String representation SR<em>i</em> is used to partition statements that could not be partitioned using SR<em>i</em>-1. Thus, the six string representations act as a succession of filters.</p>
<p>The string representations need not preserve the semantics of the original statement since they are used only for ordering statements. The string representations are designed so that they do not depend on the names of the variable in the program, or the order of statements in the program, or order of expressions in commutative operators.</p>
<p>Figure 11 shows an example of SR1 representations of two expressions. Figure 10 gives the algorithm for computing this SR1 form. The result of the algorithm is placed in the property <em>String</em> of the expression node. In the SR1 form every identifier is replaced by the same symbol, "I". The string representation of an operator is created by concatenating the string representations of its operands. To counter expression reshaping, the string representations of the operands of a commutative operator are sorted before concatenation. The algorithm assumes that nested sequences of commutative binary operators are represented using a single <em>n</em>-ary operator. In addition, other transformations may also be pre-applied on the AST, such as representing the subtraction operator as addition of a negative number.</p>
<div align="center">
<img src="img/aal01/img8.gif" alt="Figure 8 Working of Partitioning Algorithm"/>
<p><strong>Figure 8 Working of Partitioning Algorithm (a) Processing the node [A=0] (b) Processing the node [B=3] (c) Processing the node [if (A>B)] (d) Processing the node [F=A+C] (e) Processing the node [G=A+B] (f) Dependence graph depths after partitioning</strong></p>
<img src="img/aal01/img9.gif" alt="Figure 9 Examples of Dependence Chains"/>
<p><strong>Figure 9 Examples of Dependence Chains (a) Tree-Dependence Graph (b) Dependence Chains</strong></p>
</div>
<p>The string representation of expressions in a PT is used to create the string representation of a PT (and its subtrees). Figure 12 presents the algorithm to compute
 
string form of a PT node, and its children. The reorderable sets are processed in their sequence order.</p>
<p>The string representations of nodes are used to partition reorderable sets by sorting the nodes on their string representation. The statements with the same string representation are grouped into isomorphic sets. The isomorphic sets are sorted using the string representation of its member elements. For instance, the statements <em>A=B+20</em> and <em>C=20+D</em> have the same SR1s. If these statements are in the same reorderable set then they will also be placed in the same isomorphic set.</p>
<p>Statements that cannot be differentiated into singleton sets by SR<em>i</em> are attempted to partition using SR<em>i</em>+1 through SR6, until one differentiates them. These representations are summarized below.</p>
<ul>
<li><strong>SR1 representation:</strong> Replace each variable in the statement by the symbol `I', convert commutative (binary) operators to N-ary operators, and sort the operands of the N-ary commutative operators using the SR1 representation for the operands.</li>
<li><strong>SR2 representation:</strong> For each variable used in an expression count the number of reaching definitions for that expression. For each variable defined in the expression, count the number of statements using that definition. Create a string using the counts of the number of uses and definitions. Figure 13 contains an example of SR2 form. The string U{1,3} implies that of the two variables used in expression "A=C+D", one variable has `1' reaching definition and the other variable has `3' reaching definitions. The string "D{2}" in the SR2 form implies that the variable defined in this expression is used in two statements.</li>
<li><strong>SR3 representation:</strong> Concatenate the sorted sequence of strings representing the SR1 representations of all the data dependence predecessors of the statement.</li>
<li><strong>SR4 representation:</strong> Concatenate the sorted sequence of strings representing the SR1 representations of all the data dependence successors of the statement.</li>
<li><strong>SR5 representation:</strong> Replace each function call in the statement by the SR1 representation of the body of that function.</li>
<li><strong>SR6 representation:</strong> Concatenate the sorted sequence of strings representing the SR1 representations of all the statements in forward and backward slices of that statement.</li>
</ul>
<p>Reorderable statements that yield the same string representation for SR1 through SR6 representations are placed in the same isomorphic set.</p>
<p>Let us return to Figure 2. All statements in the two rograms in this example can be completely ordered using the SR1 representation. The box after `Create String' gives the SR1 representation of the programs, with a caveat. The strings for the children have not been sorted. The box after `Fix Order' shows the resulting order of statements. The result from renaming the variables is shown in the last step.</p>
<p>More details on the zeroing transformation may be found in [13].</p>
<pre class="source">
Stringify-Expression (<em>e</em> : Expression )
{
  if (<em>e</em> is a variable) <em>e</em>.String = "I";
  elseif (<em>e</em> is a constant)
    <em>e</em>.String = string rep of <em>e</em>;
  else {
    // <em>e</em> is an operator
    S = string rep of root operator of <em>e</em>;
    for each child <em>c</em> of <em>e</em> do
      Stringify-Expression (<em>c</em>);
    if (<em>e</em> represents a commutative operator)
      L = sorted list of string reps of children of <em>e</em>;
    else
      L = list of string reps of children of <em>e</em>;
    fi;
    S' = concatenate strings in L;
    <em>e</em>.String = concatenate S and S';
  }
</pre>
<p><strong>Figure 10 Creating SR1 Strings of Expressions</strong></p>
<div align="center">
<img src="img/aal01/img11.gif" alt="Figure 11 SR1 Form of Expressions"/>
<p><strong>Figure 11 SR1 Form of Expressions</strong></p>
</div>
<h2>4. Empirical analysis</h2>
<p>We have developed a tool, C&oplus;, that implements the proposed algorithm for imposing order on the statements of C programs. It does not implement transformations to undo expression reshaping. C&oplus; uses the Program Dependence Graph (PDG) [7], generated by CodeSurfer&trade; [8] of GrammaTech, to gather the control
 
and data dependences needed to identify reorderable statements.</p>
<p>We analyzed a set of real-world C programs to study how well the proposed approach imposed order on their statements. Our test systems represent a `best case' scenario. If the results for the best case are not satisfactory, then one cannot expect any significant returns from using the method for metamorphic viruses whose code is inherently obfuscated.</p>
<p>The test systems used in the experiments are described below:</p>
<ul>
<li><strong>Bison:</strong> The Bison program is a LALR parser generator. It consists of 33 C files generating 10,718 nodes in the program dependence graph.</li>
<li><strong>Cook:</strong> The COOK system [6] is used for writing build scripts for projects. It is a powerful and easy to use replacement for make [14]. It consists of 39 files generating 9,147 nodes in the PDG.</li>
<li><strong>SNNS:</strong> The SNNS system is a neural network simulator for Unix&reg; workstations. It consists of 11 files generating 8,835 nodes in the PDG.</li>
<li><strong>Fractal:</strong> The Fractal programs [15] create fractals using C programming language. It contains 36 files generating 8,856 nodes in the PDG.</li>
<li><strong>Computer vision:</strong> The Computer Vision programs is a collection of programs illustrating computer vision. It consists of 21 files generating 13,159 nodes in the PDG.</li>
</ul>
<p>For each of these systems we measure the following:</p>
<ol>
<li><em>Reorderable Percentages:</em> The percentage of statements that can be reordered.</li>
<li><em>Total Number of Permutations:</em> Product of the number of permutations of each reorderable set.</li>
</ol>
<p>The two measures are computed for the original program, referred to as SR0 representation, and the program resulting after fixing statement order using the filters SR1 through SR6, but without the transformation for expression reshaping.</p>
<p>Figure 14 shows the reorderable percentages for our test programs. On an average 55% of the statements of the original program are reorderable. The number of reorderable statements is reduced to 6% after transformation. The Fractal programs have higher reorderable percentages than other systems. This is because the Fractal programs have computer graphics code has many code fragments with similar statement structures, but which compute on different coordinate axes.</p>
<p>Table 1 shows the total number of possible permutations for the test programs before and after applying zeroing transformations. The rows P1 to P6 are number of possible permutations that can be created by reordering statements whose order is not fixed by SR1 to SR6, respectively. P0 is the permutations for the original program.</p>
<p>The SR1 filter significantly reduces the number of possible permutations for each program. For Bison the reduction was from 10<sup>61</sup> possible permutations to 10<sup>17</sup>. The number of variants of the Cook system was reduced from 10<sup>47</sup> to 10<sup>21</sup> ; for SNNS a reduction from 10<sup>184</sup> to 10<sup>29</sup>; for Fractal a reduction from 10<sup>88</sup> to 10<sup>21</sup>; and for Computer Vision a reduction from 10<sup>113</sup> to 10<sup>7</sup>. The sample programs exhibit significant variation on the effect of the successive filters SR2 to SR6. The SR2, SR4, and SR6 filters produce at least an order of magnitude reduction for Computer Vision and Fractal, whereas SR2 and SR6 produced similar reduction for SNNS. None of the other filters made any significant difference to Bison and Cook.</p>
<pre class="source">
Stringify-PT-Node ( <em>n</em>: PT-Node)
{
  if (<em>n</em> is a leaf node) {
    Stringify-Expression (expression of <em>n</em>);
    <em>n</em>.String = <em>n</em>.String;
  } else {
    Stringify-Expression (expression of <em>n</em>);
    S = (expression of <em>n</em>).String;
    for each reorderable set <em>r</em> of <em>n</em> do {
      for each child <em>c</em> in <em>r</em> do
        Stringify-PT-Node-SR1 (<em>c</em>);
      R = sorted list of SRs of nodes in <em>r</em>;
      <em>r</em>.String = concatenation of strings in R;
   }
   L = sorted list of SRs of reorderable sets of <em>n</em>;
   S' = concatenation of strings in L;
    <em>n</em>.String = concatenate S and S'
  }
</pre>
<p><strong>Figure 12 Creating String Form of PT-Nodes</strong></p>
<div align="center">
<img src="img/aal01/img13.gif" alt="Figure 13 SR2 Form of Expressions"/>
<p><strong>Figure 13 SR2 Form of Expressions</strong></p>
</div>
<h2>5. Related work</h2>
<p>Besides making it difficult to detect a virus using signature-based analysis [3, 10], metamorphic transformations also obfuscate the code to make it difficult for an anti-virus analyst to analyze the program. Such obfuscations have legitimate uses too. Programs may be obfuscated to protect intellectual property, and to increase security by making it difficult for others to identify vulnerabilities [5, 11, 19]. The art of obfuscation is quite advanced. Collberg et al. [5] present a taxonomy
 
of obfuscating transformations and a detailed theoretical description of such transformations.</p>
<div align="center">
<img src="img/aal01/img14.gif" alt="Figure 14 Reorderable percentages for test systems"/>
<p><strong>Figure 14 Reorderable percentages for test systems</strong></p>
</div>
<table summary="Table 1 Number of permutations for test systems" border="1">
<tr><th>&nbsp;</th><th>Bison</th><th>Cook</th><th>SNNS</th><th>Fractal</th><th>C/Vision</th></tr>
<tr><th>P0</th><td>1.8E61</td><td>2.8E47</td><td>1.4E184</td><td>9.1E88</td><td>1.3E113</td></tr>
<tr><th>P1</th><td>8.5E17</td><td>9.1E21</td><td>2.7E29</td><td>3.0E21</td><td>5.9E7</td></tr>
<tr><th>P2</th><td>8.5E17</td><td>9.1E21</td><td>4.9E9</td><td>3.0E21</td><td>15,156</td></tr>
<tr><th>P3</th><td>8.5E17</td><td>4.6E21</td><td>4.9E9</td><td>5.9E16</td><td>15,155</td></tr>
<tr><th>P4</th><td>8.5E17</td><td>4.6E21</td><td>3.0E9</td><td>1.8E9</td><td>1,591</td></tr>
<tr><th>P5</th><td>8.5E17</td><td>4.6E21</td><td>3.0E9</td><td>1.8E9</td><td>1,104</td></tr>
<tr><th>P6</th><td>8.5E17</td><td>4.6E21</td><td>1.3E6</td><td>6.6E8</td><td>203</td></tr>
</table>
<p><strong>Table 1 Number of permutations for test systems</strong></p>
<p>The Bloodhound technology [16] of Symantec Inc. uses static and dynamic heuristic scanners. The static heuristic scanner maintains a signature database. The signatures are associated with program code representing different functional behaviors. The dynamic heuristic scanner uses CPU emulation to gather information about the interrupt calls the program is making. Based on this information it can identify the functional behavior of the program. Once different functional behaviors are identified, they are fed to an expert system, which judges whether the program is malicious or not. Static heuristics fail to detect morphed variants of the viruses because such variants may have different signatures. Dynamic heuristics consider only one possible execution of a program. A virus can avoid being detected by a dynamic scanner by introducing arbitrary loops.</p>
<p>Lo et al.'s MCF [12] uses program slicing and flow analysis for detecting computer viruses, worms, Trojan-horses, and time/logic bombs. MCF identifies telltale signs that differentiate between malicious and benign programs. MCF slices a program with respect to these telltale signs to get a smaller program segment representing the malicious behavior. This smaller program segment is manually analyzed for the existence of virus behavior.</p>
<p>Szappanos [17] uses code normalization techniques to remove junk code &amp; white spaces, and comments in macro viruses before they generate virus signature. To deal with variable renaming, Szappanos suggests two methods: first, renaming variables using the order in which they appear in the program and second, renaming all the variables in a program with a same name. Former approach fails if the virus reorders its statements, and the later approach abstracts a lot of information and may lead to incorrect results. As our approach fixes the order of the statements in a program, the first approach suggested by Szappanos for renaming the variable can be used in combination with our method.</p>
<p>Christodorescu et al. [3] have developed a method for detecting patterns of malicious code in executables. They use abstraction patterns - patterns representing sequences of instructions. These patterns are parameterized to match different instructions sequences with the same instruction set but different operands. Their approach gives fewer false positives but the cost of creating and matching the abstraction patterns is high. They detect the virus variants created by performing dead code insertion, variable renaming in the absence of statement reordering, and break &amp; join transformations. Our method, in addition to the above morphing transformations, can be used to detect the viruses that apply statement reordering and expression reshaping transformations.</p>
<p>The problem of detecting malicious code is related to that of detecting software clones. Current anti-virus technologies in essence check whether a given executable is a clone of a known, malicious executable. The primary difference is that an anti-virus software, running on a user's desktop, must make the determination without having access to a complete copy of the original, or else the anti-virus software itself may be distributing viruses. Our algorithm has some similarities to Komondoor and Horwitz's PDG based algorithm for detecting software clone [9]. While we create string representations using the data-dependence relations of a statement, Komondoor and Horwitz match theses statements to determine clones. They too compare statements by factoring out differences in the names of variables.</p>
<h2>6. Conclusions</h2>
<p>We are investigating methods for transforming a program into a canonical form. Such a method may be used to map different variants of a metamorphic virus to the same canonical form, thereby making it easier to detect such viruses. With this goal, we have developed transformations to undo the effect of statement reordering, expression reshaping, and variable renaming transformations. We call the resulting form a zero form. As our method is a heuristic, we may not always map all the variants to a single zero form. But the application of
 
zeroing transformations results in a significant decrease in the number of possible variants of a program. Our initial experiments show that on an average 55% of the statements of a program statements are reorderable. After imposing order on these statements using our zeroing transformation only 6% of the statements remained reorderable, that is, could not be ordered using our method. This is a significant reduction in the number of variants that can be created by statement reordering. To utilize the method in AV technologies, the method needs to be adapted for binary programs.</p>
<p><strong>Acknowledgments:</strong> The authors thank Andrew Walenstein for his help in improving the presentation of this paper.</p>
<h2>7. References</h2>
<ol>
<li>A. Aho, R. Sethi, and J. Ullman, <em>Compilers Principles, Techniques, and Tools</em>: Addison-Wesley, 1986.</li>
<li>V. Bontchev, "Macro and Script Virus Polymorphism," in <em>Proceedings of the 12th International Virus Bulletin Conference</em>, 2002.</li>
<li>M. Christodrescu and S. Jha, "Static Analysis of Executables to Detect Malicious Patterns," in <em>The 12th USENIX Security Symposium (Security '03),</em> Washington DC, USA, 2003.</li>
<li>F. Cohen, "<a href="/lib/afc01.html">Computer Viruses - Theory and Experiments</a>," <em>Computers and Security</em>, 6, 1984</li>
<li>C. Collberg and C. Thomborson, "Watermarking, Tamper-Proofing, and Obfuscation - Tools for Software Protection," <em>IEEE Transactions on Software Engineering</em>, vol. 28, pp. 735-746, 2002.</li>
<li>C. G. Davis, "Debian Cook Package," http://packages.debian.org/stable/devel/cook.html, Last accessed 08/29/2003.</li>
<li>J. Ferrante, K. J. Ottenstein, and J. Warren, "The Program Dependence Graphs and Its Use in Optimization," <em>ACM Transactions on Programming Languages and Systems (TOPLAS)</em>, vol. 9, pp. 319-349, 1987.</li>
<li>GrammaTech, "Codesurfer - Program Analysis Tool," http://www.codesurfer.com, Last accessed 08/29/2003.</li>
<li>R. Komondoor and S. Horwitz, "Using Slicing to Identify Duplication in Source Code," in <em>Proceedings of the 8th International Symposium on Static Analysis</em>, Paris, France, 2001.</li>
<li>A. Lakhotia and P. K. Singh, "<a href="/lib/aal00.html">Challenges in Getting Formal with Viruses</a>," <em>Virus Bulletin</em>, 2003, http://www.virusbtn.com/magazine/archives/200309/formal.xml.</li>
<li>C. Linn and S. Debray, "Obfuscation of Executable Code to Improve Resistance to Static Disassembly," in <em>Proceedings of the 10th ACM Conference on Computer and Communication Security 2003,</em> Washington D.C., USA, 2003.</li>
<li>R. W. Lo, K. N. Levitt, and R. A. Olsson, "MCF: A Malicious Code Filter," <em>Computers &amp; Security</em>, vol. 14, pp. 541-566, 1995.</li>
<li>M. Mohammed, <em>Zeroing in on Metamorpic Computer Viruses</em>, Center for Advanced Computer Studies, University of Louisiana at Lafayette, M.S. Thesis, 2003.</li>
<li>R. M. Stallman, R. McGrath, and P. Smith, "GNU Make, a Program for Directing Recompilation," 2002.</li>
<li>R. T. Stevens, <em>Fractal Programming in C</em>: John Wiley and Sons, 1989.</li>
<li>Symantec, "Understanding Heuristics: Symantec's Bloodhound Technology," http://www.symantec.com/avcenter/reference/heuristc.pdf, Last accessed July 1, 2004.</li>
<li>G. Szappanos, "Are There Any Polymorphic Macro Viruses at All? (... and What to Do with Them)," in <em>Proceedings of the 12th International Virus Bulletin Conference</em>, 2002.</li>
<li>P. Sz&ouml;r and P. Ferrie, <a href="/lib/apf39.html">"Hunting for Metamorphic,"</a> in <em>Proceedings of the 11th International Virus Bulletin Conference</em>, 2001.</li>
<li>G. Wroblewski, <em>General Method of Program Code Obfuscation</em>, Institute of Engineering Cybernetics, Wroclaw University of Technology, PhD. Thesis, 2002.</li>
</ol>
 
[<a style="" href="/lib/?lang=EN&amp;index=ME#aal01">Back to index</a>] [<a href="/lib/aal01.html#disqus_thread">Comments</a>]<br/> <div id="disqus_thread"></div>
<script type="text/rocketscript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'vxheaven'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="/agreement.php">Terms of Use</a>!</small> <small>vxheaven.org aka vx.netlux.org</small></div>
<div style="margin-top: 2px; float: left;" class="adsapeu">
<script type="text/rocketscript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script>
</div>
<script data-rocketsrc="http://www.google-analytics.com/urchin.js" type="text/rocketscript"></script><script type="text/rocketscript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="/lib/index.php?lang=de&amp;id=aal01">de</a><a href="/lib/index.php?lang=en&amp;id=aal01">en</a><a href="/lib/index.php?lang=es&amp;id=aal01">es</a><a href="/lib/index.php?lang=it&amp;id=aal01">it</a><a href="/lib/index.php?lang=fr&amp;id=aal01">fr</a><a href="/lib/index.php?lang=pl&amp;id=aal01">pl</a><a href="/lib/index.php?lang=ru&amp;id=aal01">ru</a><a href="/lib/index.php?lang=ua&amp;id=aal01">ua</a></div>
</body>
</html>
