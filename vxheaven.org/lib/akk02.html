<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Константин Климентьев 'Внутренний формат документов MS WORD' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Author" content="Константин Климентьев"/>
<meta name="KeyWords" lang="en" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, Климентьев, Константин,Внутренний формат документов MS WORD, dword, неиспользуется, word, stgm, хранилище, сектор, деле, самом, format, каталоге, секторов, binary, сектору, термин, объект"/>
<meta name="Description" content="Хотя официально фирма Microsoft информацией по  этой  теме мало с кем делилась, и даже одно время пыталась препятствовать ее распространению,  все же нельзя сказать, что эта информация закрыта.  Ей на самом деле владеют многие. Без этой информации не существовали бы такие продукты, как антивирусы KAV и DrWEb, переводчик Stylus, пакет 1С:Предприятие и т.п."/>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"047a5bcbf67431883fc9ed25fba33612",petok:"1d9236d507aa2e1ca797b2b7546558ee92eacdf0-1498757966-1800",zone:"vxheaven.org",rocket:"a",apps:{}}];document.write('<script type="text/javascript" src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=85b614c0f6/cloudflare.min.js"><'+'\/script>');}}catch(e){};
//]]>
</script>
<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="/style.css"/><link rel="canonical" href="http://vxheaven.org/lib/akk02.html"/>
<script type="text/rocketscript" data-rocketsrc="https://apis.google.com/js/plusone.js">{"parsetags": "explicit"}</script>
</head>
<body bgcolor="#dbc8a0" text="#302000" link="#225599" vlink="#113366">
<div class="s1">
<div style="float:right;"><a href="/lib/index.php?tbs=1"><img src="/img/max.gif" alt="Maximize"/></a></div> <form id="lf" style="margin: 0; float: right;" method="get" action="/index.php"><input type="hidden" name="action" value="set"/><select name="lang" onchange="javascript:document.getElementById('lf').submit();"><option value="ru">Русский</option><option selected="selected" value="en">English</option><option value="ua">Українська</option><option value="de">Deutsch</option><option value="es">Español</option><option value="fr">Fran&ccedil;ais</option><option value="it">Italiano</option><option value="pl">Polski</option></select></form>
<div style="float: right;"><div id="plusone"></div></div>
<script type="text/rocketscript">gapi.plusone.render("plusone", {"size":"small","count":"true"});</script>
<div style="float: right;" class="addthis_toolbox addthis_default_style">
<script type="text/rocketscript">var addthis_config = { ui_click: true }</script>
<a style="text-decoration: none; font-size: 10pt;" href="/?action=addthis" class="addthis_button_compact">Bookmark</a>
<script type="text/rocketscript" data-rocketsrc="http://s7.addthis.com/js/250/addthis_widget.js#username=herm1t"></script>
</div>
<div style="float: right;">
<script type="text/rocketscript" data-rocketsrc="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<form action="/search.php" id="cse-search-box">
<input type="hidden" name="cx" value="002577580816726040001:z9_irkorydo"/>
<input type="hidden" name="cof" value="FORID:10"/>
<input type="hidden" name="ie" value="UTF-8"/>
<input type="text" name="q" size="12" value=" "/>
<input type="submit" name="sa" value="Search"/>
</form>
</div><h1><a href="/" style="text-decoration: none; color: #000000;">VX Heaven</a></h1>
<span class="nav"><a href="/lib/">Library</a> <a href="/vl.php">Collection</a> <a href="/src.php">Sources</a> <a href="/vx.php?id=eidx">Engines</a> <a href="/vx.php?id=tidx">Constructors</a> <a href="/vx.php?id=sidx">Simulators</a> <a href="/vx.php?id=uidx">Utilities</a> <a href="/links.php">Links</a> <a href="/donate.php" style="color: #706020" id="donate">Donate</a> <a href="/forum" style="text-decoration: underline;">Forum</a> </span><br clear="all"/>
</div>
<div class="s2"><h1>Внутренний формат документов MS WORD</h1><p><a href="/lib/?lang=ru&amp;author=%D0%9A%D0%BB%D0%B8%D0%BC%D0%B5%D0%BD%D1%82%D1%8C%D0%B5%D0%B2%2C%20%D0%9A%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82%D0%B8%D0%BD">Константин Климентьев</a><br/> <em>http://www.uinc.ru/</em><br/> <em> 2000</em></p><script type="text/rocketscript">var disqus_url = 'http://vxheaven.org/lib/akk02.html';</script>[<a style="" href="/lib/?lang=RU&amp;index=MA#akk02">Вернуться к списку</a>] [<a href="/lib/akk02.html#disqus_thread">Комментарии</a>]<br/> 
<ul>
<li><a href="#p0">Введение</a></li>
<li><a href="#p1">1. Общее описание. Терминология</a></li>
<li><a href="#p2">2. Доступ к STRUCTURED STORAGE через OLE2 API</a></li>
<li><a href="#p3">3. Низкоуровневый доступ к STRUCTURED STORAGE</a>
<ul>
<li><a href="#p31">3.1. FAT "Больших Блоков"</a></li>
<li><a href="#p32">3.2. FAT "Малых Блоков"</a></li>
<li><a href="#p33">3.3. Структура каталога</a></li>
</ul></li>
<li><a href="#p4">4. Структура документа MS WORD</a></li>
<li><a href="#p5">Заключение</a></li>
<li><a href="#p6">Дополнение от зимы 2004 года</a></li>
</ul>
<h2><a name="p0">Введение</a></h2>
<div align="right">
...Стоило ему прослышать, что где-то <br/>
результаты многообещающих исследований <br/>
сданы на консервацию, как он приходил в <br/>
зоологическое неистовство и рвался <br/>
разоблачать, обличать и срывать покровы. <br/>
А. и Б. Стругацкие. Жук в муравейнике.
</div>
<p>Хотя официально фирма Microsoft информацией по этой теме мало с кем делилась, и даже одно время пыталась препятствовать ее распространению, все же нельзя сказать, что эта информация закрыта. Ей на самом деле владеют многие. Без этой информации не существовали бы такие продукты, как антивирусы KAV и DrWEb, переводчик Stylus, пакет 1С:Предприятие и т.п.</p>
<p>Сейчас в Интернете ее вполне достаточное количество, просто она разбросана мелкими порциями по разным малоизвестным источникам, и, что еще более неприятно, озаглавлена совсем не так, как хотелось бы нам. К сожалению, это как раз тот случай, о котором предупреждал незабвенный Козьма Прутков: на клетке слона частенько можно встретить надписи "буйвол", "мышь", "муравей", "динозавр", но только не "слон".</p>
<p>Цель этой статьи - попытаться собрать наиболее важные осколки информации в одно целое и указать места, где они валяются россыпью.</p>
<h2><a name="p1">1. Общее описание. Терминология</a></h2>
<div align="right">
- Тот, кто хочет стать Чародеем Моря, <br/>
должен знать Настоящее Имя каждой капли воды.<br/>
Урсула Ле Гуин. Волшебник Земноморья.
</div>
<p>Файлы документов MS WinWord с расширением .DOC представляют собой сложные объекты, организованные по правилам структурированного хранилища (structured storage). Фактически, структурированное хранилище - это отдельная файловая система от Microsoft, примерно такая же, как FAT или NTFS. Используют ее очень многие Windows-приложения разных производителей, функционирующие в рамках технологий OLE/COM/ActiveX. Вот (очень неполный!) список расширений файлов, устроенных по правилам структурированного хранилища, которые я обнаружил на своем компьютере: .DOC, .DOT, .XLS, .XLA, .WIZ, .CAG, .FLA, .PPT, .MD и пр.</p>
<p>Сам же дисковый файл, хранящий внутри себя структурированное хранилище, называется "файл-документ" (docfile) или "составной файл" (compound file). Первый термин применялся во времена OLE 1, второй появился в середине 90-х годов вместе с OLE 2, сейчас они обычно используются как синонимы.</p>
<p>В OLE существует еще понятие "составной документ" (compound document), но этот термин обозначает абстрактный подкласс хранилищ особого вида... в-общем, это уже ария несколько из другой оперы.</p>
<p>Внутри составной файл состоит из следующих элементов:</p>
<ul>
<li>"хранилища" (storages), а на самом деле это просто внутренние каталоги, описывающие состав и расположение других объектов внутри составного файла;</li>
<li>"потоки" (streams), а на самом деле это своего рода файлы, массивы структурированной информации, имеющие собственное имя;</li>
<li>"заблокированные данные" (lock-bytes), а на самом деле это довольно редко встречающиеся неструктурированные массивы двоичной информации, своего рода "посторонние" данные, которые разрешается иметь внутри составного файла, но которые не могут служить OLE-объектами.</li>
</ul>
<p>Еще в литературе про OLE можно встретить термин "корневое хранилище" (root storage). Нетрудно сообразить, что он на самом деле означает всего лишь корневой каталог, т.е. главный каталог в составном файле. Фактически, так оно и есть. Но в литературе этот термин иногда используется в качестве синонима для составного файла и файл-документа, ведь они без корневого каталога не могут существовать, также как и он без них. Ну что ж, будем иметь это в виду.</p>
<p>Наконец, потоки (streams), на которые имеются ссылки в корневом хранилище (root storage), могут называться "наборы свойств" (property sets). На самом деле, так имеют право наименоваться не все потоки (streams), а только те из них, кто организован особым родом: имеют стандартизованный заголовок, разбиты на специфические разделы и т.п. Для нас это не слишком важно.</p>
<p>Разобраться в теринологических хитросплетениях мне помогла книжка: <em>Харрис Л. Освой самостоятельное программирование OLE за 21 день. - М.: Бином, 1995.-462 с.</em></p>
<h2><a name="p2">2. Доступ к STRUCTURED STORAGE через OLE2 API</a></h2>
<div align="right">
- Добро пожаловать! Это автобус для ведьм <br/>
и волшебников, попавших в трудное <br/>
положение! Взмахните палочкой и входите в <br/>
салон: мы домчим вас куда угодно! <br/>
Дж. К. Ролинг. Гарри Поттер и узник Азбакана
</div>
<p>Microsoft предоставляет мощные средства для работы в рамках технологии OLE, они сконцентрированы в библиотеках OLE2.DLL (для 16-разрядных приложений) и OLE32.DLL (для 32-разрядных приложений). В принципе, к ним можно обращаться из любой системы программирования (например, из MS VB и даже из языка ассемблера), использовав традиционный механизм GetModuleHandle/GetProcAddress. Но проще всего это делать из MS VC или Borland C/C++. По крайней мере, все примеры из этой статьи компилировались при помощи Borland C/C++ v5.01.</p>
<p>Итак, в довольно объемной и сложной библиотеке OLE32.DLL для нас с точки зрения темы статьи интересны около дюжины API- функций, позволяющих создавать и открывать составные файлы в различных режимах, обращаться к их каталогам и т.п. Рассмотрим некоторые из них.</p>
<ol>
<li> Создание нового составного файла с форматом структурированного хранилища:
<pre class="source">HRESULT StgCreateDocfile (WCHAR *ИмяФайла,
                          DWORD ФлагиДоступа,
                          DWORD НеИспользуется,
                          IStorage **Интерфейс);</pre>
<p>Обычно для параметра ФлагиДоступа используется конкатенация из битов STGM_CREATE (создать новый составной файл), STGM_READ (разрешить чтение), STGM_WRITE (разрешить запись) или STGM_READWRITE (разрешить чтение и запись). Но можно указать STGM_CONVERT, это якобы позволяет преобразовывать "сырые" данные в структурированное хранилище, помещая их в поток с предопределенныи именем CONTENTS.</p></li>
<li> Открытие существующего составного файла, имеющего формат структурированного хранилища, флаги те же:
<pre class="source">HRESULT StgOpenStorage (WCHAR *ИмяФайла,
                        IStorage *УжеОткрытыйИнтерфейс,
                        DWORD ФлагиДоступа,
                        SNB МаскаИсключения,
                        DWORD НеИспользуется,
                        IStorage **Интерфейс);</pre></li>
<li> Проверка файла на соответствие формату структурированного хранилища. Возвращает S_OK - это хранилище; S_FALSE - это не хранилище; STG_E_FILENOTFOUND - файла вообще нет:
<pre>HRESULT StgIsStorageFile(WCHAR* ИмяФайла)</pre>
<p> Функции StgCreateDocfile и StgOpenStorage требуют имя дискового файла (например, L"C:\FILE.DOC"), а возвращают в последнем параметре интерфейс доступа - т.е. указатель на объект класса IStorage, свойства и методы которого позволяют манипулировать с элементами структуры уже открытого или созданного составного документа (физически это - просто массив адресов).</p>
<p> Дальше кратко описываются некоторые, наиболее интересные методы этого интерфейса.</p></li>
<li> Создание нового подкаталога в главном каталоге открытого составного файла.
<pre class="source">HRESULT CreateStorage(wchar_t *ИмяПодкаталога,
                      DWORD ФлагиДоступа,
                      DWORD НеИспользуется1,
                      DWORD НеИспользуется2,
                      IStorage **ОткрытыйОбъект);</pre></li>
<li> Открытие существующего подкаталога в главном каталоге открытого составного файла.
<pre class="source">HRESULT OpenStorage(wchar_t *ИмяПодкаталога,
                    IStorage *УжеОткрытыйОбъект
                    DWORD ФлагиДоступа,
                    SNB ИменаПотоков,
                    DWORD НеИспользуется,
                    IStorage **ОткрытыйОбъект);</pre></li>
<li> Закрытие открытого каталога или подкаталога после завершения работы с ними (крайне рекомендуется использовать!). <pre>ULONG Release(void);</pre></li>
<li> Инициализация перечисления записей в каталоге или подкаталоге.
<pre class="source"> HRESULT EnumElements(DWORD НеИспользуется1,
                     void НеИспользуется2,
                     DWORD НеИспользуется3,
                     IEnumSTATSTG **ИнтерфейсПеречисления);</pre>
<p>Возвращает новый интерфейс к объекту-перечислителю, который обладает методами:</p>
<dl>
<dt>HRESULT Next(ULONG Сколько, void *Куда, void *РеальноПолученные)</dt>
<dd>- возвращает очередные элементы;</dd>
<dt>HRESULT Skip(ULONG Сколько)</dt>
<dd>- пропускает элементы списка;</dd>
<dt>HRESULT Reset(void)</dt>
<dd>- возвращает позицию начала списка;</dd>
<dt>HRESULT Clone(Позиция)</dt>
<dd>- возвращает копию перечислителя.</dd>
</dl></li>
<li> Создание нового потока внутри открытого каталога.
<pre class="source">HRESULT CreateStream(wchar_t * ИмяПотока,
                     DWORD ФлагиДоступа,
                     DWORD НеИспользуется1,
                     DWORD НеИспользуется2,
                     IStream **ОткрытыйПоток);</pre></li>
<li> Открытие потока внутри открытого каталога.
<pre class="source">HRESULT OpenStream(const wchar_t *ИмяПотока,
                   void *НеИспользуется1,
                   DWORD ФлагиДомтупа,
                   DWORD НеИспользуется2,
                   IStream **ОткрытыйПоток);</pre></li>
<li> Запись данных в поток.
<pre class="source">HRESULT Write(void *Буфер,
              ULONG Размер,
              ULONG *РеальноЗаписано);</pre></li>
<li> Чтение данных из потока.
<pre class="source">HRESULT Read(void *Буфер,
             ULONG Размер,
             ULONG *РеальноПрочитано);</pre></li>
<li> Переименование записи в каталоге.
<pre class="source">HRESULT RenameElement(wchar_t *СтароеИмя,
                      wchar_t *НовоеИмя);</pre></li>
</ol>
<p>Фактически, сервисных методов гораздо больше. Например, существует большой набор методов для работы с lock-bytes, но он нам в контексте статьи не слишком актуален.</p>
<p>Теперь рассмотрим примерчик работы с составным файлом через OLE API, а именно - рекурсивный просмотр дерева заключенных внутри объектов:</p>
<pre class="source">// Рекурсивный сканер docfile. (с) Климентьев К., Самара 2002
#include "windows.h"
#include "ole2.h"
#include "iostream.h"
#include "stdio.h"

int level=0;

walk(char *s, LPSTORAGE ls)
{
 OLECHAR FileName[256]; LPENUMSTATSTG lpEnum=NULL;
 LPSTORAGE pIStorage=NULL; LPSTORAGE pIStorage2=NULL;
 ULONG uCount; STATSTG stat; int i;

 if (!ls) {
  mbstowcs(FileName, s, 256); wprintf(L"[%s]\n", FileName);
  StgOpenStorage(FileName, NULL,
                 STGM_READ|STGM_SHARE_EXCLUSIVE,
                 NULL,0,&amp;pIStorage);
  walk("", pIStorage);
 }
 else  {
  ls-&gt;EnumElements(0,NULL,0,&amp;lpEnum);
  if (lpEnum)
   while (lpEnum-&gt;Next(1,&amp;stat,&amp;uCount)==S_OK) {
    for (i=0;i&lt;level;i++) wprintf(L" ");
    wprintf(L"%d: %s\n", stat.type, (LPSTR)stat.pwcsName);
    if (stat.type==STGTY_STORAGE) {
      ls-&gt;OpenStorage(stat.pwcsName, NULL,
                      STGM_READ|STGM_SHARE_EXCLUSIVE,
                      NULL, 0, &amp;pIStorage2);
      level++;
      walk("", pIStorage2);
      level--;
     }
   };
   ls-&gt;Release();
 }
}

int main(int argc, char* argv[]) {
 if (argc&gt;1) walk(argv[1],NULL);
}
</pre>
<p>Создадим в Word 97/2000/XP пустой DOC-файл без текста и напустим на него нашу программу. Мы увидим примерно следующее:</p>
<pre class="source">[word97.doc]
2: 1Table
2: \1CompObj
1: ObjectPool
2: WordDocument
2: \5SummaryInformation
2: \5DocumentSummaryInformation
</pre>
<p> Для DOC-файла в формате Word 6/7 (его можно создать, например, при помощи Wordpad) картинка будет попроще:</p>
<pre class="source">[word6.doc]
2: \1CompObj
2: WordDocument
</pre>
<p> Примерно так, как описано в этом разделе, устроены популярный FAR-плагин DocFile Browser Игоря Павлова и утилита OLE2View из MS Visual C/С++.</p>
<p> Если хотите подробностей, то рекомендую:</p>
<ol>
<li> хорошую статью Артема Каева <a href="http://www.uinc.ru/articles/39/%5C%5Cwww.firststeps.ru/mfc/activex/">"ActiveX по шагам"</a>;</li>
<li> фирменный материал от Microsoft "OLE 2 programmers reference" (его можно найти в файлах OLE.HLP или OLE2.HLP).</li>
</ol>
<h2><a name="p3">3. Низкоуровневый доступ к STRUCTURED STORAGE</a></h2>
<div align="right">
Вокруг разобранной автомашины моментально <br/>
собралась толпа коротышек. Каждому было <br/>
интересно взглянуть на устройство <br/>
механизма. <br/>
Н. Носов. Незнайка в Солнечном городе</div>
<p>Широко известен народный персонаж по имени Чукча, который служил "писателем" и по этой причине не считал для себя нужным учиться читать. Наверное, имеются автомобилисты, которые никогда не заглядывали под капот своего четырехколесного друга. Не исключено, что существуют нежно любящие друг друга супруги, которые ни разу в жизни... гм... надеюсь, мы к их числу не относимся?</p>
<p>Давайте же приоткроем "кошмарную тайну кровавой фирмы Microsoft": посмотрим на составной файл невооруженными глазками и пощупаем его голыми ручками. Впрочем, "программисты", которые умеют только кликать по иконкам и таскать мышом картинки между окошкам, могут этот раздел с чистой совестью пропустить.</p>
<p>Составной файл состоит из целого числа "больших блоков" (big blocks), размер каждого из которых соответствует одному дисковому сектору, т.е. 512 байт. Поэтому, в отличие от англоязычной документации, мы будем называть их просто секторами. Все сектора в файле пронумерованы следующим образом: -1, 0, 1, 2... и т.д.</p>
<p>Сектор с номером -1 содержит заголовок составного файла:</p>
<pre class="source">struct DOC_FILE_HEADER
{
 DWORD Сигнатура;      // +00h - "магическое" число E011CFD0h
 DWORD КодВерсииOLE;   // +04h - "магическое" число E11AB1A2h
 DWORD НеИспользуется1[9];
 DWORD РазмерBBD;      // +2Ch - количество секторов в BBD
 DWORD НачалоКаталога; // +30h - стартовый сектор каталога
 DWORD НеИспользуется2[2];
 DWORD НачалоSBD;      // +3Сh - стартовый сектор SBD
 DWORD РазмерСектора;  // +40h - обычно имеет значение 1
 DWORD НеИспользуется3[2];
 DWORD НачалоBBD;      // +4Ch - стартовый сектор BBD
};
</pre>
<p><em>Примечание. Есть предположние, что по смещению 40h располагается поле, описывающее размер сектора. В подавляющем большинстве DOC-файлов длиной до 1 Мб в этом поле содержится значение 1 (т.е. размер сектора равен 512), но изредка встречается 2 (т.е. размер сектора равен 1024). Вероятно, возможны 3, 4, и так далее. В этом случае лучше говорить не о "секторах", но о "кластерах". Но идеология организации составного файла от этого не меняется.</em></p>
<p> Теперь очень легко проверить, организован ли какой-нибудь файл по правилам структурированного хранилища: достаточно проверить его первые 4 байта. Они должны быть: 0D0h, 0CFh, 11h, E0h.</p>
<p> Все остальное, не занятое заголовком, пространство составного файла разбито на четыре (не обязательно непрерывных!) области:</p>
<ul>
<li>область каталогов;</li>
<li>FAT данных, организованных в виде 512-байтовых больших блоков (в оригинале это BBD - big blocks depot);</li>
<li>FAT даных, организованных в виде 64-байтовых малых блоков (в оригинале это SBD - small blocks depot);</li>
<li>область собственно данных.</li>
</ul>
<h3><a name="p31">3.1. FAT "Больших Блоков"</a></h3>
<p>Я не случайно пошел вразрез с англоязычной терминологией. Дело в том, что структура, о которой пойдет речь в этом разделе, является ничем иным, как FAT - File Allocation Table, т.е. таблицей секторов, занимаемых файлом (вернее, занимаемых потоком или каким-либо другим объектом). А оригинальный термин "BBD - big blocks depot" может только ввести в заблуждение.</p>
<p>FAT - она и в Африке FAT. Это последовательный список 4-байтовых "строчек", каждая из которых соответствует одному сектору. Нулевая запись соответствует сектору с номером 0 (т.е. 512-байтовому сектору, начинающемуся в файле по абсолютному смещению 200h), первая - сектору с номером 1 (смещение 400h) и т.д. Еще раз напомним: сектора нумеруются с -1, т.е. самый первый сектор составного файла в этой таблице просто не упоминается!</p>
<p>Содержимое 4-байтовой строчки FAT может быть выбрано из следующих вариантов:</p>
<ul>
<li>-3 = 0FFFFFFFDh - признак специального сектора;</li>
<li>-2 = 0FFFFFFFEh - конец цепочки секторов;</li>
<li>-1 = 0FFFFFFFFh - неиспользуемый сектор;</li>
<li>иное &gt;0 - номер сектора, следующего за текущим.</li>
</ul>
<p>Если мы знаем номер стартового сектора для какого-либо объекта (например, для потока), мы легко можем вытянуть всю цепочку принадлежащих ему секторов. Вот конкретный пример, фрагмент дампа файла, содержащий начало FAT:</p>
<pre>
01 00 00 00 - 02 00 00 00 - 05 00 00 00 - 06 00 00 00
07 00 00 00 - 03 00 00 00 - FF FF FF FE - 08 00 00 00
FF FF FF FE - FF FF FF FD - FF FF FF FF - FF FF FF FF
</pre>
<p>Давайте выпишем значения "строчек" таблицы в более удобной для глаза форме и в скобочках каждой строчке припишем ее номер:</p>
<pre>
    (00) 01
    (01) 02
    (02) 05
    (03) 06
    (04) 07
    (05) 03
    (06) -2
    (07) 08
    (08) -2
    (09) -3
    (0A) -1
    (0B) -1
</pre>
<p>Допустим, известно, что стартовый сектор потока имеет значение 0, т.е. этот сектор заведомо уже принадлежит потоку. В нулевой строчке читаем: следующий сектор потока имеет номер 1. Переходим к строчке номер 1, и т.д., окончательно получаем цепочку номеров секторов: {0, 1, 2, 5, 3, 6}. Именно так, именно в таком порядке и разместил MS Word фрагменты какого-то потока внутри составного файла!</p>
<p>Кстати, обратите внимание на вклинившиеся куски какого-то другого объекта, живущего в секторах {4, 7, 8} и на пустые сектора с адресами 0A и 0B. Вероятно, это свидетельство того, что над документом долго и мучительно работали: многократно удаляли и вставляли фрагменты текста, рисунки, формулы и т.п.</p>
<p>Осталось выяснить, как же до этой FAT добраться. Смотрим на заголовок составного файла: по смещению 4Ch живет адрес стартового сектора в составном файле, а количество этих секторов живет по смещению 2Ch. Сектора располагаются непрерывно.</p>
<h3><a name="p32">3.2. FAT "Малых Блоков"</a></h3>
<p>Хранить множество малоразмерных объектов в 512-байтных секторах довольно нерационально. Поэтому в структуре составного файла предусмотрена возможность размещать данные в маленьких, 64-байтовых "блочках" (small blocks).</p>
<p>Идеология расположения 64-байтовых "блочков" мало отличается от рассмотренной нами в предыдущем разделе для 512- байтовых "больших блоков". Под них выделяются область составного файла, отдельные "блочки" в которой пронумерованы с 0.</p>
<p>Но область "блочков" носит подчиненный характер. Она описана в "главной" FAT как отдельный объект, под который отведена отдельная цепочка секторов. Для нее же существует отдельная FAT, которая тоже фактически представлена цепочкой 512-байтовых секторов в "главной" FAT.</p>
<p>Числа в строчках "маленькой" FAT соответствуют не абсолютным номерам 512-байтовых секторов, а относительным номерам 64-байтовых "блочков" внутри своей области.</p>
<p>Местоположение стартового сектора FAT "блочков" берется из заголовка составного файла (смещение 3Сh), остальные можно вытянуть по цепочке в "главной" FAT. Не хватает только информации о том, где брать стартовый сектор области, распределенной под "блочки", но речь об этом пойдет в следующем разделе.</p>
<p>Кстати, область "блочков" в файле может просто отсутствовать.</p>
<h3><a name="p33">3.3. Структура каталога</a></h3>
<p>Вопреки нашим предварительным предположениям, каталогов внутри составного файла не несколько, он - один единственный! Сей объект также представлен цепочкой секторов внутри "главной" FAT, а номер его стартового сектора можно найти в заголовке составного файла по смещению 30h.</p>
<p>Каталог состоит из 128-байтовых записей следующей структуры:</p>
<pre class="source">
struct DIR_ENTRY
    {
     BYTE ИмяОбъекта[64];      // +00  - имя объекта в UNICODE
     WORD РазмерИмени;         // +40h - фактическая длина имени
     BYTE ТипОбъекта;          // +42h - 1,2,3 или 5
     BYTE НеИспользуется1;     // +43h
     DWORD Предыдущий;         // +44h - предыдущий объект
     DWORD Следующий;          // +48h - следующий объект
     DWORD Первый;             // +4Сh - первый подчиненный
     DWORD НеИспользуется2[9]; // +50h
     DWORD СтартСектор;        // +74h - стартовый сектор объекта
     DWORD РазмерОбъекта;      // +78h - размер объекта в байтах
     DWORD НеИспользуется3;    // +7Сh
    };
</pre>
<p>Хотя записи в каталогах обычно называются термином "entry" (вхождение), разработчики OLE решили (IMHO, напрасно!) взглянуть на них с точки зрения объектного подхода и назвали их (а также те объекты, которые они описывают) словом "property" (свойство). Остается только сокрушенно покачать головой по этому поводу и продолжать называть вещи пусть и "нелегальными", но более понятными именами.</p>
<p>Имя объекта записывается латинскими буквами и хранится в формате UNICODE, т.е. для того, чтобы перевести его в удобочитаемую форму, потребуется собрать вместе все нечетные байты. Имейте в виду: самый первый символ имени может оказаться "нечитабельным" и иметь значение, например, 05h ("трефы") или 01h ("рожица"). Не пугайтесь, это так и должно быть. Фактическая длина имени хранится в записи по смещению 40h.</p>
<p>Тип объекта описан байтом, хранящимся по смещению 42h:</p>
<ul>
<li>1 - это подкаталог нижнего уровня;</li>
<li>2 - поток (т.е. набор каких-то данных);</li>
<li>3 - lock-bytes (?)</li>
<li>5 - корневой каталог.</li>
</ul>
<p>Местоположение объекта задается номером его стартового сектора (см. смещение 74h), под которым его и нужно искать в FAT. А фактическая длина объекта (например, потока) располагается по смещению 78h. Необходимо иметь в виду: если длина объекта &gt;= 1000h = 4096, то он располагается в больших 512- байтовых блоках (т.е. в секторах). В противном случае значение по адресу 74h указывает на стартовый "блочок" в области 64-байтовых "блочков". Сама эта область представлена в каталоге как "Root Entry", и искать ее следует в FAT больших блоков (даже если ее длина &lt;4096) - вот она, недостававшая нам в предыдущем разделе информация! </p>
<p>Три поля по смещениям 44h, 48h и 4Сh описывают отношения страшинства между объектами. Для каталогов и подкаталогов (но не для потков!) в поле "Первый" хранится номер записи для какого-то своего дочернего объекта, которые, в свою очередь, имеют своих "Следующих" и т. д. Таким образом, все записи в каталоге упорядочиваются в виде дерева.</p>
<p>Вот дамп одной из записей в каталоге:</p>
<pre>05 00 44 00-6F 00 63 00-75 00 6D 00-65 00 06 00 ..D.o.c.u.m.e.n
74 00 53 00-75 00 6D 00-6D 00 61 00-72 00 79 00 t.S.u.m.m.a.r.y
49 00 06 00-66 00 6F 00-72 00 6D 00-61 00 74 00 I.n.f.o.r.m.a.t
69 00 6F 00-6E 00 00 00-00 00 00 00-00 00 00 00 .i.o.n.........
38 00 02 01-02 00 00 00-04 00 00 00-FF FF FF FF 8..............
00 00 00 00-00 00 00 00-00 00 00 00-00 00 00 00 ...............
00 00 00 00-00 00 00 00-00 00 00 00-00 00 00 00 ...............
00 00 00 00-10 00 00 00-00 10 00 00-00 00 00 00 ...............
</pre>
<p>Легко видеть, что:</p>
<ul>
<li>имя объекта \5DocumentSummaryInformation;</li>
<li>длина имени 38h = 56 байтов;</li>
<li>тип объекта = 2, т.е. это поток;</li>
<li>предыдущий объект имеет номер = 2;</li>
<li>следующий объект имеет номер = 4;</li>
<li>стартовый сектор = 10h, т.е. файловая позиция = 2200h;</li>
<li>размер = 1000h = 4096 байтов, т.е. искать его надо в "больших блоках".</li>
</ul>
<p>А вот пример полного каталога:</p>
<pre class="source">
 # Имя                        Тип Пред След Перв Старт  Разм

 0 Root Entry                   5   -1   -1    3    24  1440
 1 \1Table                      2   -1   -1   -1     8  1000
 2 WordDocument                 2    5   -1   -1     0  1000
 3 \5SummaryInformation         2    2    4   -1    10  1000
 4 \5DocumentSummaryInformation 2   -1   -1   -1    18  1000
 5 Macros                       1    1    C    B     0     0
 6 VBA                          1   -1   -1    7     0     0
 7 ThisDocument                 2    9    8   -1     0   44D
 8 _VBA_PROJECT                 2   -1   -1   -1    12   AA5
 9 dir                          2   -1   -1   -1    3D   2A3
 A PROJECTwm                    2   -1   -1   -1    48    29
 B PROJECT                      2    6    A   -1    49   151
 C \1CompObj                    2   -1    D   -1    4F    6A
 D ObjectPool                   1   -1   -1   -1     0     0
</pre>
<p>Попробуем выполнить упорядочивание. Начнем с узла "0" ("Root Entry"), его первым "сыном" является узел "3". Собрав воедино все узлы, связанные с узлом "0" и между собой, получим следующее множество: {1, 2, 3, 4, 5, С, D}. Оно образует первый уровень дерева.</p>
<p>На первом уровне присутствуют три объекта со статусом каталогов: "5" и "D". Дочерними объектами каталога "5" являются узел "B" и все связанные с ним объекты: {A, B, 6}. Каталог "D" не имеет дочерних объектов, т.е. он пуст. И так далее...</p>
<p>Можно написать несложный рекурсивный алгоритм, который построит желаемое дерево:</p>
<div align="center"><img src="img/akk02/docfmt.gif" alt="Дерево"/></div>
<p>Итак, с составным файлом можно работать не только через OLE API, но и напрямую - например, из DOS-овской программы.</p>
<p>Данный раздел является существенно упорядоченным и несколько дополненным изложением статьи <i> M. Schwartz. LAOLA file system</i>. Единственный известный мне перевод этой статьи на русский язык можно найти, например, в материалах 4 -го выпуска электронного журнала "<a href="http://www.karimov.ru/zf/zf4.zip">Земский Фершал</a>".</p>
<h2><a name="p4">4. Структура документа MS WORD</a></h2>
<div align="right">
-... Он съедал десять тарелок супу... <br/>
- А на второе, - пятнадцать отбивных котлет... <br/>
- И, наконец,... двадцать компотов!... <br/>
- А потом этот человек подвязывал салфетку <br/>
на грудь и говорил: "Ну, кажется, я <br/>
заморил червячка, теперь, пожалуй, можно <br/>
приступить к настоящему обеду! <br/>
Ларри Я.Л. Необыкновенные приключения Карика и Вали
</div>
<p>Итак, мы подробно изучили с разных сторон множество действительно интересных вопросов, но... Следует признать, что основную тему статьи мы пока не раскрыли. В ближайшее же время попытаемся исправиться.</p>
<p>В Интернете можно найти немало ссылок на фирменные материалы "Microsoft Word 6.0 Binary File Format" и "Microsoft Word 97 Binary File Format", которые представляют собой огромные файлы, заполненные большим количеством малопонятных терминов, таблиц, списков и пр. Но название не совсем точно отражает действительность: на самом деле эти материалы описывают всего лишь структуру потока под названием "WordDocument". Продемонстрируем, что ничего совсем уж иррационального и трансцендентного в фирменной документации от Micrisoft нет.</p>
<p>Итак, поток "WordDocument" (в документации он называется "главным потоком" - main stream) начинается со своего собственного внутреннего заголовка, в котором мы упомянем всего несколько наиболее интересных для нас полей:</p>
<pre class="source">
Смещение  Длина   Назначение       Примечание
-----------------------------------------------
       0h     2   Сигнатура        Word6/Word97
       2h     2   Код версии       Word6/Word97
      18h     4   Начало текста    Word6/Word97
      1Ch     4   Конец текста+1   Word6/Word97
      34h     4   Длина текста+1   Word6
      4Ch     4   Длина текста+1   Word97
</pre>
<p>Для документов, созданных в Word v6.0/7.0 или WordPad, сигнатура обычно равна 0A5DCh, а для Word97/2K/XP она равна 0A5ECh (все это верно по крайней мере для русских версий).</p>
<p>Если документ создан в MS WinWord, то текст обычно начинается по "круглым" смещениям (например, 200h или 300h), для прочих продуктов это не всегда выполняется (например, WordPad может разместить его по "треугольному" смещению 312h).</p>
<p>Текст для формата версий 6.0/7.0 представляет собой обычную последовательность однобайтовых символов в той или иной кодировке, а для более старших версий - в двухбайтовой кодировке UNICODE:</p>
<pre class="source">
Символ  Кодировка
-----------------
   0-9  030h-039h
   A-Z  041h-05Ah
   a-z  061h-07Ah
   А-Я  410h-42Fh
     Ё  401h
   а-я  430h-44Fh
     ё  451h
</pre>
<p>Этой информации вполне достаточно, чтобы, например, извлечь из Word-документа текст. Производить обратную операцию несколько сложнее - для этого придется параллельно формировать таблицы описания свойств символов и абзацев.</p>
<h3>Ссылки:</h3>
<ol>
<li><a href="http://www.codemanual.net/main/file_formats/files/wword60.zip">Microsoft Word for Windows 6.0 Binary File Format. Updated structures and sprm table for Windows Word 6.0 format;</a></li>
<li><a href="http://www.codemanual.net/main/file_formats/files/wword60t.zip">Microsoft Word for Windows 6.0 Binary File Format 09/03/94;</a></li>
<li><a href="http://www.codemanual.net/main/file_formats/files/word8.zip">Microsoft Word 97 Binary File Format For Windows and Macintosh. Last Revised July, 1997. 1998 Microsoft Corporation;</a></li>
<li><a href="http://www.codemanual.net/main/file_formats/files/wword8.zip">Microsoft Word 97 (aka Version 8) Binary File Format. Revised Aug 1 1998;</a></li>
</ol>
<h2><a name="p5">Заключение</a></h2>
<div align="right">
В этой статье для меня все ясно, за <br/>
исключением упоминаний о сепульках, <br/>
трансме и хмепе. Увы, последний вышедший в <br/>
свет том энциклопедии кончался статьей <br/>
"Соус грибной", значит, ни о трансме, ни о <br/>
хмепе ничего нет. <br/>
С. Лем. Звездные дневники Ийона Тихого. Путешествие четырандцатое.
</div>
<p>Конечно, в статье рассмотрено далеко не все, что хотелось бы. И не всему вышенаписанному стоит беспрекословно доверять: например, весьма вероятно, что в случае огромных DOC-файлов структурированное хранилище может быть образовано из "секторов" с размерами большими, чем 512 байтов. Но теперь любознательный читатель может не только проверить информацию, но и продолжить собственные иследования двоичного формата документов WinWord.</p>
<p>Кому-то может показаться излишним приведенное выше подробное описание формата структурированных хранилищ. Но мне, например, оно сильно пригодилась, когда необходимо было вытаскивать текст из DOC-файлов, записанных на поцарапанную дискету. Функции OLE2 API в этой ситуации просто отказывались работать.</p>
<p>Кроме того, знание подробностей организации этого формата позволяет существенно ускорить работу с составным файлом: можно, например, напрямую искать в файле заголовочные сигнатуры отдельных компонентов (главного потока, вирусных макросов и т.п.) по смещениям, кратным 512.</p>
<p>Возможны и иные применения для информации, приведенной в этой статье. Желаю успехов!</p>
<h2><a name="p6">Дополнение от зимы 2004 года</a></h2>
<p>После обнародования предыдущей версии этой статьи мне пришлось выслушать немало критики за ее неполноту, наличие многочисленых неточностей, и даже за то, что я дерзнул написать ее поперед тех "батьков", кто знает на эту тему гораздо больше, но шибко дорожит своей монополией на информацию.</p>
<p>К счастью, большинство читателей восприняли ту статью благожелательно. А правильней всех поступил С. Новодворский, который очень удачно углубил рассмотренную тему в своей собственной статье "<a href="http://www.klerk.ru/soft/1c/?2429">Доступ к MD-файлам при помощи VBA</a>", попутно исправив самые крупные мои неточности и дописав иллюстрирующий софт. Спасибо, Сергей, и так держать!</p>
<p>Итак, самая крупная неточность в моей статье касалась формата заголовка структурированного хранилища. Часть полей я тогда намеренно не описал (посчитав не важными), одно поле описал ошибочно, а о назначении некоторых полей в то время лишь смутно догадывался. Теперь я имею возможность привести новый, уточненный формат заголовка структурированного хранилища:</p>
<pre class="source">
struct DOC_FILE_HEADER
{
 DWORD Сигнатура;       // +00h - "магическое" число E011CFD0h
 DWORD КодВерсииOLE;    // +04h - "магическое" число E11AB1A2h
 DWORD НеИспользуется;  // +08h
 WORD  НеИспользуется;  // +0Ch
 WORD  РазмерСектора;   // +0Eh - Log2(512)=9  <strong>(new!)</strong>
 DWORD НеИспользуется;  // +10h
 DWORD НеИспользуется;  // +14h
 WORD  НомерРевизии;    // +18h - ? <strong>(new!)</strong>
 WORD  НомерВерсии;     // +1Ah - ? <strong>(new!)</strong>
 DWORD НеИспользуется;  // +1Ch
 DWORD НеИспользуется;  // +20h
 DWORD НеИспользуется;  // +24h
 DWORD НеИспользуется;  // +28h
 DWORD РазмерBBD;       // +2Сh - количество секторов в BBD
 DWORD НачалоКаталога;  // +30h - стартовый сектор каталога
 DWORD НеИспользуется;  // +34h
 DWORD НеИспользуется;  // +38h
 DWORD НачалоSBD;       // +3Сh - стартовый сектор SBD
 DWORD ПродолжениеSBD;  // +40h - ? <strong>(new!)</strong>
 DWORD ОкончаниеBBD;    // +44h - стартовый сектор окончания BBD <strong>(new!)</strong>
 DWORD НеИспользуется;  // +48h
 DWORD НачалоBBD;       // +4Сh - стартовый сектор BBD
 DWORD ПродолжениеBBD[108];	// +50h - адреса секторов продолжения BBD <strong>(new!)</strong>
};
</pre>
<p>Комментарии.</p>
<ol>
<li>Знаком "?" помечены поля, в назначении которых я не уверен.</li>
<li>С адреса 50h начинается массив DWORD-ов, каждый из которых непосредственно адресует очередной сектор FAT больших блоков. Поля по смещениям 40h и 50h дают возможность иметь длинные FAT. </li>
<li>Говорят, что MS Word, начиная с версии 2000 умеет <b>ЧИТАТЬ</b> документы с секторами длиной &gt;512 (например, 4096), но все равно не умеет их <b>СОЗДАВАТЬ</b>. </li>
<li>Убедитесь, насколько все у Microsoft запущено!</li>
</ol>
<p>Не исключено, что и это еще не конец...</p>
<h3>* * *</h3>
<p>Выражаю благодарность Андрею Каримову, участнику проекта "Антивирус Stop!", в беседах с которым эта статья появилась на свет. Также ряд ценных критических замечаний сделал сотрудник "Лаборатории Касперского" Андрей Крюков.</p>
<p>Благодарю за внимание. С глубочайшим почтением и искреннейшей преданностию есмь, милостивые государи, Ваш покорный слуга</p>
[<a style="" href="/lib/?lang=RU&amp;index=MA#akk02">Вернуться к списку</a>] [<a href="/lib/akk02.html#disqus_thread">Комментарии</a>]<br/> <div id="disqus_thread"></div>
<script type="text/rocketscript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'vxheaven'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="/agreement.php">Terms of Use</a>!</small> <small>vxheaven.org aka vx.netlux.org</small></div>
<div style="margin-top: 2px; float: left;" class="adsapeu">
<script type="text/rocketscript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script>
</div>
<script data-rocketsrc="http://www.google-analytics.com/urchin.js" type="text/rocketscript"></script><script type="text/rocketscript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="/lib/index.php?lang=de&amp;id=akk02">de</a><a href="/lib/index.php?lang=en&amp;id=akk02">en</a><a href="/lib/index.php?lang=es&amp;id=akk02">es</a><a href="/lib/index.php?lang=it&amp;id=akk02">it</a><a href="/lib/index.php?lang=fr&amp;id=akk02">fr</a><a href="/lib/index.php?lang=pl&amp;id=akk02">pl</a><a href="/lib/index.php?lang=ru&amp;id=akk02">ru</a><a href="/lib/index.php?lang=ua&amp;id=akk02">ua</a></div>
</body>
</html>
