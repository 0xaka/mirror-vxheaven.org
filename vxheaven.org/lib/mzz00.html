<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Zhihong Zuo, Mingtian Zhou 'Some Further Theoretical Results about Computer Viruses' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Author" content="Zhihong Zuo, Mingtian Zhou"/>
<meta name="KeyWords" lang="en" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, Zuo, Zhihong; Zhou, Mingtian,Some Further Theoretical Results about Computer Viruses, computer, mathbf, dots, virus, viruses, text, system, rightarrow, rangle, langle, kinds, definitions, polymorphic, align, called"/>
<meta name="Description" content="In this paper we give some general definitions of computer viruses which comply with our common understanding of computer viruses. Based on these definitions, we prove theoretically that there may exist some special kinds of computer viruses that have not been found in the real world yet. Furthermore, we prove that the set of computer viruses with the same kernel is &amp;prod;2-complete. In general the set of computer viruses is &amp;Sigma;3-complete."/>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"047a5bcbf67431883fc9ed25fba33612",petok:"d6ea6a0cc6ebc38b693f5174706babea6df9d02b-1498757155-1800",zone:"vxheaven.org",rocket:"a",apps:{}}];document.write('<script type="text/javascript" src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=85b614c0f6/cloudflare.min.js"><'+'\/script>');}}catch(e){};
//]]>
</script>
<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="/style.css"/><link rel="canonical" href="http://vxheaven.org/lib/mzz00.html"/>
<script type="text/rocketscript" data-rocketsrc="https://apis.google.com/js/plusone.js">{"parsetags": "explicit"}</script>
</head>
<body bgcolor="#dbc8a0" text="#302000" link="#225599" vlink="#113366">
<div class="s1">
<div style="float:right;"><a href="/lib/index.php?tbs=1"><img src="/img/max.gif" alt="Maximize"/></a></div> <form id="lf" style="margin: 0; float: right;" method="get" action="/index.php"><input type="hidden" name="action" value="set"/><select name="lang" onchange="javascript:document.getElementById('lf').submit();"><option value="ru">Русский</option><option selected="selected" value="en">English</option><option value="ua">Українська</option><option value="de">Deutsch</option><option value="es">Español</option><option value="fr">Fran&ccedil;ais</option><option value="it">Italiano</option><option value="pl">Polski</option></select></form>
<div style="float: right;"><div id="plusone"></div></div>
<script type="text/rocketscript">gapi.plusone.render("plusone", {"size":"small","count":"true"});</script>
<div style="float: right;" class="addthis_toolbox addthis_default_style">
<script type="text/rocketscript">var addthis_config = { ui_click: true }</script>
<a style="text-decoration: none; font-size: 10pt;" href="/?action=addthis" class="addthis_button_compact">Bookmark</a>
<script type="text/rocketscript" data-rocketsrc="http://s7.addthis.com/js/250/addthis_widget.js#username=herm1t"></script>
</div>
<div style="float: right;">
<script type="text/rocketscript" data-rocketsrc="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<form action="/search.php" id="cse-search-box">
<input type="hidden" name="cx" value="002577580816726040001:z9_irkorydo"/>
<input type="hidden" name="cof" value="FORID:10"/>
<input type="hidden" name="ie" value="UTF-8"/>
<input type="text" name="q" size="12" value=" "/>
<input type="submit" name="sa" value="Search"/>
</form>
</div><h1><a href="/" style="text-decoration: none; color: #000000;">VX Heaven</a></h1>
<span class="nav"><a href="/lib/">Library</a> <a href="/vl.php">Collection</a> <a href="/src.php">Sources</a> <a href="/vx.php?id=eidx">Engines</a> <a href="/vx.php?id=tidx">Constructors</a> <a href="/vx.php?id=sidx">Simulators</a> <a href="/vx.php?id=uidx">Utilities</a> <a href="/links.php">Links</a> <a href="/donate.php" style="color: #706020" id="donate">Donate</a> <a href="/forum" style="text-decoration: underline;">Forum</a> </span><br clear="all"/>
</div>
<div class="s2"><h1>Some Further Theoretical Results about Computer Viruses</h1><p><a href="/lib/?lang=en&amp;author=Zuo%2C%20Zhihong">Zhihong Zuo</a>, <a href="/lib/?lang=en&amp;author=Zhou%2C%20Mingtian">Mingtian Zhou</a><br/> <em>The Computer Journal, Vol. 47, No. 6</em><br/> <em>ISSN 0010-4620</em><br/> <em> 2004</em></p><script type="text/rocketscript">var disqus_url = 'http://vxheaven.org/lib/mzz00.html';</script><div class="ci"><a href="/lib/?ci=mzz00">3</a></div><img src="/img/pdf.gif" alt="PDF"/><a href="/lib/pdf/Some%20Further%20Theoretical%20Results%20about%20Computer%20Viruses.pdf">Download</a> PDF (1.63Mb) (You need to be registered on <a href="/forum">forum</a>)<br/>[<a style="" href="/lib/?lang=EN&amp;index=TH#mzz00">Back to index</a>] [<a href="/lib/mzz00.html#disqus_thread">Comments</a>]<br/> <form method="post" action="">
<img src="/img/cache/0b9fd596a90421f9f1f68a9760275737.gif" alt="\text{T_EX size}" valign="middle"/>
<select name="TeX_size"><option value="-2">-2</option><option value="-1">-1</option><option value="0" selected="selected">0</option><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option> </select>
<input type="submit" value="Scale"/>
</form><form method="post" action=""><input type="hidden" name="pages" value="1"/><input type="submit" value="Turn on page numbers"/></form>
<p><em>&copy; The British Computer Society; all rights reserved</em></p>
<address>
School of Computer Science and Engineering,<br/>
University of Electronic Science and Technology of China,<br/>
Chengdu, P.R. China<br/>
Email: <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="bfc5d7c5cad0ff8d898c91d1dacb">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>
</address>
<ul>
<li><a href="#c1">1. Introduction</a></li>
<li><a href="#c2">2. Preliminaries</a></li>
<li><a href="#c3">3. Definitions of some kinds of computer viruses</a></li>
<li><a href="#c4">4. Some theorems about computer viruses</a></li>
<li><a href="#c5">5. Discussion</a></li>
<li><a href="#c6">Acknowledgements</a></li>
<li><a href="#c7">References</a></li>
</ul>
<p><strong>In this paper we give some general definitions of computer viruses which comply with our common understanding of computer viruses. Based on these definitions, we prove theoretically that there may exist some special kinds of computer viruses that have not been found in the real world yet. Furthermore, we prove that the set of computer viruses with the same kernel is &prod; <sub>2</sub>-complete. In general the set of computer viruses is &Sigma; <sub>3</sub>-complete.</strong></p>
<h2><a name="c1"></a>1. Introduction</h2>
<p>The first abstract theory of computer viruses is the viral set theory given by Cohen, based on the Turing machine [1, 2]. A viral set is defined by <img src="/img/cache/a68d675c477064e9adccbffee0fef3a2.gif" alt="(M, V)" valign="middle"/> where <img src="/img/cache/69691c7bdcc3ce6d5d8a1361f22d04ac.gif" alt="M" valign="middle"/> is a Turing machine and <img src="/img/cache/5206560a306a2e085a437fd258eb57ce.gif" alt="V" valign="middle"/> is a non-empty set of programs on Turing machine. Each <img src="/img/cache/489f07bffe8b7e18a6112f5022b09410.gif" alt="v \in V" valign="middle"/> is called a computer virus and satisfies the following condition: if it is contained in the tape at time <img src="/img/cache/e358efa489f58062f10dd7316b65649e.gif" alt="t" valign="middle"/>, then there exist a time <img src="/img/cache/3b11da5ab8568206a5e1184fbf7f2005.gif" alt="t'" valign="middle"/> and a <img src="/img/cache/68c0403d08fefde2fd7c9c6a680e79dd.gif" alt="v' \in V" valign="middle"/> such that <img src="/img/cache/b3afdc4dc7644ad636e084509b04ddab.gif" alt="v'" valign="middle"/> is contained in the tape at time <img src="/img/cache/3b11da5ab8568206a5e1184fbf7f2005.gif" alt="t'" valign="middle"/>. The most important of Cohen's theorems is about the undecidability of computer viruses [1].</p>
<p>In a different approach, Adleman developed an abstract theory of computer viruses based on recursive functions [3]. In his definition a virus is a total recursive function <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> which applies to all programs <img src="/img/cache/865c0c0b4ab0e063e5caa3387c1a8741.gif" alt="i" valign="middle"/> (the G&ouml;del numberings of programs), such that <img src="/img/cache/add8d046f17a44fba3f6407e6c8294e7.gif" alt="v(i)" valign="middle"/> has some characteristic behaviors of computer viruses like injury, infection and imitation. Furthermore, Adleman proved that the set of computer viruses is <img src="/img/cache/c092b7daa73baafd26c210aec4174dcc.gif" alt="\prod{}_2" valign="middle"/>-complete [3].</p>
<p>In the past 10 years, the number and variety of computer viruses have greatly increased, and many of them may not be conveniently and directly described by Cohen's or Adleman's theory. For example, we can list resident viruses, polymorphic viruses, stealthy viruses and so on. Hence some other models and theories of computer viruses have been established [4]. But these models do not comply with the common understanding of computer viruses.</p>
<p>The structure of this paper is as follows: the next section introduces preliminaries and recursive-function-based definitions for several kinds of computer viruses are presented in Section 3. In Section 4, we derive some important results about computer viruses based on the definitions. In the last section, we discuss the limitations of our work and give some comments and suggestions for further research.</p>
<h2><a name="c2"></a>2. Preliminaries</h2>
<p>We briefly present here basic notation used in this paper.</p>
<p>Let <img src="/img/cache/8d9c307cb7f3c4a32822a51922d1ceaa.gif" alt="N" valign="middle"/> be the set of all natural numbers and <img src="/img/cache/5dbc98dcc983a70728bd082d1a47546e.gif" alt="S" valign="middle"/> be the set of all finite sequences of natural numbers. For every <img src="/img/cache/cff496013eaed9693f268f95d9d42b4f.gif" alt="s_1,s_2,\dots,s_n \in S" valign="middle"/>, <img src="/img/cache/4c679480082e6ca783c8066e62db07a6.gif" alt="\langle s_1,s_2,\dots,s_n \rangle" valign="middle"/> denotes a computable injective function from <img src="/img/cache/f74115260830faf5178589e98c061a4e.gif" alt="S^n" valign="middle"/> to <img src="/img/cache/8d9c307cb7f3c4a32822a51922d1ceaa.gif" alt="N" valign="middle"/> with computable inverse. If <img src="/img/cache/8fa14cdd754f91cc6554c9e71929cce7.gif" alt="f" valign="middle"/> is a partial function <img src="/img/cache/5bac712ea859167a5e1630403d07bea7.gif" alt="f: N \rightarrow N" valign="middle"/>, then for <img src="/img/cache/cff496013eaed9693f268f95d9d42b4f.gif" alt="s_1,s_2,\dots,s_n \in S" valign="middle"/>, <img src="/img/cache/4ab1c83022b75a52471afd60106ec9ab.gif" alt="f(s_1,s_2,\dots,s_n)" valign="middle"/> denotes <img src="/img/cache/14435cd27c98dc55d355131d0089b0b4.gif" alt="f(\langle s_1,s_2,\dots,s_n \rangle)" valign="middle"/>. Similarly, for every <img src="/img/cache/fe10735dd5b54ff98fdee96ab3e5ab43.gif" alt="i_1,i_2,\dots,i_n \in N" valign="middle"/>, <img src="/img/cache/29b094dfd111b727ee1a8f65f880e0e8.gif" alt="\langle i_1,i_2,\dots,i_n\rangle" valign="middle"/> denotes a computable injective function from <img src="/img/cache/0e0bd2c8e68af9a3b617b79a9f082157.gif" alt="N^n" valign="middle"/> to <img src="/img/cache/8d9c307cb7f3c4a32822a51922d1ceaa.gif" alt="N" valign="middle"/> with computable inverse such that <img src="/img/cache/28bb4f5f39af0b3c60685c66831d1ae6.gif" alt="\langle i, j\rangle \ge i" valign="middle"/> and <img src="/img/cache/00c6c293cb2e69f1c3b6eab5c0cc6c41.gif" alt="f(i_1,i_2,\dots,i_n)" valign="middle"/> means <img src="/img/cache/20bb3b7cb47aed52477b70d1e13dfc00.gif" alt="f(\langle i_1,i_2,\dots,i_n\rangle)" valign="middle"/> for partial function <img src="/img/cache/0533ac7ff7ddc0ca86356234b3b69dfb.gif" alt="f: N^n \rightarrow N" valign="middle"/>. Furthermore, we write <img src="/img/cache/012ceb827f14572dac3e93d888dc4fc7.gif" alt="f(i_1,i_2,\dots,i_n)\downarrow" valign="middle"/> when <img src="/img/cache/00c6c293cb2e69f1c3b6eab5c0cc6c41.gif" alt="f(i_1,i_2,\dots,i_n)" valign="middle"/> is defined and <img src="/img/cache/b87535bd0fc6b617afc8940cacfa193e.gif" alt="f(i_1,i_2,\dots,i_n)\uparrow" valign="middle"/> when <img src="/img/cache/00c6c293cb2e69f1c3b6eab5c0cc6c41.gif" alt="f(i_1,i_2,\dots,i_n)" valign="middle"/> is undefined.</p>
<p>For a sequence <img src="/img/cache/77fa14a408e7d6d75c76c84006a21099.gif" alt="p = (i_1,i_2,\dots,i_k,\dots,i_n) \in S" valign="middle"/>, we use <img src="/img/cache/066d57739b0e7cde961a462c79a09dde.gif" alt="p[j_k / i_k]" valign="middle"/> to denote the sequence which is the same as <img src="/img/cache/83878c91171338902e0fe0fb97a8c47a.gif" alt="p" valign="middle"/> except that <img src="/img/cache/f0807c8c623bbafb36dbdb9e24cdfc4d.gif" alt="i_k" valign="middle"/> replaced by <img src="/img/cache/a1cba1f93521e19e4c6b36a35c5959cc.gif" alt="j_k" valign="middle"/>, i.e. <img src="/img/cache/ba353081a8c5cabfd3630f4a8720d1d3.gif" alt="p[j_k / i_k] = (i_1,i_2,\dots,j_k,\dots,i_n)" valign="middle"/>. If the element <img src="/img/cache/f0807c8c623bbafb36dbdb9e24cdfc4d.gif" alt="i_k" valign="middle"/> in sequence <img src="/img/cache/83878c91171338902e0fe0fb97a8c47a.gif" alt="p" valign="middle"/> is operated by a computable function <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/>, namely <img src="/img/cache/5c7fdbc1cc3b3e3593f6937902ff8d6d.gif" alt="p[v(i_k)/i_k]" valign="middle"/>, for conciseness of notation, it will always be written in this paper as <img src="/img/cache/54cc5e04ec19a1e8aa695bc844d97a55.gif" alt="p[v(\underline{i_k})]" valign="middle"/> where the underlined symbol denotes the element being operated. If there are more than one element in <img src="/img/cache/83878c91171338902e0fe0fb97a8c47a.gif" alt="p" valign="middle"/> that have been replaced by other values or operated by computable functions, we write them as <img src="/img/cache/1cc039cd56979e84ef533caa9c69eebd.gif" alt="p[j_{k_1}/i_{k_1},j_{k_2}/i_{k_2},\dots,j_{k_l}/i_{k_l}]" valign="middle"/> or <img src="/img/cache/a75624d65b3806bc692738d6319a2953.gif" alt="p[v_1(\underline{i_{k_1}}),v_2(\underline{i_{k_2}}),\dots,v_l(\underline{i_{k_l}})]" valign="middle"/>, respectively.</p>
<p>The symbol <img src="/img/cache/7db4d8d77961ae04ad43de0cdc0a24a2.gif" alt="\phi_P(d, p)" valign="middle"/> denotes a function computed by a computer program <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/> with the running environment <img src="/img/cache/e9bd8422573abf98550035828bcd91f6.gif" alt="(d, p)" valign="middle"/> where <img src="/img/cache/8277e0910d750195b448797616e091ad.gif" alt="d" valign="middle"/> and <img src="/img/cache/83878c91171338902e0fe0fb97a8c47a.gif" alt="p" valign="middle"/> mean data (including clock, spaces of diskettes and so on) and programs (including operating systems), respectively. If the G&ouml;del numbering of <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle"/> is <img src="/img/cache/e1671797c52e15f763380b45e841ec32.gif" alt="e" valign="middle"/>, the function is commonly written as <img src="/img/cache/3740a1ba03a661f77da99a6604f007dc.gif" alt="\phi_e(d, p)" valign="middle"/>. Its domain and range are written as <img src="/img/cache/534a2fde5e31a892dc035f6f50282d30.gif" alt="W_e" valign="middle"/> and <img src="/img/cache/15c12465c0c4ff1ec7413404cbf6ce34.gif" alt="E_e" valign="middle"/>, respectively.</p>
<p><em>S-m-n</em> theorem, universal theorem and recursion theorem [5] are the main tools used in our development of the abstract theory of computer viruses.</p>
 
<h2><a name="c3"></a>3. Definitions of some kinds of computer viruses</h2>
<p>In this section, we give definitions of some kinds of computer viruses, including not only some common kinds of computer viruses, e.g. non-resident viruses and resident viruses, but also some special kinds of computer viruses, e.g. polymorphic viruses with infinite forms which have not been found till now in the real world.</p>
<p><strong>Definition 3.1.</strong> (Non-resident virus) <em>A total recursive function <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> is called a non-resident virus if for all <img src="/img/cache/865c0c0b4ab0e063e5caa3387c1a8741.gif" alt="i" valign="middle"/>,</em></p>
<ol type="a">
<li><img src="/img/cache/d9edbccccdd90af3f2eb69791764d811.gif" alt="\phi_{v(i)}(d, p) = \{
	\begin{align}
		&amp;&amp; D(d,p),				&amp;&amp;&amp; \text{if }T(d, p)	&amp;&amp;&amp; (i)\\
		&amp;&amp; \phi_i(d, p[v(\underline{S(p)})]),	&amp;&amp;&amp; \text{if }I(d, p)	&amp;&amp;&amp; (ii)\\
		&amp;&amp; \phi_i(d, p),			&amp;&amp;&amp; \text{otherwise}	&amp;&amp;&amp; (iii)
	\end{align}" valign="middle"/></li>
<li><em><img src="/img/cache/73935fb4b5311cef1414a3954cf6c0c5.gif" alt="T(d, p)" valign="middle"/> and <img src="/img/cache/5354f3368b049ed7a919de8181ca462e.gif" alt="I(d, p)" valign="middle"/> are two recursive
predicates and no <img src="/img/cache/3e2df3a66619ac333bb68436a7867cbe.gif" alt="\langle d, p\rangle" valign="middle"/> satisfies them
simultaneously; <img src="/img/cache/1d1e4261a7ac80044ab2ff3245548fb4.gif" alt="D(d, p)" valign="middle"/> and <img src="/img/cache/be81fe0f3d9275a189495781bf2f49b8.gif" alt="S(p)" valign="middle"/> are two
recursive functions;</em></li>
<li><em>the set <img src="/img/cache/09a78ce6714c36b863ea31fcf46407d2.gif" alt="\{\langle d, p \rangle : \neg(T(d, p) \vee I(d, p))\}" valign="middle"/>
is an infinite set.</em></li>
</ol>
<p>The two predicates, <img src="/img/cache/73935fb4b5311cef1414a3954cf6c0c5.gif" alt="T(d, p)" valign="middle"/> and <img src="/img/cache/5354f3368b049ed7a919de8181ca462e.gif" alt="I(d, p)" valign="middle"/>, are called injury condition (trigger) and infection condition, respectively. When condition <img src="/img/cache/73935fb4b5311cef1414a3954cf6c0c5.gif" alt="T(d, p)" valign="middle"/> is satisfied, the virus executes the injury function <img src="/img/cache/1d1e4261a7ac80044ab2ff3245548fb4.gif" alt="D(d, p)" valign="middle"/>, and when condition <img src="/img/cache/5354f3368b049ed7a919de8181ca462e.gif" alt="I(d, p)" valign="middle"/> is met, the virus chooses a program using the selection function <img src="/img/cache/be81fe0f3d9275a189495781bf2f49b8.gif" alt="S(p)" valign="middle"/>, infects it first, and then executes the original program. These two conditions and two functions, called the kernel of a non-resident virus, determine a non-resident virus uniquely. In what follows, unless stated otherwise, the kernel of a computer virus always denotes the set of mathematical objects (functions and predicates) which theoretically determine a computer virus uniquely.</p>
<p>In clause (a) of the above definition, three branches (i), (ii) and (iii) describe three typical behaviors of computer viruses, injury, infection and imitation, respectively.</p>
<p>In the following definitions of other kinds of computer viruses, we no longer list (b) and (c) as in the definition above, and always regard them as satisfied by each kind of computer virus. It should be noted that the kernels of different kinds of computer viruses are different in general.</p>
<p><strong>Definition 3.2.</strong> (Resident virus) <em>The pair <img src="/img/cache/a8409dad1719c099a14bb0c7dfac71fe.gif" alt="(v, \mathbf{sys})" valign="middle"/> of a total recursive function <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> and a system call <img src="/img/cache/e12fff89833df6aab15e1e0e0a223e3d.gif" alt="\mathbf{sys}" valign="middle"/> (also a recursive function) is called a resident virus with respect to the system call <img src="/img/cache/e12fff89833df6aab15e1e0e0a223e3d.gif" alt="\mathbf{sys}" valign="middle"/> if for all <img src="/img/cache/865c0c0b4ab0e063e5caa3387c1a8741.gif" alt="i" valign="middle"/>,</em></p>
<img src="/img/cache/fad9197992242cc822dc0d58ecfa640d.gif" alt="
	\begin{eqnarray}
	&amp;&amp; \phi_{v(i)}(d, p) &amp;=&amp; \{
		\begin{align}
			&amp;&amp; D(d, p),					&amp;&amp;&amp; \text{if }T(d, p)\\
			&amp;&amp; \phi_i(d, p[v(\underline{\mathbf{sys}})]),	&amp;&amp;&amp; \text{if }I(d, p)\\
			&amp;&amp; \phi_i(d, p),				&amp;&amp;&amp; \text{otherwise}
		\end{align}
	\\
	&amp;and&amp; \\
	&amp;&amp; \phi_{v(\mathbf{sys})}(d, p) &amp;=&amp; \{
		\begin{align}
			&amp;&amp; D'(d, p),						&amp;&amp;&amp; \text{if }T'(d, p)\\
			&amp;&amp; \phi_{\mathbf{sys}}(d, p[v(\underline{S(p))}]),	&amp;&amp;&amp; \text{if }I'(d, p)\\
			&amp;&amp; \phi_{\mathbf{sys}}(d, p),				&amp;&amp;&amp; \text{otherwise}
		\end{align}
	\end{eqnarray}
" valign="middle"/>
<p>Resident viruses always employ some system calls or endless execution processes (e.g. under Unix) to reside in the memory and modify some system calls (or some user processes) by which they infect other programs. For example, resident viruses in the DOS environment often modify system calls such as int 21h and int 13h to reach their objects.</p>
<p><strong>Definition 3.3.</strong> (polymorphic virus with two forms) <em>The pair <img src="/img/cache/f2d15124e5d0820e6547bc1aab8f3c24.gif" alt="(v, v')" valign="middle"/> of two different total recursive functions <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> and <img src="/img/cache/b3afdc4dc7644ad636e084509b04ddab.gif" alt="v'" valign="middle"/> is called a polymorphic virus with two forms if for all <img src="/img/cache/865c0c0b4ab0e063e5caa3387c1a8741.gif" alt="i" valign="middle"/>,</em></p>
<img src="/img/cache/61034a0b1d6a71e58690a2ac19129ffa.gif" alt="
	\begin{eqnarray}
	&amp;&amp; \phi_{v(i)}(d, p) &amp;=&amp; \{
		\begin{align}
			&amp;&amp; D(d, p),				&amp;&amp;&amp; \text{if }T(d, p)\\
			&amp;&amp; \phi_i(d, p[v'(\underline{S(p)})]),	&amp;&amp;&amp; \text{if }I(d, p)\\
			&amp;&amp; \phi_i(d, p),			&amp;&amp;&amp; \text{otherwise}
		\end{align}
	\\
	&amp;and&amp; \\
	&amp;&amp; \phi_{v'(i)}(d, p) &amp;=&amp; \{
		\begin{align}
			&amp;&amp; D(d, p),				&amp;&amp;&amp; \text{if }T(d, p)\\
			&amp;&amp; \phi_i(d, p[v(\underline{S(p))}]),	&amp;&amp;&amp; \text{if }I(d, p)\\
			&amp;&amp; \phi_i(d, p),			&amp;&amp;&amp; \text{otherwise}
		\end{align}
	\end{eqnarray}
" valign="middle"/>
<p>Polymorphic viruses with <img src="/img/cache/7b8b965ad4bca0e41ab51de7b31363a1.gif" alt="n" valign="middle"/> forms can be defined as sequences <img src="/img/cache/3c2c90d0ffcd5b84908fa350a4e93907.gif" alt="(v_1,v_2,\dots,v_n)" valign="middle"/> of <img src="/img/cache/7b8b965ad4bca0e41ab51de7b31363a1.gif" alt="n" valign="middle"/> different total recursive functions which satisfy similar conditions as the above definition. Polymorphic viruses have become transplanted over last 10 years and detectinf them involves considerable difficulty. Commonly they have billions of forms and no two forms have the same consecutive three bytes in general. However, they are not the most difficult viruses to detect. In what follows, we define the polymorphic viruses with infinite forms, and prove their existence theoretically in the next section.</p>
<p><strong>Definition 3.4.</strong> (Polymorphic virus with infinite forms) <em>A total recursive function <img src="/img/cache/92c8bcae4c64b7228c0a2d42598a4216.gif" alt="v(m, i)" valign="middle"/> is called a polymorphic virus with infinite forms if for all <img src="/img/cache/e9949fcf444c83d0cb3b4464e87d87a0.gif" alt="m, i" valign="middle"/>,</em></p>
<img src="/img/cache/33fda5c483182f0e3dd10e6e631557a7.gif" alt="
	\phi_{v(m, i)}(d, p) = {\{
	\begin{align}
		&amp;&amp; D(d, p),					&amp;&amp;&amp; \text{if }T(d, p)\\
		&amp;&amp; \phi_i(d, p[v(m + 1, \underline{S(p)})]),	&amp;&amp;&amp; \text{if }I(d, p)\\
		&amp;&amp; \phi_i(d, p),				&amp;&amp;&amp; \text{otherwise}
	\end{align}
	}\\
" valign="middle"/>
<p><em>and for all <img src="/img/cache/8b78e8d0e42d41bb1e20e7035b7999dd.gif" alt="m \ne n" valign="middle"/>, <img src="/img/cache/de52eb029d3a3b7243b971d45af594db.gif" alt="v(m, i) \ne v(n, i)" valign="middle"/>.</em></p>
<p>Polymorphic viruses with infinite forms have not actually been found so far, but their existence, similar to common computer viruses, is guaranteed by the same mathematical theorem (recursion theorem).</p>
<p><strong>Definition 3.5.</strong> (Stealthy virus) <em>The pair <img src="/img/cache/a8409dad1719c099a14bb0c7dfac71fe.gif" alt="(v, \mathbf{sys})" valign="middle"/> of a total recursive function <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> and a system call <img src="/img/cache/e12fff89833df6aab15e1e0e0a223e3d.gif" alt="\mathbf{sys}" valign="middle"/> is called a stealthy virus with respect to the system call <img src="/img/cache/e12fff89833df6aab15e1e0e0a223e3d.gif" alt="\mathbf{sys}" valign="middle"/> if there is a recursive function <img src="/img/cache/2510c39011c5be704182423e3a695e91.gif" alt="h" valign="middle"/> such that for all <img src="/img/cache/865c0c0b4ab0e063e5caa3387c1a8741.gif" alt="i" valign="middle"/>,</em></p>
<img src="/img/cache/14f1d4c5fbc2d5a9306a81f38a9a7061.gif" alt="
	{ \phi_{v(i)}(d, p) = \{
	\begin{align}
		&amp;&amp; D(d, p),		&amp;&amp;&amp; \text{if }T(d, p)\\
		&amp;&amp; \phi_i(d, p[v(\underline{S(p)}), h(\underline{\mathbf{sys}})]),	&amp;&amp;&amp; \text{if }I(d, p)\\
		&amp;&amp; \phi_i(d, p),	&amp;&amp;&amp; \text{otherwise}
	\end{align}
	}\\
	and\\
	\hspace{50} \phi_{h(\mathbf{sys})}(x) = \{
	\begin{align}
		&amp;&amp; \phi_{\mathbf{sys}}(y),	&amp;&amp;&amp; \text{if }x = v(y)\\
		&amp;&amp; \phi_{\mathbf{sys}}(x),	&amp;&amp;&amp; \text{otherwise}
	\end{align}
" valign="middle"/>
<p>The crucial distinction between stealthy viruses and common viruses is that stealthy viruses not only infect programs as common viruses do, but also modify some system calls such that, when someone or the computer system uses these system calls to check programs, the infected program appears the same as if it were not infected.</p>
 
<p><strong>Definition 3.6.</strong> (Combinatorial virus) <em>The pair <img src="/img/cache/ac162bd835175a328cc003c17e2abf9d.gif" alt="(a, h)" valign="middle"/> of two total recursive functions <img src="/img/cache/0cc175b9c0f1b6a831c399e269772661.gif" alt="a" valign="middle"/> and <img src="/img/cache/2510c39011c5be704182423e3a695e91.gif" alt="h" valign="middle"/> is called a combinatorial virus if for all <img src="/img/cache/865c0c0b4ab0e063e5caa3387c1a8741.gif" alt="i" valign="middle"/>,</em></p>
<img src="/img/cache/a548bb685d0a0123f48c456921676bc1.gif" alt="
{	\phi_{ah(i)}(d, p) =\{
	\begin{align}
		&amp;&amp; D(d, p),	&amp;&amp;&amp; \text{if }T(d, p)\\
		&amp;&amp; \phi_i(d, p[ah(\underline{S_1(p)}), h(\underline{S_2(p)})]), &amp;&amp;&amp; \text{if }I(d, p)\\
		&amp;&amp; \phi_i(d, p),&amp;&amp;&amp; \text{otherwise}
	\end{align}
}\\
and\\
	\hspace{100} \phi_{h(i)}(d, p) = \phi_i(d, p)
" valign="middle"/>
<p><em>where the two total recursive functions <img src="/img/cache/0cc175b9c0f1b6a831c399e269772661.gif" alt="a" valign="middle"/> and <img src="/img/cache/2510c39011c5be704182423e3a695e91.gif" alt="h" valign="middle"/> are called the <strong>activation</strong> function and the <strong>hiding</strong> function, respectively.</em></p>
<p>The combinatorial virus <img src="/img/cache/a1e6e7ec339e9dd5d5304d56406ced02.gif" alt="(a,h_1,\dots,h_n)" valign="middle"/> with <img src="/img/cache/7b8b965ad4bca0e41ab51de7b31363a1.gif" alt="n" valign="middle"/> hiding functions can be defined similarly to the above. The extraordinary feature of combinatorial viruses is that they imitate totally original programs and do not make any injury and infection unless their activation functions apply to them.</p>
<h2><a name="c4"></a>4. Some theorems about computer viruses</h2>
<p>In this section, we use some symbols listed as follows.</p>
<p><strong>Symbols 1.</strong></p>
<img src="/img/cache/4a5d51c3b2e6489b2b632908eb968a94.gif" alt="
	D_n = \{ i : \phi_i \text{ is a non-resident virus \}\\
	D_r = \{ \langle i, j \rangle : (\phi_i, \phi_j) \text{ is a resident virus} \}\\
	D_p = \{ \langle i_1,\dots,i_n\rangle : (\phi_{i_1},\dots,\phi_{i_n})\text{ is a polymorphic virus with n forms} \}\\
	D_i = \{ i : \phi_i \text { is a polymorphic virus with infinite forms} \}\\
	D_s = \{ \langle i, j \rangle : (\phi_i, \phi_j) \text{ is a stealthy virus} \}\\
	D_c = \{ \langle i, j \rangle : (\phi_i, \phi_j) \text{ is a combinatorial virus} \}
" valign="middle"/>
<p>If the superscript 'fixed' is attached to a symbol above, then it denotes the set of one kind of viruses which have a fixed kernel, e.g. <img src="/img/cache/360bb48ee07123aa1e3a348649910ba7.gif" alt="D^{\text{fixed}}_r" valign="middle"/> denotes the set of all resident viruses that have a fixed kernel. If its superscript is a name of a virus, e.g., <img src="/img/cache/0538017de8a490fc64f1458c36b80d51.gif" alt="D^{\text{Jerusalem}}" valign="middle"/>, then it denotes the set of all viruses which have the same kernel as the Jerusalem virus.</p>
<p><strong>Theorem 4.1.</strong> <em>There exist polymorphic viruses with infinite forms.</em></p>
<p><em>Proof.</em> Let <img src="/img/cache/5064a4644fd358221233bb9df923601d.gif" alt="b(m, i, k)" valign="middle"/> be a 1-1 total recursive function such that</p>
<img src="/img/cache/c7207d14fd500195b5c18c4dae3c5d0c.gif" alt="
	\phi_{b(m,i,k)}(d, p) = \{
	\begin{align}
		&amp;&amp; \langle m, p \rangle,	&amp;&amp;&amp; \text{if }T(d, p)\\
		&amp;&amp; \phi_i(d, p[\phi_k(m + 1, \underline{S(p)})]), &amp;&amp;&amp; \text{if }I(d, p)\\
		&amp;&amp; \phi_i(d, p),		&amp;&amp;&amp; \text{otherwise}
	\end{align}
" valign="middle"/>
<p>Applying <em>s-m-n</em> theorem to <img src="/img/cache/5064a4644fd358221233bb9df923601d.gif" alt="b(m, i, k)" valign="middle"/>, there exists a total recursive function <img src="/img/cache/8fa14cdd754f91cc6554c9e71929cce7.gif" alt="f" valign="middle"/> such that</p>
<img src="/img/cache/928e248d00395d345ba11b8f94635e00.gif" alt="
	\phi_{f(k)}(m, i) = b(m, i, k).
" valign="middle"/>
<p>By the recursion theorem, there is an <img src="/img/cache/7b8b965ad4bca0e41ab51de7b31363a1.gif" alt="n" valign="middle"/> such that
<img src="/img/cache/1a5d61116fb9e2c5f5387654c553fae2.gif" alt="\phi_{f(n)} = \phi_n" valign="middle"/>. Let <img src="/img/cache/a20c14bf7c0c249e70761a3e44a21e9e.gif" alt="v(m, i) = b(m, i, n) = \phi_{f(n)}(m, i) = \phi_n(m, i)" valign="middle"/>, so</p>
<img src="/img/cache/072311208e8f57c38f38bd81b41aeb39.gif" alt="
\begin{eqnarray}
	\phi_{v(m, i)}(d, p)
		&amp;=&amp; \phi_{b(m,i,n)}(d, p)\\
		&amp;=&amp; \{
		\begin{align}
			&amp;&amp; \langle m, p \rangle,&amp;&amp;&amp; \text{if }T(d, p)\\
			&amp;&amp; \phi_i(d, p[\phi_n(m+1,\underline{S(p)})]), &amp;&amp;&amp; \text{if }I(d, p)\\
			&amp;&amp; \phi_i(d, p)		&amp;&amp;&amp; \text{otherwise}
		\end{align}\\
		&amp;=&amp; \{
		\begin{align}
			&amp;&amp; \langle m, p \rangle,&amp;&amp;&amp; \text{if }T(d, p)\\
			&amp;&amp; \phi_i(d, p[v(m+1,\underline{S(p)})]), &amp;&amp;&amp; \text{if }I(d, p)\\
			&amp;&amp; \phi_i(d, p)		&amp;&amp;&amp; \text{otherwise}
		\end{align}
\end{eqnarray}
" valign="middle"/>
<p>Notice that if <img src="/img/cache/8b78e8d0e42d41bb1e20e7035b7999dd.gif" alt="m \ne n" valign="middle"/>, then for all <img src="/img/cache/865c0c0b4ab0e063e5caa3387c1a8741.gif" alt="i" valign="middle"/> and all <img src="/img/cache/8a87ee7567f6f6a7ab914a3bff6687db.gif" alt="d, p" valign="middle"/> such that <img src="/img/cache/73935fb4b5311cef1414a3954cf6c0c5.gif" alt="T(d, p)" valign="middle"/> holds, <img src="/img/cache/89a2b861c054f5c9d298b99ace7f4933.gif" alt="\phi_{v(m,i)}(d,p)=\langle m,p\rangle \ne \langle n,p\rangle=\phi_{v(n,i)}(d,p)" valign="middle"/> i.e. <img src="/img/cache/de52eb029d3a3b7243b971d45af594db.gif" alt="v(m, i) \ne v(n, i)" valign="middle"/></p>
<div align="right"><img src="/img/cache/09cfa2435552d2f8a90d85e99701606a.gif" alt="\boxempty" valign="middle"/></div>
<p><strong>Theorem 4.2.</strong> <em> There exist combinatorial viruses.</em></p>
<p><em>Proof.</em> Let <img src="/img/cache/2510c39011c5be704182423e3a695e91.gif" alt="h" valign="middle"/> be a recursive function such that <img src="/img/cache/4ed6541b04fed21496ac68efa869205d.gif" alt="\phi_{h(i)}(d, p) = \phi_i(d, p)" valign="middle"/>. Applying the <em>s-m-n</em> theorem, there exists a total recursive function <img src="/img/cache/70ea35729b335c3d57dc638d59727b74.gif" alt="b(i, k)" valign="middle"/> such that</p>
<img src="/img/cache/3fd710e285266b487e44ab707f589cf6.gif" alt="
	\phi_{b(i, k)}(d, p) = \{
	\begin{align}
		&amp;&amp; D(d, p),	&amp;&amp;&amp; \text{if }T(d, p)\\
		&amp;&amp; \phi_i(d, p[\phi_k(h(\underline{S_1(p)})), h(\underline{S_2(p)})]), &amp;&amp;&amp; \text{if }I(d, p)\\
		&amp;&amp; \phi_i(d, p),&amp;&amp;&amp; \text{otherwise}
	\end{align}
" valign="middle"/>
<p>By the recursion theorem, as in Theorem 4.1, there exists a total recursive function <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> such that</p>
<img src="/img/cache/49aa915338bfd7cfc0e9f7bc3cfa909c.gif" alt="
	\phi_{v(i)}(d, p) = \{
	\begin{align}
		&amp;&amp; D(d, p),	&amp;&amp;&amp; \text{if }T(d, p)\\
		&amp;&amp; \phi_i(d, p[v(h(\underline{S_1(p)})), h(\underline{S_2(p)})]), &amp;&amp;&amp; \text{if }I(d, p)\\
		&amp;&amp; \phi_i(d, p),&amp;&amp;&amp; \text{otherwise}
	\end{align}
" valign="middle"/>
<p>Let <img src="/img/cache/726061e13d2de751d46af955dccac840.gif" alt="a = v" valign="middle"/>, substituting <img src="/img/cache/865c0c0b4ab0e063e5caa3387c1a8741.gif" alt="i" valign="middle"/> by <img src="/img/cache/b9682475432c1a2833a2ffe001f722a2.gif" alt="h(i)" valign="middle"/> in the above equation, it follows that</p>
<img src="/img/cache/54151f6df3a5a45bc34d050f9611835f.gif" alt="
	\begin{eqnarray}
	\phi_{ah(i)}(d, p)
		&amp;=&amp; \{
		\begin{align}
			&amp;&amp; D(d, p),	&amp;&amp;&amp; \text{if }T(d, p)\\
			&amp;&amp; \phi_{h(i)}(d, p[a(h(\underline{S_1(p)})), h(\underline{S_2(p)})]), &amp;&amp;&amp; \text{if }I(d, p)\\
			&amp;&amp; \phi_{h(i)}(d, p),&amp;&amp;&amp; \text{otherwise}
		\end{align} 
		\\
		&amp;=&amp; \{
		\begin{align}
			&amp;&amp; D(d, p),	&amp;&amp;&amp; \text{if }T(d, p)\\
			&amp;&amp; \phi_i(d, p[a(h(\underline{S_1(p)})), h(\underline{S_2(p)})]), &amp;&amp;&amp; \text{if }I(d, p)\\
			&amp;&amp; \phi_i(d, p),&amp;&amp;&amp; \text{otherwise}
		\end{align}
	\end{eqnarray}
" valign="middle"/>
<div align="right"><img src="/img/cache/09cfa2435552d2f8a90d85e99701606a.gif" alt="\boxempty" valign="middle"/></div>
<p>In fact, we proved that there exists a combinatorial virus <img src="/img/cache/ac162bd835175a328cc003c17e2abf9d.gif" alt="(a, h)" valign="middle"/>
for any padding or compressing program <img src="/img/cache/2510c39011c5be704182423e3a695e91.gif" alt="h" valign="middle"/> in Theorem 4.2.</p>
<p>The proofs of existence of other viruses are similar to the proof above,
thus we omit them here. One thing necessary to know is that proofs of
existence of resident viruses, polymorphic viruses and stealthy viruses will
make use of the double (or multi-) recursion theorem.</p>
<p><strong>Theorem 4.3.</strong> <em>The set <img src="/img/cache/c0cb12d7348ea6bd9a5743a0d0121bc1.gif" alt="D^{\text{fixed}}_n" valign="middle"/> is a <img src="/img/cache/c092b7daa73baafd26c210aec4174dcc.gif" alt="\prod{}_2" valign="middle"/>-complete set.</em></p>
 
<p><em>Proof.</em> Suppose recursive predicates <img src="/img/cache/73935fb4b5311cef1414a3954cf6c0c5.gif" alt="T(d, p)" valign="middle"/> and
<img src="/img/cache/5354f3368b049ed7a919de8181ca462e.gif" alt="I(d, p)" valign="middle"/> are the injury condition and the infection condition, and
recursive functions <img src="/img/cache/1d1e4261a7ac80044ab2ff3245548fb4.gif" alt="D(d, p)" valign="middle"/> and <img src="/img/cache/be81fe0f3d9275a189495781bf2f49b8.gif" alt="S(p)" valign="middle"/> are the injury
function and the selection function, respectively. Then, since</p>
<img src="/img/cache/600f5d9c24f69ec150dc24a4db66bdda.gif" alt="
e \in D^{\text{fixed}}_n\\
\hspace{50} {
  \Longleftrightarrow \phi_e \text{ is a total recursive function}\\
  \bigwedge \forall i\forall d, p\\
  [
  [T(d, p) \rightarrow \phi_{\phi_e(i)}(d, p) = D(d, p)]\\
  \vee [I(d,p)\rightarrow\phi_{\phi_e(i)}(d,p)=\phi_i(d,p[\phi_e(\underline{S(p)})])]\\
  \vee [\neg(T(d,p)\vee I(d,p))\rightarrow\phi_{\phi_e(i)}(d,p)=\phi_i(d,p)]
  ]
}
" valign="middle"/>
<p>and '<img src="/img/cache/277a6c2c6668e5e52bbd960553f2fa8b.gif" alt="\phi_e\text{ is a total recursive function}" valign="middle"/>' is a
<img src="/img/cache/c092b7daa73baafd26c210aec4174dcc.gif" alt="\prod{}_2" valign="middle"/>-predicate, and '<img src="/img/cache/8c6479263cccc1a9dcd9342695a976f9.gif" alt="\phi_x(z) = \phi_y(z)" valign="middle"/>' is a
<img src="/img/cache/bd934229daa49924f9cb8b578efd8095.gif" alt="\sum{}_1" valign="middle"/>-predicate, so '<img src="/img/cache/f5043e44a241755c2f5b0d2816cf96eb.gif" alt="e \in D^{\text{fixed}}_n" valign="middle"/>' is a
<img src="/img/cache/c092b7daa73baafd26c210aec4174dcc.gif" alt="\prod{}_2" valign="middle"/>-predicate.</p>
<p>To prove <img src="/img/cache/f5043e44a241755c2f5b0d2816cf96eb.gif" alt="e \in D^{\text{fixed}}_n" valign="middle"/> is a
<img src="/img/cache/c092b7daa73baafd26c210aec4174dcc.gif" alt="\prod{}_2" valign="middle"/>-complete set, without loss of generality, we suppose
that viruses do not make any injury and their infection condition is
<img src="/img/cache/5354f3368b049ed7a919de8181ca462e.gif" alt="I(d, p)" valign="middle"/>.</p>
<p>Let <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/> be an <img src="/img/cache/c092b7daa73baafd26c210aec4174dcc.gif" alt="\prod{}_2" valign="middle"/>-set, then there exists a
recursive predicate <img src="/img/cache/e1e1d3d40573127e9ee0480caf1283d6.gif" alt="R" valign="middle"/> such that <img src="/img/cache/ab45e569e6ac5005929921e468f92757.gif" alt="x \in A \Leftrightarrow \forall y \exist z R(x, y, z)" valign="middle"/>.</p>
<p>Consider the function</p>
<img src="/img/cache/bf7340a9c8edf65dadc6998f7111c4cc.gif" alt="
	f(i, k, x, \langle d, p \rangle) = \{
	\begin{align}
		&amp;&amp; \phi_i(d, p[\phi_k(\underline{S(p)})]),	&amp;&amp;&amp; \text{if }I(D, p)\\
		&amp;&amp; \phi_i(d, p),				&amp;&amp;&amp; \text{if }\neg I(d, p)\wedge\forall y\\
		&amp;&amp;						&amp;&amp;&amp; \lt \langle d, p\rangle\exist z R(x, y, z)\\
		&amp;&amp; \uparrow,					&amp;&amp;&amp; \text{otherwise}
	\end{align}
" valign="middle"/>
<p>By Church's thesis, it is a recursive function: suppose <img src="/img/cache/3aa87d9873db93fd55d89666927783b9.gif" alt="P(x, y, z)" valign="middle"/>
is the procedure computing the characteristic function of predicate
<img src="/img/cache/bb8dc6d62f3a255dae0bcd22c8f2eb4d.gif" alt="R(x, y, z)" valign="middle"/>. For a given <img src="/img/cache/227d815bad00f559932f3d69a84aac2c.gif" alt="(i,k,x,\langle d, p\rangle)" valign="middle"/>,
first test the recursive predicate <img src="/img/cache/5354f3368b049ed7a919de8181ca462e.gif" alt="I(d, p)" valign="middle"/>; if it is true, then
compute <img src="/img/cache/3d53815b1d11b1ed142342c0188212ff.gif" alt="\phi_i(d, p[\phi_k(\underline{S(p)})])" valign="middle"/>; if it is false,
then compute
<img src="/img/cache/46243cb6d1572dab84137cae928a38b6.gif" alt="	P(x, 0, 0),\dots,P(x,\langle d, p \rangle, 0),
	P(x, 0, 1),\dots,P(x,\langle d, p \rangle, 1), \dots" valign="middle"/>. If for
each <img src="/img/cache/56dabc928d1014df149a1a8e18308245.gif" alt="y \lt \langle d, p \rangle" valign="middle"/> there exist an <img src="/img/cache/7b8b965ad4bca0e41ab51de7b31363a1.gif" alt="n" valign="middle"/> in this
sequence such that <img src="/img/cache/fbd5543a11cb49ae68ddcd0e83f791d4.gif" alt="P(x, y, n) = 1" valign="middle"/>, then stop the computing procedure
to compute <img src="/img/cache/6da2155c10f64f16922e180a7277ec96.gif" alt="\phi_i(d, p)" valign="middle"/>; otherwise, the procedure cannot stop, so
function <img src="/img/cache/801b2bbb17252ccbe58cc8c6fda33478.gif" alt="f(i, k, x, \langle d, p \rangle)\uparrow" valign="middle"/>.</p>
<p>Applying the <em>s-m-n</em> theorem to <img src="/img/cache/136684e788e17a1e617d0f2b584a7070.gif" alt="f(i,k,x,\langle d,p\rangle)" valign="middle"/>,
there exists a recursive function <img src="/img/cache/f8c4029a634dadb23d95d3f998dbce97.gif" alt="b(i,k,x)" valign="middle"/> such that
<img src="/img/cache/fdf948c525fc10993babbbd40957c6a6.gif" alt="\phi_{b(i,k,x)}(d,p) = f(i,k,x,\langle d,p\rangle)" valign="middle"/>. By the
recursion theorem with parameters, there exists a recursive function
<img src="/img/cache/a04b553e10c56083cfaa0c6da420a1f6.gif" alt="n(x)" valign="middle"/> such that <img src="/img/cache/ae29ff5f39b19e7fd3eea6af6769b03a.gif" alt="\phi_{n(x)}(i) = b(i,n(x),x)" valign="middle"/>, i.e.</p>
<img src="/img/cache/f96a824adab70b735ee9b775aa0df12f.gif" alt="
\begin{eqnarray}
\phi_{\phi_{n(x)}(i)}(d,p)
	&amp;=&amp; \phi_{b(i,n(x),x)}(d,p)\\
	&amp;=&amp; \{
	\begin{align}
		&amp;&amp; \phi_i(d, p[\phi_{n(x)}(\underline{S(p)})]),	&amp;&amp;&amp; \text{if }I(d,p)\\
		&amp;&amp; \phi_i(d, p),	&amp;&amp;&amp; \text{if }\neg I(d,p)\wedge\forall y\\
		&amp;&amp;			&amp;&amp;&amp; \lt\langle d, p\rangle\exist z R(x,y,z)\\
		&amp;&amp; \uparrow,		&amp;&amp;&amp; \text{otherwise}
	\end{align}
\end{eqnarray}
" valign="middle"/>
<p>Thus, if <img src="/img/cache/15ba9457f86ec9a30bc9c1186628cce1.gif" alt="x \in A" valign="middle"/>, then</p>
<img src="/img/cache/a809d3b19ca4355d74e29eb8c3a80276.gif" alt="
\begin{eqnarray}
	x \in A &amp;\Rightarrow&amp; \forall y \exist z R(x, y, z)\\
		&amp;\Rightarrow&amp; \phi_{\phi_{n(x)}(i)}(d, p)\\
		&amp;=&amp; \{
		\begin{align}
			&amp;&amp; \phi_i(d, p[\phi_{n(x)}(\underline{S(p)})]), &amp;&amp;&amp; \text{if }I(d, p)\\
			&amp;&amp; \phi_i(d, p),	&amp;&amp;&amp; \text{otherwise}
		\end{align}
		\\
		&amp;\Rightarrow&amp; n(x) \in D^{\text{fixed}}_n
\end{eqnarray}
" valign="middle"/>
<p>On the other hand, assume <img src="/img/cache/53ebeffeb57ef338724c98c40cb69a1b.gif" alt="x \not\in A" valign="middle"/>, then
<img src="/img/cache/aecdf98db9ff9bb29b201103acd64473.gif" alt="\exist y\forall z\neg R(x,y,z)" valign="middle"/>. Since, for each
<img src="/img/cache/f5043e44a241755c2f5b0d2816cf96eb.gif" alt="e \in D^{\text{fixed}}_n" valign="middle"/>, there exist infinite numbers of
<img src="/img/cache/3e2df3a66619ac333bb68436a7867cbe.gif" alt="\langle d, p\rangle" valign="middle"/> such that
<img src="/img/cache/86600580f69472a738d47baced82a98d.gif" alt="\phi_{\phi_e(i)}(d, p) = \phi_i(d, p)" valign="middle"/>, it follows that there
exists a large enough <img src="/img/cache/3ee8d172ece0c42d858ec13366f877e0.gif" alt="\langle d', p'\rangle" valign="middle"/> such that
<img src="/img/cache/5b77025e0749c6c2d314850d13d25904.gif" alt="\exist y \lt \langle d', p'\rangle \forall z \neg R9x, y, z)" valign="middle"/>,
hence for all <img src="/img/cache/865c0c0b4ab0e063e5caa3387c1a8741.gif" alt="i" valign="middle"/>, <img src="/img/cache/b578c5627e6e45d6c97dec498fecb35b.gif" alt="\phi_{\phi_{n(x)}(i)}(d',p')\uparrow" valign="middle"/>.
Assume <img src="/img/cache/83c4a0f64b5c308332e71b11e874d4cc.gif" alt="\phi_i" valign="middle"/> is a total recursive function, then for all
<img src="/img/cache/f5043e44a241755c2f5b0d2816cf96eb.gif" alt="e \in D^{\text{fixed}}_n" valign="middle"/>, <img src="/img/cache/0212541860c0959f527fc7d366f6e722.gif" alt="\phi_{\phi_e(i)}(d',p') = \phi_i(d',p')" valign="middle"/>
is defined at each <img src="/img/cache/3ee8d172ece0c42d858ec13366f877e0.gif" alt="\langle d', p'\rangle" valign="middle"/>, hence
<img src="/img/cache/d50b95b5cc4fc64e621ed9d5f5c6e932.gif" alt="n(x) \not\in D^{\text{fixed}}_n" valign="middle"/>.</p>
<p>According to the above discussion, it follows that</p>
<div class="N5"><img src="/img/cache/2f6a5a45a5c4b9b31ff9016807c6acf6.gif" alt="
	A \le{}_m D^{\text{fixed}}_n
" valign="middle"/></div>
<p>i.e. <img src="/img/cache/c0cb12d7348ea6bd9a5743a0d0121bc1.gif" alt="D^{\text{fixed}}_n" valign="middle"/> is a <img src="/img/cache/c092b7daa73baafd26c210aec4174dcc.gif" alt="\prod{}_2" valign="middle"/>-complete set.</p>
<div align="right"><img src="/img/cache/09cfa2435552d2f8a90d85e99701606a.gif" alt="\boxempty" valign="middle"/></div>
<p>In the following proof, we shall use the lemma below.</p>
<p><strong>Lemma 4.1.</strong> <em>For a given set <img src="/img/cache/e1e1d3d40573127e9ee0480caf1283d6.gif" alt="R" valign="middle"/>, if its
complement <img src="/img/cache/91831c7dcee18f70c1be0a75ba446874.gif" alt="\overline{R}" valign="middle"/> is an infinite set, then there exists
a recursive function <img src="/img/cache/b2f5ff47436671b6e533d8dc3614845d.gif" alt="g" valign="middle"/> such that for all <img src="/img/cache/9cde9d1e2d215a063449df716b0611cc.gif" alt="\sum{}_3" valign="middle"/>-set
<img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/>,</em></p>
<img src="/img/cache/cba777035c2d963476e43193e11fd3d0.gif" alt="
	x \in A \Rightarrow [W_{g(x)}\ is\ a\ recursive\ set] \wedge [R \subseteq W_{g(x)}]\\
	x \not\in A \Rightarrow [W_{g(x)}\ is\ not\ a\ recursive\ set] \wedge [R \subseteq W_{g(x)}]
" valign="middle"/>
<p><em>Proof.</em> Let <img src="/img/cache/b955eca2a03bf3d6497eb29ae7552404.gif" alt="W^0_{g(x)} = R" valign="middle"/> in the proof of theorem 3.4 in
chapter IV in [6].</p>
<div align="right"><img src="/img/cache/09cfa2435552d2f8a90d85e99701606a.gif" alt="\boxempty" valign="middle"/></div>
<p><strong>Theorem 4.4.</strong> <em><img src="/img/cache/e4f7629b574dd05d19a2107c87806700.gif" alt="D_n" valign="middle"/> is a <img src="/img/cache/9cde9d1e2d215a063449df716b0611cc.gif" alt="\sum{}_3" valign="middle"/>
-complete set.</em></p>
<p><em>Proof.</em> By the definition of <img src="/img/cache/e4f7629b574dd05d19a2107c87806700.gif" alt="D_n" valign="middle"/>, we can establish the
following logical equivalence,</p>
<img src="/img/cache/5a71461f79767e0a27440f41b1d0f34a.gif" alt="
e \in D_n\\
\hspace{50} {
	\Longleftrightarrow \phi_e\text{ is a total recursive function}\\
	\bigwedge\exist t\exist i\exist o\exist b\exist s\\
	[[W_t,W_i,W_o\text{ are recursive sets}]\\
	\wedge[W_t,W_i,W_o\text{ are pairwise disjoint}]\\
	\wedge[W_t \cup W_i \cup W_o = N]\\
	\wedge\forall x\forall d, p\\
	[[\langle d, p\rangle \in W_t \rightarrow \phi_{\phi_e(x)}(d, p) = \phi_b(d, p)]\\
	\vee [\langle d, p\rangle \in W_i \rightarrow \phi_{\phi_e(x)}(d, p) = \phi_x(d, p[\phi_e(\underline{\phi_S(p)})])]\\
	\vee [\langle d, p\rangle \in W_o \rightarrow \phi_{\phi_e(x)}(d, p) = \phi_x(d, p)]]]
}
" valign="middle"/>
<p>where <img src="/img/cache/0e33e67a943f418806d63f8a25b962ae.gif" alt="\langle d, p\rangle \in W_t" valign="middle"/>,<img src="/img/cache/a9af2e2895eb06d8cfc4db102076d1a8.gif" alt="\langle d, p\rangle \in W_i" valign="middle"/>
and <img src="/img/cache/c83442aade46ddb70355b42c979f2f22.gif" alt="\langle d, p\rangle \in W_o" valign="middle"/> correspond to <img src="/img/cache/c4b72d5f8efcc872f5c30a5768871f40.gif" alt="T(d, p), I(d, p)" valign="middle"/>
and otherwise in the Definition 3.1 of non-resident viruses respectively, and
recursive functions <img src="/img/cache/daa315bc321deab6193d9e07a702c62f.gif" alt="\phi_b(d, p)" valign="middle"/> and <img src="/img/cache/71626ef3b07425abf9f234933a9bdb43.gif" alt="\phi_S(d, p)" valign="middle"/>
denote <img src="/img/cache/1d1e4261a7ac80044ab2ff3245548fb4.gif" alt="D(d, p)" valign="middle"/> and <img src="/img/cache/be81fe0f3d9275a189495781bf2f49b8.gif" alt="S(p)" valign="middle"/>, respectively.</p>
<p>Since '<img src="/img/cache/277a6c2c6668e5e52bbd960553f2fa8b.gif" alt="\phi_e\text{ is a total recursive function}" valign="middle"/>' and
<img src="/img/cache/230c3a43eeb8a3f1a14e8fc38c77b0d6.gif" alt="W_x = N" valign="middle"/>' are <img src="/img/cache/c092b7daa73baafd26c210aec4174dcc.gif" alt="\prod{}_2" valign="middle"/>-predicates, '<img src="/img/cache/db960728e6ac4c64c398d6350e749ab0.gif" alt="W_x = 0" valign="middle"/>'
is a <img src="/img/cache/53d3dc158d1e185c694dc09a6ed22eb8.gif" alt="\prod{}_1" valign="middle"/>-predicate,
 
'<img src="/img/cache/8c6479263cccc1a9dcd9342695a976f9.gif" alt="\phi_x(z) = \phi_y(z)" valign="middle"/>' is a <img src="/img/cache/bd934229daa49924f9cb8b578efd8095.gif" alt="\sum{}_1" valign="middle"/>-predicate, and
'<img src="/img/cache/76da8cce394642a03a3c559c4615194c.gif" alt="W_x\text{ is a recursive set}" valign="middle"/>' is a <img src="/img/cache/9cde9d1e2d215a063449df716b0611cc.gif" alt="\sum{}_3" valign="middle"/>-predicate,
so <img src="/img/cache/16af904b80be4e397c5a7766a443331d.gif" alt="e \in D_n" valign="middle"/> is a <img src="/img/cache/9cde9d1e2d215a063449df716b0611cc.gif" alt="\sum{}_3" valign="middle"/>-predicate.</p>
<p>Let <img src="/img/cache/e1e1d3d40573127e9ee0480caf1283d6.gif" alt="R" valign="middle"/> be an infinite recursive set whose complement
<img src="/img/cache/91831c7dcee18f70c1be0a75ba446874.gif" alt="\overline{R}" valign="middle"/> is also infinite. Let <img src="/img/cache/8eefaa434bf807a9f24a67ee2181b531.gif" alt="a \in N" valign="middle"/> and
<img src="/img/cache/be81fe0f3d9275a189495781bf2f49b8.gif" alt="S(p)" valign="middle"/> be the selection function. Consider the function</p>
<img src="/img/cache/d180c953af5b4597eca34f457c17e35d.gif" alt="
f(i,k,x,\langle d, p\rangle) = \{
\begin{align}
	&amp;&amp; \phi_i(d, p[\phi_k(\underline{S(p)})]),	&amp;&amp;&amp;\text{if }\langle d, p\rangle = a\\
	&amp;&amp; \phi_i(d, p),				&amp;&amp;&amp;\text{if }\langle d, p\rangle \in W_{g(x)} \backslash \{a\}\\
	&amp;&amp; \uparrow,					&amp;&amp;&amp;\text{otherwise}
\end{align}
" valign="middle"/>
<p>where <img src="/img/cache/e84fec1e074026d6fa8e3155482c35c3.gif" alt="g(x)" valign="middle"/> is the function in Lemma 4.1. By Church's thesis,
function <img src="/img/cache/950e923ba192a4d1bfa87ef218afe6de.gif" alt="f(i,k,x,\langle d, p\rangle)" valign="middle"/> is a recursive function.
Applying the <em>s-m-n</em> theorem to it, there exist a recursive function
<img src="/img/cache/f8c4029a634dadb23d95d3f998dbce97.gif" alt="b(i,k,x)" valign="middle"/> such that <img src="/img/cache/8be3f8b9efa36c5a37fe919f72c650fa.gif" alt="\phi_{b(i,k,x)}(d, p) = f(i,k,x,\langle d, p\rangle)" valign="middle"/>.
By the recursion theorem with parameters, there exists a recursive function
<img src="/img/cache/a04b553e10c56083cfaa0c6da420a1f6.gif" alt="n(x)" valign="middle"/> such that <img src="/img/cache/ae29ff5f39b19e7fd3eea6af6769b03a.gif" alt="\phi_{n(x)}(i) = b(i,n(x),x)" valign="middle"/>, thus</p>
<img src="/img/cache/630d019f10edc6a877652d0c1eca0574.gif" alt="
\begin{eqnarray}
\phi_{\phi_{n(x)}(i)}(d, p)
	&amp;=&amp; \phi_{b(i,n(x),x)}(d, p)\\
	&amp;=&amp; \{
	\begin{align}
		&amp;&amp; \phi_i(d, p[\phi_{n(x)}(\underline{S(p)})]),	&amp;&amp;&amp;\text{if }\langle d, p\rangle = a\\
		&amp;&amp; \phi_i(d, p),				&amp;&amp;&amp;\text{if }\langle d, p\rangle \in W_{g(x)} \backslash \{a\}\\
		&amp;&amp; \uparrow,					&amp;&amp;&amp;\text{otherwise}
	\end{align}
\end{eqnarray}
" valign="middle"/>
<p>Let <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/> be a <img src="/img/cache/9cde9d1e2d215a063449df716b0611cc.gif" alt="\sum{}_3" valign="middle"/>-set, it follows from Lemma 4.1
and the above equation that</p>
<img src="/img/cache/b19590e5a1d6f93f2cd2dd14e112ca23.gif" alt="
\begin{eqnarray}
	x \in A &amp;\Rightarrow&amp; [ W_{g(x)} \text{ is a recursive set}]\wedge[R\subseteq W_{g(x)}]\\
		&amp;\Rightarrow&amp; W_{g(x)} \backslash \{a\} \text{ is an infinite recursive set}\\
		&amp;\Rightarrow&amp; n(x) \in D_n
\end{eqnarray}
" valign="middle"/>
<p>On the other hand,</p>
<img src="/img/cache/cbb775b11667f334bab09d8de594f024.gif" alt="
\begin{eqnarray}
	x \not\in A
		&amp;\Rightarrow&amp; [ W_{g(x)} \text{ is not a recursive set}]\wedge[R\subseteq W_{g(x)}]\\
		&amp;\Rightarrow&amp; W_{g(x)} \backslash \{a\} \text{ is not an infinite recursive set}\\
		&amp;\Rightarrow&amp; n(x) \not\in D_n
\end{eqnarray}
" valign="middle"/>
<p>Thus, it follows that <img src="/img/cache/e4f7629b574dd05d19a2107c87806700.gif" alt="D_n" valign="middle"/> is a <img src="/img/cache/9cde9d1e2d215a063449df716b0611cc.gif" alt="\sum{}_3" valign="middle"/>-complete set.</p>
<div align="right"><img src="/img/cache/09cfa2435552d2f8a90d85e99701606a.gif" alt="\boxempty" valign="middle"/></div>
<p>Theorems 4.3-4.5 mean that detecting viruses is quite intractable in the
following sense: the degree of undecidability of the set of one kind of
computer viruses which have same kernel, is 2 (e.g. <img src="/img/cache/39f1175f601a922c8b17e66b6d47374a.gif" alt="D^{\text{Jerusalem}}_r" valign="middle"/>);
the degree of undecidability of the set of one kind of all computer viruses
(e.g. <img src="/img/cache/fa81b3830bd7f711581ba9f999e50abe.gif" alt="D_r" valign="middle"/>) is 3. Furthermore, in the proof of Theorem 4.4, if
<img src="/img/cache/53ebeffeb57ef338724c98c40cb69a1b.gif" alt="x \not\in A" valign="middle"/>, then the recursive function <img src="/img/cache/a04b553e10c56083cfaa0c6da420a1f6.gif" alt="n(x)" valign="middle"/> is not a
virus by our definition of viruses, because it has at least one branch in
which condition is not a recursive predicate. Thus, the corollary below is
obtained.</p>
<p><strong>Corollary 4.1.</strong> <em>If the set of all computer viruses is a
<img src="/img/cache/9cde9d1e2d215a063449df716b0611cc.gif" alt="\sum{}_3" valign="middle"/>-set, then it is a <img src="/img/cache/9cde9d1e2d215a063449df716b0611cc.gif" alt="\sum{}_3" valign="middle"/>-complete set.</em></p>
<p>For a given virus <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/>, let the set of all programs infected by
<img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> be <img src="/img/cache/acd319a2ea7d3f7a4611ce853350d894.gif" alt="I_v = Rg(v) = \{v(x) | x \in N \}" valign="middle"/> [3]. If <img src="/img/cache/7becf419ca4290e38585809f5624b28d.gif" alt="I_v" valign="middle"/>
is a recursive set, then there exists a procedure deciding whether or not a
particular program is infected by virus <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/>. Whenever a program
becomes infected by <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/>, it can be detected by this procedure and
removed from the computer, i.e. the virus <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> can be isolated from
the computer environment. Set <img src="/img/cache/7becf419ca4290e38585809f5624b28d.gif" alt="I_v" valign="middle"/> is a recursively enumerable set
certainly, but does not have to be a recursive set. The next theorem gives an
instantial computer virus <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> such that <img src="/img/cache/7becf419ca4290e38585809f5624b28d.gif" alt="I_v" valign="middle"/> is not a
recursive set. In other words, for this virus <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/>, the strongest
detecting procedure for it can just pick up every program infected by
<img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/>, but cannot find all programs not infected by <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/>.</p>
<p>Before giving the proof of the next theorem, we first state a lemma that
will be used in the proof.</p>
<p><strong>Lemma 4.2.</strong> <em>There exists a total recursive function
<img src="/img/cache/2510c39011c5be704182423e3a695e91.gif" alt="h" valign="middle"/> such that <img src="/img/cache/96a1b30a3b9bd2e73b11486c99fefe70.gif" alt="\phi_{h(i)}(d,p)=\phi_i(d,p)" valign="middle"/> and <img src="/img/cache/cbf7813c1ed53709229b2810992aeae0.gif" alt="E_h" valign="middle"/>
is a <img src="/img/cache/bd934229daa49924f9cb8b578efd8095.gif" alt="\sum{}_1" valign="middle"/>-complete set.</em></p>
<p><em>Proof.</em> Let <img src="/img/cache/5772cff2b17dbf56e4f75d1ba33cd0c1.gif" alt="j(i, x)" valign="middle"/> be an increasing padding function,
i.e. for all <img src="/img/cache/865c0c0b4ab0e063e5caa3387c1a8741.gif" alt="i" valign="middle"/> and <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/>, <img src="/img/cache/d63cc800e91f0bb2a7ceb9bb9aa71e9d.gif" alt="\phi_{j(i, x)}(d, p) = \phi_i(d, p)" valign="middle"/>
(as in the proof of Theorem 4 of [3]). Let <img src="/img/cache/b2f5ff47436671b6e533d8dc3614845d.gif" alt="g" valign="middle"/> be a total recursive
function such that <img src="/img/cache/fc6117d18704527157f9bfb2e77f98d1.gif" alt="\mathbf{K} = E_g" valign="middle"/>, consider the function</p>
<div class="N5"><img src="/img/cache/b94465d114286497f5db7c3f575930ee.gif" alt="
	h(i) = \{
	\begin{align}
		&amp;&amp; j(1, g(x)),	&amp;&amp;&amp; \text{if }i=j(1, x)\\
		&amp;&amp; j(i, g(0)),	&amp;&amp;&amp; \text{otherwise}
	\end{align}
" valign="middle"/></div>
<p>It is clear that <img src="/img/cache/4ed6541b04fed21496ac68efa869205d.gif" alt="\phi_{h(i)}(d, p) = \phi_i(d, p)" valign="middle"/>. Let
<img src="/img/cache/c98bb546f61a6fd6b2c5afcd913a3ec6.gif" alt="c(x) = j(1, x)" valign="middle"/>, since <img src="/img/cache/5772cff2b17dbf56e4f75d1ba33cd0c1.gif" alt="j(i, x)" valign="middle"/> is a 1-1 function it
follows that</p>
<div class="N5"><img src="/img/cache/4f699eb94c025f430a87d9e18e043bbf.gif" alt="
	x \in \mathbf{K} \Leftrightarrow c(x) \in E_h
" valign="middle"/></div>
<p>i.e. <img src="/img/cache/8e222abbec1b50396471a6f0fe3c7e4b.gif" alt="\mathbf{K}\le{}_1 E_h" valign="middle"/>. Thus, <img src="/img/cache/cbf7813c1ed53709229b2810992aeae0.gif" alt="E_h" valign="middle"/> is a
<img src="/img/cache/bd934229daa49924f9cb8b578efd8095.gif" alt="\sum{}_1" valign="middle"/>-complete set.</p>
<div align="right"><img src="/img/cache/09cfa2435552d2f8a90d85e99701606a.gif" alt="\boxempty" valign="middle"/></div>
<p><strong>Theorem 4.6.</strong> <em>There exists a computer virus <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/>
such that <img src="/img/cache/7becf419ca4290e38585809f5624b28d.gif" alt="I_v" valign="middle"/> is a <img src="/img/cache/bd934229daa49924f9cb8b578efd8095.gif" alt="\sum{}_1" valign="middle"/>-complete set.</em></p>
<p><em>Proof.</em> Let <img src="/img/cache/2510c39011c5be704182423e3a695e91.gif" alt="h" valign="middle"/> be the function satisfying conditions in
Lemma 4.2. Applying the <em>s-m-n</em> theorem, let <img src="/img/cache/70ea35729b335c3d57dc638d59727b74.gif" alt="b(i, k)" valign="middle"/> be the
1-1 total recursive function such that</p>
<img src="/img/cache/bdc79587e1b9f2842745f6cbf59a9035.gif" alt="
	\phi_{b(i,k)}(d, p) = \{
	\begin{align}
		&amp;&amp; D(d, p),	&amp;&amp;&amp;\text{if }T(d, p)\\
		&amp;&amp; \phi_i(d, p[\phi_k(h(\underline{S(p)}))]), &amp;&amp;&amp; \text{if }I(d, p)\\
		&amp;&amp; \phi_i(d, p),&amp;&amp;&amp;\text{otherwise}
	\end{align}
" valign="middle"/>
<p>By recursion theorem, there exists a function <img src="/img/cache/7b8b965ad4bca0e41ab51de7b31363a1.gif" alt="n" valign="middle"/> such that</p>
<img src="/img/cache/8426566ac363807218b6b2078c0fc6bf.gif" alt="
	\phi_{n(i)}(d, p) = \{
	\begin{align}
		&amp;&amp; D(d, p),	&amp;&amp;&amp;\text{if }T(d, p)\\
		&amp;&amp; \phi_i(d, p[n(h(\underline{S(p)}))]), &amp;&amp;&amp; \text{if }I(d, p)\\
		&amp;&amp; \phi_i(d, p),&amp;&amp;&amp;\text{otherwise}
	\end{align}
" valign="middle"/>
<p>Substituting <img src="/img/cache/865c0c0b4ab0e063e5caa3387c1a8741.gif" alt="i" valign="middle"/> by <img src="/img/cache/b9682475432c1a2833a2ffe001f722a2.gif" alt="h(i)" valign="middle"/> in the above equation, it
follows that</p>
<img src="/img/cache/37a52012a5b9a7d697e71c7355b49fe9.gif" alt="
\begin{eqnarray}
	\phi_{nh(i)}(d, p) &amp;=&amp; \{
	\begin{align}
		&amp;&amp; D(d, p),	&amp;&amp;&amp;\text{if }T(d, p)\\
		&amp;&amp; \phi_{h(i)}(d, p[n(h(\underline{S(p)}))]), &amp;&amp;&amp; \text{if }I(d, p)\\
		&amp;&amp; \phi_{h(i)}(d, p),&amp;&amp;&amp;\text{otherwise}
	\end{align}
	\\
	&amp;=&amp; \{
	\begin{align}
		&amp;&amp; D(d, p),	&amp;&amp;&amp;\text{if }T(d, p)\\
		&amp;&amp; \phi_i(d, p[n(h(\underline{S(p)}))]), &amp;&amp;&amp; \text{if }I(d, p)\\
		&amp;&amp; \phi_i(d, p),&amp;&amp;&amp;\text{otherwise}
	\end{align}
\end{eqnarray}
" valign="middle"/>
 
<p>Let <img src="/img/cache/9983e598eca4af71336c85c7fa63260e.gif" alt="v = nh" valign="middle"/>, then <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> is a non-resident virus. Since
<img src="/img/cache/a04b553e10c56083cfaa0c6da420a1f6.gif" alt="n(x)" valign="middle"/> is a 1-1 function, so <img src="/img/cache/3ef1245d66532c8b7de746558af27b8b.gif" alt="I_v = E_{nh}" valign="middle"/> is not a
recursive set. Otherwise, since</p>
<div class="N5"><img src="/img/cache/6bac86196e0b4e17dcd2086a7e8e1da3.gif" alt="
	x \in E_h \Leftrightarrow n(x) \in E_{nh}
" valign="middle"/></div>
<p>it follows that <img src="/img/cache/cbf7813c1ed53709229b2810992aeae0.gif" alt="E_h" valign="middle"/> is a recursive set and contradicts Lemma 4.2.</p>
<div align="right"><img src="/img/cache/09cfa2435552d2f8a90d85e99701606a.gif" alt="\boxempty" valign="middle"/></div>
<p>The method proving Lemma 4.2 comes from Adleman's paper [3] and the method
proving Theorem 4.6 can be used to prove that there exists any type of computer
virus <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> such that <img src="/img/cache/7becf419ca4290e38585809f5624b28d.gif" alt="I_v" valign="middle"/> is a <img src="/img/cache/bd934229daa49924f9cb8b578efd8095.gif" alt="\sum{}_1" valign="middle"/>-complete
set.</p>
<h2><a name="c5"></a>5. Discussion</h2>
<p>Definition 3.1 of non-resident viruses, which we take as the typical
definition of computer viruses, describes the characteristic behaviors of
computer viruses. But clauses in the definition seem too restrictive,
especially clauses (b) and (c), which deserve some further discussion here.</p>
<p>The clause (b) in Definition 3.1 requires that <img src="/img/cache/73935fb4b5311cef1414a3954cf6c0c5.gif" alt="T(d, p)" valign="middle"/> and
<img src="/img/cache/5354f3368b049ed7a919de8181ca462e.gif" alt="I(d, p)" valign="middle"/> are recursive predicates. It means that a computer virus
must make injury and infection in some definite conditions (random activations
of some computer viruses can be thought as definite functions of
<img src="/img/cache/3e2df3a66619ac333bb68436a7867cbe.gif" alt="\langle d, p\rangle" valign="middle"/> mathematically). Computer viruses found up to
now satisfy this restriction, but there may be computer viruses whose injury
and infection conditions are semi-recursive predicates. This restrictive
condition is necessary in the proof of Theorem 4.4, thus, if we can prove
the theorem without it, then it can be removed from clause (b) in all
definitions of computer viruses.</p>
<p>Clause (c) in Definition 3.1, which requires that an infected program
imitate the original program at infinite points, is a quite strong condition
(even though most computer viruses in the real world satisfy this condition)
and excludes several rogue programs. The proof of Theorem 4.3 makes use of it.
In fact, Theorem 4.3 can be proved in a weaker condition that the infected
program has infinite points satisfying branches (ii) and (iii) in clause (a),
namely, the set <img src="/img/cache/e85940143fcb78b6ec4dee85debd3ef5.gif" alt="\{\langle d,p\rangle : \neg T(d, p)\}" valign="middle"/> is an infinite
set. It is unknown whether Theorem 4.3 can be proved without clause (c) or not.</p>
<p>Another important fact that needs to be known in definitions of computer
viruses is that there are two different ways of infection. One is infecting
programs first and then executing the original program, i.e.
<img src="/img/cache/ef1bdd0e6fe3fee63b402bed7683bd09.gif" alt="\phi_i(d, p[v(\underline{S(p)})])" valign="middle"/>, and another is executing the
original programs, i.e. <img src="/img/cache/5df9965db8a5a3ded98422c8436a1db8.gif" alt="\phi_i(d, p)[v(\underline{S(p)})]" valign="middle"/>. We
adopt the former in our definitions of computer viruses and there is no
essential difference if we use the latter.</p>
<p>Corollary 4.1 looks strange at first glance because it was proved in
Adleman's paper [3] that the set of all computer viruses is <img src="/img/cache/c092b7daa73baafd26c210aec4174dcc.gif" alt="\prod{}_2" valign="middle"/>
-complete. This variation comes from the difference between our definitions
and Adlemsn's definitions of computer viruses. It is known from the proof
of Theorem 4.4 that the reason that <img src="/img/cache/e4f7629b574dd05d19a2107c87806700.gif" alt="D_n" valign="middle"/> is <img src="/img/cache/9cde9d1e2d215a063449df716b0611cc.gif" alt="\sum{}_3" valign="middle"/>-set
is that there exist recursive sets <img src="/img/cache/75565270da0c2b034ed41c4b4bf3c3ee.gif" alt="W_t" valign="middle"/>, <img src="/img/cache/540bdf656419f2a308d7ad1571c664a0.gif" alt="W_i" valign="middle"/> and
<img src="/img/cache/d64e3b64be4763e19a477369eb7b56e5.gif" alt="W_o" valign="middle"/> which satisfy some conditions, but this requirement is not
needed in Adleman's definitions of computer viruses.</p>
<p>We only define some familiar and interesting kinds of computer viruses in
Section 3, however, other kinds of computer viruses can be defined easily in
this way (sometimes, slight modification is needed). We give illustrative
definitions of some other kinds of computer viruses as follows.</p>
<p><strong>Definition 5.1.</strong> (Non-resident overwriting virus) <em>A
total recursive function <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> is called a non-resident overwriting
virus if for all <img src="/img/cache/865c0c0b4ab0e063e5caa3387c1a8741.gif" alt="i" valign="middle"/>,</em></p>
<img src="/img/cache/c06d32c09559a6c386f8cbecac4eec3a.gif" alt="
	\phi_{v(i)}(d,p) = \{
	\begin{align}
		&amp;&amp; D(d,p),	&amp;&amp;&amp; \text{if }T(d,p)	&amp;(i)\\
		&amp;&amp; \langle d, p[v(\underline{S(p)})]\rangle, &amp;&amp;&amp; \text{otherwise} &amp;(ii)
	\end{align}
" valign="middle"/>
<p>A non-resident overwriting virus does not imitate the original program. When
injury condition <img src="/img/cache/11b4dcf414ef856f32f9f99682dc7303.gif" alt="T(d,p)" valign="middle"/> is met, it causes damage; otherwise, it
selects a program and overwrites it by itself, In this sense, non-resident
overwriting viruses still satisfy the requirement in clause (b) in Definition
3.1 that no <img src="/img/cache/7b697bbacb8b13df9519174ac2209719.gif" alt="\langle d,p \rangle" valign="middle"/> satisfies <img src="/img/cache/73935fb4b5311cef1414a3954cf6c0c5.gif" alt="T(d, p)" valign="middle"/> and
<img src="/img/cache/a3bb77f74c408d4088734e4a1083ef52.gif" alt="I(d, p)(=\negT(d,p))" valign="middle"/> simultaneously.</p>
<p><strong>Definition 5.2.</strong> (Interconvertible virus) <em>The pair
<img src="/img/cache/f2d15124e5d0820e6547bc1aab8f3c24.gif" alt="(v, v')" valign="middle"/> of two different total recursive functions <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/>
and <img src="/img/cache/b3afdc4dc7644ad636e084509b04ddab.gif" alt="v'" valign="middle"/> is called an interconvertible virus if for all <img src="/img/cache/865c0c0b4ab0e063e5caa3387c1a8741.gif" alt="i" valign="middle"/>,</em></p>
<img src="/img/cache/4f3de31d49cf4a93a432b03e4cf76512.gif" alt="
{	\phi_{v(i)}(d,p) = \{
	\begin{align}
		&amp;&amp; D(d, p),	&amp;&amp;&amp; \text{if }T(d, p)\\
		&amp;&amp; \phi_i(d, p[v'(\underline{S(p)})]), &amp;&amp;&amp;\text{if }I(d,p)\\
		&amp;&amp; \phi_i(d,p),	&amp;&amp;&amp; \text{otherwise}
	\end{align}
}	\\
and\\
{	\phi_{v'(i)}(d,p) = \{
	\begin{align}
		&amp;&amp; D'(d, p),	&amp;&amp;&amp; \text{if }T'(d, p)\\
		&amp;&amp; \phi_i(d, p[v'(\underline{S'(p)})]), &amp;&amp;&amp;\text{if }I'(d,p)\\
		&amp;&amp; \phi_i(d,p),	&amp;&amp;&amp; \text{otherwise}
	\end{align}
}
" valign="middle"/>
<p><em>where <img src="/img/cache/11b4dcf414ef856f32f9f99682dc7303.gif" alt="T(d,p)" valign="middle"/>(resp. <img src="/img/cache/e5e74008d20781dd719e13705b437590.gif" alt="I(d,p),D(d,p),S(p)" valign="middle"/>) is
different from <img src="/img/cache/0848008d83b2676e1c8f11d404c79890.gif" alt="T'(d,p)" valign="middle"/>(resp. <img src="/img/cache/aed61fb7e521e416f2a6cdae6a1ff43b.gif" alt="I'(d,p),D'(d,p),S'(p)" valign="middle"/>).</em></p>
<p>An interconvertible virus <img src="/img/cache/3a045f4fcf78849b91a8ea7f38549366.gif" alt="(v,v')" valign="middle"/> looks like it consists of two
different computer viruses <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> and <img src="/img/cache/b3afdc4dc7644ad636e084509b04ddab.gif" alt="v'" valign="middle"/>. But, there is a
crucial distinction that when <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> infects a program, the result is
infected by <img src="/img/cache/b3afdc4dc7644ad636e084509b04ddab.gif" alt="v'" valign="middle"/> (not <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/>), and vice versa. The
interconvertible virus <img src="/img/cache/3c2c90d0ffcd5b84908fa350a4e93907.gif" alt="(v_1,v_2,\dots,v_n)" valign="middle"/> can be defined
similarly. The main dissimilarity between interconvertible viruses and
polymorphic viruses is that each form of a polymorphic virus has the same
kernel, but each component <img src="/img/cache/b17d30899a9047efcf74e562297dea22.gif" alt="v_n" valign="middle"/> of an interconvertible virus has
its own different kernel.</p>
<p><strong>Definition 5.3.</strong> (Compositive virus) <em>The pair
<img src="/img/cache/cae8476c66e5e279e8b1019030add46b.gif" alt="(v_1,v_2)" valign="middle"/> of two different computer viruses <img src="/img/cache/84fc825e5c5d6969221754059de4a804.gif" alt="v_1" valign="middle"/> and
<img src="/img/cache/e2e643399f285b0efc0310e52afa3112.gif" alt="v_2" valign="middle"/> is called a compositive virus if and only if <img src="/img/cache/522c699d73fe7a888f14939311e0ed89.gif" alt="v_1v_2" valign="middle"/>
is a computer virus too, namely for all <img src="/img/cache/865c0c0b4ab0e063e5caa3387c1a8741.gif" alt="i" valign="middle"/>, <img src="/img/cache/23f567a1eb2cab6bd4fb673b147459b3.gif" alt="v_1,v_2" valign="middle"/> and
<img src="/img/cache/522c699d73fe7a888f14939311e0ed89.gif" alt="v_1v_2" valign="middle"/> satisfy the following equations respectively,</em></p>
<img src="/img/cache/1ccb1c62825649bb1733967fda5db6ec.gif" alt="
{	\phi_{v_1(i)}(d,p) = \{
	\begin{align}
		&amp;&amp; D_1(d,p),	&amp;&amp;&amp; \text{if }T_1(d,p)\\
		&amp;&amp; \phi_i(d, p[v_1(\underline{S_1(p)})]), &amp;&amp;&amp; \text{if }I_1(d, p)\\
		&amp;&amp; \phi_i(d, p),&amp;&amp;&amp; \text{otherwise}
	\end{align}}\\
and\\
{	\phi_{v_2(i)}(d,p) = \{
	\begin{align}
		&amp;&amp; D_2(d,p),	&amp;&amp;&amp; \text{if }T_2(d,p)\\
		&amp;&amp; \phi_i(d, p[v_2(\underline{S_2(p)})]), &amp;&amp;&amp; \text{if }I_2(d, p)\\
		&amp;&amp; \phi_i(d, p),&amp;&amp;&amp; \text{otherwise}
	\end{align}}
" valign="middle"/>
 
<br/>
<img src="/img/cache/02815408f35bcd33ed1969fab5ffafe3.gif" alt="
and\\
	\phi_{v_1v_2(i)}(d,p) = \{
	\begin{align}
		&amp;&amp; D(d,p),	&amp;&amp;&amp; \text{if }T(d,p)\\
		&amp;&amp; \phi_i(d, p[v_1v_2(\underline{S(p)})]), &amp;&amp;&amp; \text{if }I(d, p)\\
		&amp;&amp; \phi_i(d, p),&amp;&amp;&amp; \text{otherwise}
	\end{align}
" valign="middle"/>
<p><em>where <img src="/img/cache/fdbd3f468f3758c9158ffee0e6ae4fa4.gif" alt="T_1(d,p)" valign="middle"/>(resp. <img src="/img/cache/d1017ca4f5af2517e6f91cea4611cdaf.gif" alt="I_1(d,p),D_1(d,p),S_1(p)" valign="middle"/>),
<img src="/img/cache/be1034fb941b7433de00af4e66f48049.gif" alt="T_2(d,p)" valign="middle"/>(resp. <img src="/img/cache/898e08846792352e23ccd3bd08f8859a.gif" alt="I_2(d,p),D_2(d,p),S_2(p)" valign="middle"/>) and
<img src="/img/cache/11b4dcf414ef856f32f9f99682dc7303.gif" alt="T(d,p)" valign="middle"/>(resp. <img src="/img/cache/e5e74008d20781dd719e13705b437590.gif" alt="I(d,p),D(d,p),S(p)" valign="middle"/>) are different from
each other, namely, viruses <img src="/img/cache/8436c23468b3b111c573ce4145b210c0.gif" alt="v_1, v_2" valign="middle"/> and <img src="/img/cache/522c699d73fe7a888f14939311e0ed89.gif" alt="v_1v_2" valign="middle"/> have
different kernels.</em></p>
<p>Compositive viruses resemble combinatorial viruses in the sense that they
both create a new virus when their components meet in the computer system.
The difference between them is that the components of a compositive virus
are viruses themselves whilst the components of a combinatorial virus are not.</p>
<p><strong>Definition 5.4.</strong> (Multipartite virus) <em>A total
recursive function <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> is called a multipartite virus if for all
<img src="/img/cache/865c0c0b4ab0e063e5caa3387c1a8741.gif" alt="i" valign="middle"/>,</em></p>
<img src="/img/cache/5ffe925d03e7b08035e2947156c07488.gif" alt="
{	\phi_{v(i)}(d,p) = \{
	\begin{align}
		&amp;&amp; D(d,p),	&amp;&amp;&amp; \text{if }T(d,p)\\
		&amp;&amp; \phi_i(d,p[v(\underline{\mathbf{MBR}})]), &amp;&amp;&amp; \text{if }I_1(d,p)\\
		&amp;&amp; \phi_i(d,p[v(\underline{S(p)})]), &amp;&amp;&amp; \text{if }I_2(d,p)\\
		&amp;&amp; \phi_i(d,p), &amp;&amp;&amp; \text{otherwise}
	\end{align}
}\\
and\\
{	\phi_{v(\mathbf{MBR})}(d,p) = \{
	\begin{align}
		&amp;&amp; D'(d,p),	&amp;&amp;&amp; \text{if }T'(d,p)\\
		&amp;&amp; \phi_{\mathbf{MBR}}(d,p[v(\underline{\mathbf{sys}})]), &amp;&amp;&amp; \text{otherwise}
	\end{align}
}\\
and\\
{	\phi_{v(\mathbf{sys})}(d,p) = \{
	\begin{align}
		&amp;&amp; D''(d,p),	&amp;&amp;&amp; \text{if }T''(d,p)\\
		&amp;&amp; \phi_{\mathbf{sys}}(d,p[v(\underline{S''(p)})]), &amp;&amp;&amp; \text{if }I''(d,p)\\
		&amp;&amp; \phi_{\mathbf{sys}}(d,p), &amp;&amp;&amp;\text{otherwise}
	\end{align}
}
" valign="middle"/>
<p><em>where <img src="/img/cache/e460eb1ca74b0ebc6821b30922723cd1.gif" alt="\mathbf{MBR}" valign="middle"/> and <img src="/img/cache/e12fff89833df6aab15e1e0e0a223e3d.gif" alt="\mathbf{sys}" valign="middle"/> denote
<strong>master boot record</strong> and a <strong>system call</strong>,
respectively.</em></p>
<p>Multipartite viruses use a combination of techniques including infecting
documents, executables and boot sectors to infect computers. The above definition
is that of a typical multipartite virus. Each of its infected programs infects
MBR (under condition <img src="/img/cache/1b59b23ac81462397c78e98d1fbfa7fd.gif" alt="I_1(d,p)" valign="middle"/>) or a selected program (under
condition <img src="/img/cache/55e269fe357e738cd8160fe1e4bad326.gif" alt="I_2(d,p)" valign="middle"/>). The infected MBR employs a system call to
reside in memory when booting and then infect other programs. Multipartite
viruses are examples of computer viruses which have more than one spreading
mode and can be described similarly.</p>
<p>We may define almost all kinds of computer viruses in this way, however,
there are some special kinds of computer viruses that are still difficult
to describe. For example, there may be a computer virus that does nothing
but modify a .C file on computer. After the user compiles and links the .C
source file, the infected program is workable. Extending our definitions
of computer viruses so as to describe all kinds of computer viruses is one
of our further research works.</p>
<h2><a name="c6"></a>Acknowledgements</h2>
<p>Prof. Qingxin Zhu read the whole paper and helped us with the English for
which the authors are gratefull. The referees made useful comments that
improved the presentation of the paper enormously.</p>
<h2><a name="c7"></a>References</h2>
<ol>
<li>Cohen, F. (1989) <a href="/lib/afc10.html">Computational aspects of computer viruses</a>. <em>Comput. Security</em>, 8(4), 325-244.</li>
<li>Cohen, F. (1994) <em><a href="/lib/afc13.html">A short Course on Computer Viruses</a></em>. Wiley.</li>
<li>Adleman, L. M. (1988) <a href="/lib/ala01.html">An Abstract theory of computer viruses</a>. In Goldwasser, S. (ed.), <em>Advances in Cryptology (CRYPTO'88)</em>, LNCS 403, pp. 354-374. Springer-Verlag, Berlin.</li>
<li>Thimbleby, H., Anderson, S. and Cairns, P. (1999) <a href="/lib/aht01.html">A framework for modelling trojans and computer virus infection</a>. <em>Comput. J.</em>, 41, 444-458.</li>
<li>Rogers, H., Jr (1967) <em>Theory of Recursive Functions and Effective Computability</em>. McGraw-Hill.</li>
<li>Soare, R.I. (1987) <em>Recursively Enumerable Sets and Degrees</em>. Springer-Verlag.</li>
</ol>
 
[<a style="" href="/lib/?lang=EN&amp;index=TH#mzz00">Back to index</a>] [<a href="/lib/mzz00.html#disqus_thread">Comments</a>]<br/> <div id="disqus_thread"></div>
<script type="text/rocketscript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'vxheaven'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="/agreement.php">Terms of Use</a>!</small> <small>vxheaven.org aka vx.netlux.org</small></div>
<div style="margin-top: 2px; float: left;" class="adsapeu">
<script type="text/rocketscript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script>
</div>
<script data-rocketsrc="http://www.google-analytics.com/urchin.js" type="text/rocketscript"></script><script type="text/rocketscript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="/lib/index.php?lang=de&amp;id=mzz00">de</a><a href="/lib/index.php?lang=en&amp;id=mzz00">en</a><a href="/lib/index.php?lang=es&amp;id=mzz00">es</a><a href="/lib/index.php?lang=it&amp;id=mzz00">it</a><a href="/lib/index.php?lang=fr&amp;id=mzz00">fr</a><a href="/lib/index.php?lang=pl&amp;id=mzz00">pl</a><a href="/lib/index.php?lang=ru&amp;id=mzz00">ru</a><a href="/lib/index.php?lang=ua&amp;id=mzz00">ua</a></div>
</body>
</html>
