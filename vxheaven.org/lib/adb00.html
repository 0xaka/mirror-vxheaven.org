<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Danilo Bruschi, Lorenzo Martignoni, Mattia Monga 'Using Code Normalization for Fighting Self-Mutating Malware' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Author" content="Danilo Bruschi, Lorenzo Martignoni, Mattia Monga"/>
<meta name="KeyWords" lang="en" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, Bruschi, Danilo; Martignoni, Lorenzo; Monga, Mattia,Using Code Normalization for Fighting Self-Mutating Malware, techniques, detection, strategy, instruction, computer, propagation, variable, instructions, level, optimization, distance, malware, definition, jumps, code"/>
<meta name="Description" content="Self mutating malware has been introduced by computer virus writers who, in '90s, started to write polymorphic and metamorphic viruses in order to defeat anti-virus products. In this paper we present a novel approach for dealing with self mutating code which could represent the basis for a new detection strategy for this type of malware. A tool prototype has been implemented in order to validate the idea and the results are quite encouraging, and indicate that it could represent a new strategy for detecting this kind of malware"/>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"047a5bcbf67431883fc9ed25fba33612",petok:"e57664d011bae7958c42949eb58926de24eb877a-1498757385-1800",zone:"vxheaven.org",rocket:"a",apps:{}}];document.write('<script type="text/javascript" src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=85b614c0f6/cloudflare.min.js"><'+'\/script>');}}catch(e){};
//]]>
</script>
<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="/style.css"/><link rel="canonical" href="http://vxheaven.org/lib/adb00.html"/>
<script type="text/rocketscript" data-rocketsrc="https://apis.google.com/js/plusone.js">{"parsetags": "explicit"}</script>
</head>
<body bgcolor="#dbc8a0" text="#302000" link="#225599" vlink="#113366">
<div class="s1">
<div style="float:right;"><a href="/lib/index.php?tbs=1"><img src="/img/max.gif" alt="Maximize"/></a></div> <form id="lf" style="margin: 0; float: right;" method="get" action="/index.php"><input type="hidden" name="action" value="set"/><select name="lang" onchange="javascript:document.getElementById('lf').submit();"><option value="ru">Русский</option><option selected="selected" value="en">English</option><option value="ua">Українська</option><option value="de">Deutsch</option><option value="es">Español</option><option value="fr">Fran&ccedil;ais</option><option value="it">Italiano</option><option value="pl">Polski</option></select></form>
<div style="float: right;"><div id="plusone"></div></div>
<script type="text/rocketscript">gapi.plusone.render("plusone", {"size":"small","count":"true"});</script>
<div style="float: right;" class="addthis_toolbox addthis_default_style">
<script type="text/rocketscript">var addthis_config = { ui_click: true }</script>
<a style="text-decoration: none; font-size: 10pt;" href="/?action=addthis" class="addthis_button_compact">Bookmark</a>
<script type="text/rocketscript" data-rocketsrc="http://s7.addthis.com/js/250/addthis_widget.js#username=herm1t"></script>
</div>
<div style="float: right;">
<script type="text/rocketscript" data-rocketsrc="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<form action="/search.php" id="cse-search-box">
<input type="hidden" name="cx" value="002577580816726040001:z9_irkorydo"/>
<input type="hidden" name="cof" value="FORID:10"/>
<input type="hidden" name="ie" value="UTF-8"/>
<input type="text" name="q" size="12" value=" "/>
<input type="submit" name="sa" value="Search"/>
</form>
</div><h1><a href="/" style="text-decoration: none; color: #000000;">VX Heaven</a></h1>
<span class="nav"><a href="/lib/">Library</a> <a href="/vl.php">Collection</a> <a href="/src.php">Sources</a> <a href="/vx.php?id=eidx">Engines</a> <a href="/vx.php?id=tidx">Constructors</a> <a href="/vx.php?id=sidx">Simulators</a> <a href="/vx.php?id=uidx">Utilities</a> <a href="/links.php">Links</a> <a href="/donate.php" style="color: #706020" id="donate">Donate</a> <a href="/forum" style="text-decoration: underline;">Forum</a> </span><br clear="all"/>
</div>
<div class="s2"><h1>Using Code Normalization for Fighting Self-Mutating Malware</h1><p><a href="/lib/?lang=en&amp;author=Bruschi%2C%20Danilo">Danilo Bruschi</a>, <a href="/lib/?lang=en&amp;author=Martignoni%2C%20Lorenzo">Lorenzo Martignoni</a>, <a href="/lib/?lang=en&amp;author=Monga%2C%20Mattia">Mattia Monga</a><br/> <em>Technical Report 08-06, Dipartimento di Informatica e Comunicazione - Universita degli Studi di Milano, 2006.</em><br/> <em> 2006</em></p><script type="text/rocketscript">var disqus_url = 'http://vxheaven.org/lib/adb00.html';</script><div class="ci"><a href="/lib/?ci=adb00">2</a></div><img src="/img/pdf.gif" alt="PDF"/><a href="/lib/pdf/Using%20Code%20Normalization%20for%20Fighting%20Self-Mutating%20Malware.pdf">Download</a> PDF (120.62Kb) (You need to be registered on <a href="/forum">forum</a>)<br/>[<a style="" href="/lib/?lang=EN&amp;index=AT#adb00">Back to index</a>] [<a href="/lib/adb00.html#disqus_thread">Comments</a>]<br/> <form method="post" action="">
<img src="/img/cache/0b9fd596a90421f9f1f68a9760275737.gif" alt="\text{T_EX size}" valign="middle"/>
<select name="TeX_size"><option value="-2">-2</option><option value="-1">-1</option><option value="0" selected="selected">0</option><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option> </select>
<input type="submit" value="Scale"/>
</form><form method="post" action=""><input type="hidden" name="pages" value="1"/><input type="submit" value="Turn on page numbers"/></form>
<address>
<p>UNIVERSIT&Agrave; DEGLI STUDI DI MILANO<br/>
FACOLT&Agrave; DI SCIENZE MATEMATICHE, FISICHE E NATURALI<br/>
DI.C.O. - DIPARTIMENTO DI INFORMATICA E COMUNICAZIONE</p>
<p>Dipartimento di Informatica e Comunicazione<br/>
Universit&agrave; degli Studi di Milano<br/>
Via Comelico 39/41, 20135 Milano - Italy<br/>
{bruschi,martign,<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="dcb1b3b2bbbda19cb8b5bfb3f2a9b2b5b1b5f2b5a8">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script></p>
</address>
<p>RAPPORTO TECNICO N. 08-06</p>
<h2>Abstract</h2>
<p>Self mutating malware has been introduced by computer virus writers who, in '90s, started to write polymorphic and metamorphic viruses in order to defeat anti-virus products. In this paper we present a novel approach for dealing with self mutating code which could represent the basis for a new detection strategy for this type of malware. A tool prototype has been implemented in order to validate the idea and the results are quite encouraging, and indicate that it could represent a new strategy for detecting this kind of malware.</p>
<h2>1 Introduction</h2>
<p>Most of malware detection mechanisms are based on pattern matching, i.e. they recognize malware by looking for the presence of <em>malware signatures</em><sup><a href="#f1" name="b1">1</a></sup> inside programs, IP packet sequences, email attachments, etc. One of the most obvious strategy adopted for circumventing them is based on the notion of self mutating malware, i.e. malicious code which continuously changes its own code and, consequently, makes signature based detection, completely useless.</p>
<p>Self mutation is a particular form of code obfuscation<sup><a href="#f2" name="b2">2</a></sup>, which is performed <em>automatically by</em> the code itself. Some well known self mutating programs are <tt>METAPHOR</tt> [2], <tt>ZMIST</tt> [16] and <tt>EVOL</tt> [22]. The diffusion of this type of malware is quite worrying as, in some papers recently appeared in literature [8, 7], it has been shown that current commercial virus scanners can be easily circumvented by using simple obfuscation techniques.</p>
<p>In this paper we present a novel approach for dealing, with self mutating code which could represent the basis for a new detection strategy for this type of malware. Even if in [6] it has been proven that, in the general case, perfect detection of self-mutating code is a non computable problem, such a result leaves room for the implementation of techniques which, even if not perfect, can defeat a significant percentage of self mutating code; the strategy we devised is one of them.</p>
<p>Such a strategy, is based on a static analysis approach for verifying security properties of executable code and it is derived by the following observation (see also [19]). A self-mutating malware has to be able to analyze its own body and extract from it all the information needed to mutate into the next generation, which has to be able to perform the same process, and so on. As the mutation mechanisms adopted has to be particularly efficient, the mutations performed cannot be too complex and, in the general case, it is possible to iteratively reverse the mutation process until an <em>archetype</em><sup><a href="#f3" name="b3">3</a></sup> has been derived. Such a consideration is enforced by experimental observations in which we have shown that malware produced by self mutating programs is characterized by highly unoptimized code, that is, it contains a lot of redundant and useless instructions. Thus, giving a piece of code <img src="/img/cache/69691c7bdcc3ce6d5d8a1361f22d04ac.gif" alt="M" valign="middle"/>, our strategy for verifying whether is a malware code is the following. Initially we decode <img src="/img/cache/69691c7bdcc3ce6d5d8a1361f22d04ac.gif" alt="M" valign="middle"/> and transform it into a normal form <img src="/img/cache/c0c8156de7a5455113e67f33c15182fb.gif" alt="M'" valign="middle"/>, and during such a phase we also perform a code optimization by removing from <img src="/img/cache/c0c8156de7a5455113e67f33c15182fb.gif" alt="M'" valign="middle"/> all useless and redundant computations. Subsequently we verify whether <img src="/img/cache/c0c8156de7a5455113e67f33c15182fb.gif" alt="M'" valign="middle"/> shares common features with the normalized code of a known malware. In order to perform the normalization process we referred to well known code optimization techniques adopted in compilers' construction (for example see [3, 20]).</p>
 
<p>The comparison between a normalized code is instead realized using <em>clone detection</em> techniques [18, 17, 5]. We briefly remember that clone detection is primarily used in software engineering to identify fragments of source code that can be considered similar despite little differences. We adapted such techniques to work on binary code instead of source code, since malware is normally available only as a compiled executable.</p>
<p>We implemented a tool prototype in order to validate our idea and the results are quite encouraging, and indicate that the current stable version of such tool could be considered as a basic component in the design of security architectures.</p>
<p>This paper is organized as follows. In Section 2 we describe mutation techniques adopted by malware writers. In section 3 we describe the optimization techniques we implemented for removing the mutations previously described. In section 4 we provide a brief overview of the clone detection techniques we decide to adopt. In Section 5 we describe the prototype implemented while in section 6 we describe the experiments we performed with our prototype and the preliminary results. Section 7 discusses related works. In the final section some conclusions on the work presented are drawn.</p>
<h2>2 Mutation Techniques</h2>
<p>The mutation of an executable object can be performed using various types of program transformations techniques, exhaustively described in [11, 12]. For the sake of completeness we report in the following a brief summary of the most common strategies used by a malicious code to mutate itself.</p>
<h3>Instructions substitution</h3>
<p>A sequence of instructions is associated to a set of alternative sequences of instructions which are semantically equivalent to the original one. Every occurrence of the original sequence can be replaced by an arbitrary element of this set. For example, as far as the <code>eax</code> and <code>ebx</code> registers are concerned, the following code fragments are equivalent.</p>
<table summary="Equivalent machine instructions">
<tr><th>Machine instructions</th><th>Equivalent form</th></tr>
<tr><td><div class="asm" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #00007f; font-weight: bold;">mov</span> <span style="color: #46aa03; font-weight: bold;">eax</span><span style="color: #339933;">,</span><span style="color: #46aa03; font-weight: bold;">ecx</span> <br/>
<span style="color: #00007f; font-weight: bold;">mov</span> <span style="color: #46aa03; font-weight: bold;">ebx</span><span style="color: #339933;">,</span><span style="color: #46aa03; font-weight: bold;">eax</span> <br/>
<span style="color: #00007f; font-weight: bold;">mov</span> <span style="color: #46aa03; font-weight: bold;">ecx</span><span style="color: #339933;">,</span><span style="color: #46aa03; font-weight: bold;">ebx</span> <br/>
&nbsp;</div></td><td><div class="asm" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #00007f; font-weight: bold;">xor</span> <span style="color: #46aa03; font-weight: bold;">ebx</span><span style="color: #339933;">,</span><span style="color: #46aa03; font-weight: bold;">eax</span><br/>
<span style="color: #00007f; font-weight: bold;">xor</span> <span style="color: #46aa03; font-weight: bold;">eax</span><span style="color: #339933;">,</span><span style="color: #46aa03; font-weight: bold;">ebx</span><br/>
<span style="color: #00007f; font-weight: bold;">xor</span> <span style="color: #46aa03; font-weight: bold;">ebx</span><span style="color: #339933;">,</span><span style="color: #46aa03; font-weight: bold;">eax</span><br/>
&nbsp;</div></td></tr></table>
<h3>Instructions permutation</h3>
<p>Independent instructions, i.e., instructions whose computations do not depend on the result of previous instructions, are arbitrarily permutated without altering the semantic of the program. For example, the three statements <code>a = b * c, d = b + e and c = b &amp; c</code> can be executed in any order, provided that the use of the <code>c</code> variable precedes its new definition.</p>
<h3>Garbage insertion</h3>
<p>Also known as dead-code insertion. It consists of the insertion, at a particular program point, of a set of valid instructions which does not alter the expected behavior of the program. For example given the following sequence of instructions <code>a = b / d, b = a * 2</code>; any instruction which modifies <code>b</code>, can be inserted between the first and the second instruction; moreover instructions that reassign any other variables without really changing their value can be inserted at any point of the program (e.g., <code>a = a + 0, b = b * 1,...</code> ).</p>
<h3>Variable substitutions</h3>
<p>The usage of a variable (register, memory address or stack element) is replaced by another variable belonging to a set of valid candidates preserving the behavior of the program.</p>
<h3>Control flow alteration</h3>
<p>The order of the instructions, as well as the structure of the program, is altered introducing fake conditional and unconditional branch instructions such that at run-time the order in which single instructions are executed is not modified. Furthermore, direct jumps and function calls can be translated into indirect ones whose destination addresses are camouflaged into other instructions in order to prevent an accurate reconstruction of the control flow.</p>
 
<h2>3 Normalization Techniques</h2>
<p>Code normalization is the process of transforming a piece of code into a canonical form more useful for comparison.</p>
<p>Most of the transformations used by malware to dissimulate its presence (see Section 2) led to a major consequence: the code size is highly increased. In other words, the various mutations of a piece of malware can be thought of as unoptimized versions of its archetype, since they contain some irrelevant computations whose presence has the only goal of defeating recognition. Normalization of a malware aims at removing all the "dust" introduced during the mutation process and optimization techniques can be used to reduce the "dust".</p>
<p>Usually optimization is performed by the compiler to improve the execution time of the object code or to reduce the size of the text or data segment it uses. The optimization process encompasses a lot of analysis and transformations that are well documented in the compilers literature [3, 20]. As shown by [21, 13] the same techniques can also be directly applied to executable in order to achieve the same goals. We deeply investigated such techniques and we found that some of them can be successfully used in order to fight the mutation engines adopted by self mutating malware. In the following we briefly describe such techniques.</p>
<h3>Instructions meta-representation</h3>
<p>All the instructions of a CPU can be classified in the following categories: (i) jumps, (ii) function calls and returns, and (iii) all the other instructions that have side effects on registers, memory and control flags. In the following we call the instructions in category (iii) <em>assignments</em>. Comparison instructions can be considered as assignments because they usually perform some arithmetic on their operands and then update a control register accordingly (e.g. <code>eflags</code> on IA-32). In order to ease the manipulation of object code, we used a high-level representation of machine instructions that expresses the operational semantics of every opcode, as well as the registers, memory address and control flags involved. A simple example follows:</p>
<table summary="Meta representation of machine instrcutions">
<tr><th>Machine instruction</th><th>Meta-representation</th></tr>
<tr><td><div class="asm" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #00007f; font-weight: bold;">pop</span> <span style="color: #46aa03; font-weight: bold;">eax</span> <br/>
<br/>
<span style="color: #00007f; font-weight: bold;">lea</span> <span style="color: #46aa03; font-weight: bold;">edi</span><span style="color: #339933;">,</span><span style="color: black;">&#91;</span><span style="color: #46aa03; font-weight: bold;">ebp</span><span style="color: black;">&#93;</span><br/>
<span style="color: #00007f; font-weight: bold;">dec</span> <span style="color: #46aa03; font-weight: bold;">ebx</span><br/>
<span style="color: #339933;">...</span><br/>
&nbsp;</div></td><td><pre class="source">
r10 = [r11]
r11 = r11 + 4
r06 = r12
tmp = r08
r08 = r08 - 1
NF = <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="99eba9a1d9c2aaa8a3aaa8c4">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>
ZF = [r08 = 0?1:0]
CF = (~(<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="3e4a534e7e650d0f040d0f63">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>)
...
</pre></td></tr></table>
<p>It is worth noting that even the simple <code>dec</code> instruction conceals a complex semantics: its argument is decremented by one and six control flags are updated according to the result (the above example is reduced for space constraints).</p>
<h3>Propagation</h3>
<p>Propagation is used to propagate forward values assigned or computed by intermediate instructions. Whenever an instruction defines a variable (a register or a memory cell) and this variable is used by subsequent instructions without being redefined, then all its occurrences can be replaced with the value computed by the defining instruction. The main advantage of propagation is that, it allows to generate higher level expressions (with more than two operands) and eliminate all intermediate temporary variables that were used to implement high-level expressions. The following code fragment sketches a simple scenario where, thanks to propagation, a higher level expression is generated:</p>
<table summary="Generating higher level expressions">
<tr><th>Before propagation</th><th>After propagation</th></tr>
<tr><td><pre class="source">
r10 = [r11] 
r10 = r10 | r12 
[r11] = [r11] & r12
[r11] = ~[r11]
[r11] = [r11] & r10
</pre></td><td><pre class="source">
r10 = [r11]
r10 = [r11] | r12


[r11] = (~([r11] & r12)) & ([r11] | r12)
</pre></td></tr></table>
 
<h3>Dead code elimination</h3>
<p>Dead instructions are those whose results are never used. For example, if a variable is on the left hand side of two assignments but it is never used between them (i.e., does not appear on the right hand side of an expression), the first assignment is consider dead or useless (the second is called a <em>killing definition</em> of the assigned variable). For example, the first assignment of the little instructions sequence shown above (<code>r10 = [r11]</code>) is useless after propagation. Dead instructions, without side effects, can be safely removed from a program because they do not contribute to the final computation.</p>
<h3>Algebraic simplification</h3>
<p>Since most of the expressions contain arithmetical or logical operators, they can sometimes be simplified according to the ordinary algebraic rules. When simplification are not possible, variables and constants could be reordered to enable further simplifications after propagation. The following table shows some examples of the rules that can be used to perform simplification and reordering (<img src="/img/cache/4a8a08f09d37b73795649038408b5f33.gif" alt="c" valign="middle"/> denotes a constant value and <img src="/img/cache/e358efa489f58062f10dd7316b65649e.gif" alt="t" valign="middle"/> a variable):</p>
<table summary="Simplifying expressions">
<tr><th>Original expression</th><th>Simplified expression</th></tr>
<tr><td><img src="/img/cache/4687a34a1af0a1af1ac6752e040b4743.gif" alt="c1 + c2\\
t1 - c1\\
t1 + c1\\
0 + t1\\
t1 + (t2 + t3)\\
(t1 + t2) * c1
" valign="middle"/></td><td><img src="/img/cache/9f1c1bd16418d9f757fa76c211137d14.gif" alt=" 
\text{the sum of the two}\\
-c1 + t1\\
c1 + t1\\
t1\\
(t1 + t2) + t3\\
(c1 * t1) + (c1 * t2)
" valign="middle"/></td></tr></table>
<h3>Control flow graph compression</h3>
<p>The control flow graph can be heavily twisted with the insertion of fake conditional and unconditional jumps. A twisted control flow graph could impact on the quality of the whole normalization process because it can limit the effectiveness of other transformations. At the same time other transformations are essential to improve the quality of the normalization of the control flow graph.</p>
<p>Expressions which represent branch conditions and branch (or call) destinations could benefit from the results of previous transformations: to be able to calculate the result of a branch condition expression means to be able to predict whether a path in the control flow graph will be followed or not. If a path is never accessed then all paths that are originating from it and that have no other incoming paths will never be accessed too (i.e., they are unreachable) and can be removed from the original control flow graph. The same applies to expressions that represent the addresses of indirect function calls and of indirect branches. If an expression could be calculated then the indirection would be replaced with a fixed constant address and that means that new nodes can precisely be added to the control flow graph.</p>
<p>Chances for normalization may also arise even if an expression can not be fully calculated. For example, suppose that propagation into one of the operands of a branch condition is not possible because there are two different incoming definitions of the same variable coming from two different concurrent paths. Nothing can be told about the truth value of the condition because it still contains a variable. But, if looking back at the values that an incoming variable may assume, we find only fixed values, and not variables, we can evaluate the condition for all possible incoming values and if the result is always the same, one of the two outgoing paths can be removed from the control flow graph. The same approach can be used to determine the set of possible target addresses of an indirect jump (or of a function call).</p>
<h2>4 Comparison techniques</h2>
<p>Unfortunately we can not expect that, at the end of the normalization, all the samples of a self-mutating malware reduce to the same normal form. Differences that can not be handled (e.g., some temporary assignment that cannot be removed) usually remains. For these reasons it is not possible to compare two samples just comparing byte per byte their normalized form. For dealing with such a problem we need a method that is able to provide a measure of the similarity among different pieces of code, which allow us to capture the effective similarity of them.</p>
<p>The problem of comparing codes in order to discover common fragments among them is known as <em>clone detection</em>. Clone detection is primarily used by software engineers to detect equivalent blocks within source code, in order to factor out them
 
in macros and function calls, reducing the size of the code and improving its understandability and maintainability. Clone detection techniques can rely on the analysis of the text of the code [14], or on some more sophisticated representation of the program (see [4, 5, 17]).</p>
<p>In this paper we are interested in the approach proposed in [18] where the structure of a code fragment is characterized by a vector of software metrics and a measure of distance between different fragments is proposed.</p>
<p>The metrics we decided to adopt during our experiments are the following:</p>
<ol>
<li><img src="/img/cache/377b1a53b01e907138040867edc7cac2.gif" alt="m_1" valign="middle"/>: number of nodes in the control flow graph;</li>
<li><img src="/img/cache/a4e435d4d078e7df1fa07e13d4a32ebb.gif" alt="m_2" valign="middle"/>: number of edges in the control flow graph;</li>
<li><img src="/img/cache/7068ce0a09670fa0de05318019a7a44a.gif" alt="m_3" valign="middle"/>: number of direct calls;</li>
<li><img src="/img/cache/b5d338975faf94db214094f2008a10b0.gif" alt="m_4" valign="middle"/>: number of indirect calls;</li>
<li><img src="/img/cache/e2437082f101720a99a9dd5af0028268.gif" alt="m_5" valign="middle"/>: number of direct jumps;</li>
<li><img src="/img/cache/64c2a065639590d1db8fd6a81b042bb1.gif" alt="m_6" valign="middle"/>: number of indirect jumps;</li>
<li><img src="/img/cache/fd8afa1c7cf39c4d7f53e8447cca8284.gif" alt="m_7" valign="middle"/>: number of conditional jumps;</li>
</ol>
<p>These metrics have been chosen such that they should capture the structure of an executable code. Thus, we have defined the fingerprint of a code fragment as the tuple <img src="/img/cache/6c676090fe5a046ae642c91dafd48387.gif" alt="(m_1 : m_2 : m_3 : m_4 : m_5 : m_6 : m_7)" valign="middle"/> and we used it for comparing code fragments. More precisely we say that two code fragments a and b are equivalent if the Euclidean distance, <img src="/img/cache/3a55958e17e5f8325f262d88116dcd4e.gif" alt="\sqrt{\sum_{i=1}^7{(m_{i,a} - m_{i,b})}^2 }" valign="middle"/>, where <img src="/img/cache/b0145a1d27ed246a925ae48bfa0e6fec.gif" alt="m_{i,a}" valign="middle"/> and <img src="/img/cache/ac0dd1a41d634c60a3e164aa55ef0d8d.gif" alt="m_{i,b}" valign="middle"/> are the <img src="/img/cache/97361f12a3555fc4fc4e2ffce1799ac3.gif" alt="i^{th}" valign="middle"/> metric calculated respectively on fragment <img src="/img/cache/0cc175b9c0f1b6a831c399e269772661.gif" alt="a" valign="middle"/> and <img src="/img/cache/92eb5ffee6ae2fec3ad71c777531578f.gif" alt="b" valign="middle"/>, is below a given threshold. Ideally the threshold should be 0, but a higher value would allow to tolerate little imperfections in the normalization process.</p>
<p>The structure of different instances of the same malicious code is far from being constant, but we believe that, after normalization, most of the structural differences will be removed. Roughly speaking, we expect that most of fake conditional jumps get translated into unconditional jumps or removed, fake indirect function calls and jumps get translated into direct, because the destination addresses have been computed, and nodes in the control flow that are not reachable get simply removed.</p>
<p>Thus, the Euclidean distance of a code fragments before and after normalization allows to quantify the effectiveness of the normalization and the Euclidean distance between a normalized code fragments and the malicious code archetype allows to quantify their similarity.</p>
<h2>5 The prototype</h2>
<p>We have implemented the techniques described in Sections 3 and 4 in a tool which, given as input two code fragments <img src="/img/cache/0cc175b9c0f1b6a831c399e269772661.gif" alt="a" valign="middle"/> and <img src="/img/cache/92eb5ffee6ae2fec3ad71c777531578f.gif" alt="b" valign="middle"/>, will decide whether <img src="/img/cache/92eb5ffee6ae2fec3ad71c777531578f.gif" alt="b" valign="middle"/> is a mutated version of <img src="/img/cache/0cc175b9c0f1b6a831c399e269772661.gif" alt="a" valign="middle"/>. In this Section we describe the architecture of our tool and its main components.</p>
<p>Figure 1 represents the steps performed during the code analysis. The malware executable is processed through a disassembler and it is converted into an intermediate form. Subsequently, the malware is processed by a set of transformations in order to reshape the code and to remove, as much as possible, redundant and useless instructions while trying to compact their form. Each step of the normalization process (depicted in gray in Figure 1), is highly dependent on both prior and subsequent steps; for this reason they are repeated until the latest normalized form does not introduce new improvements over the previous one. At the end of the normalization process the resulting malware, that should resemble as much as possible its archetype, is processed by the evaluator in order to compare it with other samples.</p>
<p>We built our prototype on top of <tt>BOOMERANG</tt> [1], an open source decompiler. The aim of <tt>BOOMERANG</tt> is to translate machine code programs into an equivalent C source code and to do this it reconstructs, from low level machine instructions, high level concepts (e.g. compound statements like <em>while, for, ...</em> and high level expressions with more than two operands) which are subsequently translated into source code. <tt>BOOMERANG</tt> provides an excellent framework which can be used to perform any kind of machine code manipulation, so we decided to build out tool on top of it by modifying some of its native functionality and adding new ones. For example, the control flow compression routine has been enhanced in order to deal with obfuscated branches predicates and to remove pending unreachable nodes; the algebraic simplification routines has also
 
been enhanced to handle a bigger set of simplifications not previously handled and without which normalization would have been less effective. It is worth noting that none of the simplifications and the transformations implemented are malware specific. A brief description of our tool follows.</p>
<div align="center">
<img src="img/adb00/fig1.gif" alt="Figure 1: Normalization and identification process"/>
<p><strong>Figure 1: Normalization and identification process.</strong></p>
</div>
<p>During the first phase of the analysis, called <em>decoding</em>, the code is translated from machine code to an intermediate representation. Each instruction is disassembled and it is expanded into the respective semantic, which is expressed through the SSL [10] language. When jump and call instructions are encountered the decoding is performed following the execution paths; this approach of disassembling is called <em>recursive traversal</em> because the program flow is followed. During decoding, sequential instructions are grouped together into blocks, called <em>basic blocks</em>, which are then connected together, according to flow transition instructions, in order to construct the <em>control flow graph</em>. The instructions belonging to the same basic block satisfy the property that all of them is always executed before all the subsequent ones.</p>
<p>Once a code fragment is completely decoded and its control flow graph is built, it is transformed into <em>static single assignment form</em> [15] (or simply <em>SSA</em>). The particularity of this representation is that every definition of a program variable gives rise to a new variable, thus the same variable is defined only once. For example the first definition of the variable <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/> generates the variable <img src="/img/cache/4be60c01260fad068dd84cb934d15c36.gif" alt="A_1" valign="middle"/> and the <img src="/img/cache/d6c87401ed2f8589600d6db807438139.gif" alt="j^{th}" valign="middle"/> definition generates the variable <img src="/img/cache/6daefbe0428efd37faed840230bb5fda.gif" alt="A_j" valign="middle"/>. The main advantage of the SSA form is that it allows to enormously simplify the data-flow analysis process because it makes explicit the relation between the use of a variable (when it appears inside an expression) and its definition (when it appears on the left hand side of an assignment). A trick has to be used when more than one definition reach the same use, through different paths: a special statement, called <img src="/img/cache/1ed346930917426bc46d41e22cc525ec.gif" alt="\phi" valign="middle"/>-statement, is inserted at the beginning of the basic blocks that uses these definitions, and it is used to define a new variable which indicates the use of multiple concurrent definitions. For example if both <img src="/img/cache/fb185a5b342b50fff8732781bfc1d738.gif" alt="A_i := 0" valign="middle"/> and <img src="/img/cache/a47c67b438c575a3aef2bc9710555325.gif" alt="A_j := 1" valign="middle"/> reach the instruction <img src="/img/cache/bb8237d8c27af581ab497ef7ed12b07c.gif" alt="B := A + 1" valign="middle"/> of block <img src="/img/cache/8ce4b16b22b58894aa86c421e8759df3.gif" alt="k" valign="middle"/> the following instruction <img src="/img/cache/72eaf7ebdc3a83bef401e99869fda694.gif" alt="A_k := (i, j)" valign="middle"/> is inserted before <img src="/img/cache/9d5ed678fe57bcca610140957afab571.gif" alt="B" valign="middle"/> definition, which is then translated into <img src="/img/cache/421b6e1c029bf07ecedff4f326526498.gif" alt="B := A_k + 1" valign="middle"/>, in order to explicits that the assignment uses either <img src="/img/cache/693a3b974c23e87e8c941211cd45cfb8.gif" alt="A_i" valign="middle"/> or <img src="/img/cache/6daefbe0428efd37faed840230bb5fda.gif" alt="A_j" valign="middle"/>.</p>
<p>Figure 2 shows the assembly code of a dummy code fragment and Figure 3 shows the same program whose instructions are translated into the intermediate form plus SSA, and grouped in order to construct the control flow graph. The numbers between curly brackets near each variable use indicate, for clearness, the number of the instruction at which a variable is defined, instead of the incremental number of the variable definition, <code>m[0x1000400c]</code> is used to indicate the memory address <code>0x1000400c</code>, and <code><a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="6e2b2f362e355d5f545d5f33">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script></code> means the 31<sup>st</sup> bit of the register <em>EAX</em>.</p>
<p>Further transformations are applied directly on the SSA form. Chances for propagation and dead instruction removal can be easily identified thanks to the SSA form. For example the flag <em>ZF</em> (Zero Flag) definition at instruction 8 (Figure 3), <em>ZF<sub>8</sub></em>, is dead because no instruction uses it, instead <em>ZF<sub>12</sub></em> is used by instruction 14. The same applies for definitions <em>CF<sub>5</sub></em> (Carry Flag), <em>OF<sub>6</sub></em> (Overflow Flag) and <em>SF<sub>7</sub></em> (Sign Flag), they are all dead. Propagation is applied in the same way, every use of a variable <img src="/img/cache/693a3b974c23e87e8c941211cd45cfb8.gif" alt="A_i" valign="middle"/> can be substituted with its definition whenever it is unique (i.e. it is not defined by a <img src="/img/cache/1ed346930917426bc46d41e22cc525ec.gif" alt="\phi" valign="middle"/>-statement).</p>
 
<div class="asm" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #adadad; font-style: italic;">8048</span><span style="color: #ff0000;">354</span><span style="color: #339933;">:</span> <span style="color: #00007f; font-weight: bold;">mov</span> <span style="color: #0000ff; font-weight: bold;">$</span><span style="color: #ff0000;">0x1000400c</span><span style="color: #339933;">,%</span><span style="color: #46aa03; font-weight: bold;">eax</span><br/>
<span style="color: #adadad; font-style: italic;">8048</span><span style="color: #ff0000;">359</span><span style="color: #339933;">:</span> <span style="color: #00007f; font-weight: bold;">mov</span> <span style="color: #339933;">%</span><span style="color: #46aa03; font-weight: bold;">eax</span><span style="color: #339933;">,</span><span style="color: #ff0000;">0x10004014</span><br/>
<span style="color: #adadad; font-style: italic;">8048</span>35e<span style="color: #339933;">:</span> <span style="color: #00007f; font-weight: bold;">add</span> <span style="color: #339933;">%</span><span style="color: #46aa03; font-weight: bold;">eax</span><span style="color: #339933;">,%</span><span style="color: #46aa03; font-weight: bold;">ebx</span><br/>
<span style="color: #adadad; font-style: italic;">8048</span><span style="color: #ff0000;">360</span><span style="color: #339933;">:</span> <span style="color: #00007f; font-weight: bold;">test</span> <span style="color: #339933;">%</span><span style="color: #46aa03; font-weight: bold;">ebx</span><span style="color: #339933;">,%</span><span style="color: #46aa03; font-weight: bold;">ebx</span><br/>
<span style="color: #adadad; font-style: italic;">8048</span><span style="color: #ff0000;">362</span><span style="color: #339933;">:</span> <span style="color: #00007f; font-weight: bold;">jne</span> 804836a<br/>
<span style="color: #adadad; font-style: italic;">8048</span><span style="color: #ff0000;">364</span><span style="color: #339933;">:</span> <span style="color: #00007f; font-weight: bold;">push</span> <span style="color: #339933;">%</span><span style="color: #46aa03; font-weight: bold;">ebx</span><br/>
<span style="color: #adadad; font-style: italic;">8048</span><span style="color: #ff0000;">365</span><span style="color: #339933;">:</span> <span style="color: #00007f; font-weight: bold;">mov</span> <span style="color: #0000ff; font-weight: bold;">$</span><span style="color: #ff0000;">0x0</span><span style="color: #339933;">,%</span><span style="color: #46aa03; font-weight: bold;">ebx</span><br/>
<span style="color: #adadad; font-style: italic;">8048</span><span style="color: #ff0000;">365</span><span style="color: #339933;">:</span> <span style="color: #00007f; font-weight: bold;">inc</span> <span style="color: #339933;">%</span><span style="color: #46aa03; font-weight: bold;">eax</span><br/>
<span style="color: #adadad; font-style: italic;">8048</span>36c<span style="color: #339933;">:</span> <span style="color: #00007f; font-weight: bold;">jmp</span> <span style="color: #339933;">*%</span><span style="color: #46aa03; font-weight: bold;">ebx</span><br/>
&nbsp;</div>
<p><strong>Figure 2: Assembly code of a dummy code fragment.</strong></p>
<pre class="source">
	08048354  1 EBX := 0x1000400c
	08048359  2 m[0x10004014] := EBX{1}
	0804835e  3 TMP1 := EAX{-}
	          4 EAX := EAX{-} + EBX{1}
	          5 CF := ((<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="0450495435445f37353e373559">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>{3}) & (<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="aeebecf6eef59d9f949d9ff3">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>{1}))
	                  | (~(<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="4d080c150d167e7c777e7c10">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>{4}) & ((<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="cb9f869bfa8b90f8faf1f8fa96">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>{3})
	                  | (<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="5d181f051d066e6c676e6c00">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>{1})))
	          6 OF := ((<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="792d34294839224a48434a4824">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>{3}) & (<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="96d3d4ced6cda5a7aca5a7cb">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>{1}) &
	                  ~(<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="7237332a322941434841432f">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>{4})) | (~(<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="37637a6706776c04060d04066a">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>{3})
	                  & ~(<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="31747369716a02000b02006c">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>{1}) & (<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="9cd9ddc4dcc7afada6afadc1">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>{4}))
	          7 SF := <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="7f3a3e273f244c4e454c4e22">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>{4}
	          8 ZF := [EAX{4} = 0?1:0]
	08048360  9 TMP1 := EAX{4}
	         10 CF := 0
	         11 OF := 0
	         12 ZF := (TMP1{9} = 0?1:0)
	         13 SF := <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="95c1d8c5a4d5cea6a4afa6a4c8">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>{9}
	08048362 14 BRANCH 0x804836a
      /                           |
     /                            |
    / ZF{12} != 0                 | ZF{12} == 0
   /                              |
  /                               |
08048364 15 ESP := ESP{-} - 4     |
         16 m[ESP] := EAX{4}      |
08048365 17 EAX := 0              |
                            \     |
                             \    |
                              \   |
			       \  |
			         18 EAX := phi(4, 17)
			0804836a 19 TMP1 := EAX{18}
			         20 EAX := EAX{18} + 1
			         21 CF := ((<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="481c05187908137f727f15">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>) & 1)
					  | (~(<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="6722263f273c505d503a">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>{20}) & ((<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="2571687514657e121f1278">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>) | 1))
			         22 OF := ((<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="184c55482958432f222f45">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>) & 1 & ~(<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="2a6f6b726a711d101d77">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>{20}))
			                  | (~(<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="6a3e273a5b2a315d505d37">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>) & ~1 & (<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="01444059415a363b365c">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>{20}))
			         23 NF := <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="7732362f372c404d402a">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>{20}
			         24 ZF := [EAX{20} = 0?1:0]
			0804836c 25 JUMP EBX{1}
</pre>
<p><strong>Figure 3: Single Static Assignment Form of the code fragment of Figure 2; instructions are expanded in order to expose their semantic and are grouped according to control flow relations.</strong></p>
 
<p>Simplifications instead are performed on each expression through pattern matching. Each expression, and all of its subexpressions, are compared against a set of known reducible expressions and, when a match is found, simplification rules are applied until no changes are applicable. The set of simplification applied are just well known arithmetic and logical simplification rules. Whenever a branch condition is simplified into an expression that always evaluates to true or false, the unreachable path is removed from the control flow graph. If the deletion of a path has consequences on the instructions already processed (for example a block that was previously reached by two concurrent definitions it is now reached by one only) then new chances for propagation and simplification may arise, so the process must be repeated again. Other control flow simplifications may occur when, thanks to propagation and simplification, it is possible to determine the set of values that a variable, used as the target address, may assume. The discovery of new paths can have consequences on the whole analysis and thus it must be repeated until there are no new improvements.</p>
<p>For example (Figure 3) the propagation of <em>EAX<sub>4</sub></em> into instruction 9, and then of <em>TMP1<sub>9</sub></em> into instruction 12, leads to <em>ZF_{12} := (EAX_ + 0x1000400c == 0 ? 1 : 0)</em> (<em>EAX_</em> means that <em>EAX</em> has not yet been defined) which can then be propagated into instruction 14, thus substituting the branch condition into <em>(EAX_ +0x1000400c == 0 ? 1 : 0) == 0</em>, which is true when <em>EAX_ &ne; -0x1000400c</em>. Propagation of <em>EBX<sub>1</sub></em> into instruction 25 instead allows to resolve the indirection and thus to translate the instructions into a direct jump to the address <em>0x1000400c</em>. This new address, if not yet decoded and analysed, must be treated as any other program instructions and, consequently, processed in the same way.</p>
<p>At the end the last normalized form of the input sample is emitted, represented into the intermediate form and provided with the fingerprint based on the metrics (described in Section 4) calculated at the end of the process. The similarity of the samples, instead, is calculated by a separate tool that receives in input a set of fingerprints and returns a number representing their similarity degree.</p>
<h2>6 Experiments and results</h2>
<p>We performed our experiments on the <tt>METAPHOR</tt> [2] virus which is one of the most interesting malware from the mutation point of view. <tt>METAPHOR</tt> evolves itself through five steps: (i) disassembling of the current payload, (ii) compression of the current payload using some transformation rules, (iii) permutation of the payload introducing fake conditional and unconditional branches, (iv) expansion of the payload using some transformation rules and (v) assembling of the new payload.</p>
<p>The malware analyzed applied the whole mutation process only on its payload that is stored encrypted in the binary; the decryption routine is instead is mutated only using step (iv)<sup><a href="#f4" name="b4">4</a></sup>. We then performed our experiments on this routine, but we expect similar results on the payload since our normalization is able to cancel most of the transformations introduced in steps (ii) and (iii). Moreover, compression is only used to avoid explosion of the size during evolution and its influence on the structure of the code is analogous to expansion, just the inverse way.</p>
<p>The experiments we performed are the followings. The malware archetype was executed in a controlled environment in order to infect some dummy programs; after the first infection the newly infected program were executed to infect new dummy programs, and so on, until we collected 114 samples. The infected dummy programs were compared with their uninfected copy such that it was possible to extract the decryption routine and the encrypted payload. The extracted decryption routines were then given in input to our prototype in order to perform the normalization and the comparison. Firstly we computed the fingerprint of each decryption routine without performing any normalization. Subsequently, we performed the normalization process and computed the fingerprints of the rearranged samples. The calculated fingerprints were then compared with the one that resembles the archetype. We noticed that the fingerprints of the original samples (i.e., without having carried out normalization) were almost different from the archetype and that just a little subset matches exactly, probably because during mutation weak transformations were chosen. After the normalization most of the samples, instead, matched perfectly the archetype:</p>
<table summary="">
<tr><th>Distance range</th><th># of samples (before norm.)</th><th># (after norm.)</th></tr>
<tr><td>0.0 - 0.9</td><td>29</td><td>85</td></tr>
<tr><td>1.0 - 1.9</td><td>9</td><td>19</td></tr>
<tr><td>2.0 - 2.9</td><td>38</td><td>2</td></tr>
<tr><td>3.0 - 3.9</td><td>4</td><td>7</td></tr>
<tr><td>4.0 - 4.9</td><td>21</td><td>1</td></tr>
<tr><td>&gt; 4.9</td><td>13</td><td>0</td></tr>
</table>
<p>The results of comparison of the similarity degree with and without normalization are depicted in figure 4. We manually inspected the normalized samples that still presented a different structure (similarity degree &ne; 0) and noticed that the
 
differences were due to some garbage located after the end of the decryption routine that were recognized as valid machine instructions and became part of the control flow graph. This is a limitation of the comparison function chosen, because it is susceptible to garbage in the control flow graph. We also measured the difference between the number of instructions in the original samples and in the normalized ones, they were about 57% less.</p>
<div align="center">
<img src="img/adb00/fig4.gif" alt="Figure 4: Distance of the analyzed samples from the malware archetype before and after the normalization."/>
<p><strong>Figure 4: Distance of the analyzed samples from the malware archetype before and after the normalization.</strong></p>
</div>
<div align="center">
<img src="img/adb00/fig5.gif" alt="Figure 5: Distance of some harmless functions from the malware archetype."/>
<p><strong>Figure 5: Distance of some harmless functions from the malware archetype.</strong></p>
</div>
<p>Furthermore, we collected randomly a small number of system executable binaries, normalized them and compared their functions fingerprints with the archetype one, just to see what would have been their degree of similarity. The results, for a total of 1000 functions, are shown in figure 5 and in the following summary:</p>
<table summary="">
<tr><th>Distance range</th><th># of functions</th></tr>
<tr><td>0.0 - 0.9</td><td>0</td></tr>
<tr><td>1.0 - 1.9</td><td>4</td></tr>
<tr><td>2.0 - 2.9</td><td>28</td></tr>
<tr><td>3.0 - 3.9</td><td>44</td></tr>
<tr><td>4.0 - 4.9</td><td>46</td></tr>
<tr><td>&gt; 4.9</td><td>827</td></tr>
</table>
<p>The current prototype implementation imposes some restrictions on the type of program characteristics that can be used to measure the similarity of the samples, mostly because of the presence of dead code. A manual inspection of the normalized samples highlighted that the main problem was the presence of temporary defined intermediate memory cells that could not be removed from the code because it was not possible to tell if they were used or not by other instructions. We can not
 
tell if they are dead until we are not able to add to our prototype a smarter alias analysis algorithm; actually the memory is handled in a conservative way. The use of more rigorous and uncorrelated metrics would allow to have a more accurate evaluation of the quality of the normalization process. Another problem we envisioned, even if we did not found evidence of it in our experiments, is that one could introduce branches conditional on the result of a complex function. It could be difficult to evaluate statically that the value of the function falls always in a given range, but this could be exploited by a malicious programmer. However, the complexity of the function is still bounded by the constraint that it has to be introduced <em>automatically</em> (see previous discussion in Section 1).</p>
<p>Although the normalization of our samples was quite fast (less than a second each) performances could be an issue with big executables; our attempts to normalize common executables of a UNIX system took an enormous amount of time and system resources. The running time, calculated on an Intel 3.0Ghz machine, ranges from 0.2 to 8 seconds per functions.</p>
<h2>7 Related works</h2>
<p>The idea of using object code static analysis for dealing with malware code obfuscation has been firstly introduced by Christodorescu and Jha in [7]. In such a paper they introduced a system for detecting malicious patterns in executable code, based on the comparison of the control flow graph of a program and an automaton that described a malicious behavior. More precisely, they generalized a program <em>P</em> translating it into an annotated control flow graph using a set of predefined patterns and then performed detection by determining whether there existed, or not, a binding such that the intersection between the annotated control flow graph and the malicious code automaton (i.e., the abstract description of the malware archetype) was not empty; if a binding existed then <em>P</em> was classified as malicious. The obfuscation techniques they were able to deal with using such an approach were registers reassignments, control flow rearrangement through unconditional jumps plus a limited set of dead-code instructions as they were detected through patterns during annotation. A further refinement of the their work has been presented in [9]. The malware detection algorithm presented in such a work received as input a program (converted into an intermediate form and which control flow is normalized removing useless unconditional jumps) and a template describing a malicious behavior and tried to identify bindings between program instructions and template nodes. Whenever a binding inconsistence was found (e.g. two different expression are bounded to the same template variable) a decision procedure (based on pattern matching, random execution and theorem proving) was used to determine if the inconsistence was due to an absence of the malicious behavior in the program or because the binding had been obfuscated inserting garbage. The class of obfuscation transformations was wider than the one handled by their first work: the system was able to detect using only a template different hand-made variants of the same malware. The algorithm returned <em>true</em> if the whole template had been found in the program, <em>don't know</em> otherwise. In both papers some experimental results were reported and they showed that the systems worked pretty well, especially the second one because; at the moment the real problem of these approaches is speed.</p>
<p>We decided to concentrate our efforts on malware that is able to obfuscate itself autonomously so our approach deals with mutations in a way that is closer to the ways in which it is generated. Thus, we can revert lot of the modifications that malware suffered during its life cycle by reverting the mutation process. The works described above concentrate on comparison but do not try to fight the obfuscation, so if the malicious code is highly obfuscated the proposed detection techniques could become useless. We, instead, have proposed that deobfuscation becomes a fundamental step in the analysis process and we also have shown which techniques can be successfully used.</p>
<h2>8 Conclusions and future works</h2>
<p>We presented a strategy, based on static analysis, that can be used to pragmatically fight malicious codes that evolve autonomously in order to circumvent detection mechanisms. To verify our ideas we developed a prototype and successfully used it to show that the transformations used by malware can be reverted and that a malware that suffers a cycle of mutations can be brought back to a canonical shape that is highly similar to its original one. The similarities among the analyzed samples were measured to determine the quality of the whole process. The same approach was also used to compare generic executables with the malware in analysis.</p>
<p>Our original intentions were to use more metrics, for example the number of different used and defined variables, the total number of statements and the number of concurrent variable definitions reaching program assignments. The improvement of the prototype will be targeted by future works. We are also planning to work on more accurate techniques for the comparison
 
of pieces of code that are not susceptible to undesired garbage and that could provide a more reliable way for the detection of known malicious codes in generic executables, even when they are located within already existing and harmless functions.</p>
<h2>References</h2>
<ol>
<li>Boomerang. http://boomerang.sourceforge.net.</li>
<li>MetaPHOR. http://securityresponse.symantec.com/avcenter/venc/data/w32.simile.html.</li>
<li>A. V. Aho, R. Sethi, and J. D. Ullman. Compilers: Principles, Techniques and Tools. Addison-Wesley, 1986.</li>
<li>B. S. Baker. On finding duplication and near-duplication in large software systems. <em>In Proceedings of the second working conference on reverse engineering</em>, pages 86-95, Los Alamitos, CA, USA, 1995. IEEE.</li>
<li>I. D. Baxter, A. Yahin, L. Moura, M. Sant'Anna, and L. Bier. Clone detection using abstract syntax trees. In <em>ICSM '98: Proceedings of the International Conference on Software Maintenance</em>, page 368, Washington, DC, USA, 1998. IEEE Computer Society.</li>
<li>D. M. Chess and S. R. White. <a href="/lib/adc06.html">An undetectable computer virus</a>. In <em>Proceedings of Virus Bulletin Conference</em>, Sept. 2000.</li>
<li>M. Christodorescu and S. Jha. Static analysis of executables to detect malicious patterns. In <em>Proceedings of USENIX Security Symposium</em>, Aug. 2003.</li>
<li>M. Christodorescu and S. Jha. Testing malware detectors. In <em>Proceedings of the 2004 ACM SIGSOFT International Symposium on Software Testing and Analysis (ISSTA 2004)</em>, pages 34-44, Boston, MA, USA, July 2004. ACM Press.</li>
<li>M. Christodorescu, S. Jha, S. A. Seshia, D. Song, and R. E. Bryant. Semantics-aware malware detection. In <em>Proceedings of the 2005 IEEE Symposium on Security and Privacy (Oakland 2005)</em>, Oakland, CA, USA, May 2005.</li>
<li>C. Cifuentes and S. Sendall. Specifying the semantics of machine instructions. In <em>6th International Workshop on Program Comprehension - IWPC'98, Ischia, Italy, June 24-26 1998</em>, pages 126-133. IEEE Computer Society, 1998.</li>
<li>F. B. Cohen. <em><a href="/lib/afc13.html">A Short Course on Computer Viruses</a></em>, 2nd Edition. Wiley, 1994.</li>
<li>C. Collberg, C. Thomborson, and D. Low. A taxonomy of obfuscating transformations. Technical Report 148, Department of Computer Science, University of Auckland, July 1997.</li>
<li>S. K. Debray, W. Evans, R. Muth, and B. D. Sutter. Compiler techniques for code compaction. <em>ACM Transactions on Programming Languages and Systems</em>, 22(2):378-415, 2000.</li>
<li>S. Ducasse, M. Rieger, and S. Demeyer. A language independent approach for detecting duplicating code. In <em>Proceedings of the International Conference of Software Maintenance</em>, pages 109-118, Sept. 1999.</li>
<li>J. Ferrante, K. J. Ottenstein, and J. D. Warren. The program dependence graph and its use in optimization. <em>ACM Trans. Program. Lang. Syst.</em>, 9(3):319-349, 1987.</li>
<li>P. Ferrie and P. Sz&ouml;r. <a href="/lib/apf47.html">Zmist opportunities</a>. <em>Virus Bullettin</em>, 2001.</li>
<li>R. Komondoor and S. Horwitz. Using slicing to identify duplication in source code. <em>Lecture Notes in Computer Science</em>, 2126, 2001.</li>
<li>K. Kontogiannis, R. DeMori, E. Merlo, M. Galler, and M.Bernstein. Pattern matching techniques for clone detection. <em>Journal of Automated Software Engineering</em>, 1996.</li>
<li>A. Lakhotia, A. Kapoor, and E. U. Kumar. Are metamorphic viruses really invincible? <em>Virus Bulletin</em>, Dec. 2004.</li>
<li>S. Muchnick. <em>Advanced Compiler Design and Implementation</em>. Morgan Kaufmann, 1997.</li>
 
<li>B. Schwarz, S. K. Debray, and G. Andrews. Plto: A link-time optimizer for the intel ia-32. In <em>Proceedings of the 2001 Workshop on Binary Translation</em>, 2001.</li>
<li>Symantec. W32.evol. http://www.symantec.com/avcenter/venc/data/w32.evol.html.</li>
</ol>
 
<hr/>
<p><a href="#b1" name="f1">1</a> By malware signature we mean peculiar sequences of bytes (usually represented by a regular expression) which characterize a specific malware with respect to any other program.</p>
<p><a href="#b2" name="f2">2</a> Code obfuscation is a set of techniques adopted for transforming a program into an equivalent one which is more difficult to understand yet it is functionally equivalent to the original.</p>
<p><a href="#b3" name="f3">3</a> The term archetype is used to describe the zero-form of a malware, i.e. the original and un-mutated version of the program from which other instances are derived.</p>
<p><a href="#b4" name="f4">4</a> Instructions are not reordered but the control flow graph is mutated with the insertion of new branches.</p>
[<a style="" href="/lib/?lang=EN&amp;index=AT#adb00">Back to index</a>] [<a href="/lib/adb00.html#disqus_thread">Comments</a>]<br/> <div id="disqus_thread"></div>
<script type="text/rocketscript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'vxheaven'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="/agreement.php">Terms of Use</a>!</small> <small>vxheaven.org aka vx.netlux.org</small></div>
<div style="margin-top: 2px; float: left;" class="adsapeu">
<script type="text/rocketscript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script>
</div>
<script data-rocketsrc="http://www.google-analytics.com/urchin.js" type="text/rocketscript"></script><script type="text/rocketscript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="/lib/index.php?lang=de&amp;id=adb00">de</a><a href="/lib/index.php?lang=en&amp;id=adb00">en</a><a href="/lib/index.php?lang=es&amp;id=adb00">es</a><a href="/lib/index.php?lang=it&amp;id=adb00">it</a><a href="/lib/index.php?lang=fr&amp;id=adb00">fr</a><a href="/lib/index.php?lang=pl&amp;id=adb00">pl</a><a href="/lib/index.php?lang=ru&amp;id=adb00">ru</a><a href="/lib/index.php?lang=ua&amp;id=adb00">ua</a></div>
</body>
</html>
