<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Jurgen Kraus 'Selbstreproduktion bei programmen' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Author" content="Jurgen Kraus"/>
<meta name="KeyWords" lang="en" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, Kraus, Jurgen,Selbstreproduktion bei programmen, text, longr, procedure, nbsp, tilde, underline, overline, vdots, loop, varphi, dots, alternative, mathbb, copy, begin"/>
<meta name="Description" content="VX Heaven site is dedicted to providing information about computer viruses (virii) and web space for virus authors and groups"/>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"047a5bcbf67431883fc9ed25fba33612",petok:"f2057ae463aed1e684de3b9a1c9acf506182ee94-1498757858-1800",zone:"vxheaven.org",rocket:"a",apps:{}}];document.write('<script type="text/javascript" src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=85b614c0f6/cloudflare.min.js"><'+'\/script>');}}catch(e){};
//]]>
</script>
<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="/style.css"/><link rel="canonical" href="http://vxheaven.org/lib/mjk00.html"/>
<script type="text/rocketscript" data-rocketsrc="https://apis.google.com/js/plusone.js">{"parsetags": "explicit"}</script>
</head>
<body bgcolor="#dbc8a0" text="#302000" link="#225599" vlink="#113366">
<div class="s1">
<div style="float:right;"><a href="/lib/index.php?tbs=1"><img src="/img/max.gif" alt="Maximize"/></a></div> <form id="lf" style="margin: 0; float: right;" method="get" action="/index.php"><input type="hidden" name="action" value="set"/><select name="lang" onchange="javascript:document.getElementById('lf').submit();"><option value="ru">Русский</option><option selected="selected" value="en">English</option><option value="ua">Українська</option><option value="de">Deutsch</option><option value="es">Español</option><option value="fr">Fran&ccedil;ais</option><option value="it">Italiano</option><option value="pl">Polski</option></select></form>
<div style="float: right;"><div id="plusone"></div></div>
<script type="text/rocketscript">gapi.plusone.render("plusone", {"size":"small","count":"true"});</script>
<div style="float: right;" class="addthis_toolbox addthis_default_style">
<script type="text/rocketscript">var addthis_config = { ui_click: true }</script>
<a style="text-decoration: none; font-size: 10pt;" href="/?action=addthis" class="addthis_button_compact">Bookmark</a>
<script type="text/rocketscript" data-rocketsrc="http://s7.addthis.com/js/250/addthis_widget.js#username=herm1t"></script>
</div>
<div style="float: right;">
<script type="text/rocketscript" data-rocketsrc="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<form action="/search.php" id="cse-search-box">
<input type="hidden" name="cx" value="002577580816726040001:z9_irkorydo"/>
<input type="hidden" name="cof" value="FORID:10"/>
<input type="hidden" name="ie" value="UTF-8"/>
<input type="text" name="q" size="12" value=" "/>
<input type="submit" name="sa" value="Search"/>
</form>
</div><h1><a href="/" style="text-decoration: none; color: #000000;">VX Heaven</a></h1>
<span class="nav"><a href="/lib/">Library</a> <a href="/vl.php">Collection</a> <a href="/src.php">Sources</a> <a href="/vx.php?id=eidx">Engines</a> <a href="/vx.php?id=tidx">Constructors</a> <a href="/vx.php?id=sidx">Simulators</a> <a href="/vx.php?id=uidx">Utilities</a> <a href="/links.php">Links</a> <a href="/donate.php" style="color: #706020" id="donate">Donate</a> <a href="/forum" style="text-decoration: underline;">Forum</a> </span><br clear="all"/>
</div>
<div class="s2"><h1>Selbstreproduktion bei programmen</h1><p><a href="/lib/?lang=de&amp;author=Kraus%2C%20Jurgen">Jurgen Kraus</a><br/> <em>Universit&auml;t Dortmund</em><br/> <em>Februar 1980</em></p><script type="text/rocketscript">var disqus_url = 'http://vxheaven.org/lib/mjk00.html';</script><div class="ci"><a href="/lib/?ci=mjk00">1</a></div><img src="/img/pdf.gif" alt="PDF"/><a href="/lib/pdf/Selbstreproduktion%20bei%20programmen.pdf">Download</a> PDF (37.66Mb) (Du musst im <a href="/forum">Forum</a> registriert sein)<br/>[<a style="" href="/lib/?lang=DE&amp;index=SR#mjk00">zurück zum Index</a>] [<a href="/lib/mjk00.html#disqus_thread">Kommentare</a>]<br/> <form method="post" action="">
<img src="/img/cache/0b9fd596a90421f9f1f68a9760275737.gif" alt="\text{T_EX size}" valign="middle"/>
<select name="TeX_size"><option value="-2">-2</option><option value="-1">-1</option><option value="0" selected="selected">0</option><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option> </select>
<input type="submit" value="Scale"/>
</form><form method="post" action=""><input type="hidden" name="pages" value="1"/><input type="submit" value="Turn on page numbers"/></form>
<img src="img/mjk00/cover.gif" alt="Selbstreproduktion bei programmen" align="left"/>
<div align="center">
<h1>Selbstreproduktion bei programmen</h1>
<p>J&uuml;rgen Kraus</p>
<p>Diplomarbeit</p>
<p>Abteilung Informatik</p>
<p>Universit&auml;t Dortmund</p>
<p>Februar 1980</p>
</div>
<br clear="all"/>
 
<p>Hiermit, erkl&auml;re ich, da&szlig; ich diese Arbeit
selbst&auml;ndig und ohne fremde Hilfe verfa&szlig;t
und keine anderen als die angegeben
Quellen und Hilfsmittel benutzt habe.</p>
<div align="right">
J. Kraus
</div>
 
<h2>Inhalt</h2>
<ul>
<li><a href="#c1">1. Einleitung</a>
<ul>
<li><a href="#c11">1.1. Motivation</a></li>
<li><a href="#c12">1.2. Definition selbstreproduzierender Programme</a></li>
</ul></li>
<li><a href="#c2">2. Existenz selbstreproduzierender Programme</a>
<ul>
<li><a href="#c21">2.1. Einleitung</a></li>
<li><a href="#c22">2.2. Definition einer einfachen Programmiersprache PL(A)</a></li>
<li><a href="#c23">2.3. Eine kontextfreie Grammatik f&uuml;r PL(A)</a></li>
<li><a href="#c24">2.4. PL(A)-berechenbare Funktionen, Church'sche These</a></li>
<li><a href="#c25">2.5. Kodierungen, G&ouml;delisierungen von <img src="/img/cache/d1cdbf2fe7e18516c3a793a652b36039.gif" alt="\cal{P}" valign="middle"/></a></li>
<li><a href="#c26">2.6. Lexikographische Ordnung von <img src="/img/cache/1304435c8bc4c0f5b8ecbe7f16727d75.gif" alt="A^*" valign="middle"/></a></li>
<li><a href="#c27">2.7. Reduktion auf jeweils eine Eingabeund eine Ausgabevariable</a></li>
<li><a href="#c28">2.8. s-m-n-Theorem, Rekursionstheorem</a></li>
</ul></li>
<li><a href="#c3">3. Selbstreproduzierende Programme in realen Programmiersprachen - Einige Beispiele</a>
<ul>
<li><a href="#c31">3.1. Einleitung</a></li>
<li><a href="#c32">3.2. Selbstreproduzierende Programme in SIMULA</a>
<ul>
<li><a href="#c321">3.2.1. Naiver Ansatz</a></li>
<li><a href="#c322">3.2.2. Textzerlegung und Algorithmus</a></li>
<li><a href="#c323">3.2.3. Ein tabellengesteuertes Programm</a></li>
<li><a href="#c324">3.2.4. Wahl der Iterationsfunktion F</a>
<ul>
<li><a href="#c3241">3.2.4.1 Eine Iterationsfunktion mittels Modulo-Bildung</a></li>
 
<li><a href="#c3242">3.2.4.2. Eine Iterationsfunktion basierend auf der G&ouml;delisierung g aus 2.5.</a></li>
</ul></li>
<li><a href="#c325">3.2.5. Win textgesteuertes SIMULA-Programm <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/></a></li>
<li><a href="#c326">3.2.6. Implernentierung des Programms <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/></a></li>
<li><a href="#c327">3.2.7. Ein prozedurgesteuertes Programm <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/></a></li>
<li><a href="#c328">3.2.8. Implementierung des Programms <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/></a></li>
</ul></li>
<li><a href="#c33">3.3. Selbstreproduzierende Programme in PASCAL</a>
<ul>
<li><a href="#c331">3.3.1. Ein textgesteuertes PASCAL-Programm <img src="/img/cache/5c65925f7761e05b8e9c7887246a532a.gif" alt="\pi_5" valign="middle"/></a></li>
<li><a href="#c332">3.3.2. Implementierung des Programms <img src="/img/cache/5c65925f7761e05b8e9c7887246a532a.gif" alt="\pi_5" valign="middle"/></a></li>
<li><a href="#c333">3.3.3. Ein prozedurgesteuertes PASCAL-Programm <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/></a></li>
<li><a href="#c334">3.3.4. Implementierung des Programms <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/></a></li>
</ul></li>
<li><a href="#c34">3.4. Selbstreproduzierende Programme in SIEMENS-Assembler</a></li>
</ul></li>
<li><a href="#c4">4. Varianten zur Selbstreproduktion von Programmen</a>
<ul>
<li><a href="#c41">4.1. Motivation</a></li>
<li><a href="#c42">4.2. Unendlich reproduzierende Programme</a>
<ul>
<li><a href="#c421">4.2.1. Implementierung des Programms <img src="/img/cache/5a48c5b9023c5bb7d43c73edec8cc3b1.gif" alt="\overset{\infty}{\pi}_0" valign="middle"/></a></li>
</ul></li>
<li><a href="#c43">4.3. Zyklisch selbstreproduzierende Programme</a>
<ul>
<li><a href="#c431">4.3.1. Implementierung des Programms <img src="/img/cache/9f903bc39a300cfd459c9ebfcef045e2.gif" alt="\overset{k}{\pi}_0" valign="middle"/></a></li>
<li><a href="#c432">4.3.2. Implementierung des Programms <img src="/img/cache/af483344a82997c8ab9e79efcf0963bd.gif" alt="\pi^{zyk}_0" valign="middle"/></a></li>
</ul></li>
<li><a href="#c44">4.4. Unter Wechsel der Programmiersprache sich zyklisch selbstreproduzierende Programme</a></li>
<li><a href="#c45">4.5. k-fach selbstreproduzierende Programme</a>
<ul>
<li><a href="#c451">4.5.1. Implementierung fon <img src="/img/cache/ffe6b5cce0427aeca812533ebe028417.gif" alt="\pi(k)" valign="middle"/></a></li>
</ul></li>
<li><a href="#c46">4.6. Reproduktionshierarchie bei Programmen</a></li>
</ul></li>
 
<li><a href="#c5">5. Selbstreproduzierende Programme mit Zusatzeigenschaften</a>
<ul>
<li><a href="#c51">5.1. Einleitung</a></li>
<li><a href="#c52">5.2. Selbstreproduktionssatz f&uuml;r die Programmiersprache PASCAL</a></li>
<li><a href="#c53">5.3. Selbstreproduktionssatz f&uuml;r die Programmiersprache SIMULA</a></li>
</ul></li>
<li><a href="#c6">6. Selbstreproduktion bei <strong>loop</strong>-Programmen</a>
<ul>
<li><a href="#c61">6.1. Einleitung</a></li>
<li><a href="#c62">6.2. Definition der Programmiersprache LP(A)</a></li>
<li><a href="#c63">6.3. Eine kontextfreie Grammatik f&uuml;r LP(A)</a></li>
<li><a href="#c64">6.4. Erweiterung der Sprache LP(A)</a></li>
<li><a href="#c65">6.5. Selbstreproduzierende Programme in <img src="/img/cache/49bebbff33cd93d792ebb447aefa2e78.gif" alt="\overline{\text{LP(A)}}" valign="middle"/></a></li>
<li><a href="#c66">6.6. Selbstreproduktionssatz f&uuml;r <img src="/img/cache/49bebbff33cd93d792ebb447aefa2e78.gif" alt="\overline{\text{LP(A)}}" valign="middle"/>-programme</a></li>
</ul></li>
<li><a href="#c7">7. Leben bei Programmen?</a>
<ul>
<li><a href="#c71">7.1. Einleitung</a></li>
<li><a href="#c72">7.2. Biologisches Leben</a></li>
<li><a href="#c73">7.3. Selbstreproduzierende Programme und Leben</a></li>
<li><a href="#c74">7.4. Selbstreproduzierende Programme und Viren</a></li>
</ul></li>
<li><a href="#c8">8. Modelle f&uuml;r konkurrierendes Verhalten selbstreproduzierender Programme</a>
<ul>
<li><a href="#c81">8.1. Motivation</a></li>
<li><a href="#c82">8.2. Ein einfaches Grundmodell</a>
<ul>
<li><a href="#c821">8.2.1. Informelle Beschreibung von MOD1</a></li>
 
<li><a href="#c822">8.2.2. MOD1 als SIMULA-Programm</a></li>
<li><a href="#c823">8.2.3. Absichten von MOD1</a></li>
<li><a href="#c824">8.2.4. Einige Aspekte des SIMULA-Programms f&uuml;r MOD1</a></li>
</ul></li>
<li><a href="#c83">8.3. Ein Modell mit konkurrierenden Verhalten</a>
<ul>
<li><a href="#c831">8.3.1. Informelle Beschreibung von MOD2</a></li>
<li><a href="#c832">8.3.2. M0D2 als SIMULA-Programm</a></li>
<li><a href="#c833">8.3.3. Einige Aspekte des SIMULA-Programms f&uuml;r MOD2</a></li>
</ul></li>
</ul></li>
<li><a href="#c9">9. Evolution bei Programmen</a>
<ul>
<li><a href="#c91">9.1. Motivation</a></li>
<li><a href="#c92">9.2. Ein Modell MOD3 f&uuml;r Evolution selbstreproduzierender Programme</a>
<ul>
<li><a href="#c921">9.2.1. Informelle Beschreibung von MOD3</a></li>
<li><a href="#c922">9.2.2. M0D3 als SIMULA-Programm</a></li>
<li><a href="#c923">9.2.3. Einige Aspekte des SIMULA-Programms f&uuml;r MOD3</a></li>
</ul></li>
</ul></li>
<li><a href="#cl">Literaturverzeichnis</a></li>
<li>Anhang</li>
<li>Anhang A</li>
<li>Anhang A. 1.</li>
<li>Anhang A. 2.</li>
<li>Anhang A. 3.</li>
<li>Anhang A. 4.</li>
<li>Anhang A. 5.</li>
 
<li>Anhang A. 6.</li>
<li>Anhang A. 7.</li>
<li>Anhang A. 8.</li>
<li>Anhang A. 9.</li>
<li>Anhang A. 10.</li>
<li>Anhang A. 11.</li>
<li>Anhang A. 12.</li>
<li>Anhang B</li>
<li>Anhang B. 1.</li>
<li>Anhang B. 2.</li>
<li>Anhang B. 3.</li>
<li>Anhang B. 4.</li>
<li>Anhang C</li>
<li>Anhang C. 1.</li>
<li>Anhang C. 2.</li>
<li>Anhang C. 3.</li>
</ul>
<p>Alle in der vorliegenden Diplomarbeit vorkommenden Beispielprogramme
wurden auf dem SIEMENS-Rechner, Typ 7738,
der Abteilung Informatik an der Universit&auml;t Dortmund gerechnet.</p>
 
<h2><a name="c1"></a>1. Einleitung</h2>
<h3><a name="c11"></a>1.1. Motivation</h3>
<p>Die Erde, wie sie sich heute pr&auml;sentiert, ist mit einer
F&uuml;lle von Lebensformen ausgestattet. In vergangenen Zeitepochen
hat es schon Leben gegeben. Zum Teil handelte es
sich dabei um die gleichen Formen wie heute, zum Teil um
ausgestorbene Arten. Die Biologie hat alle bekannten Lebensformen
in ein einheitliches System gestellt. So unterschiedlich
die einzelnen Lebensformen auch sind, so
entsprechen sie doch einem gemeinsamen Prinzip: Jedes Lebewesen
ist aus Zellen aufgebaut. Zellen, die Grundeinheiten
des Lebens, sind h&ouml;chst komplexe biochemische Apparate.
Auf Grund der Abstammungslehre mu&szlig; es irgendwann in
der Erdgeschichte eine erste Zelle gegeben haben. Diese
Zelle hat sich als Ergebnis der chemischen Evolution auf
der Erde herangebildet und wurde zum Ausgangspunkt der
biologischen Evolution. Die Frage, wie es zu den ersten
Zellen auf der Erde und somit zu den ersten Lebensformen
kommen konnte, l&auml;&szlig;t sich im gro&szlig;en und ganzen mit Hilfe
von Experimenten und der Wahrscheinlichkeitsrechnung kl&auml;ren
[13]. Das Ergebnis ist, da&szlig; Entwicklung und Existenz
von Leben praktisch als Konsequenzen der Komplexit&auml;t
der Verh&auml;ltnisse auf der Fr&uuml;herde anzusehen sind.
Sieht man diese Auffassung als richtig an, so ist es
durchaus denkbar, da&szlig; sich auch in anderen gen&uuml;gend komplexen
"Welten" Leben <sup><a href="#p001_1" name="b001_1">1)</a></sup> entwickeln kann oder diese "Welten"
zumindest eine Existenzm&ouml;glichkeit f&uuml;r bestimmte Formen
von Leben bieten.</p>
<p>Die Computertechnik hat in den letzten zwei Jahrzehnten
gewaltige Fortschritte gemacht. Die Entwicklung immer
 
neuerer und leistungsf&auml;higerer elektronischer Bauelemente
erm&ouml;glicht den Bau von digitalen Rechenanlagen, deren Kapazit&auml;t
noch vor wenigen Jahren Utopie gewesen w&auml;re. Durch
Zusammenschaltung mehrerer Rechenanlagen bis hin zu &uuml;berregionalen
Rechnernetzen [21] ist es m&ouml;glich, die Kapazit&auml;t
weiter zu steigern. Dem Benutzer stehen somit Systeme
zur Verf&uuml;gung, die er kaum noch &uuml;berblicken kann. So
wird z.B. die Verwaltung von Rechnernetzen durch Hilfscomputer
vorgenommen. Insgesamt gibt es also heute schon Rechenanlagen,
die wie ein Universum - bestehend aus Schaltkreisen
und Bits - wirken. Die Komplexit&auml;t solcher Rechenanlagen
erinnert durchaus an die Komplexit&auml;t auf der Fr&uuml;herde,
ist die Vorstellung richtig, da&szlig; die Entstehung bzw.
die Existenz von Leben eine Folge der Komplexit&auml;t ist, so
w&auml;re die spekulative Idee von Leben auf Computerebene zumindest
denkbar. Bei der Vorstellung, wie ein solches Leben
aussehen k&ouml;nnte, kann man sich nur am gegenw&auml;rtigen
biologischen Leben orientieren, da es das einzig bekannte
Leben &uuml;berhaupt ist. Eingangs haben wir die Zelle als
Grundelement des biologischen Lebens angef&uuml;hrt. Ohne Kapitel
7 vorgreifen zu wollen, seien hier die F&auml;higkeit zur
identischen Reproduktion auf eigene Veranlassung (Autoreproduktion)
und die M&ouml;glichkeit zur fehlerhaften Reproduktion
(Mutation) als zwei ckarakteristische Eigenschaften
lebender Zellen genannt. Im Hinblick auf diese beiden Eigenschaften
scheinen sich auf Computerebene selbstreproduzierende
Programme als brauchbares Analogon zu lebenden
Zellen zu erweisen. Wir werden in 1.2. selbstreproduzierende
Programme als Programme definieren, die in der Lage
sind, ihren eigenen Programmtext w&auml;hrend ihrer Laufzeit
auszugeben, ohne da&szlig; ihnen dazu der "Bauplan" ihres Textes
von au&szlig;erhalb mitgeteilt werden mu&szlig;. Da elektronische
Rechenanlagen nicht hundertprozentig fehlerfrei arbeiten,
ist die M&ouml;glichkeit einer fehlerhaften Ausgabe des Programmtextes,
also einer Mutation, automatisch immer vorhanden.
Selbstreproduzierende Programme k&auml;men also als
Tr&auml;ger von Leben auf Computerebene durchaus in Frage.</p>
<p>Hauptaufgabe dieser Arbeit ist es nicht nur, die Existenz
 
selbstreproduzierender Programme zu beweisen (Kapitel 2),
sondern konkrete Beispiele f&uuml;r selbstreproduzierende Programme
in verschiedenen Programmiersprachen anzugeben
(Kapitel 3 und 6) und deren Eigenschaften zu diskutieren
(Kapitel 4 und 5). Reproduktion und Mutation sind Eigenschaften,
die zur Evolution bef&auml;higen. Evolution tritt ein,
wenn Selektion als zus&auml;tzliche Komponente mitwirkt. Evolution
ist die Ursache f&uuml;r die unerh&ouml;rte Artenf&uuml;lle irdischen
Lebens und m&uuml;&szlig;te auch bei selbstreproduzierenden Programmen
zu immer neuen Programmen mit verschiedensten Eigenschaften
f&uuml;hren. Einige Modelle zur Evolution selbstreproduzierender
Programme werden in den Kapiteln 8 und 9 er&ouml;rtert. Zuvor
wird jedoch in Kapitel 7 die Frage untersucht werden, inwieweit
sich selbstreproduzierende Programme in der "Umwelt"
Rechner wirklich mit lebenden Zellen vergleichen lassen.</p>
<h3><a name="c12"></a>1.2. Definition selbstreproduzierender Programme</h3>
<p>Die vorliegende Arbeit handelt in erster Linie von Programmen
und den. Programmiersprachen, denen diese angeh&ouml;ren. Um
pr&auml;zise zu sein, m&uuml;&szlig;te daher an dieser Stelle definiert werden,
was unter einer Programmiersprache zu verstehen ist,
wie Programme in einer jeweiligen konkreten Programmiersprache
aufgebaut sind (Syntax) und wie ein konkretes Programm
auf einer konkreten Rechenmaschine zu interpretieren ist
(Semantik) (vgl. etwa [9] [14]). Derartige Definitionen
w&uuml;rden sicher den Rahmen dieser Arbeit sprengen. In Kapitel
2 werden sie jedoch wenigstens ansatzweise f&uuml;r die
abstrakte Programmiersprache PL durchgef&uuml;hrt. Bei konkreten
Programmiersprachen wird bzgl. der Syntax auf die jeweiligen
Arbeiten verwiesen, in denen die Syntax beschrieben
ist. Im Hinblick auf die Semantik wird sich der Begriff der
von einem Programm realisierten Funktion als ausreichend
erweisen (vgl.(5.1.1)). Im &uuml;brigen setzt die Arbeit voraus,
da&szlig; der Leser mit dem in der Informatik &uuml;blichen Sprachgebrauch
bzgl. Programmen und Programmiersprachen vertraut
ist.
 
Konkrete Programmiersprachen lassen sich allgemein in h&ouml;here
Programmiersprachen und in Assembler-Sprachen differenzieren.
Im Hinblick auf Selbstreproduktion sind folgende
Charakteristika wesentlich.</p>
<dl>
<dt>Assembler-Sprachen</dt>
<dd>sind direkte Produkte der jeweiligen Maschinenstruktur
und lassen sich deshalb als maschinenorientiert bezeichnen.
Viele Kennzeichen einer konkreten Rechenanlage
lassen sich an der zugeh&ouml;rigen Assembler-Sprache
ablesen, unter anderem auch die Struktur des Arbeitsspeichers,
auf den Assembler-Programme zugreifen k&ouml;nnen.
Ausf&uuml;hrbare Assembler-Programme befinden sich in
der Form ihres Maschinenkodes im Arbeitsspeicher.
W&auml;hrend der Laufzeit k&ouml;nnen. Assembler-Programme also
auf ihren eigenen Maschinenkode zugreifen und ihn
auch verarbeiten.</dd>
<dt>H&ouml;here Programmiersprachen</dt>
<dd>sind Programmiersprachen, die die physikalische Struktur
des Rechners unber&uuml;cksichtigt lassen und somit
auch nicht an eine feste Rechenanlage gebunden sind.
Auf der Ebene von h&ouml;heren Programmiersprachen gibt es
daher auch in der Regel keine Zugriffsm&ouml;glichkeit auf
den Arbeitsspeicher des jeweiligen Rechners. Programme
in h&ouml;heren Programmiersprachen haben also nicht die
M&ouml;glichkeit, ihren eigenen Maschinenkode zu lesen und
zu verarbeiten.</dd>
</dl>
<p>Programme werden im allgemeinen mit den von ihnen berechneten
Funktionen identifiziert. F&uuml;r die vorliegende Arbeit
ist jedoch ein anderer Aspekt von Programmen ebenso wichtig:</p>
<blockquote>Programme sind endliche Zeichenketten, also Texte.</blockquote>
<p>Im Verlauf seiner Verarbeitung durch den Rechner liegt ein
und dasselbe Programm als unterschiedlicher Text &uuml;berverschiedenen
 
Alphabeten vor. Ein Programm in Assembler-Sprache
unterscheidet sich textuell von seiner &Uuml;bersetzung
in Maschinenkode. W&auml;hrend Assembler-Programme zun&auml;chst
alphanumerische Texte darstellen, sind Programme
in Maschinenkode nur aus den 16 Hexadezimalziffern 0 bis
F aufgebaut. &Auml;hnlich liegen die Verh&auml;ltnisse bei h&ouml;heren
Programmiersprachen. Zwischen dem Quellprogramm in h&ouml;herer
Programmiersprache und dem Objektprogramm im Maschinenkode
liegen unter Umst&auml;nden jedoch noch ein oder mehrere
&Uuml;bergangsformen in irgendwelchen Zwischenkodes.</p>
<p>Gem&auml;&szlig; den unterschiedlichen Charakterisierungen f&uuml;r h&ouml;here
Programmiersprachen und Assembler-Sprachen weisen
die Definitionen f&uuml;r selbstreproduzierende Programme in
diesen beiden Sprachebenen Unterschiede auf.</p>
<p>Sei zun&auml;chst S eine h&ouml;here Programmiersprache im &uuml;blichen
Sinn.</p>
<p><strong>(1.2.1) Definition:</strong> Sei <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> ein (syntaktisch korrektes)
Programm aus S.</p>
<ol type="i">
<li>Weist <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> keine Eingabe auf, so hei&szlig;t <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> (streng)
<strong>selbstreproduzierend</strong>, falls <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> (genau) seinen
Programmtext in S ausgibt.</li>
<li>Weist <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> Eingabe auf, so hei&szlig;t <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> (streng)
<strong>selbstreproduzierend</strong>, falls <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> bei <strong>jeder</strong>
zul&auml;ssigen Eingabe (genau) seinen Programmtext
in S ausgibt.</li>
</ol>
<p>Definition (1.2.1) schlie&szlig;t also selbstreproduzierende Programme
mit Eingabe nicht grunds&auml;tzlich aus, verhindert jedoch,
da&szlig; der Eingabe Informationen entnommen werden, die
zur Selbstreproduktion ben&ouml;tigt werden; da die Selbstreproduktion
bei jeder Eingabe erfolgt, erfolgt sie unabh&auml;ngig von der Eingabe.</p>
<p>Sei nun M eine zu einer konkreten Rechenanlage geh&ouml;rige
 
Assem&uuml;er-Sprache. Die Definition f&uuml;r selbstreproduzierende
Assembler-Programme spiegelt die Tatsache wider, da&szlig;
Assembler-Programme ihren eigenen Maschinenkode lesen k&ouml;nnen.</p>
<p><strong>(1.2.2) Definition:</strong> Sei <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> ein g&uuml;ltiges Programm aus der Assembler-Sprache M.</p>
<ol type="i">
<li>Weist <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> keine Eingabe auf, so hei&szlig;t <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> (streng)
<strong>selbstreproduzierend</strong>, falls <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> (genau) seinen
Maschinenkode ausgibt oder innerhalb des Arbeitsspeichers kopiert.</li>
<li>Weist <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> Eingabe auf, so hei&szlig;t <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> (streng)
<strong>selbstreproduzierend</strong>, falls <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> bei jeder Eingabe
(genau) seinen Maschinenkode ausgibt oder innerhalb des Arbeitsspeichers kopiert.</li>
</ol>
<p>Im Gegensatz zu h&ouml;heren Programmiersprachen brauchen die
Kopien selbstreproduzierender Assembler-Programme vor der
Ausf&uuml;hrung nicht in Maschinenkode &uuml;bersetzt zu werden.
Abb. 1.2.A zeigt die Unterschiede, die sich im Hinblick
auf Selbstreproduktion zwischen h&ouml;heren Programmiersprachen
und Assembler-Sprachen ergeben, im Zusammenhang.</p>
<p>Aus der Tatsache, da&szlig; Assembler-Programme ihren eigenen
Maschinenkode im Arbeitsspeicher lesen k&ouml;nnen, l&auml;&szlig;t sich bei einiger
Kenntnis von Assembler-Sprachen leicht die Existenz
selbstreproduzierender Assembler-Programme folgern. Auch die
Angabe von Beispielen f&uuml;r seibstreproduzierende Assembler-Programme
f&auml;llt nicht schwer (Abschnitt 3.4.). Anders liegen
jedoch die Verh&auml;ltnisse bei h&ouml;heren Programmiersprachen.
Hier ist die Existenz selbstreproduzierender Programme durchaus
nicht intuitiv klar und mu&szlig; daher in Kapitel 2 auf theoretischem
Weg nachgewiesen werden. Auch die Angabe von realisierbaren
Beispielen ist bedeutend schwieriger als bei
Assembler-Sprachen. Ganz allgemein liegen im Hinblick auf
Selbstreproduktion die Verh&auml;ltnisse bei Assembler-Sprachen
einfacher als bei h&ouml;heren Programmiersprachen. Aus diesem
Grund besch&auml;ftigen sich die Kapitel 3, 4 und 5 fast ausschlie&szlig;lich
mit der Selbstreproduktion bei h&ouml;heren Programmiersprachen.</p>
 
<table border="1" summary="">
<tr><th>H&ouml;here Programmier sprachen</th><th>Assembler-sprachen</th></tr>
<tr><td>Programme k&ouml;nnen Arbeitsspeicher nicht lesen <div align="center"><img src="/img/cache/4d69c6b2bcfc3559f2790a0c8ba18b43.gif" alt="\Downarrow" valign="middle"/></div></td><td>Programme k&ouml;nnen Arbeitsspeicher und damit ihren eigenen Maschinenkode lesen<div align="center"><img src="/img/cache/4d69c6b2bcfc3559f2790a0c8ba18b43.gif" alt="\Downarrow" valign="middle"/></div></td></tr>
<tr><td>Selbstreproduktion <img src="/img/cache/f7a5d162a03dd05e03147acd5c9f5037.gif" alt="\hat=" valign="middle"/> Erzeugung des Quellprogramms in der h&ouml;heren Programmiersprache<div align="center"><img src="/img/cache/4d69c6b2bcfc3559f2790a0c8ba18b43.gif" alt="\Downarrow" valign="middle"/></div></td><td>Selbstreproduktion <img src="/img/cache/f7a5d162a03dd05e03147acd5c9f5037.gif" alt="\hat=" valign="middle"/> Erzeugung direkter Kopie des Maschinenkodes<div align="center"><img src="/img/cache/4d69c6b2bcfc3559f2790a0c8ba18b43.gif" alt="\Downarrow" valign="middle"/></div></td></tr>
<tr><td>&Uuml;bersetzung der Kopie erforderlich</td><td>Keine &Uuml;bersetzung der Kopie erforderlich</td></tr>
</table>
<p><strong>Abb. 1.2.A</strong></p>
 
<h2><a name="c2"></a>2. Existenzselbstreproduzierender Programme</h2>
<h3><a name="c21"></a>2.1. Einleitung</h3>
<p>In diesem Kapitel soll auf theoretischem Weg die Existenz
selbstreproduzierender Programme in h&ouml;heren Programmiersprachen
nachgewiesen werden. Wir werden dabei nicht mit
Hilfe von realen Programmiersprachen (PASCAL,SIMULA,ALGOL
etc.) und deren vielen Eigenarten argumentieren. Statt
dessen definieren wir, soweit das in diesem Rahmen m&ouml;glich
ist, eine eigene einfache Programmiersprache, die sich
durch besonders einfache Datentypen und allgemein in h&ouml;heren
Programmiersprachen benutzte Konstruktionsprinzipien
auszeichnet. Diese Programmiersprache wird PL hei&szlig;en. Trotz
ihrer Einfachheit wird PL die gleiche "Berechenkapazit&auml;t"
haben wie alle g&auml;ngigen Programmiersprachen. PL wird sich
als geeigneter Einstieg in die Theorie der "berechenbaren
Funktionen" erweisen. Diese Theorie werden wir nur soweit
verfolgen, wie es zum Nachweis selbstreprcduzierender Programme
in PL notwendig ist.</p>
<p>Da alle g&auml;ngigen Programmiersprachen die gleiche "Berechenkapazit&auml;t"
wie PL haben, l&auml;&szlig;t sich aus der Existenz
selbstreproduzierender Programme in PL die Existenz
selbstreproduzierender Programme in realen Programmiersprachen -
sowohl in h&ouml;heren Programmiersprachen als auch in Assembler-Sprachen - folgern.</p>
<h3><a name="c22"></a>2.2. Definition einer einfachen Programmiersprache PL(A)</h3>
<p>Grundlage ist zun&auml;chst ein beliebiges, aber festes, endliches
Alphabet <img src="/img/cache/1646d92adf407dff954724cda1ced6e4.gif" alt="A=\{a_1,\dots,a_n\}, n\in\mathbb{N}" valign="middle"/>. Die Menge <img src="/img/cache/1304435c8bc4c0f5b8ecbe7f16727d75.gif" alt="A^*" valign="middle"/> aller endlichen
W&ouml;rter &uuml;ber <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/> stellt die Menge der <strong>Daten</strong> dar, auf denen
Programme in PL arbeiten. Das leere Wort <img src="/img/cache/db5f55e5ec1591ece86e5a5930f36bfc.gif" alt="\varepsilon \in A^*" valign="middle"/> ist dabei als
Datum zugelassen.</p>
<p><strong>(2.2.1) Definition (Ausdr&uuml;cke):</strong></p>
<ol type="i">
<li>Die <strong>Konstanten</strong> in PL sind die Elemente von <img src="/img/cache/1304435c8bc4c0f5b8ecbe7f16727d75.gif" alt="A^*" valign="middle"/>.</li>
 
<li>Die <strong>Variablen</strong> <img src="/img/cache/2b3b3265d85ef4c76421d1d087bb6e3e.gif" alt="X_1,X_2,\dots,Y,Z,W" valign="middle"/> sind Elemente
aus einer festen Menge VR. Jede Variable kann
Werte aus <img src="/img/cache/1304435c8bc4c0f5b8ecbe7f16727d75.gif" alt="A^*" valign="middle"/> annehmen.</li>
<li><strong>Operationen</strong> sind Xa und <img src="/img/cache/eb88fb4613df9411580f357327336fb4.gif" alt="\cal{P}(X)" valign="middle"/> f&uuml;r jedes <img src="/img/cache/e240f1a1ecee6cf874a2ae136a9af13a.gif" alt="X \in VR, a \in A" valign="middle"/>.
<p><strong>Bedeutung:</strong></p>
<p>Xa hat den Wert xa, falls <img src="/img/cache/ac4df3d19e82c7cf1e3bd5a674171e19.gif" alt="x \in A^*" valign="middle"/> der Wert
von X ist.</p>
<p><img src="/img/cache/eb88fb4613df9411580f357327336fb4.gif" alt="\cal{P}(X)" valign="middle"/> hat den Wert <img src="/img/cache/ac4df3d19e82c7cf1e3bd5a674171e19.gif" alt="x \in A^*" valign="middle"/>, falls xa der Wert
von X ist f&uuml;r ein Element <img src="/img/cache/026638d7828e8287894f1cccedfaee9c.gif" alt="a \in A" valign="middle"/>. Andernfalls
hat <img src="/img/cache/eb88fb4613df9411580f357327336fb4.gif" alt="\cal{P}(X)" valign="middle"/> den Wert <img src="/img/cache/92e4da341fe8f4cd46192f21b6ff3aa7.gif" alt="\epsilon" valign="middle"/>.</p>
</li>
<li><strong>Bedingiqngen</strong> haben die Form <img src="/img/cache/278f73c754f687ede306acfccb1c2010.gif" alt="\omega(X)=a" valign="middle"/> oder <img src="/img/cache/2bd836c530ad4208d8c3fd603747102e.gif" alt="X=\epsilon" valign="middle"/>
mit <img src="/img/cache/b8ee23d2cfffbf0f40fc731fe59a7938.gif" alt="X \in VR" valign="middle"/> und <img src="/img/cache/026638d7828e8287894f1cccedfaee9c.gif" alt="a \in A" valign="middle"/>.
<p><strong>Bedeutung:</strong></p>
<p><img src="/img/cache/278f73c754f687ede306acfccb1c2010.gif" alt="\omega(X)=a" valign="middle"/> ist genau dann wahr, wenn a der
letzte Buchstabe des Wertes der Variablen
X ist. <img src="/img/cache/2bd836c530ad4208d8c3fd603747102e.gif" alt="X=\epsilon" valign="middle"/> ist genau dann wahr, wenn <img src="/img/cache/92e4da341fe8f4cd46192f21b6ff3aa7.gif" alt="\epsilon" valign="middle"/> der
Wert von X ist.</p>
</li>
</ol>
<p><strong>(2.2.2) Definition (Grundanweisungen):</strong></p>
<p>Die <strong>Grundanweisungen</strong> in PL sind:</p>
<img src="/img/cache/6d4937d6a21871f5b52b013652942e1d.gif" alt="
\begin{align}
	&amp;&amp;\text{Die leere Anweisung}	&amp;&amp;&amp;\gamma_1 :\ \ \overline\epsilon\\
	&amp;&amp;\text{und die Wertzuweisungen}&amp;&amp;&amp;\gamma_2 :\ \ X:=\epsilon\\
	&amp;&amp;				&amp;&amp;&amp;\gamma_3 :\ \ X:=Xa\\
	&amp;&amp;				&amp;&amp;&amp;\gamma_4 :\ \ X:=Y\\
	&amp;&amp;				&amp;&amp;&amp;\gamma_5 :\ \ X:=\cal{P}(X),
\end{align}
" valign="middle"/>
<p>f&uuml;r alle Variablen X und Y aus VR und <img src="/img/cache/026638d7828e8287894f1cccedfaee9c.gif" alt="a \in A" valign="middle"/>.</p>
<p><strong>(2.2.3) Definition (Kontrollstrukturen):</strong></p>
<p>Die <strong>Kontrollstrukturen</strong> in PL sind:</p>
<p><img src="/img/cache/e87c643b9f769cb45ddf85558c14bbb9.gif" alt="\chi_1:\ \ P;Q" valign="middle"/></p>
<p><strong>Bedeutung:</strong></p>
<p>Hintereinanderausf&uuml;hrung von Anweisungen.</p>
<p>Vergleiche &uuml;bliche Programmiersprachen.</p>
 
<p><img src="/img/cache/50bcc348140240ed7fd3c50ea325281a.gif" alt="\chi_2:\ \ \text{\underline{if} p \underline{then goto} L}" valign="middle"/></p>
<p><strong>Bedeutung:</strong></p>
<p><img src="/img/cache/08188712f92f9e9f72d0f5d3f2f52369.gif" alt="\chi_2" valign="middle"/> stellt einen bedingten Sprung dar. p steht
f&uuml;r eine Bedingung (vgl. (2.2.1)(iv)).</p>
<p>L ist eine Marke (vgl. (2.2.4)).</p>
<p>Ansonsten wie in &uuml;blichen Programmiersprachen.</p>
<p><img src="/img/cache/4191758e88f020891a9d339efb2fc05f.gif" alt="\chi_3:\ \ \text{\underline{if} p \underline{then} P \underline{else} Q \underline{fi}}" valign="middle"/></p>
<p><strong>Bedeutung:</strong></p>
<p>Verzweigung; p ist eine Bedingung. Die Anweisungen P und Q stellen die Alternativen dar.
Vergleiche &uuml;bliche Programmiersprachen.</p>
<p><img src="/img/cache/9fd664e07611517e352605b4ab53724f.gif" alt="\chi_4:\ \ \text{\underline{while} X=\epsilon\ \underline{do} P \underline{od}}" valign="middle"/></p>
<p><strong>Bedeutung:</strong></p>
<p><strong>while</strong>-Schleife; Bedingungen der Form <img src="/img/cache/c279164c67196623db9e8ead40acdc22.gif" alt="\omega(X)=a, X \in VR, a \in A" valign="middle"/>,
sind nicht erlaubt. P ist eine Anweisung. Ansonsten wie in &uuml;blichen Programmiersprachen.</p>
<img src="/img/cache/de123209c882c4f289736034b1bff544.gif" alt="
\begin{array}{rccclBCB}
\chi_5:\ \ \text{\underline{loop} X
		\underline{case}}	&amp; a_1 		&amp; \longr	&amp; P_1,\\
					&amp; \vdots	&amp; \ \ \ \ \ \	&amp; \vdots\\
					&amp; a_n		&amp; \longr	&amp; P_n,\\
		\text{\underline{end}}	&amp;		&amp;		&amp;
\end{array}
" valign="middle"/>
<p><img src="/img/cache/ebe0bb3dfbd23c5c966b1381c166dbcf.gif" alt="\chi_5" valign="middle"/> stellt eine <strong>loop</strong>-Schleife mit Fallunterscheidung
dar. Bei der Auswertung wird zun&auml;chst eine
interne Kopie der Variablen X angelegt. Danach
wird der Wert von X von links nach rechts durchlaufen.
F&uuml;r jeden Buchstaben (d.h. Element aus A)
<img src="/img/cache/e045635af82f8f48986a6e931cb70b8f.gif" alt="a_j" valign="middle"/> des Wertes von X wird die zugeh&ouml;rige Anweisung
<img src="/img/cache/7f57ce5c29b329529f4e3f9a3765b114.gif" alt="P_j" valign="middle"/> ausgef&uuml;hrt. Fehlt f&uuml;r einen Buchstaben
<img src="/img/cache/e045635af82f8f48986a6e931cb70b8f.gif" alt="a_j" valign="middle"/> die Vorschrift <img src="/img/cache/85b0602558644e7cf307f725142cad8a.gif" alt="a_j \longr P_j" valign="middle"/> in der Liste der
Alternativen, so wird so verfahren, als w&uuml;rde in
der Liste <img src="/img/cache/936abddf1a919ffb80e033d251d6147d.gif" alt="a_j \longr \overline\epsilon" valign="middle"/> stehen, <img src="/img/cache/f5bc850edd04bca36e7f9253554bbeb6.gif" alt="j \in [n]" valign="middle"/>.</p>
<p><strong>(2.2.4) Definition (Marken):</strong></p>
<p><strong>Marken</strong> sind Elemente aus einer festen Menge
 
<img src="/img/cache/390853a6d73ddfd0d80db3f548d695f9.gif" alt="M = \{L_1,L_2,\dots\}" valign="middle"/>. Eine Marke kann in der Form
<img src="/img/cache/2ca555e85c6aa5d1ffd469bdfa4500bc.gif" alt="L\ :\ P" valign="middle"/> vor jeder Anweisung P stehen.</p>
<p><strong>(2.2.5) Definition (Anweisung):</strong></p>
<p>Eine <strong>Anweisung</strong> in PL ist entweder eine Grundanweisung,
oder sie besteht aus Grundanweisungen, die
mittels der Kontrollstrukturen <img src="/img/cache/f3b0e9b118a636ca97aece99d4d699be.gif" alt="\chi_1" valign="middle"/> bis <img src="/img/cache/ebe0bb3dfbd23c5c966b1381c166dbcf.gif" alt="\chi_5" valign="middle"/> miteinander
verkn&uuml;pft sind.</p>
<p><strong>(2.2.6) Definition (PL-Programme):</strong></p>
<p>Ein Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> in PL hat die Form</p>
<img src="/img/cache/4ef09c40c9ad6b453e939ef30b4697fd.gif" alt="
\begin{array}{rccclBCB}
	\pi = \text{\underline{input}}	&amp; X_1,		&amp;\dots,X_r;\\
					&amp; AW_\pi;	&amp;\\
	\text{\underline{output}}	&amp; Z_1,		&amp;\dots,Z_s	&amp; r \ge 0, s\ge 0
\end{array}
" valign="middle"/>
<p>wobei <img src="/img/cache/aafc0430452071887da8c26f9bfa060c.gif" alt="AW_\pi" valign="middle"/> eine Anweisung ist.</p>
<p>Die paarweise verschiedenen Variablen <img src="/img/cache/68e10b59f96f10a94b324c2279ed5918.gif" alt="X_1,\dots,X_r \in VR" valign="middle"/> hei&szlig;en <strong>Eingabevariable</strong>.</p>
<p>Die paarweise verschiedenen Variablen <img src="/img/cache/6cb597082703d42138499bc055efb770.gif" alt="Z_1,\dots,Z_s \in VR" valign="middle"/> hei&szlig;en <strong>Ausgabevariable</strong>.</p>
<p>Tritt in <img src="/img/cache/aafc0430452071887da8c26f9bfa060c.gif" alt="AW_\pi" valign="middle"/> die Kontrollstruktur <img src="/img/cache/75fb026f9e9e3cf9dac5e94d9bed1302.gif" alt="\chi_2 :\ \ \text{\underline{if} p \underline{then goto} L" valign="middle"/>
auf, so darf L in <img src="/img/cache/aafc0430452071887da8c26f9bfa060c.gif" alt="AW_\pi" valign="middle"/> nur einmal in der Form <img src="/img/cache/2ca555e85c6aa5d1ffd469bdfa4500bc.gif" alt="L\ :\ P" valign="middle"/> auftreten, wobei P eine Anweisung ist.</p>
<p><strong>(2.2.7) Definition (Ausf&uuml;hrung von PL-Programmen):</strong></p>
<p>Die Ausf&uuml;hrung eines Programms <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> in PL beginnt damit,
da&szlig; die Eingabevariablen <img src="/img/cache/a45fe3def7e5bcae37f581ed1fc279d0.gif" alt="X_1,\dots,X_r" valign="middle"/> mit Eingabewerten
belegt werden. Alle anderen in <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> vorkommenden
Variablen werden mit <img src="/img/cache/92e4da341fe8f4cd46192f21b6ff3aa7.gif" alt="\epsilon" valign="middle"/> initialisiert. Danach
wird <img src="/img/cache/aafc0430452071887da8c26f9bfa060c.gif" alt="AW_\pi" valign="middle"/> ausgef&uuml;hrt. Nach Ausf&uuml;hrung von <img src="/img/cache/aafc0430452071887da8c26f9bfa060c.gif" alt="AW_\pi" valign="middle"/> liegt
das Ergebnis der Programmausf&uuml;hrung in Form der
Werte der Ausgabevariablen <img src="/img/cache/5b53920373d483f42a5797b3c6a47a44.gif" alt="Z_1,\dots,Z_s" valign="middle"/> vor.
H&auml;lt das Programm nie an, so ist das Ergebnis von
<img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> undefiniert.</p>
<p><strong>(2.2.8)</strong> Bezeichnung: Prinzipiell haben wir hier nicht genau
 
eine Programmiersprache PL definiert, sondern eine
Klasse von Programmiersprachen. Das liegt daran,
da&szlig; wir noch Freiheit haben in der Wahl der Mengen
VR und L und insbesondere in der Wahl des Alphabets
A. W&auml;hrend die Elemente von VR und L nur programminterne
Bezeichnungen darstellen, bestimmt das Alphabet
A die Datenmenge, auf der PL-Programme arbeiten.
Je nachdem, welches endliche Alphabet A wir
zugrunde legen, werden wir in Zukunft die in den
Definitionen (2.2.1) bis (2.2.7) definierte Programmiersprache
mit <strong>PL(A)</strong> bezeichnen.</p>
<p><strong>(2.2.9) Bemerkung:</strong> Streng genommen haben wir keine formale
Definition von PL(A) vorgenommen. Fehlinterpretationen
sind denkbar. Unsere Definition w&auml;re exakt,
h&auml;tten wir sowohl die Syntax als auch die Semantik
von PL(A) mit formalen Methoden beschrieben. Besonders
die Beschreibung der Semantik ist sehr m&uuml;hsam
und w&uuml;rde den gegebenen Rahmen sprengen. Es soll
aber wenigstens die Syntax von PL(A) in Form einer
kontextfreien Grammatik angegeben werden.</p>
<h3><a name="c23"></a>2.3. Eine kontextfreie Grammatik f&uuml;r PL(A)</h3>
<p>Die folgende kontextfreie erzeugende Grammatik
<img src="/img/cache/37b220b8a0c7fec332302fd51e5030a5.gif" alt="G(A) = (V_T,V_N,s_0,P)" valign="middle"/> erzeugt alle g&uuml;ltigen PL(A)-Programme
zu gegebenem Alphabet A. Leider werden nicht <strong>genau</strong> die g&uuml;ltigen
PL-Programme erzeugt, sondern auch Programme, die sich
nicht durchf&uuml;hren lassen. Es sei hier auf Definition (2.2.7)
verwiesen. Dort finden sich einige umgangssprachliche Regeln,
wie z.B. "eine Marke L darf nur einmal in der Form L : P in
<img src="/img/cache/aafc0430452071887da8c26f9bfa060c.gif" alt="AW_\pi" valign="middle"/> auftreten". Derartige Regeln lassen sich nicht mittels
einer kontextfreien Grammatik erfassen. Wir ben&ouml;tigen diese
Regeln, um unter den von G(A) erzeugten Programmen die g&uuml;ltigen
Programme von den nicht durchf&uuml;hrbaren zu unterscheiden.
Der gleiche Effekt tritt bei der Beschreibung realer
Programmiersprachen durch kontextfreie Grammatiken auf. Auch
hier kommt man i.a. nicht ohne umgangssprachliche Regeln aus.</p>
 
<p>Beispiel (SIMULA>: "Spr&uuml;nge in das Innere von <strong>while</strong>-Schleifen sind verboten". [17] [7]</p>
<p><strong>(2.3.1) Angabe der Grammatik <img src="/img/cache/ad3175a89e77335c26fbd70c0d804bd2.gif" alt="G(A)=(V_T,V_S,s_0,P)" valign="middle"/>:</strong></p>
<p>Die Menge der terminalen Zeichen <img src="/img/cache/836249d25ff1e3569fb77f337d1ed248.gif" alt="V_T" valign="middle"/> ist:</p>
<img src="/img/cache/b8b9ca4634b65dd813d3db00c0c296fa.gif" alt="
\begin{align}
V_T = A \cup M \cup VR \cup 
	&amp;&amp; \big\{ \text{\underline{input}, \underline{output}, \underline{if}, \underline{then}, \underline{goto},} \\
	&amp;&amp; \text{\underline{else}, \underline{fi}, \underline{while}, \underline{do}, \underline{od}, \underline{loop}, \underline{case},}\\
	&amp;&amp; \underbrace{ \text{\underline{end},\ :\ ,\ =\ , \longr ,\ ;\ ,\ ,\ , \rotate{-90}],\ (\ ,\ )\ , \cal{P}, \omega, \epsilon, \overline\epsilon} } \big\}\\
	&amp;&amp; \text{Grundsymbole}
\end{align}
" valign="middle"/>
<p>Die Menge der nichtterminalen Zeichen <img src="/img/cache/b9bf93a4c3c27af89ff0f6a20ddb9b41.gif" alt="V_N" valign="middle"/> ist:</p>
<img src="/img/cache/93806fe7d8544a8dc7a9ffa562038317.gif" alt="
\begin{align}
V_N = 	&amp;&amp; \big\{\text{&lt;program&gt;, &lt;statement&gt;, &lt;simple statement&gt;,}\\
	&amp;&amp; \text{&lt;identifier&gt;, &lt;label&gt;, &lt;identifier list&gt;,}\\
	&amp;&amp; \text{&lt;condition&gt; \big\}
\end{align}
" valign="middle"/>
<p>Das Startzeichen <img src="/img/cache/8320d1005489da544f0244dd5ee9af63.gif" alt="s_0" valign="middle"/> ist &lt;program>.</p>
<p>Die Menge P umfa&szlig;t die Produktionen:</p>
<ol>
<li><img src="/img/cache/7444eef9d2f20fd2d4f4f1b167342d84.gif" alt="
\begin{align}
\text{&lt;program&gt;} \longr
	&amp;\text{\underline{input}}	&amp;&amp;\text{&lt;identifier list&gt;;}\\
	&amp;				&amp;&amp;\text{&lt;statement&gt;;}\\
	&amp;\text{\underline{output}}	&amp;&amp;\text{&lt;identifier list&gt;}
\end{align}" valign="middle"/></li>
<li><img src="/img/cache/c8e44961a58f89a762db5472953f8c09.gif" alt="\text{&lt;identifier list&gt; \longr &lt;identifier list&gt;, &lt;identifier&gt;}" valign="middle"/></li>
<li><img src="/img/cache/ded53ed88560ce008baf0c871713d065.gif" alt="\text{&lt;identifier list&gt; \longr &lt;identifier&gt;}" valign="middle"/></li>
<li><img src="/img/cache/bf0aca09d2183dbd767787c0dd004059.gif" alt="\text{&lt;identifier&gt; \longr X, f\ddot{u}r alle X \in VR}" valign="middle"/></li>
<li><img src="/img/cache/2abadd7d0e6d832010ef4038ffcc8bf4.gif" alt="\text{&lt;identifier&gt; \longr \epsilon}" valign="middle"/></li>
<li><img src="/img/cache/3f883566ab2e21eae24c7c78300bf151.gif" alt="\text{&lt;statement&gt; \longr &lt;label&gt;\ :\ &lt;statement&gt;}" valign="middle"/></li>
<li><img src="/img/cache/b1b18933e1ad4abede1d08b6e6504aa7.gif" alt="\text{&lt;statement&gt; \longr &lt;statement&gt;\ ;\ &lt;statement&gt;}" valign="middle"/></li>
<li><img src="/img/cache/e11ea900f07c7596e3f372a42499c778.gif" alt="\text{&lt;statement&gt; \longr \underline{if} &lt;condition&gt; \underline{then goto} &lt;label&gt;}" valign="middle"/></li>
<li><img src="/img/cache/512a297c7fca59dc6a890fcf897baaf6.gif" alt="
\begin{align}
&amp;\text{&lt;statement&gt; \longr \underline{if} &lt;condition&gt;}	&amp;\text{\underline{then} &lt;statement&gt;}\\
&amp;							&amp;\text{\underline{else} &lt;statement&gt; \underline{fi}}\\
\end{align}" valign="middle"/></li>
<li><img src="/img/cache/47b5c65ad8aa5a3a15fd86d9240f3415.gif" alt="
\begin{align}
&amp;\text{&lt;statement&gt; \longr \underline{while}} 	&amp; \text{&lt;identifier&gt; = \epsilon\ \underline{do}}\\
&amp;						&amp; \text{&lt;statement&gt; \underline{od}}
\end{align}
" valign="middle"/></li>
<li><img src="/img/cache/67baf7a39627bdbabac0ac9e932cd0d5.gif" alt="
\begin{align}
&amp;\text{&lt;statement) \longr}	&amp; \text{\underline{loop} &lt;identifier&gt; \underline{case}}\\
&amp;				&amp; \text{a_1 \longr &lt;statement&gt;},\\
&amp;				&amp; \vdots\\
&amp;				&amp; \text{a_n \longr &lt;statement&gt;, \underline{end}}
\end{align}
" valign="middle"/></li>
 
<li><img src="/img/cache/66985034f7dc13931aef1997038b24a5.gif" alt="\text{&lt;statement&gt; \longr &lt;simple statement&gt;}" valign="middle"/></li>
<li><img src="/img/cache/278d15730778cd147caaf980b733face.gif" alt="\text{&lt;label&gt; \longr L, f\ddot{u}r alle L \in M}" valign="middle"/></li>
<li><img src="/img/cache/aadd52ae984cd689de3a0328f95daf0e.gif" alt="\text{&lt;condition&gt; \longr \omega(X)=a f\ddot{u}r alle a \in A, X \in VR}" valign="middle"/></li>
<li><img src="/img/cache/93c6a10ed31f59e2c9c9a3c00348bbfc.gif" alt="\text{&lt;condition&gt; \longr X=\epsilon\ f\ddot{u}r alle X \in VR}" valign="middle"/></li>
<li><img src="/img/cache/c17c0fb8c198a7b4c7c03ca179cf2980.gif" alt="\text{&lt;simple statement) \longr \overline\epsilon}" valign="middle"/></li>
<li><img src="/img/cache/f05951d22d15c83e582572aca734a384.gif" alt="\text{&lt;simple statement&gt;\longr X:=\epsilon\ f\ddot{u}r alle X \in VR}" valign="middle"/></li>
<li><img src="/img/cache/12e435f421314d582e2c6ecaf3f6be03.gif" alt="\text{&lt;simple statement&gt;\longr X:=Xa, f\ddot{u}r alle X \in VR, a \in A}" valign="middle"/></li>
<li><img src="/img/cache/a3888fe0074d9663f5b3f3080b29c07b.gif" alt="\text{&lt;simple statement&gt;\longr X:=X', f\ddot{u}r alle X,X' \in VR}" valign="middle"/></li>
<li><img src="/img/cache/cadca0d7e954b98ac2142b31131eddec.gif" alt="\text{&lt;simple statement&gt;\longr X:=\cal{P}(X), f\ddot{u}r alle X \in VR}" valign="middle"/></li>
</ol>
<p>Wir k&ouml;nnen folgende Entsprechungen feststellen:</p>
<table summary="">
<tr><td>Regel 1-5 </td><td><img src="/img/cache/e3a39edb05d819769e8315b5b322c08a.gif" alt="\hat{=}" valign="middle"/> </td><td>Definition (2.2.6)</td></tr>
<tr><td>Regel 6 </td><td><img src="/img/cache/e3a39edb05d819769e8315b5b322c08a.gif" alt="\hat{=}" valign="middle"/> </td><td>Definition (2.2.4)</td></tr>
<tr><td>Regel 7-13 </td><td><img src="/img/cache/e3a39edb05d819769e8315b5b322c08a.gif" alt="\hat{=}" valign="middle"/> </td><td>Definition (2.2.3),(2.2.5)</td></tr>
<tr><td>Hegel 14-20 </td><td><img src="/img/cache/e3a39edb05d819769e8315b5b322c08a.gif" alt="\hat{=}" valign="middle"/> </td><td>Definition (2.2.1),(2.2.2)</td></tr>
</table>
<p>Die oben erw&auml;hnten umgangssprachlichen Regeln in den
Definitionen bleiben von G(A) unber&uuml;cksichtigt.</p>
<h3><a name="c24"></a>2.4. PL(A)-berechenbare Funktionen, Church'sche These</h3>
<p>Sei nun A endliches Alphabet, <img src="/img/cache/059a81fdbe82299258386c59c446d593.gif" alt="\pi \in PL(A)" valign="middle"/>. <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> besitzt <img src="/img/cache/7ef7e67117f57235e1b36cb66ddf791a.gif" alt="r \ge 0" valign="middle"/> Eingabe-
und <img src="/img/cache/1d97f671bc34c3c6b9f655abaae4f871.gif" alt="s \ge 0" valign="middle"/> Ausgabevariable. W&auml;hrend der Programmausf&uuml;hrung
wird aus der Belegung der Eingabevariablen eine Belegung
der Ausgabevariablen ermittelt, falls das Programm
anh&auml;lt. H&auml;lt das Programm an, was i.a. nicht vorausgesetzt
werden kann, so stellt die letzte Belegung der Ausgabevariablen
das Ergebnis der Programmausf&uuml;hrung dar. H&auml;lt das Programm
nicht, so ist das Ergebnis undefiniert. In beiden F&auml;llen
interessieren etwaige Zwischenbelegungen irgendwelcher
Variablen w&auml;hrend der Programmausf&uuml;hrung nicht. Dieser Sichtweise
entspricht Definition (2.4.1).</p>
<p><strong>(2.4.1) Definition:</strong> Sei <img src="/img/cache/059a81fdbe82299258386c59c446d593.gif" alt="\pi \in PL(A)" valign="middle"/>. Die von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> <strong>berechnete
Funktion</strong> ist <img src="/img/cache/faae594217bb5abb98a75587a7670ee7.gif" alt="\varphi_\pi : (A^*)^r \longr (A^*)^s, r,s \ge 0" valign="middle"/>.
<img src="/img/cache/90b61a2121d1a615de7acea3cc9e74ff.gif" alt="\varphi_\pi" valign="middle"/> ordnet jeder Anfangsbelegung <img src="/img/cache/1237317a6c1603571ad83f619a1d4f23.gif" alt="(x_1,\dots,x_r), x_i \in A^*" valign="middle"/>,
<img src="/img/cache/6d00963952ab0bd1facefd4402cbfa62.gif" alt="i \in [r]" valign="middle"/><sup><a href="#p014_1" name="b014_1">1)</a></sup>, der Eingabevariablen ein Ergebnis
<img src="/img/cache/1c57ca0349cfe036a8a7b1a45930be86.gif" alt="(z_1,\dots,z_s) = \varphi_\pi(x_1,\dots,x_r), z_j \in A^*, j \in S" valign="middle"/>, zu,
 
falls das Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> anh&auml;lt. H&auml;lt <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> nicht an, so
ist <img src="/img/cache/ce362e3ea2de290048adc04a19b402be.gif" alt="\varphi_\pi(x_1,\dots,x_r)" valign="middle"/> undefiniert.</p>
<p><strong>(2.4.2) Bemerkung:</strong> Aus Definition (2.4.1) folgt:</p>
<ol type="I">
<li><img src="/img/cache/90b61a2121d1a615de7acea3cc9e74ff.gif" alt="\varphi_\pi" valign="middle"/> ist i.a. eine partielle Funktion.</li>
<li>Die Sonderf&auml;lle <img src="/img/cache/2c3db681686c1b080e21688bf57b256a.gif" alt="r=0" valign="middle"/> und <img src="/img/cache/787d0b6e5d9e7525a7054c6f96c377ea.gif" alt="s=0" valign="middle"/> sind ausdr&uuml;cklich zugelassen.
Die Bedeutung dieser Sonderf&auml;lle sei hier
jedoch kurz erl&auml;utert. Es bezeichne () das Nulltupel:
<ol type="i">
<li><img src="/img/cache/199111e0cb62d9d1018ee52cae7891c1.gif" alt="\varphi_\pi : (A^*)^r \longr (A^*)^0, r\ge1" valign="middle"/>, ordnet jedem r-Tupel
<img src="/img/cache/636b8164e2274f8b0d6fe553b0b9ec64.gif" alt="(x_1,\dots,x_r) \in (A^*)^r" valign="middle"/> das Nulltupel () zu, falls <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/>
mit <img src="/img/cache/0e1aa556883aec7eb83fac55c36cee1b.gif" alt="(x_1,\dots,x_r)" valign="middle"/> als Eingabebelegung anh&auml;lt.
<p><img src="/img/cache/592e7d67b49084c175021e331a191fd3.gif" alt="
		\varphi_\pi(x_1,\dots,x_r)=\{
			\text{
			(), falls \pi\ h\ddot{a}lt\\
			undefiniert sonst}
		" valign="middle"/></p></li>
<li><img src="/img/cache/6069c3628f1e8c3b3d8e161697eb7379.gif" alt="\varphi_\pi : (A^*)^0 \longr (A^*)^s, s\ge1" valign="middle"/>, ordnet dem Nulltupel ()
ein s-Tupel <img src="/img/cache/567be74268ab3652e52e31df1d6ea98c.gif" alt="(z_1,\dots,z_s)\in(A^*)^s" valign="middle"/> zu, falls <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/>
anh&auml;lt.
<p><img src="/img/cache/c76f1bfc3ab29eaa4c66537e66df53ca.gif" alt="
		\varphi_\pi() = \{
			\text{
			(z_1,\dots,z_s)\in(A^*)^s, falls \pi\ h\ddot{a}lt\\
			undefiniert sonst
			}
		" valign="middle"/></p></li>
<li><img src="/img/cache/c95c7e55af5d9f96369befacc07eb895.gif" alt="\varphi_\pi : (A^*)^0 \longr (A^*)^0" valign="middle"/> ordnet dem Nulltupel ()
das Nulltupel () zu, falls <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> h&auml;lt.
<p><img src="/img/cache/6c4c36360b73b873869c601857e40baa.gif" alt="
			\varphi_\pi()= \{
			\text{
				(), falls \pi\ h\ddot{a}lt\\
				undefiniert sonst
			}
		" valign="middle"/></p></li>
</ol></li>
</ol>
<p><strong>(2.4.3) Definition:</strong> Sei A fest gew&auml;hlt.</p>
<ol type="i">
<li>Eine Wortfunktion <img src="/img/cache/628b54eeef0bae38384e105bfd111d56.gif" alt="f : (A^*)^r \longr (A^*)^s, r,s\ge0" valign="middle"/>,
hei&szlig;t <strong>PL(A)-berechenbar</strong> oder kurz <strong>berechenbar</strong>,
falls ein Programm <img src="/img/cache/7e7fe94308ce517db1af0bf826cf8e26.gif" alt="\pi_f \in PL(A)" valign="middle"/> existiert mit <img src="/img/cache/53fd8245b20948a88d4e026aa855511c.gif" alt="\varphi_{\pi_f}=f" valign="middle"/>.</li>
<li>Die Menge <img src="/img/cache/748e42ca234e7c7e800a503ef7ad6f54.gif" alt="\cal{P}(A) := \{ \varphi_\pi | \pi \in PL(A) \}" valign="middle"/> hei&szlig;t <strong>Menge der
PL(A)-berechenbaren Funktionen</strong>.</li>
</ol>
<p>Um den intuitiven Begriff der Berechenbarkeit zu pr&auml;zisieren,
hat es immer wieder Versuche gegeben, Klassen von
 
"berechenbaren" Funktionen zu definieren. All diese Versuche
haben zu der gleichen Menge von "berechenbaren" Funktionen
gef&uuml;hrt. So ist zum Beispiel die Menge der "mit Turingmaschinen
berechenbaren" Funktionen mit der Menge der
"partiell rekursiven" Funktionen identisch. Mit diesen Mengen
wiederum ist bei festem A die Menge <img src="/img/cache/2e514fb84940353618c991e05016eb8f.gif" alt="\cal{P}(A)" valign="middle"/> identisch.
Diese Identit&auml;ten geben Anla&szlig; zur Church'schen These.</p>
<p><strong>(2.4.4) Church'sche These:</strong></p>
<p>Jede intuitiv berechenbare Funktion ist PL(A)-berechenbar und umgekehrt.</p>
<p>Aus (2.4.4) folgt: Sind <img src="/img/cache/4be60c01260fad068dd84cb934d15c36.gif" alt="A_1" valign="middle"/>, und <img src="/img/cache/e7fb081e7d6a49314607f263a85eef3c.gif" alt="A_2" valign="middle"/> zwei voneinander verschiedene
endliche Alphabete, so lassen sich offensichtlich die
Mengen <img src="/img/cache/ea3d62772f0f46caf5812ed57f17c863.gif" alt="\cal{P}(A_1)" valign="middle"/> und <img src="/img/cache/f7036f6715213a441489075c3a56134d.gif" alt="\cal{P}(A_2)" valign="middle"/> identifizieren. Wir geben daher die
Differenzierung nach dem zugrunde liegenden Alphabet auf und
schreiben von nun an einfach <img src="/img/cache/d1cdbf2fe7e18516c3a793a652b36039.gif" alt="\cal{P}" valign="middle"/> f&uuml;r die Menge der berechenbaren
oder partiell rekursiven Funktionen (siehe auch (2.4.6)).
Wichtig ist die folgende Erg&auml;nzung zur Church'schen These.</p>
<p><strong>(2.4.5) Erg&auml;nzung zur Church'schen These:</strong></p>
<p>Zu jeder berechenbaren Funktion f l&auml;&szlig;t sich f&uuml;r
beliebiges endliches A <strong>effektiv</strong> ein Programm <img src="/img/cache/059a81fdbe82299258386c59c446d593.gif" alt="\pi \in PL(A)" valign="middle"/>
angeben mit <img src="/img/cache/13547628d4c47c2890f83da5a922a042.gif" alt="f = \varphi_\pi" valign="middle"/></p>
<p><strong>(2.4.6) Definition:</strong></p>
<ol type="i">
<li><img src="/img/cache/d6759ce8a96cb9bc63f10e68654bc8bf.gif" alt="\cal{P}^r_s := \{f \in \cal{P} | f : (A^*)^r \longr (A^*)^s, r,s\ge0 \}" valign="middle"/></li>
<li><img src="/img/cache/57b062146d694802bbe0432873e5c4d3.gif" alt="\cal{R} := \{ f \in \cal{P} |\text{f ist  total} \}" valign="middle"/> ist die Menge der total rekursiven Funktionen.</li>
<li><img src="/img/cache/4a04c23cb24801aa4982c54f1e3b7c26.gif" alt="\cal{R}^r_s := \cal{R} \cap \cal{P}^r_s, r,s\ge0" valign="middle"/></li>
</ol>
 
<h3><a name="c25"></a>2.5. Codierungen, G&ouml;delisierungen von <img src="/img/cache/d1cdbf2fe7e18516c3a793a652b36039.gif" alt="\cal{P}" valign="middle"/></h3>
<p><strong>(2.5.1) Definition:</strong> Sei A endliches Alphabet. Eine Menge
<img src="/img/cache/0ad3a9df615c16c0f30d256d907e1088.gif" alt="B \subseteq (A^*)^r, r\ge0" valign="middle"/>, hei&szlig;t <strong>entscheidbar</strong> oder auch
<strong>rekursiv</strong> genau dann, wenn es eine total rekursive
Funktion <img src="/img/cache/69b08d488119d6b33ee64e0be11ee232.gif" alt="\chi_B : (A^*)^r \longr A^*" valign="middle"/> gibt mit
<img src="/img/cache/893d964754fe94f23a322578135b4eb1.gif" alt="\chi_B(x_1,\dots,x_r)=\varepsilon \Leftrightarrow (x_1,\dots,x_r)\in B" valign="middle"/></p>
<p><strong>(2.5.2) Definition:</strong> Seien <img src="/img/cache/4be60c01260fad068dd84cb934d15c36.gif" alt="A_1" valign="middle"/>, und <img src="/img/cache/e7fb081e7d6a49314607f263a85eef3c.gif" alt="A_2" valign="middle"/> endliche Alphabete.
Eine Funktion <img src="/img/cache/2b275a7843c5b97548dd618c9805e1ee.gif" alt="\xi : A^*_1 \longr A^*_2" valign="middle"/> hei&szlig;t genau dann
<strong>Kodierung</strong> von <img src="/img/cache/92b279a694589908c7ba7a0b09edfd8f.gif" alt="A^*_1" valign="middle"/> durch <img src="/img/cache/f6c87b6c86154bc3dac9d2e6dd91a217.gif" alt="^*_2" valign="middle"/>, falls gilt:</p>
<ol type="i">
<li><img src="/img/cache/fa671feaa17b9d18e9afacde0790ef3e.gif" alt="\xi \in \cal{R}" valign="middle"/>,</li>
<li><img src="/img/cache/195246810f9bfc228bca491859062b14.gif" alt="\xi" valign="middle"/> ist injektiv,</li>
<li><img src="/img/cache/c2f18e2d6aff1c9fdcbaaba5da0ec179.gif" alt="\xi(A^*_1)" valign="middle"/> ist entscheidbar,</li>
<li><img src="/img/cache/b795f8df4375d36ddfdaa64860afe4b6.gif" alt="\xi^{-1} \in \cal{P}" valign="middle"/></li>
</ol>
<p>Sei <img src="/img/cache/e32ea026ac2ac5cf7de5dd71d20e2468.gif" alt="A_0=\{1\}" valign="middle"/>. Dann kann man <img src="/img/cache/087a72ab80d8e28b0d0117420632b6a0.gif" alt="A^*_0" valign="middle"/> mit den nat&uuml;rlichen Zahlen
einschlie&szlig;lich der Null, <img src="/img/cache/f6da4851806d2190d2dda3541571573a.gif" alt="\mathbb{N}_0" valign="middle"/>, wie folgt identifizieren.</p>
<img src="/img/cache/b1ef2ad25e62de92fe58346668435bef.gif" alt="
\begin{align}
		\varepsilon	&amp; \hat{=} &amp; 0 \\
\underbrace{111.......1111111}	&amp; \hat{=} &amp; n \in \mathbb{N}\\
\text{n Einsen}
\end{align}
" valign="middle"/>
<p><strong>(2.5.3) Definition:</strong> Eine Kodierung <img src="/img/cache/3bd868dd37ad0672577f0cde72c20682.gif" alt="\xi : A^* \longr A^*_0=\{1\}^*\hat{=}\mathbb{N}_0" valign="middle"/>
hei&szlig;t <strong>G&ouml;delisierung</strong>. <img src="/img/cache/50d61e7eb9f46371a2d5f0a8121950d6.gif" alt="\xi(\omega)" valign="middle"/> hei&szlig;t G&ouml;delnummer von <img src="/img/cache/260b57b4fdee8c5a001c09b555ccd28d.gif" alt="\omega" valign="middle"/>
f&uuml;r alle <img src="/img/cache/f7b2ec83acab34ac9dd3723822ea76f3.gif" alt="\omega\in A^*_0" valign="middle"/>.</p>
<p>Es soll im folgenden eine G&ouml;delisierung aller PL(A)-Programme
mit festem A angegeben werden. Damit wird gleichzeitig eine
G&ouml;delisierung von <img src="/img/cache/d1cdbf2fe7e18516c3a793a652b36039.gif" alt="\cal{P}" valign="middle"/> angegeben. Sei <img src="/img/cache/7cfbb19da0e3d47cd1ceaad154327e51.gif" alt="A:=\{a_1,\dots,a_n\}" valign="middle"/> fest gew&auml;hlt.
In der Menge B listen wir alle Sonderzeichen und alle Buchstaben
auf, aus denen die Wortsymbole "<strong>input, if, fi</strong> usw."
von PL(A) aufgebaut werden. <img src="/img/cache/8ad213e4188b463934558144039ed8c8.gif" alt="B:=\{:,=,\epsilon,\overline\epsilon,\longr,;,,,\rotate{-90}],\omega,\cal{P},(,),a,c,d,e,f,g,h,i,l,n,o,p,s,t,u,w\}" valign="middle"/>
Die Mengen der Marken und Variablen in PL(A)-Programmen sind
<img src="/img/cache/b09c61cdd19bf3e7bf6b8bca25201ba1.gif" alt="M: = \{L_1,L_2,\dots\}" valign="middle"/> bzw. <img src="/img/cache/b5615c70e4704aedec3f7a9face317ba.gif" alt="VR:=\{V_1,V_2,\dots\}" valign="middle"/>. Dabei bezeichnen <img src="/img/cache/6b623bcf78099c519f69e9dbba46fbf2.gif" alt="L_i" valign="middle"/> bzw.
<img src="/img/cache/397712a8f7b0bc2442b37d1697fc7bc3.gif" alt="V_j,\ i,j\ge1" valign="middle"/>, irgendwelche Namen f&uuml;r Variable bzw. Marken. Es
war bisher nicht n&ouml;tig, die Wahl dieser Namen einzuengen, F&uuml;r
 
die folgender, &Uuml;berlegungen mu&szlig; jedoch sichergestellt werden,
da&szlig; die Namen W&ouml;rter&uuml;ber einem <strong>endlichen</strong> Alphabet sind. Es
wird daher wie folgt normiert.</p>
<ul>
<li>Der Name <img src="/img/cache/2c6f3b6c16df97a1b00e04ff17e4906e.gif" alt="L_1" valign="middle"/> ist textuell gleich "L1"</li>
<li>Der Name <img src="/img/cache/07cbd6c155424e110559a84df364be5a.gif" alt="L_2" valign="middle"/> ist textuell gleich "L2" u.s.w.</li>
</ul>
<p>entsprechend</p>
<ul>
<li>Der Name <img src="/img/cache/47e205a9f01f6951d4dc6de16c404a8d.gif" alt="V_1" valign="middle"/> ist textuell gleich "V1" u.s.w.</li>
</ul>
<p>Damit gilt:</p>
<p><img src="/img/cache/0707c54ac401030e4b81f9e0def5551d.gif" alt="M\subset\{L,0,1,\dots,9\}^*,\ \ VR \subset\{V,0,1,\dots,9\}^*" valign="middle"/></p>
<p>Sei nun <img src="/img/cache/9db4fe19167fd7d0b42d566edfd5bead.gif" alt="C:=A \cup B \cup \{L,V,0,1,\dots,9\}" valign="middle"/>. Jedes Programm <img src="/img/cache/059a81fdbe82299258386c59c446d593.gif" alt="\pi \in PL(A)" valign="middle"/> l&auml;&szlig;t
sich somit als Wort aus <img src="/img/cache/0f1a0bf001f82a76496bc5b40d6efaf7.gif" alt="C^*" valign="middle"/> und PL(A) selbst als Teilmenge
von <img src="/img/cache/0f1a0bf001f82a76496bc5b40d6efaf7.gif" alt="C^*" valign="middle"/> auffassen. Wir geben eine injektive Abbildung
<img src="/img/cache/b11f08ccf9aa0f3faefe0d4fe496531e.gif" alt="H : C \longr \{1\}* \hat{=} \mathbb{N}_0" valign="middle"/> elementweise an:</p>
<img src="/img/cache/0b8408ab3f9e080b26c740090285a4ab.gif" alt="
\begin{array}{rccclBCB}
:&amp;\longr&amp;0&amp;\ &amp;c&amp;\longr&amp;13&amp;\ &amp;u&amp;\longr&amp; 26\\
=&amp;\longr&amp;1&amp;\ &amp;d&amp;\longr&amp;14&amp;\ &amp;w&amp;\longr&amp; 27\\
;&amp;\longr&amp;2&amp;\ &amp;e&amp;\longr&amp;15&amp;\ &amp;L&amp;\longr&amp; 28\\
,&amp;\longr&amp;3&amp;\ &amp;f&amp;\longr&amp;16&amp;\ &amp;V&amp;\longr&amp; 29\\
(&amp;\longr&amp;4&amp;\ &amp;g&amp;\longr&amp;17&amp;\ &amp;0&amp;\longr&amp; 30\\
)&amp;\longr&amp;5&amp;\ &amp;h&amp;\longr&amp;18&amp;\ &amp;\vdots\\
\rotate{-90}]&amp;\longr&amp;6&amp;\ &amp;i&amp;\longr&amp;19&amp;\ &amp;\vdots\\
\longr&amp;\longr&amp;7&amp;\ &amp;l&amp;\longr&amp;20&amp;\ &amp;9&amp;\longr&amp; 39\\
\epsilon&amp;\longr&amp;8&amp;\ &amp;n&amp;\longr&amp;21&amp;\ &amp;a_1	&amp;\longr&amp; 40\\
\overline\epsilon&amp;\longr&amp; 9&amp;\ &amp;o&amp;\longr&amp;22&amp;\ &amp;\vdots\\
\cal{P}&amp;\longr&amp; 10&amp;\ &amp;p&amp;\longr&amp;23&amp;\ &amp;\vdots\\
\omega&amp;\longr&amp; 11&amp;\ &amp;s&amp;\longr&amp;24&amp;\ &amp;a_n	&amp;\longr&amp; 39+n\\
a&amp;\longr&amp;12&amp;\ &amp;t&amp;\longr&amp;25&amp;\ &amp;
\end{array}
" valign="middle"/>
<p>Die injektive Abbildung H l&auml;&szlig;t sich zu einer ebenfalls
injektiven Abbildung <img src="/img/cache/29a0da7f6b93d816af437a03b00a0112.gif" alt="H^* : C^* \longr \mathbb{N}^*_0" valign="middle"/> erweitern.</p>
<img src="/img/cache/fd77cffdd10cbc2eb2c86de75406910b.gif" alt="
\begin{array}{rccclBCB}
H^*(\varepsilon)&amp;\longr&amp;\varepsilon\\
H^*(\overline{x}y)&amp;\longr&amp;H^*(\overline{x})H(y),&amp; \forall y \in C, \forall \overline{x} \in C^*
\end{array}
" valign="middle"/>
<p><strong>(2.5.4) Lemma:</strong> <img src="/img/cache/b24706b0ccdfef2e717e271b7a9aaeef.gif" alt="H^*" valign="middle"/> ist eine Kodierung von <img src="/img/cache/0f1a0bf001f82a76496bc5b40d6efaf7.gif" alt="C^*" valign="middle"/> durch <img src="/img/cache/7ae5ffbd44f6888800357baa239ea5c5.gif" alt="\mathbb{N}^*_0" valign="middle"/>.</p>
<p><strong>Beweis:</strong></p>
<ol type="i">
<li>Nach Definition von H und <img src="/img/cache/b24706b0ccdfef2e717e271b7a9aaeef.gif" alt="H^*" valign="middle"/> ist <img src="/img/cache/b24706b0ccdfef2e717e271b7a9aaeef.gif" alt="H^*" valign="middle"/> nat&uuml;rlich
intuitiv berechenbar und auf Grund der
 
Church'schen These berechenbar. <img src="/img/cache/b24706b0ccdfef2e717e271b7a9aaeef.gif" alt="H^*" valign="middle"/> ist f&uuml;r alle
Elemente aus <img src="/img/cache/0f1a0bf001f82a76496bc5b40d6efaf7.gif" alt="C^*" valign="middle"/> definiert. Also ist <img src="/img/cache/b24706b0ccdfef2e717e271b7a9aaeef.gif" alt="H^*" valign="middle"/> total und
insgesamt aus <img src="/img/cache/d1c1edae5408bade596c65526db52c5e.gif" alt="\cal{R}" valign="middle"/>,</li>
<li><img src="/img/cache/b24706b0ccdfef2e717e271b7a9aaeef.gif" alt="H^*" valign="middle"/> ist trivialerweise injektiv.</li>
<li>Sei <img src="/img/cache/93add9fed117ee56e755bdcd916d95ec.gif" alt="D := H^*(C^*)" valign="middle"/>. D ist Teilmenge von <img src="/img/cache/7ae5ffbd44f6888800357baa239ea5c5.gif" alt="\mathbb{N}^*_0" valign="middle"/>. Sei
<img src="/img/cache/530b470aefd8fbefa0cece934cdddf90.gif" alt="\overline{i}\in\mathbb{N}^*_0" valign="middle"/>. <img src="/img/cache/e7b06e56bc1bc0ddb7d4b18f610a22f1.gif" alt="\overline{i}" valign="middle"/> hat endliche L&auml;nge <img src="/img/cache/c3957d8ed2cdad8e3c3928bd7f6d7bde.gif" alt="l(\overline{i}), \overline{i}=m_1 \dots m_{l(\overline{i})}" valign="middle"/><sup><a href="#p019_1" name="b019_1">1)</a></sup>
mit <img src="/img/cache/afc8981f9c16397baa6731584453c8b9.gif" alt="m_j\in\mathbb{N}^*_0" valign="middle"/> f&uuml;r <img src="/img/cache/29707c4b1cbf932622d71bd6fba7d451.gif" alt="j\in[l(\overline{i})]" valign="middle"/>. <img src="/img/cache/e7b06e56bc1bc0ddb7d4b18f610a22f1.gif" alt="\overline{i}" valign="middle"/> ist genau dann aus
D, wenn jedes <img src="/img/cache/5f94656c489cf1820f46b6b5c53f0210.gif" alt="m_j" valign="middle"/> ein Urbild in C bzgl. H hat
Um festzustellen, ob <img src="/img/cache/cb0a1e83b82c02ceb641a9babd154789.gif" alt="\overline{i}\in D" valign="middle"/> ist, sind also h&ouml;chstens
<img src="/img/cache/253cad9d7adabd0c1f0c598ed089ae25.gif" alt="l(\overline{i})\cdot\text{card}(C)" valign="middle"/> Tests n&ouml;tig. Es existiert
also eine total rekursive Funktion
<p><img src="/img/cache/5ffbb830a7ea9f310fe327db6c791088.gif" alt="\chi_D : \mathbb{N}^*_0 \longr \mathbb{N}^*_0" valign="middle"/> mit</p>
<img src="/img/cache/85dd51bae954cf63278b40e4d93fd9f3.gif" alt="\chi_D(\overline{i}) = \varepsilon \Leftrightarrow" valign="middle"/> (Jedes Element von <img src="/img/cache/e7b06e56bc1bc0ddb7d4b18f610a22f1.gif" alt="\overline{i}" valign="middle"/> hat unter H Urbild in C)
<img src="/img/cache/fa0b8681be83a7a0061308e042dd5393.gif" alt="\Leftrightarrow \overline{i}\in D" valign="middle"/>.
Also ist <img src="/img/cache/d92021471db3f989c1f17d802b6ed9d7.gif" alt="D = H^*(C^*)" valign="middle"/> entscheidbar.</li>
<li>In (iii) wurde schon gezeigt, da&szlig; man f&uuml;r jedes
<img src="/img/cache/d3104f21c3f7a4926aebd7de14bfd8e1.gif" alt="\overline{i}\in H^*(C^*)" valign="middle"/> effektiv das Urbild in <img src="/img/cache/0f1a0bf001f82a76496bc5b40d6efaf7.gif" alt="C^*" valign="middle"/> ermitteln
kann. Also ist <img src="/img/cache/c9436d26e8cd899be4f944187c9ab2e2.gif" alt="(H^*)^{-1}" valign="middle"/> &uuml;berall dort, wo es definiert
ist, auch berechenbar. Also <img src="/img/cache/51d1566c0b3d00585d149708fb799840.gif" alt="(H^*)^{-1} \in \cal{P}" valign="middle"/></li>
</ol>
<p>Aus (i) - (iv) folgt: <img src="/img/cache/b24706b0ccdfef2e717e271b7a9aaeef.gif" alt="H^*" valign="middle"/> ist Kodierung.</p>
<div align="right">%<sup><a href="#p019_2" name="b019_2">2)</a></sup></div>
<p>Wir betrachten nun die total rekursive Funktion <img src="/img/cache/2e1e58dd87eb77980dc42b4a822dcb53.gif" alt="f : \mathbb{N}^*_0\longr\mathbb{N}_0" valign="middle"/></p>
<p>mit <img src="/img/cache/e35afbea4fc8c262264cdae79743cdd2.gif" alt="\overline{i}\longr\{ \text{0, falls \overline{i}=\varepsilon\\p_1^{m_1}\dots p_{l(\overline{i})}^{m_{l(\overline{i})}+1} - 1, falls \overline{i}=m_1\dots m_{l(\overline{i})}}" valign="middle"/></p>
<p>wobei <img src="/img/cache/8b6f59f2af8f45b773cb64ac76c9b095.gif" alt="p_j" valign="middle"/> die j-te Primzahl ist,</p>
<p><strong>Behauptung:</strong> f ist bijektiv.</p>
<p><strong>Beweis:</strong></p>
<ol type="i">
<li>f ist injektiv wegen der Eindeutigkeit der
Primfaktorzerlegung.</li>
<li>f ist surjektiv, weil jede Zahl <img src="/img/cache/f0b5604e40bf749c4dbde4da2373f2ce.gif" alt="m\in\mathbb{N}" valign="middle"/> mit <img src="/img/cache/9cf6dacb4ffa5908ac1862fc296cb176.gif" alt="m&gt;1" valign="middle"/>
eine Primzahlzerlegung hat, in der mindestens
ein Primfaktor vorkommt.</li>
</ol>
<div align="right">%</div>
 
<p>Mit <img src="/img/cache/b24706b0ccdfef2e717e271b7a9aaeef.gif" alt="H^*" valign="middle"/> als Kodierung von <img src="/img/cache/0f1a0bf001f82a76496bc5b40d6efaf7.gif" alt="C^*" valign="middle"/> durch <img src="/img/cache/7ae5ffbd44f6888800357baa239ea5c5.gif" alt="\mathbb{N}^*_0" valign="middle"/> und <img src="/img/cache/11211a39c7ef97e1f311d821416c2192.gif" alt="f\in\cal{R}" valign="middle"/> als bijektiver
Funktion von <img src="/img/cache/7ae5ffbd44f6888800357baa239ea5c5.gif" alt="\mathbb{N}^*_0" valign="middle"/> nach <img src="/img/cache/f6da4851806d2190d2dda3541571573a.gif" alt="\mathbb{N}_0" valign="middle"/> folgt Lemma (2.5.5).</p>
<p><strong>(2.5.5) Lemma:</strong> Die Funktion <img src="/img/cache/338fe828317af31bd7ed16af39c738f0.gif" alt="g := f \circ H^* : C^* \longr \mathbb{N}_0" valign="middle"/> ist
G&ouml;delisierung von <img src="/img/cache/0f1a0bf001f82a76496bc5b40d6efaf7.gif" alt="C^*" valign="middle"/> durch <img src="/img/cache/f6da4851806d2190d2dda3541571573a.gif" alt="\mathbb{N}_0" valign="middle"/>.</p>
<p>Jedem Wort w aus <img src="/img/cache/0f1a0bf001f82a76496bc5b40d6efaf7.gif" alt="C^*" valign="middle"/> und somit jedem Programm aus PL(A) ist
also eindeutig eine Zahl <img src="/img/cache/e2b50d5134268cef87032dea622fe311.gif" alt="f\circ H^*(w)" valign="middle"/> aus <img src="/img/cache/f6da4851806d2190d2dda3541571573a.gif" alt="\mathbb{N}_0" valign="middle"/> zugeordnet. Da <img src="/img/cache/b24706b0ccdfef2e717e271b7a9aaeef.gif" alt="H^*" valign="middle"/>
injektiv und f bijektiv ist, ist die Abbildung g eine bijektive
G&ouml;delisierung von <img src="/img/cache/0f1a0bf001f82a76496bc5b40d6efaf7.gif" alt="C^*" valign="middle"/>.</p>
<p><strong>(2.5.6) Lemma:</strong> Die Menge <img src="/img/cache/3a8a4f131fa64be539537061a86c70dc.gif" alt="T := \{ g(x) | x \in PL(A) \} \subset \mathbb{N}_0" valign="middle"/> ist
entscheidbar.</p>
<p><strong>Beweis:</strong></p>
<ol type="I">
<li>i=0 ist nicht aus T, da das leere Wort kein
Programm ist.</li>
<li>Sei <img src="/img/cache/8eaacb21571b89f41fa5690f9c036479.gif" alt="i\in\mathbb{N}" valign="middle"/>. Dann l&auml;&szlig;t sich i eindeutig in der Form
<img src="/img/cache/51eaa55edd5d746287024ccb4619ac32.gif" alt="i = p_1^{m_1} \dots p_k^{m_k+1}-1" valign="middle"/> darstellen (<img src="/img/cache/fdfa4c01526aef4b03bc39afbd7fd7ea.gif" alt="k\ge1" valign="middle"/>).
Existiert f&uuml;r eines der <img src="/img/cache/87edd3a477c92cd1989d2070965803da.gif" alt="m_j (j\in[k])" valign="middle"/> kein Urbild
bzgl. der Funktion H. so ist i nicht aus dem
Bildbereich, von g und damit auch nicht aus T.
Sei nun jedes <img src="/img/cache/5f94656c489cf1820f46b6b5c53f0210.gif" alt="m_j" valign="middle"/> aus dem Bildbereich von H. Dann
existiert ein <img src="/img/cache/369e0c9f3e5b8383e4f287151cebeeba.gif" alt="w\in C^*" valign="middle"/> mit g(w)=i. Aus der Grammatik
G aus 2.3. und den umgangssprachlichen Regeln
wie "Die Eingabevariablen sind paarweise verschieden."
l&auml;&szlig;t sich ein Programm konstruieren
(vgl. : "Formale Sprachen", "Compilerbau"),
das bei jeder Eingabe wenn <img src="/img/cache/369e0c9f3e5b8383e4f287151cebeeba.gif" alt="w\in C^*" valign="middle"/> h&auml;lt und <img src="/img/cache/f8b1c5a729a09649c275fca88976d8dd.gif" alt="\varepsilon" valign="middle"/> ausgibt
genau dann, wenn <img src="/img/cache/284abb5b0529f9bebe694f7d62c985ff.gif" alt="w\n PL(A)" valign="middle"/> ist. Insgesamt existiert
also eine total rekursive Funktion, deren Ergebnis
genau dann gleich <img src="/img/cache/f8b1c5a729a09649c275fca88976d8dd.gif" alt="\varepsilon" valign="middle"/> ist, wenn das Urbild eines
Elementes aus <img src="/img/cache/f6da4851806d2190d2dda3541571573a.gif" alt="\mathbb{N}_0" valign="middle"/>, falls es existiert, ein
g&uuml;ltiges PL(A)-Programm ist. Also ist T entscheidbar.</li>
</ol>
<div align="right">%</div>
<p><strong>(2.5.7) Definition:</strong> <img src="/img/cache/557bc2234a170166f1b39f26e199f005.gif" alt="B \subset (A^*)^q, q \ge 0" valign="middle"/>, hei&szlig;t <strong>aufz&auml;hlbar</strong> genau dann,
wenn B Wertebereich einer partiell rekursiven Funktion
ist.</p>
 
<p><strong>(2.5.8) Lemma:</strong> <img src="/img/cache/4b268f70ab3190590a7385ec2d3aa07d.gif" alt="B\subseteq(A^*)^q,\ q\ge0" valign="middle"/>, entscheidbar <img src="/img/cache/055889aaee38b7c53f994c5e42a40994.gif" alt="\Rightarrow" valign="middle"/> B ist
aufz&auml;hlbar.</p>
<p><strong>Beweis:</strong> Sei <img src="/img/cache/01682bff4a4d52ae0f41b853ab73a746.gif" alt="B\subseteq(A^*)^q" valign="middle"/> entscheidbar. Nach Definition (2.5.1)
existiert eine total rekursive Funktion</p>
<p><img src="/img/cache/5478f846fe647140b3ab31cf001a8697.gif" alt="\chi_B : (A^*)^q\longr A^*\text{ mit}\\ \chi_B(x_1,\dots,x_q)=\varepsilon\Leftrightarrow(x_1,\dots,x_q)\in B" valign="middle"/></p>
<p>Aus <img src="/img/cache/1985c7abe20c076db11676a64cfe184a.gif" alt="\chi_B" valign="middle"/> l&auml;&szlig;t sich eine partiell rekursive Abbildung</p>
<p><img src="/img/cache/d11d80736b56275a187f787bd39ae0ce.gif" alt="f_B\ :\ (A^*)^q\longr A^*\text{ gewinnenmit}\\f_B(x_1,\dots,x_q)=\{\varepsilon,\text{ falls }\chi_B(x_1,\dots,x_q)=\varepsilon\\\text{undefiniert sonst.}" valign="middle"/></p>
<p>Dann ist die Abbildung <img src="/img/cache/19eb1c0b9b72fc8c1deb46000a0efc68.gif" alt="g_B\ :\ (A^*)^q\longr (A^*)^q" valign="middle"/>
mit <img src="/img/cache/088d05afe7cc56783f482f8107d198d9.gif" alt="g_B(\overline{x})=\Pi^2_1(\overline{x},f_B(\overline{x})),\ \overline{x}\in(A^*)^q" valign="middle"/>, partiell rekursiv
und hat als Wertebereich die Menge B.<sup><a href="#p021_1" name="b021_1">1)</a></sup></p>
<div align="right">%</div>
<p><strong>(2.5.9) Korollar:</strong> T ist aufz&auml;hlbar.</p>
<p><strong>Beweis:</strong> Folgt aus Lemma (2.5.7), da T entscheidbar ist.</p>
<div align="right">%</div>
<p>Wie im Beweis von (2.5.6) kann man zeigen, da&szlig; auch f&uuml;r jedes
<img src="/img/cache/4f78b26b1bcc19a10294d54cb717f987.gif" alt="m,k\ge0" valign="middle"/> die Menge
<img src="/img/cache/55a8c226cfb03836373e7edb69ac0835.gif" alt="T_{m,k} := \{g(\pi)|\pi\in PL(A),\text{ \pi\ hat genau m Eingabe- und k Ausgabevariable\}\subset\mathbb{N}_0" valign="middle"/>
entscheidbar ist. Man braucht dem Entscheidungsalgorithmus
im Beweis von (2.5.6) nur noch einen Test, ob ein Programm
<img src="/img/cache/6afcb353fc38167b599660fd1cb011cb.gif" alt="v\in PL(A)" valign="middle"/> genau m Eingabe- und k Ausgabevariable aufweist,
hinzuzuf&uuml;gen. Aus der Entscheidbarkeit von <img src="/img/cache/edb5c2e30f0dfaf38bd12097f0461082.gif" alt="T_{m,k}" valign="middle"/> folgt die
Aufz&auml;hlbarkeit von <img src="/img/cache/edb5c2e30f0dfaf38bd12097f0461082.gif" alt="T_{m,k}" valign="middle"/> und damit die Existenz einer partiell
rekursiven Funktion von <img src="/img/cache/f6da4851806d2190d2dda3541571573a.gif" alt="\mathbb{N}_0" valign="middle"/> nach <img src="/img/cache/f6da4851806d2190d2dda3541571573a.gif" alt="\mathbb{N}_0" valign="middle"/>, die die Menge
<img src="/img/cache/edb5c2e30f0dfaf38bd12097f0461082.gif" alt="T_{m,k}" valign="middle"/> als Wertebereich hat. Da <img src="/img/cache/bbd82d024ef52247b4c2a52681c86b26.gif" alt="T_{m,k}\ne\emptyset" valign="middle"/> ist, folgt sogar die
Existenz einer total rekursiven Funktion (vgl.[5] Seite 82)</p>
 
<p><img src="/img/cache/bff7a7bb8699284b75b689c0fa0e6e4d.gif" alt="
	t_{m,k}\ :\ \mathbb{N}_0 \longr \mathbb{N}_0 \text{ mit }\\
	t_{m,k}(\mathbb{N}_0) = T_{m,k}
" valign="middle"/></p>
<p>Es hat also Sinn, wieder vom i-ten Element aus <img src="/img/cache/edb5c2e30f0dfaf38bd12097f0461082.gif" alt="T_{m,k}" valign="middle"/> zu sprechen.
F&uuml;r alle <img src="/img/cache/4f78b26b1bcc19a10294d54cb717f987.gif" alt="m,k\ge0" valign="middle"/> l&auml;&szlig;t sich also auch die Menge aller
Programme mit m Eingabe- und k Ausgabevariablen in der Form
<img src="/img/cache/0d04c5f6ad6c54a979dd00f5dbefe9e9.gif" alt="\{\pi_0,\pi_1,\pi_2,\dots\}" valign="middle"/> hinschreiben. Dabei ist <img src="/img/cache/68df4fedda3a6ee42485d71ce568ba2e.gif" alt="\pi_j" valign="middle"/> dasjenige
Programm aus PL(A) mit <img src="/img/cache/7d4a677594f661edbd7dc0cd023052f5.gif" alt="t_{m,k}(j) = g(\pi_j)" valign="middle"/>.</p>
<p>Insgesamt existiert also f&uuml;r alle <img src="/img/cache/4f78b26b1bcc19a10294d54cb717f987.gif" alt="m,k\ge0" valign="middle"/> eine total rekursive Funktion</p>
<p><img src="/img/cache/821750c666d61b14fb84cb18361939bf.gif" alt="\gamma_{m,k}\ : \ \mathbb{N}_0 \longr \{ \pi | \pi \in PL(A), \pi\ \text{ hat genau  m Eingabe- und k Ausgabevariable \} =: W" valign="middle"/>,</p>
<p>mit der "Umkehrung" <img src="/img/cache/433ef35fe6adedb2270f122e0b408eb0.gif" alt="\overline\gamma_{m,k}\ :\ W \longr \mathbb{N}_0" valign="middle"/> mit</p>
<p><img src="/img/cache/6ea2066e8f62b0e2c2382bd1eefa17b0.gif" alt="\overline\gamma_{m,k}(\pi) := \min\{j|\gamma_{m,k}(j)=\pi\}" valign="middle"/></p>
<p>Mit <img src="/img/cache/edb5c2e30f0dfaf38bd12097f0461082.gif" alt="T_{m,k}" valign="middle"/>, ist nat&uuml;rlich auch die Menge <img src="/img/cache/84354a4d11e73d3841434d94849d47fc.gif" alt="\cal{P}^m_k" valign="middle"/> f&uuml;r alle <img src="/img/cache/4f78b26b1bcc19a10294d54cb717f987.gif" alt="m,k\ge0" valign="middle"/>
entscheidbar und damit aufz&auml;hlbar. Die Menge <img src="/img/cache/84354a4d11e73d3841434d94849d47fc.gif" alt="\cal{P}^m_k" valign="middle"/> l&auml;&szlig;t sich
also in der Form <img src="/img/cache/3bc48333b32624f6bfa1c6a7655de84c.gif" alt="\{f_0,f_1,f_2,\dots\}" valign="middle"/> hinschreiben, wobei f&uuml;r
jedes <img src="/img/cache/f20e5f1dfc2ef35730dd05b6f6c8ac35.gif" alt="f_j" valign="middle"/> gilt: <img src="/img/cache/edd7b259bc5508a74b25a47edd791de4.gif" alt="f_j = \varphi_{\pi_j}" valign="middle"/>. Die G&ouml;delnummer von <img src="/img/cache/68df4fedda3a6ee42485d71ce568ba2e.gif" alt="\pi_j" valign="middle"/>. &uuml;bertr&auml;gt
sich dabei auf <img src="/img/cache/f20e5f1dfc2ef35730dd05b6f6c8ac35.gif" alt="f_j" valign="middle"/>. In der obigen Aufz&auml;hlung von <img src="/img/cache/84354a4d11e73d3841434d94849d47fc.gif" alt="\cal{P}^m_k" valign="middle"/>
kommen alle Funktionen aus <img src="/img/cache/84354a4d11e73d3841434d94849d47fc.gif" alt="\cal{P}^m_k" valign="middle"/> mehrfach vor. Das bedeutet
aber, da&szlig; die Funktionen aus <img src="/img/cache/84354a4d11e73d3841434d94849d47fc.gif" alt="\cal{P}^m_k" valign="middle"/>, mehrere G&ouml;delnummern besitzen.
Es gilt sogar:</p>
<p><strong>(2.5.10) Lemma:</strong> F&uuml;r alle <img src="/img/cache/aee17f7695d61fde5ed6c84eed9d526c.gif" alt="f\in\cal{P}^m_k" valign="middle"/> gilt: f hat bzgl. der G&ouml;delisierung
g unendlich viele G&ouml;delnummern (<img src="/img/cache/4f78b26b1bcc19a10294d54cb717f987.gif" alt="m,k\ge0" valign="middle"/>).</p>
<p><strong>Beweis:</strong> Seien <img src="/img/cache/f8aebb47a983fb7df0884c2cbd3c495a.gif" alt="m,k\ge0,\ f\in\cal{P}^m_k" valign="middle"/>. f wird realisiert durch das
Programm</p>
<p><img src="/img/cache/2bfbcd5319f596f8e93ef6ea5e099642.gif" alt="
\begin{align}
\pi_0 = &amp;\text{\underline{input}}	&amp; X_1,\dots,X_m;\\
	&amp;				&amp; AW_{\pi_0}\\
	&amp;\text{\underline{output}}	&amp; Z_1,\dots,Z_k
\end{align}
" valign="middle"/></p>
<p>Es gilt <img src="/img/cache/6c76ab568f86cf1ccce9f57d9751939e.gif" alt="\gamma_{\pi_0} = f" valign="middle"/>. f wird aber auch realisiert
durch die Programme <img src="/img/cache/c5648a19719b472c7d066bebb59bba96.gif" alt="\pi_1,\pi_2,\pi_3,\dots" valign="middle"/></p>
<p><img src="/img/cache/dfac50b99a5451f3b02aae167a14f59f.gif" alt="\text{mit }\pi_i\ =\ \text{input}\ X_1,\dots,X_m;\ AW_{\pi_0};\\\underbrace{\overline\varepsilon;\dots\overline\varepsilon;}\ \text{\underline{output}}\ Z_1,\dots,Z_k\\\text{i-mal}" valign="middle"/></p>
 
<p>Es gilt <img src="/img/cache/e63eba5c8808fa79f0a17014d558b329.gif" alt="f = \varphi_{\pi_1} = \varphi_{\pi_2} = \varphi_{\pi_3} = \dots" valign="middle"/></p>
<p>Wegen <img src="/img/cache/988ded7e2cce70ff95eb8ee269b7ebdc.gif" alt="g(\pi_1)\ne g(\pi_2)\ne\dots" valign="middle"/> hat f unendlich viele
G&ouml;delnummern.</p>
<div align="right">%</div>
<p><strong>(2.5.11) Definition:</strong> Sei <img src="/img/cache/a28959a16a883ae1154718e8b4ea00a5.gif" alt="\cal{F}" valign="middle"/> eine Menge von Wortfunktionen,
und sei <img src="/img/cache/5f16796745b469d2e863a72955dd9a50.gif" alt="\cal{F}^r_s := \{ f : (A^*)^r \longr (A^*)^s | f\in\cal{F}\},\ r,s\ge0" valign="middle"/>.
Eine Funktion <img src="/img/cache/2adef2b12ed0defb5eb288366b761811.gif" alt="\psi\in\cal{F}^{r+1}_s" valign="middle"/> hei&szlig;t <strong>universell f&uuml;r <img src="/img/cache/1023f4ced24a561bf06cca8bc7d9be75.gif" alt="\cal{F}^r_s" valign="middle"/></strong>,
wenn gilt:</p>
<p><img src="/img/cache/8d660c5757852351e9ce4b74cdc5207b.gif" alt="\cal{F}^r_s = \{\lambda\overline{y}[\psi(x,\overline{y})]|x\in A^*,\ \overline{y}\in(A^*)^r\}" valign="middle"/>.<sup><a href="#p023_1" name="b023_1">1)</a></sup></p>
<p><strong>(2.5.12) Satz:</strong> F&uuml;r alle <img src="/img/cache/4f78b26b1bcc19a10294d54cb717f987.gif" alt="m,k\ge0" valign="middle"/> gilt:</p>
<p>Es gibt zu <img src="/img/cache/84354a4d11e73d3841434d94849d47fc.gif" alt="\cal{P}^m_k" valign="middle"/> eine universelle Funktion <img src="/img/cache/0ef69bde630d907c2836478c43166395.gif" alt="\psi_{m,k}\in\cal{P}^{m+1}_k" valign="middle"/>.</p>
<p><strong>Beweis:</strong> (mittels Church'scher These)</p>
<p>Die Menge aller Programme mit m Eingabe- und k Ausgabevariablen
liege in aufgez&auml;hlter Form, etwa
durch <img src="/img/cache/8aed0a1046792038dde5a3e2de125b76.gif" alt="\gamma_{m,k}" valign="middle"/>, vor:</p>
<p><img src="/img/cache/7906f8c6d117713676492bb2145c0df3.gif" alt="\pi_0,\pi_1,\pi_2,\dots" valign="middle"/></p>
<p>Dann ist die Funktion</p>
<p><img src="/img/cache/a8ebb48f0f2fb4b6dc3469e15843a0a8.gif" alt="\psi_{m,k}:=\lambda x,\overline{y}[\varphi_{\pi_{\overline\gamma_{m,k}(x)}(\overline{y})}],\ y\in(A^*)^m" valign="middle"/></p>
<p>universell f&uuml;r <img src="/img/cache/84354a4d11e73d3841434d94849d47fc.gif" alt="\cal{P}^m_k" valign="middle"/>, und <img src="/img/cache/80403f6a0d37048462f823fa7066ecef.gif" alt="\psi_{m,k}" valign="middle"/> ist intuitiv berechenbar.
Wegen der Church'schen These gibt es ein
<img src="/img/cache/a677360d11e4d54256c8592719fed1af.gif" alt="\pi^{m,k}_u\in PL(A)" valign="middle"/> mit m+1 Eingabe- und k Ausgabevariablen
mit <img src="/img/cache/d2bd25a92c9395fb435d481ddf663fef.gif" alt="\psi_{m,k}=\varphi_{\pi^{m,k}_u}" valign="middle"/>.</p>
<div align="right">%</div>
<p><strong>(2.5.13) Bemerkung:</strong> Man kann (2. 5.12) auch beweisen, indem
man auf komplizierte Weise direkt <img src="/img/cache/01275d5bc256f34058dba6de819403ee.gif" alt="\pi^{m,k}_u" valign="middle"/> konstruiert.</p>
 
<h3><a name="c26"></a>2.6. Lexikographische Ordnung von <img src="/img/cache/1304435c8bc4c0f5b8ecbe7f16727d75.gif" alt="A^*" valign="middle"/></h3>
<p>Wir wollen eine weitere G&ouml;delisierung von <img src="/img/cache/1304435c8bc4c0f5b8ecbe7f16727d75.gif" alt="A^*" valign="middle"/> einf&uuml;hren.
Dazu definieren wir zun&auml;chst, was unter der lexikographischen
Ordnung auf <img src="/img/cache/1304435c8bc4c0f5b8ecbe7f16727d75.gif" alt="A^*" valign="middle"/> zu verstehen ist.</p>
<p><strong>(2.6.1) Definition:</strong> Sei <img src="/img/cache/3e5f3cdf4693cd8f757447e96f886065.gif" alt="A=\{a_1,\dots,a_n\}" valign="middle"/>. Die Nachfolgerfunktion
<img src="/img/cache/6d3557ed6ce0982a9d8e57632a413589.gif" alt="\nu : A^* \longr A^*" valign="middle"/> ist definiert durch:</p>
<p><img src="/img/cache/14bab7cef4713e8e9a9660c1498d28f9.gif" alt="
	\nu(\varepsilon) = a_1\\
	\nu(xa_i) = xa_{i+1}\\
	\nu(xa_n) = \nu(x)a_1\text{\ \ f\ddot{u}r }i\in[n-1],\ x \in A^*,\ a_i \in A
" valign="middle"/></p>
<p><strong>(2.6.2) Lemma:</strong> Die Nachfolgerfunktion <img src="/img/cache/6d3557ed6ce0982a9d8e57632a413589.gif" alt="\nu : A^* \longr A^*" valign="middle"/> ist
bijektiv.</p>
<p><strong>Beweis:</strong> Zun&auml;chst ist <img src="/img/cache/4fdefba26320686bb2bd0579a0df421c.gif" alt="\nu" valign="middle"/> injektiv, da zwei Elemente aus <img src="/img/cache/1304435c8bc4c0f5b8ecbe7f16727d75.gif" alt="A^*" valign="middle"/>
nur dann den gleichen Nachfolger haben k&ouml;nnen,
wenn sie gleich sind. <img src="/img/cache/4fdefba26320686bb2bd0579a0df421c.gif" alt="\nu" valign="middle"/> ist surjektiv, da man
durch wiederholte Anwendung von <img src="/img/cache/4fdefba26320686bb2bd0579a0df421c.gif" alt="\nu" valign="middle"/> jedes Wort aus <img src="/img/cache/1304435c8bc4c0f5b8ecbe7f16727d75.gif" alt="A^*" valign="middle"/>
auf das leere Wort reduzieren kann. Also
<img src="/img/cache/bf6a7bf5ff61f3cfc2cde5331c9f3fce.gif" alt="\{\nu^i(\varepsilon)|i\in\mathbb{N}\}=A^*" valign="middle"/>.</p>
<div align="right">%</div>
<p>Wegen <img src="/img/cache/0adeee344df4d7d59c42734f21e2a8e0.gif" alt="w_i=\nu^i(\varepsilon)" valign="middle"/> f&uuml;r jedes Element <img src="/img/cache/aa38f107289d4d73d516190581397349.gif" alt="w_i" valign="middle"/>, aus <img src="/img/cache/1304435c8bc4c0f5b8ecbe7f16727d75.gif" alt="A^*" valign="middle"/> erh&auml;lt man
eine Ordnung auf <img src="/img/cache/1304435c8bc4c0f5b8ecbe7f16727d75.gif" alt="A^*" valign="middle"/>. [5]</p>
<p><strong>(2.6.5) Definition:</strong> Seien <img src="/img/cache/0adeee344df4d7d59c42734f21e2a8e0.gif" alt="w_i=\nu^i(\varepsilon)" valign="middle"/> und <img src="/img/cache/fbcee3989f45e7ea23af9d916a8b1937.gif" alt="w_j=\nu^j(\varepsilon)" valign="middle"/> aus <img src="/img/cache/1304435c8bc4c0f5b8ecbe7f16727d75.gif" alt="A^*" valign="middle"/>,
dann ist <img src="/img/cache/4cbf362fd921c5e49f53ebf670129fb7.gif" alt="w_i\le w_j" valign="middle"/> genau dann, wenn <img src="/img/cache/4f33631eeec864aeb1fb38fe42b2c1dd.gif" alt="i \le j" valign="middle"/> gilt.
Diese Ordnung hei&szlig;t <strong>lexikographische Ordnung</strong> auf <img src="/img/cache/1304435c8bc4c0f5b8ecbe7f16727d75.gif" alt="A^*" valign="middle"/>.</p>
<p>Man kann also alle W&ouml;rter aus <img src="/img/cache/1304435c8bc4c0f5b8ecbe7f16727d75.gif" alt="A^*" valign="middle"/> eindeutig in lexikographischer
Reihenfolge auflisten:</p>
<p><img src="/img/cache/4b36ba1dcf7d7a0b288ec60a30943261.gif" alt="\varepsilon=w_0\lt w_1\lt w_2\dots" valign="middle"/>.</p>
<p><strong>(2.6.4) Satz:</strong> Sei <img src="/img/cache/999ccd0ab14df36c1eff0697a15e6daa.gif" alt="A=\{a_1,\dots,a_p\}" valign="middle"/> und <img src="/img/cache/e32ea026ac2ac5cf7de5dd71d20e2468.gif" alt="A_0=\{1\}" valign="middle"/>. Sei
<img src="/img/cache/55b5186234fdfcd39a6c93985b21310a.gif" alt="C_p:A^*\longr\mathbb{N}_0\hat{=}\{1\}^*" valign="middle"/> die Abbildung, die jedem
<img src="/img/cache/ac4df3d19e82c7cf1e3bd5a674171e19.gif" alt="x \in A^*" valign="middle"/> die Nummer von x in der lexikographischen
 
Reihenfolge zuordnet, also</p>
<p><img src="/img/cache/ee143b8d6b20a4b5f80e3b5b2b796c2c.gif" alt="x \longr i" valign="middle"/> mit <img src="/img/cache/91535a5efcaaa421c703266fa590725d.gif" alt="\nu^i(\varepsilon) = x" valign="middle"/>.</p>
<p>Dann ist <img src="/img/cache/b57ad96dc74b69cb78daf4cc31d961d9.gif" alt="C_p" valign="middle"/> eine bijektive G&ouml;delisierung.</p>
<p><strong>Beweis:</strong></p>
<ol type="i">
<li><img src="/img/cache/b57ad96dc74b69cb78daf4cc31d961d9.gif" alt="C_p" valign="middle"/> ist total, da <img src="/img/cache/b57ad96dc74b69cb78daf4cc31d961d9.gif" alt="C_p" valign="middle"/> auf ganz <img src="/img/cache/1304435c8bc4c0f5b8ecbe7f16727d75.gif" alt="A^*" valign="middle"/> definiert ist.
F&uuml;r jedes x l&auml;&szlig;t sich <img src="/img/cache/543590762caf9e43984014ce6872b21c.gif" alt="C_p(x)" valign="middle"/> durch endlich viele
Anwendungen der Definition von <img src="/img/cache/4fdefba26320686bb2bd0579a0df421c.gif" alt="\nu" valign="middle"/> effektiv
ermitteln. Also ist <img src="/img/cache/ff2ce7a26f1249ab3b339deed20690cb.gif" alt="C_p\in\cal{R}" valign="middle"/>.</li>
<li><img src="/img/cache/b57ad96dc74b69cb78daf4cc31d961d9.gif" alt="C_p" valign="middle"/> ist injektiv, da es keine zwei Elemente aus
<img src="/img/cache/1304435c8bc4c0f5b8ecbe7f16727d75.gif" alt="A^*" valign="middle"/> gibt mit gleicher Stellung in der lexikographischen
Reihenfolge.</li>
<li>Wegen <img src="/img/cache/a4c3d21af6239730945301f50f1654b5.gif" alt="C_p(A^*)=\mathbb{N}_0" valign="middle"/> ist <img src="/img/cache/77c9d5f366278dba0ad68687b16711c7.gif" alt="C_p(A^*)" valign="middle"/> nat&uuml;rlich
entscheidbar.</li>
<li>Beginnend mit dem leeren Wort kann man f&uuml;r jedes
<img src="/img/cache/e552314cfeb56e3a6c3d812674b2d3fc.gif" alt="i\in\mathbb{N}_0" valign="middle"/> mit Hilfe von <img src="/img/cache/4fdefba26320686bb2bd0579a0df421c.gif" alt="\nu" valign="middle"/> effektiv alle Worte aus <img src="/img/cache/1304435c8bc4c0f5b8ecbe7f16727d75.gif" alt="A^*" valign="middle"/>
bis zum i-ten Wort in lexikographischer Reihenfolge
erzeugen. Dieses i-te Wort ist das Urbild
von i. Also ist <img src="/img/cache/3cc61d4f95fb27467bebc94c163a2563.gif" alt="C^{-1}_p" valign="middle"/> berechenbar und wegen
<img src="/img/cache/a4c3d21af6239730945301f50f1654b5.gif" alt="C_p(A^*)=\mathbb{N}_0" valign="middle"/> sogar total. Also <img src="/img/cache/dd729b5ab802d1e72b18bf42e8622187.gif" alt="C^{-1}_p\in\cal{R}" valign="middle"/>.</li>
</ol>
<p>Aus (i) bis (iv) folgt: <img src="/img/cache/b57ad96dc74b69cb78daf4cc31d961d9.gif" alt="C_p" valign="middle"/> ist G&ouml;delisierung.
Wegen (ii) und <img src="/img/cache/a4c3d21af6239730945301f50f1654b5.gif" alt="C_p(A^*)=\mathbb{N}_0" valign="middle"/> folgt: <img src="/img/cache/b57ad96dc74b69cb78daf4cc31d961d9.gif" alt="C_p" valign="middle"/> ist bijektiv.</p>
<div align="right">%</div>
<p><strong>(2.6.5) Lemma:</strong> Seien <img src="/img/cache/3e5f3cdf4693cd8f757447e96f886065.gif" alt="A=\{a_1,\dots,a_n\}" valign="middle"/> und <img src="/img/cache/ec6842abdfd0c0717122612f4149b196.gif" alt="B=\{b_1,\dots,b_m\}" valign="middle"/>
zwei Alphabete, dann ist die Funktion
<img src="/img/cache/2943de75088bcb302dd239608689f9f4.gif" alt="\xi_{n,m}:=C^{-1}_m\circ C_n:A^*\longr B^*" valign="middle"/>
eine bijektive Kodierung von <img src="/img/cache/1304435c8bc4c0f5b8ecbe7f16727d75.gif" alt="A^*" valign="middle"/> durch <img src="/img/cache/5a4ca52d2f97862828a67f2bd32fa20b.gif" alt="B^*" valign="middle"/>.</p>
<p><strong>Beweis:</strong> Offensichtlich.</p>
<div align="right">%</div>
<h3><a name="c27"></a>2.7. Reduktion auf jeweils eine Eingabe- und eine Ausgabevariable</h3>
<p>Wir wollen zeigen, da&szlig; es m&ouml;glich ist, jedes Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/>
aus PL(A) mit r Eingabe- und s Ausgabevariablen in ein
 
"&auml;quivalentes" Programm <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> mit nur jeweils einer Eingabe-
und Ausgabevariablen zu transformieren. Wegen der Entsprechung
von <img src="/img/cache/d1cdbf2fe7e18516c3a793a652b36039.gif" alt="\cal{P}" valign="middle"/> und PL(A) gen&uuml;gt es demnach also, die
Funktionen aus <img src="/img/cache/b4a269d12116a063e30e7d050bba12f4.gif" alt="\cal{P}^1_1" valign="middle"/> zu betrachten, um ganz <img src="/img/cache/d1cdbf2fe7e18516c3a793a652b36039.gif" alt="\cal{P}" valign="middle"/> zu behandeln.
Die universelle Funktion f&uuml;r <img src="/img/cache/b4a269d12116a063e30e7d050bba12f4.gif" alt="\cal{P}^1_1" valign="middle"/> ist in diesem Sinne dann
universell f&uuml;r ganz <img src="/img/cache/d1cdbf2fe7e18516c3a793a652b36039.gif" alt="\cal{P}" valign="middle"/>.</p>
<p>Sei nun <img src="/img/cache/58e0cc48587725d99616501224cadfa5.gif" alt="\pi\in PL(A)" valign="middle"/> mit r Eingabe- und s Ausgabevariablen,
<img src="/img/cache/e791e64f45e34afb52c517f477210ba9.gif" alt="r,s\ge1" valign="middle"/>. Dann hat <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> folgenden Aufbau.</p>
<p><img src="/img/cache/4e6f4ba66fb954b75c4594af46f80a4c.gif" alt="
\begin{align}
\pi =	&amp;\text{\underline{input}}	&amp; X_1,\dots,X_r;\\
	&amp;				&amp; AW_\pi;\\
	&amp;\text{\underline{output}}	&amp; Z_1,\dots,Z_s
\end{align}
" valign="middle"/></p>
<p>Als Eingabebelegung f&uuml;r <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> kommt jedes Element <img src="/img/cache/5504c40e17a12d18fd51df6666e17bdb.gif" alt="\overline{x}=(x_1,\dots,x_r)" valign="middle"/>
aus <img src="/img/cache/31719dca1a36a0c03ffad4ef7ac47f16.gif" alt="(A^*)^r" valign="middle"/> vor. <img src="/img/cache/90d79af00b1e8a4722f418bd2fa0a839.gif" alt="\overline{x}" valign="middle"/> kann man auch wie folgt darstellen:</p>
<p><img src="/img/cache/ecd7db6857389df3c164507512b00550.gif" alt="\overline{x}=x_1|x_2|\dots|x_r\in(A\cup\{|\})^*" valign="middle"/>, dabei sei <img src="/img/cache/c46576b049ab1acf3d80e155524b4d69.gif" alt="|\not\in A" valign="middle"/>.</p>
<p>In dieser Form wird <img src="/img/cache/f7ad7ce12c6daddf30138f3276596121.gif" alt="\overline{x} als Eingabe f&amp;uuml;r ein zu &lt;tex&gt;\pi" valign="middle"/> gleichwertiges
Programm <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> mit nur einer Eingabe- und einer Ausgabevariablen
benutzt.</p>
<p><img src="/img/cache/e0122e68eca5013e4ae7745b3de83f4d.gif" alt="
\begin{align}
\pi =	&amp;&amp;\text{\underline{input}} X\\
	&amp;&amp;[X_1:=x_1;\dots X_r:=x_r];\\
	&amp;&amp;AW_\pi;\\
	&amp;&amp;[Z:=z_1|\dots|z_s];\\
	&amp;&amp;\text{\underline{output}} Z
\end{align}
" valign="middle"/></p>
<p>Die Programmteile in Klammern lassen sich wie folgt realisieren:</p>
<p><img src="/img/cache/5e1c474bd320de8939f3d0c4345c8979.gif" alt="[X_1:=x_1;\dots. X_r:=x_r]" valign="middle"/></p>
<p>durch:</p>
<p><img src="/img/cache/167160c9b7620de34b86c799b67b8002.gif" alt="
\fbox{
X_1:=\varepsilon;\dots X_r:=\varepsilon;\\
\begin{array}{rccclBCB}
\text{\underline{loop}}X&amp;\text{\underline{case}}	&amp; a_1	&amp; \longr&amp; X_r := X_r a_1,\\
			&amp;			&amp; \vdots&amp;	&amp; \vdots\\
			&amp;			&amp; a_n	&amp; \longr&amp; X_r := X_r a_n,\\
			&amp;			&amp; |	&amp; \longr&amp; X_1 := X_2;\\
			&amp;			&amp;	&amp;	&amp; X_2 := X_3;\\
			&amp;			&amp;	&amp;	&amp; \vdots\\
			&amp;			&amp;	&amp;	&amp; X_{r-1} := X_r;\\
			&amp;			&amp;	&amp;	&amp; X_r := \varepsilon,\\
			&amp;\text{\underline{end}}
\end{array}
}
" valign="middle"/></p>
 
<p>und <img src="/img/cache/ccdf4f774310cd28d49eaa7bb9eea469.gif" alt="[Z:=z_1|\dots|z_s]" valign="middle"/></p>
<p>durch</p>
<p><img src="/img/cache/b2db74654eb751973a2445579cff23a6.gif" alt="
\fbox{
	Z:=\varepsilon;\\
\begin{array}{rccclBCB}
	\text{\underline{loop}} Z_1	&amp;\text{\underline{case}}&amp;a_1	&amp; \longr&amp;Z:=Za_1,\\
					&amp;			&amp;\vdots &amp;	&amp;\vdots\\
					&amp;			&amp;a_n	&amp;\longr &amp;Z:=Za_n,\\
					&amp;\text{\underline{end}};
\end{array}\\
	Z:=Z|;\\
\begin{array}{rccclBCB}
	\text{\underline{loop}} Z_2	&amp;\text{\underline{case}}&amp;a_1	&amp; \longr&amp;Z:=Za_1,\\
					&amp;			&amp;\vdots &amp;	&amp;\vdots\\
					&amp;			&amp;a_n	&amp;\longr &amp;Z:=Za_n,\\
					&amp;\text{\underline{end}};
\end{array}\\
	Z:=Z|;\\
	\vdots\\
	Z:=Z|;\\
\begin{array}{rccclBCB}
	\text{\underline{loop}} Z_s	&amp;\text{\underline{case}}&amp;a_1	&amp; \longr&amp;Z:=Za_1,\\
					&amp;			&amp;\vdots &amp;	&amp;\vdots\\
					&amp;			&amp;a_n	&amp;\longr &amp;Z:=Za_n,\\
					&amp;\text{\underline{end}};
\end{array}\\
}
" valign="middle"/></p>
<p><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> ist nicht Element aus PL(A), da das zugrunde liegende
Alphabet nicht A sondern <img src="/img/cache/09fa6fb1a6240ada6a83061bf3e3eaff.gif" alt="A\cup\{|\}\not\in A" valign="middle"/> ist. Wir k&ouml;nnen aber
aus <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> ein ebenfalls zu <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> gleichwertiges Programm <img src="/img/cache/59042f28ef44aa07e9e30f37ab83843e.gif" alt="\pi''\in PL(A)" valign="middle"/>
mit nur einer Ein- und einer Ausgabevariablen gewinnen,
indem wir <img src="/img/cache/a770b612220d1882b93559ad35fde4c2.gif" alt="\{A\cup\{|\}\}^*" valign="middle"/> durch <img src="/img/cache/1304435c8bc4c0f5b8ecbe7f16727d75.gif" alt="A^*" valign="middle"/> kodieren. Als Kodierung k&ouml;nnen
wir die Funktion</p>
<p><img src="/img/cache/99ff584e8670d2a874554bc5d30f77a4.gif" alt="\xi_{n+1,n}:=C^{-1}_n \circ C_{n+1}" valign="middle"/></p>
<p>benutzen, wobei die Funktionen <img src="/img/cache/8bbf0305e59aa08dd91f73393c7f6514.gif" alt="C^{-1}_n" valign="middle"/> und <img src="/img/cache/24ed9b057b8d26b02b80d7cc7926f047.gif" alt="C_{n+1}" valign="middle"/> in 2.6.
definiert sind.</p>
<p>Im wesentlichen lassen sich also alle Programme aus
PL(A) auf eine Eingabe- und eine Ausgabevariable reduzieren,
falls &uuml;berhaupt Ein- bzw. Ausgabevariable vorhanden
sind. Auf Grund der Church'schen These gen&uuml;gt es also,
statt <img src="/img/cache/d1cdbf2fe7e18516c3a793a652b36039.gif" alt="\cal{P}" valign="middle"/> die Menge <img src="/img/cache/b4a269d12116a063e30e7d050bba12f4.gif" alt="\cal{P}^1_1" valign="middle"/> zu betrachten. Die universelle Funktion
<img src="/img/cache/f9b2390a919c5915513d4202e60f3147.gif" alt="\psi_{1,1}" valign="middle"/> f&uuml;r <img src="/img/cache/b4a269d12116a063e30e7d050bba12f4.gif" alt="\cal{P}^1_1" valign="middle"/> ist in diesem Sinne universell f&uuml;r ganz
<img src="/img/cache/d1cdbf2fe7e18516c3a793a652b36039.gif" alt="\cal{P}" valign="middle"/>. Um diesen Tatbestand deutlich zu machen, f&uuml;hren wir die
 
folgende Schreibweise ein.</p>
<p><strong>(2.7.1) Definition:</strong> Sei <img src="/img/cache/f9b2390a919c5915513d4202e60f3147.gif" alt="\psi_{1,1}" valign="middle"/> universelle Funktion f&uuml;r <img src="/img/cache/b4a269d12116a063e30e7d050bba12f4.gif" alt="\cal{P}^1_1" valign="middle"/>.
<img src="/img/cache/47dfb844e5513d3ad9b746c3ab894633.gif" alt="\varphi^k_x:=\lambda y_1,\dots,y_k[\psi_{1,1}(x,\xi_{n+1,n}(y_1|\dots|y_k)]" valign="middle"/>,
<img src="/img/cache/51210a03174864b3ab5817c42071b21a.gif" alt="x,y_1,\dots,y_k\in A^*" valign="middle"/>.</p>
<p>Dabei ist <img src="/img/cache/966016c3c876bb35b027dd251ed7c3ea.gif" alt="\varphi^k_x : (A^*)^k \longr A^*" valign="middle"/>.</p>
<h3><a name="c28"></a>2.8. s-m-n-Theorem, Rekursionstheorem</h3>
<p>Im folgenden werden wir das Rekursionstheorera beweisen,
das uns erm&ouml;glicht, die Existenz selbstreproduzierender
PL(A)-Programme nachzuweisen. Sei A so gew&auml;hlt, da&szlig; jedes
PL(A)-Programm in <img src="/img/cache/1304435c8bc4c0f5b8ecbe7f16727d75.gif" alt="A^*" valign="middle"/> liegt (Vermeidung von Umkodierungen).</p>
<p><strong>(2.8.1) Satz (s-m-n-Theorem):</strong></p>
<p>F&uuml;r alle <img src="/img/cache/c072c5a10fa3c84c0c0d5e6675310e0c.gif" alt="m,n\in\mathbb{N}" valign="middle"/> gibt es eine Funktion <img src="/img/cache/8fdcdb6589135a485c13e34d25ac32eb.gif" alt="s^m_n\in\cal{R}^{m+1}_1" valign="middle"/>,
die f&uuml;r alle <img src="/img/cache/d27c0cea823240b4b23ecc4390564960.gif" alt="x\in A^*,\ \overline{y}\in(A^*)^m,\ \overline{z}\in(A^*)^n" valign="middle"/> folgende Gleichung erf&uuml;llt:</p>
<p><img src="/img/cache/8ae9860ba1de05084302685544d2b8dd.gif" alt="\varphi^{m+n}_x(\overline{y},\overline{z})=\varphi^n_{s^m_n(x,\overline{y})}(\overline{z})" valign="middle"/></p>
<p><strong>Beweis:</strong> Seien <img src="/img/cache/f32ee6b846d57e75542fce9d9701f2be.gif" alt="n,m\in\mathbb{N}" valign="middle"/> fest gew&auml;hlt.</p>
<ol>
<li><strong>Fall:</strong> x ist kein g&uuml;ltiger Programmtext. Dann ist
<img src="/img/cache/47a9cbadc80011715227f9d8cec60fdb.gif" alt="\varphi^{m+n}_x" valign="middle"/> undefiniert. In diesem Falle mu&szlig; <img src="/img/cache/cb990f9b3da98daaec8f142e0dba8479.gif" alt="\varphi^n_{s^m_n(x,\overline{y})}" valign="middle"/>
auch undefiniert sein. Es wird deshalb
<img src="/img/cache/b50357bef49477795c7c0b6b895de33f.gif" alt="s^m_n(x,\overline{y}) = \varepsilon" valign="middle"/> gesetzt. Nun ist auch <img src="/img/cache/da20ba78830a01c2858cc5984c8a691b.gif" alt="s^m_n(x,\overline{y})" valign="middle"/>
kein g&uuml;ltiger Programmtext, und es gilt:
<p><img src="/img/cache/9ea1dcecc4641fb5ad43a53637073f1e.gif" alt="\varphi^{m+n}_x(\overline{y},\overline{z}) = \varphi^n_{s^m_n(x,\overline{y})}(\overline{z}) =\text{undefiniert}." valign="middle"/></p></li>
<li><strong>Fall:</strong> x ist ein g&uuml;ltiger Programmtext. Also
<img src="/img/cache/6005aaa1aae6b184547aafc692465dbe.gif" alt="x \in PL(A)" valign="middle"/>. Dann hat x den Aufbau:
<p><img src="/img/cache/f86c736080b7ab0130990b0844b76440.gif" alt="
\begin{align}
x =	&amp;\text{\underline{input}}	&amp; Y_1,\dots,Y_m,Z_1,\dots,Z_n\\
	&amp;				&amp; AW_x;\\
	&amp;\text{\underline{output}}	&amp; W
\end{align}
	" valign="middle"/></p>
</li>
</ol>
 
<p>Mit <img src="/img/cache/3dae98e81088ce74d566670cd519ca3b.gif" alt="\overline{y} = (y_1,y_2,\dots,y_m)" valign="middle"/> wird gesetzt:</p>
<p><img src="/img/cache/fa4e1910f1dca602b480986d6ca6ffd8.gif" alt="
\begin{align}
s^m_n(x,\overline{y}) =	&amp;&amp;\text{\underline{input}} Z_1,\dots,Z_n;\\
			&amp;&amp; [Y_1:=y_1];\dots;[Y_m:=y_m];\\
			&amp;&amp; AW_x;\\
			&amp;&amp;\text{\underline{output}} W
\end{align}
" valign="middle"/></p>
<p>Die Programmteile in eckigen Klammern lassen
sich leicht - wie am Beispiel von <img src="/img/cache/470ce26784c165e984b0eacb36057664.gif" alt="[Y_1:=y_1]" valign="middle"/>
gezeigt - realisieren:</p>
<p><img src="/img/cache/4764360e2689c701dfb8b917ba7638ac.gif" alt="y_1" valign="middle"/> ist Element aus <img src="/img/cache/1304435c8bc4c0f5b8ecbe7f16727d75.gif" alt="A^*" valign="middle"/> und hat somit endliche
L&auml;nge <img src="/img/cache/630bcea562ea8bc481238849960e015f.gif" alt="l(y_1)\in\mathbb{N}_0" valign="middle"/></p>
<p><img src="/img/cache/3c3624e84543470fb320213e6e963ed3.gif" alt="y_1 = a_{1_1}\dots a_{1_{l(y_1)}}" valign="middle"/> mit <img src="/img/cache/30a729604240a2f5a1d08d7eeeb9af35.gif" alt="a_{1_j}\in A^*" valign="middle"/>.</p>
<p>Damit wird <img src="/img/cache/470ce26784c165e984b0eacb36057664.gif" alt="[Y_1:=y_1]" valign="middle"/> realisiert durch</p>
<p><img src="/img/cache/591d0c9772389f494e107e485cf0ef36.gif" alt="
Y_1:=\varepsilon;\\
Y_1:=Y_1 a_{1_1}\\
\vdots\\
Y_1:=Y_1 a_{1_{l(y_1)}};
" valign="middle"/></p>
<p>Auf Grund der Cnurch'schen These ist <img src="/img/cache/8fdcdb6589135a485c13e34d25ac32eb.gif" alt="s^m_n\in\cal{R}^{m+1}_1" valign="middle"/>.</p>
<div align="right">%</div>
<p><strong>(2.8.2) Korollar:</strong> Es gibt ein <img src="/img/cache/671d790b77789d418624a1d826ad535e.gif" alt="h\in\cal{R}^m_1" valign="middle"/>, so da&szlig; f&uuml;r alle
<img src="/img/cache/af696e1316f04928e7971e8f86e9ca37.gif" alt="f\in\cal{R}^{m+n}_1" valign="middle"/> gilt:</p>
<p><img src="/img/cache/88e3873ca89f7d3e36d375ec523a0803.gif" alt="f(\overline{y},\overline{x})=\varphi^n_{h(\overline{y})}(\overline{x})" valign="middle"/> f&uuml;r alle <img src="/img/cache/add15cdd288de0f978236e1ea5ef48a1.gif" alt="\overline{x}\in(A^*)^m,\ \overline{y}\in(A^*)^n" valign="middle"/>.</p>
<p><strong>Beweis:</strong> Da f eine berechenbare Funktion ist, gibt es ein
Programm <img src="/img/cache/8153f1eb72802e5092f6db1292b0ef2b.gif" alt="\pi_0\in A^*" valign="middle"/>, mit <img src="/img/cache/ca72e017ca7bc0b45d2e5083adc1d2e8.gif" alt="f=\varphi^{m+n}_{\pi_0}" valign="middle"/>. Aus (2.3.1) folgt</p>
<p><img src="/img/cache/08e1d0cc19c5b9b92d025b04849c6fc2.gif" alt="f(\overline{y},\overline{x})=\varphi^{m+n}_{\pi_0}(\overline{y},\overline{x})=\varphi^n_{s^m_n(\pi_0,\overline{y})}(\overline{x})" valign="middle"/>.</p>
<p>Setzt man <img src="/img/cache/62cf607d7fe6c7e09692c1994aff24cd.gif" alt="h := \lambda\overline{y}[s^m_n(\pi_0,\overline{y})]" valign="middle"/>, so folgt das
Korollar.</p>
<div align="right">%</div>
 
<p><strong>(2.8.3) Bezeichnung:</strong> Sei <img src="/img/cache/3a0e11d39e35f6784f3df01a329e08dd.gif" alt="g\in\cal{P}^{k+1}_1" valign="middle"/>. Dann existiert ein
Programm <img src="/img/cache/142f074cff5b2ffee68b6ca88b777018.gif" alt="x\in A^*" valign="middle"/> mit <img src="/img/cache/a9c6e52d0a39862d28b7e24cc088f86c.gif" alt="g=\varphi^{k+1}_x" valign="middle"/>.</p>
<p>Wir f&uuml;hren nun folgende Notation ein:</p>
<p><img src="/img/cache/8307068084d786ccec65f52b588fcc5d.gif" alt="g_x:=\varphi^k_{s^1_k(x,y)}" valign="middle"/></p>
<p>Es gilt mit dieser Notation:</p>
<p><img src="/img/cache/cb0ee462c89aaba6ab66ac86e5cf687c.gif" alt="g_x(\overline{y})=g(x,\overline{y})" valign="middle"/> f&uuml;r alle <img src="/img/cache/b4e80618750d91635a761a110fc12766.gif" alt="\overline{y}\in(A^*)^k" valign="middle"/>.</p>
<p>Sei <img src="/img/cache/ce99b96fed9f426ea891e7bdfc88c709.gif" alt="h\in\cal{P}^r_1" valign="middle"/> und <img src="/img/cache/f21e8c2a352a124ebe16b3ed5254aa6a.gif" alt="h(\overline{x})=\text{undefiniert}" valign="middle"/> f&uuml;r ein <img src="/img/cache/dd12bc1ba5a19065c8a6ed826b92f5dc.gif" alt="\overline{x}\in(A^*)^r" valign="middle"/>, so
ist nach obiger Notation die Funktion <img src="/img/cache/7fec443cc832cdffe9482731d5148363.gif" alt="g_{h(\overline{x})}" valign="middle"/> &uuml;berall undefiniert.</p>
<p>Wir sind nun in der Lage, das Kleene'sche Rekursionstheorem
in der folgenden Fassung zu beweisen:</p>
<p><strong>(2.8.4) Satz (Pekursionstheorem, Formulierung wie in [5]):</strong></p>
<p>Zu jeder Funktion <img src="/img/cache/599cb2da0fca21608d40413db8bc3b80.gif" alt="f\in|cal{P}^1_1" valign="middle"/> gibt es einen Text <img src="/img/cache/142f074cff5b2ffee68b6ca88b777018.gif" alt="x\in A^*" valign="middle"/>,
so da&szlig; gilt:</p>
<p><img src="/img/cache/af88de433292f49f7a09daeeff0813df.gif" alt="\varphi_x=\varphi_{f(x)}" valign="middle"/></p>
<p><strong>Beweis:</strong> Die Funktion</p>
<p><img src="/img/cache/e78c5b6b8ad7ebe86741bf5d0b3cde24.gif" alt="g=\lambda y,x[\varphi_{\varphi_y(y)}(x)]" valign="middle"/></p>
<p>liegt in <img src="/img/cache/ff42b90d207725785e89e4c666898a26.gif" alt="\cal{P}^2_1" valign="middle"/> mit <img src="/img/cache/5973df9f9f952b6f05602c0b1307caf4.gif" alt="x,y \in A^*" valign="middle"/>. In Korollar (2.8.2)
wurde gezeigt, da&szlig; ein <img src="/img/cache/b06af090e419ac1469e26b0089276fbe.gif" alt="h\in\cal{R}^1_1" valign="middle"/>, existiert mit</p>
<p><img src="/img/cache/cdb43dc838551ef91f3d1ba98667c3c3.gif" alt="(1)\ \ \varphi_{h(y)} = g_y =\varphi_{\varphi_y(y)}\ \ \text{f\ddot{u}r alle } y\in A^*" valign="middle"/></p>
<p>Sei nun <img src="/img/cache/8a1ba8ad185a8fb33103c3e49d54c37a.gif" alt="f\in\cal{P}^1_1" valign="middle"/>. Da <img src="/img/cache/b06af090e419ac1469e26b0089276fbe.gif" alt="h\in\cal{R}^1_1" valign="middle"/> ist, kann man die
Hintereinanderausf&uuml;hrung von f und h betrachten. <img src="/img/cache/a9f82eb01490e611248753d99ed4767f.gif" alt="f \circ h" valign="middle"/>
liegt ebenfalls in <img src="/img/cache/b4a269d12116a063e30e7d050bba12f4.gif" alt="\cal{P}^1_1" valign="middle"/>. Auf Grund der Church'schen
These kann man zu <img src="/img/cache/a9f82eb01490e611248753d99ed4767f.gif" alt="f \circ h" valign="middle"/> effektiv einen Programmtext
<img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> aus PL(A) angeben mit</p>
<p><img src="/img/cache/8eed364e14c56864ee64bb24c3d7c534.gif" alt="(2)\ \ \varphi_\pi = f \circ h" valign="middle"/></p>
<p>Aus (1) und (2) folgt dann zusammen:</p>
 
<p><img src="/img/cache/3f384628885fec7905c344ac5e29943a.gif" alt="\varphi_{h(\pi)} \overset{(1)}{=} \varphi_{\varphi_\pi(\pi)} \overset{(2)}{=} \varphi_{f(h(\pi))}" valign="middle"/></p>
<p>Damit ist <img src="/img/cache/73671165e1bdcbad8b2b9b6515884553.gif" alt="x = h(\pi)" valign="middle"/> das gesuchte x.</p>
<div align="right">%</div>
<p><strong>(2.8.5) Definition:</strong> Sei <img src="/img/cache/8a1ba8ad185a8fb33103c3e49d54c37a.gif" alt="f\in\cal{P}^1_1" valign="middle"/>. Ein Element <img src="/img/cache/ac4df3d19e82c7cf1e3bd5a674171e19.gif" alt="x \in A^*" valign="middle"/> hei&szlig;t
<strong>Fixpunkt zu f</strong>, falls gilt <img src="/img/cache/cfcd51b7ce9e2c88c27e67284d6388b9.gif" alt="\varphi_x = \varphi_{f(x)}" valign="middle"/>.</p>
<p><strong>(2.8.6) Korollar:</strong> Zu jeder Funktion <img src="/img/cache/0d1933d6e44f401a3e28f5339027fc40.gif" alt="g\in\cal{P}^2_1" valign="middle"/> existiert ein
Text <img src="/img/cache/5e4d89120c0624adbe9510a9061c879d.gif" alt="x_0 \in A^*" valign="middle"/> mit <img src="/img/cache/711c7ec3aa5c37570214ad6b3acc6191.gif" alt="\varphi_{x_0} = g_{x_0}" valign="middle"/>.</p>
<p><strong>Beweis:</strong> Nach Korollar (2.8.2) existiert eine Funktion
<img src="/img/cache/b06af090e419ac1469e26b0089276fbe.gif" alt="h\in\cal{R}^1_1" valign="middle"/> mit <img src="/img/cache/c3fd8500c52b68b08c1d86b687e16320.gif" alt="\varphi_{h(y)} = g_y" valign="middle"/> f&uuml;r alle <img src="/img/cache/d118ceebeb0e802391e0ec9c1d9b324d.gif" alt="y\in A^*" valign="middle"/>.</p>
<p>h hat nach dem Rekursionstheorem einen Fixpunkt <img src="/img/cache/3e0d691f3a530e6c7e079636f20c111b.gif" alt="x_0" valign="middle"/>
mit <img src="/img/cache/63b41f6e51289e22b7e32e52473c4a6e.gif" alt="\varphi_{x_0}=\varphi_{h(x_0)}=g_{x_0}" valign="middle"/></p>
<div align="right">%</div>
<p><strong>(2.8.7) Satz:</strong> Es existiert in <img src="/img/cache/b4a269d12116a063e30e7d050bba12f4.gif" alt="\cal{P}^1_1" valign="middle"/> eine Funktion mit einem
Programmtext <img src="/img/cache/0fac8433c09af45b2dbf887a65f33ada.gif" alt="x_0\in A^*" valign="middle"/>, der f&uuml;r jede Eingabe <img src="/img/cache/d118ceebeb0e802391e0ec9c1d9b324d.gif" alt="y\in A^*" valign="middle"/>
seinen eigenen Text <img src="/img/cache/3e0d691f3a530e6c7e079636f20c111b.gif" alt="x_0" valign="middle"/> ausgibt.</p>
<p><strong>Beweis:</strong> Die Funktion <img src="/img/cache/98b19e9d0c87649a03c58f7585c65e61.gif" alt="g = \Pi^2_1 : (A^*)^2 \longr A^*" valign="middle"/> mit
<img src="/img/cache/cba8ae32f8cf623b70714b7fa7860c5c.gif" alt="g(x,y):=x" valign="middle"/> f&uuml;r alle <img src="/img/cache/5973df9f9f952b6f05602c0b1307caf4.gif" alt="x,y \in A^*" valign="middle"/> ist trivialerweise
aus <img src="/img/cache/ff42b90d207725785e89e4c666898a26.gif" alt="\cal{P}^2_1" valign="middle"/></p>
<p>Aus Korollar (2.8.6) folgt damit, da&szlig; die Gleichung
<img src="/img/cache/4ad5daa1158beb2c1f5fee582f9d2b83.gif" alt="\varphi_x = g_x" valign="middle"/> eine L&ouml;sung <img src="/img/cache/3e0d691f3a530e6c7e079636f20c111b.gif" alt="x_0" valign="middle"/> besitzt. Es
existiert also ein <img src="/img/cache/5e4d89120c0624adbe9510a9061c879d.gif" alt="x_0 \in A^*" valign="middle"/> mit</p>
<p><img src="/img/cache/55131545a411da72c0d64772842ad5f9.gif" alt="\varphi_{x_0} = g_{x_0} = \lambda y [x_0] \Rightarrow \varphi_{x_0}(y) = x_0\ \ \forall y \in A^*" valign="middle"/></p>
<p><img src="/img/cache/437f569fba742d3650fce783f8b87841.gif" alt="\varphi_{x_0}" valign="middle"/> ist also eine Funktion, die bei jeder
Eingabe <img src="/img/cache/1accda3c6e010721e4d8d78fcbc33817.gif" alt="y \in A^*" valign="middle"/> ihren eigenen Programmtext <img src="/img/cache/3e0d691f3a530e6c7e079636f20c111b.gif" alt="x_0" valign="middle"/> ausgibt.
Mit <img src="/img/cache/586013da3f604afb1f1285019f321ea2.gif" alt="\varphi_{x_0}\in\cal{P}^1_1" valign="middle"/> (trivial) ist der Satz vollst&auml;ndig
bewiesen.</p>
<div align="right">%</div>
<p>Der folgende Satz ist eine Verallgemeinerung von Satz (2.8.7).</p>
 
<p><strong>(2.8.8) Satz:</strong> Sei <img src="/img/cache/83346b95514d1163e7e16c4359171c7a.gif" alt="f\ :\ A^* \longr A^*" valign="middle"/> aus <img src="/img/cache/b4a269d12116a063e30e7d050bba12f4.gif" alt="\cal{P}^1_1" valign="middle"/>. Dann existiert
in <img src="/img/cache/b4a269d12116a063e30e7d050bba12f4.gif" alt="\cal{P}^1_1" valign="middle"/> eine Funktion mit einem Programmtext <img src="/img/cache/5e4d89120c0624adbe9510a9061c879d.gif" alt="x_0 \in A^*" valign="middle"/>, der f&uuml;r jede Eingabe den Wert <img src="/img/cache/c58b04667bcf6700fa38285f33640500.gif" alt="f(x_0)" valign="middle"/> ausgibt.</p>
<p><strong>Beweis:</strong> Sei <img src="/img/cache/8a1ba8ad185a8fb33103c3e49d54c37a.gif" alt="f\in\cal{P}^1_1" valign="middle"/>. Die Funktion <img src="/img/cache/a2fbd5576375599295d7b746201e8022.gif" alt="g\ :\ (A^*)^2 \longr A^*" valign="middle"/> mit</p>
<p><img src="/img/cache/fd417d05c1d64959f615a67554e79911.gif" alt="g(x,y):=\Pi^2_1(f(x),y)=f(x),\ \ x,y \in A^*" valign="middle"/>,</p>
<p>liegt in <img src="/img/cache/ff42b90d207725785e89e4c666898a26.gif" alt="\cal{P}^2_1" valign="middle"/>. Dies folgt aus der Abgeschlossenheit
von <img src="/img/cache/d1cdbf2fe7e18516c3a793a652b36039.gif" alt="\cal{P}" valign="middle"/> gegen&uuml;ber der Kombination und der Substitution
von Funktionen (vgl. etwa [5]). Aus (2.8.6)
folgt damit, da&szlig; die Gleichung <img src="/img/cache/4ad5daa1158beb2c1f5fee582f9d2b83.gif" alt="\varphi_x = g_x" valign="middle"/> eine
L&ouml;sung <img src="/img/cache/3e0d691f3a530e6c7e079636f20c111b.gif" alt="x_0" valign="middle"/> besitzt. Es existiert also ein <img src="/img/cache/5e4d89120c0624adbe9510a9061c879d.gif" alt="x_0 \in A^*" valign="middle"/> mit</p>
<p><img src="/img/cache/3dc7734aae8ee4271907ade74cf2fc52.gif" alt="\varphi_{x_0}=g_{x_0}=\lambda y[f(x_0)]\Rightarrow\varphi_{x_0}(y)=f(x_0)\ \ \forall y \in A^*" valign="middle"/></p>
<p>Da <img src="/img/cache/437f569fba742d3650fce783f8b87841.gif" alt="\varphi_{x_0}" valign="middle"/> eine konstante Funktion ist, liegt <img src="/img/cache/437f569fba742d3650fce783f8b87841.gif" alt="\varphi_{x_0}" valign="middle"/>
trivialerweise in <img src="/img/cache/b4a269d12116a063e30e7d050bba12f4.gif" alt="\cal{P}^1_1" valign="middle"/>. <img src="/img/cache/437f569fba742d3650fce783f8b87841.gif" alt="\varphi_{x_0}" valign="middle"/> ist die gesuchte
Funktion.</p>
<div align="right">%</div>
<p>Aus Satz (2.8.8) folgt, da&szlig; es PL(A)-Programme gibt, die
sich, nicht nur einfach selbstreproduzieren, sondern ihren
eigenen Text mehrmals ausgeben.</p>
<p><strong>(2.8.9) Korollar:</strong> F&uuml;r jedes <img src="/img/cache/8eaacb21571b89f41fa5690f9c036479.gif" alt="i\in\mathbb{N}" valign="middle"/> existiert eine Funktion
mit einem Programmtext <img src="/img/cache/7c74c583688a6fd24356cdf0ed6a3b77.gif" alt="x_{i_0} \in A^*" valign="middle"/>, der f&uuml;r jede Eingabe
<img src="/img/cache/1accda3c6e010721e4d8d78fcbc33817.gif" alt="y \in A^*" valign="middle"/> seinen eigenen Text <img src="/img/cache/a66819a079338b76af2c1faad07b2e97.gif" alt="x_{i_0}" valign="middle"/> i-mal hintereinander
ausgibt.</p>
<p><strong>Beweis:</strong> Sei <img src="/img/cache/8eaacb21571b89f41fa5690f9c036479.gif" alt="i\in\mathbb{N}" valign="middle"/>. Dann ergibt sich der Beweis aus dem
Beweis von Satz (2.8.8) mit</p>
<p><img src="/img/cache/308a3df73bb8e620c7821899cdc59c18.gif" alt="
\begin{array}{rccclBCB}
f =	&amp; f_i\ :\ A^* \longr A^*\\
	&amp; f_i(x) := x_i	&amp; ( = \underbrace{x \dots\dots x} ).\\
	&amp;		&amp; i-mal
\end{array}
" valign="middle"/></p>
<div align="right">%</div>
<p><strong>(2.8.10) Bemerkung:</strong> Satz (2.8.7) ergibt sich als Spezialfall
 
von Satz (2.8.8) mit f = id.</p>
<p>Mit Hilfe der vorangegangenen S&auml;tze haben wir die Existenz
selbstreproduzierender PL(A)-Programme auf theoretischem
Wege nachgewiesen. Die Beweise sind zwar konstruktiv, jedoch
lassen sich die Konstruktionen nicht nachvollziehen,
um ein konkretes selbstreproduzierendes PL(A)-Programm zu
erzeugen. In 2.5. haben wir gesehen, da&szlig; die Menge
aller PL(A)-Programme aufz&auml;hlbar ist. Z&auml;hlt man die Menge
aller PL(A)-Programme auf, etwa in lexikographischer
Reihenfolge, so garantiert Satz (2.8.7) die Existenz einer
Zahl <img src="/img/cache/0ecca84918a2b874483d0a7f309ebf11.gif" alt="i_0\in\mathbb{N}_0" valign="middle"/> mit <img src="/img/cache/7f2111bb6f9e11719c1d663c33d78e17.gif" alt="\pi_{i_0}" valign="middle"/> ist selbstreproduzierend. F&uuml;r die
Zahl <img src="/img/cache/4a767ada62cc8cca3501af23d53f5c8e.gif" alt="i_0" valign="middle"/> ist jedoch eine Gr&ouml;&szlig;enordnung zu erwarten, die
Aufz&auml;hlung als Mittel zur Gewinnung eines selbstreproduzierenden
PL(A)-Programms ausschlie&szlig;t.</p>
<p>Die Bedeutung von Kapitel 2 liegt darin, da&szlig; es nicht
prinzipiell sinnlos ist, selbstreproduzierende Programme
in h&ouml;heren Programmiersprachen zu suchen; sie existieren
wirklich.</p>
<p><strong>(2.8.11) Bemerkung:</strong> In 4.3. werden zyklisch selbstreproduzierende
Programme behandelt (vgl. Definition
(4.3.1)). Die Existenz zyklisch selbstreproduzierender
Programme l&auml;&szlig;t sich wahrscheinlich ebenfalls
aus dem Rekursionstheorem folgern.</p>
 
<h2><a name="c3"></a>3. Selbstreproduzierende Programme in realen Programmiersprachen - Einige Beispiele</h2>
<h3><a name="c31"></a>3.1. Einleitung</h3>
<p>In Kapitel 2 wurde gezeigt, da&szlig; in der fiktiven Programmiersprache
PL(A) selbstreproduzierende Programme existieren.
Da PL(A) die gleiche "Berechenkapazit&auml;t" wie alle
g&auml;ngigen Programmiersprachen hat, m&uuml;ssen auch in konkreten
Programmiersprachen selbstreproduzierende Programme
existieren. Ausgehend von praktischen &Uuml;berlegungen werden im
folgenden einige Beispiele f&uuml;r m&ouml;glichst kurze
selbstreproduzierende Programme in den h&ouml;heren Programmiersprachen
SIMULA und PASCAL konstruiert. Wir werden dabei sowohl auf
selbstreproduzierende Programme sto&szlig;en, die sich ohne weiteres
auf realen Rechenanlagen implementieren lassen, als
auch Programme finden, die zwar syntaktisch korrekt sind,
sich aber aus verschiedensten Gr&uuml;nden nicht realisieren
lassen. Wo es m&ouml;glich ist, werden aus Letzteren Programmen
impiementierbare Versionen gewonnen.</p>
<p>In Abschnitt 3.4. werden einige Beispiele f&uuml;r
selbstreproduzierende Programme in einer maschinenorientierten
Sprache (SIEMENS-Assemblersprache) angegeben (vgl. 3.4.).</p>
<h3><a name="c32"></a>3.2. Selbstreproduzierende Programme in SIMULA<sup><a href="#p034_1" name="b034_1">1)</a></sup></h3>
<p>In diesem Abschnitt sollen selbstreproduzierende Programme
in der Programmiersprache SIMULA entwickelt werden. SIMULA
steht hier als Beispiel f&uuml;r eine blockorientierte
Programmiersprache. Die in 3.3. behandelte Sprache PASCAL ist
dagegen nicht blockorientiert. F&uuml;r uns wird sich jedoch ein
anderes Unterscheidungsmerkmal als wichtiger erweisen. Es
handelt sich dabei um die Verf&uuml;gbarkeit von Textvariablen.
W&auml;hrend PASCAL nur einfache Textkonstanten kennt, kann in
SIMULA mit echten Textvariablen operiert werden. Durch Integration
in das SIMULA-Klassenkonzept kann die Bearbeitung
von Variablen des Typs <strong>text</strong> in SIMULA sehr komfortabel
 
sein. Dies nutzen wir in Abschnitt 3.2.5. aus.</p>
<h4><a name="c321"></a>3.2.1. Naiver Ansatz</h4>
<p>Um eine Vorstellung von der Problematik, ein selbstreproduzierendes
SIMULA-Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> anzugeben, zu erhalten, betrachten
wir folgenden naiven Ansatz:</p>
<p><img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> enth&auml;lt im wesentlichen nur eine Ausgabeanweisung.
Diese Anweisung gibt den ganzen Programmtext von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> aus.</p>
<p>Ein solcher Ansatz f&uuml;hrt zu folgendem Programm <img src="/img/cache/d4c98d75e25f5d28461f1da221eb7a95.gif" alt="\pi_0" valign="middle"/>:</p>
<pre><img src="/img/cache/d4c98d75e25f5d28461f1da221eb7a95.gif" alt="\pi_0" valign="middle"/> = <strong>begin</strong> OUTTEXT("....................") <strong>end</strong>;
                               &uarr;
               An dieser Stelle mu&szlig; der Programm-
	       text von <img src="/img/cache/d4c98d75e25f5d28461f1da221eb7a95.gif" alt="\pi_0" valign="middle"/> erscheinen, also:
	       <strong>begin</strong> OUTTEXT("..........") <strong>end</strong>;
  	                           &uarr;
				   siehe oben
               <img src="/img/cache/f750e0a797eedef801aaf50716fbd542.gif" alt="\vdots" valign="middle"/>

	       <img src="/img/cache/f750e0a797eedef801aaf50716fbd542.gif" alt="\vdots" valign="middle"/>
</pre>
<p>Insgesamt entsteht also ein sich rekursiv aufbl&auml;hendes
Programm, das sich auch wie folgt schreiben l&auml;&szlig;t:</p>
<pre><img src="/img/cache/d4c98d75e25f5d28461f1da221eb7a95.gif" alt="\pi_0" valign="middle"/> = <strong>begin</strong> OUTTEXT("BEGIN OUTTEXT("BEGIN
            OUTTEXT("BEGIN OUTTEXT("......
	    ..............................
            .............END") END") END")
      <strong>end</strong>
</pre>
<p><img src="/img/cache/d4c98d75e25f5d28461f1da221eb7a95.gif" alt="\pi_0" valign="middle"/> ist nat&uuml;rlich kein endlicher Text und damit kein
Programm mehr. Die "Unm&ouml;glichkeit" von <img src="/img/cache/d4c98d75e25f5d28461f1da221eb7a95.gif" alt="\pi_0" valign="middle"/> l&auml;&szlig;t sich
auch an der Unerf&uuml;llbarkeit der Textgleichung</p>
<pre>X = begin OUTTEXT("x") end</pre>
<p>zwischen dem Text x und den Konstanten <strong>begin OUTTEXT("</strong>
und <strong>") end</strong> ablesen: Texte verschiedener L&auml;nge k&ouml;nnen
nicht gleich sein!</p>
 
<h4><a name="c322"></a>3.2.2. Textzerlegung und Algorithmus</h4>
<p>Aus 3.2.1. folgt, da&szlig; ein selbstreproduzierendes SIMULA-programm
<img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> seinen eigenen Text nicht en bloc mit einer
einzigen Ausgabeanweisung ausgeben kann. <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> mu&szlig; seinen
Text also in mehreren Schritten aus einigen Teilstrings
zusammensetzen. Es mu&szlig; also eine</p>
<ol type="i">
<li><strong>Zerlegung des Textes <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/></strong>
<p>vorgenommen werden. Da wir &uuml;ber die Art der Zerlegung
nichts wissen, versuchen wir es zun&auml;chst mit der totalen
Zerlegung von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/>, das hei&szlig;t, wir zerlegen <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> in einzelne
Zeichen. Belassen wir es bei dieser Ma&szlig;nahme, so kommen
wir zu folgendem Programm.</p>
<pre><img src="/img/cache/4d50b474c7a8b790bdd18aa1ee199f42.gif" alt="\pi_1" valign="middle"/> = <strong>begin</strong>
      OUTTEXT("B");
      OUTTEXT("E");
      OUTTEXT("G");
      OUTTEXT("I");
      OUTTEXT("N");
      OUTTEXT("<img src="/img/cache/6ee963bd1c7a69af7c2a7569a544185a.gif" alt="\tiny{\rotate{-90}]}" valign="middle"/>");
      OUTTEXT("O");
      <img src="/img/cache/f750e0a797eedef801aaf50716fbd542.gif" alt="\vdots" valign="middle"/>

      <img src="/img/cache/f750e0a797eedef801aaf50716fbd542.gif" alt="\vdots" valign="middle"/>
</pre>
<p>Es ist klar, da&szlig; <img src="/img/cache/4d50b474c7a8b790bdd18aa1ee199f42.gif" alt="\pi_1" valign="middle"/> einen unendlichen Text darstellt
und damit kein Programm sein kann.</p>
<p>Die Unendlichkeit von <img src="/img/cache/4d50b474c7a8b790bdd18aa1ee199f42.gif" alt="\pi_1" valign="middle"/> liegt darin begr&uuml;ndet,
da&szlig; zur Ausgabe eines Zeichens eine Anweisung - und
damit auch ein Text - bestehend aus insgesamt 13 Zeichen
notwendig ist. Damit ist ein rein sequentielles
Programm wie <img src="/img/cache/4d50b474c7a8b790bdd18aa1ee199f42.gif" alt="\pi_1" valign="middle"/> zum Scheitern verurteilt, wenn der Programmtext
in einzelne Buchstaben zerlegt wird. Die Wahl
eines der Zerlegung des Programmtextes entsprechend
strukturierten</p>
</li>
<li><strong>Algorithmus</strong>
<p>ist ein bedeutendes Kriterium, das bei der praktischen
Konstruktion selbstreproduzierender Programme beachtet
 
werden mu&szlig;.</p>
</li>
</ol>
<p>(i) und (ii) stellen die beiden wichtigsten Aspekte
selbstreproduzierender Programme dar. Bei den folgenden
Konstruktionen selbstreproduzierender Programme wird es
also darum gehen, eine geschickte Zerlegung des Programmtextes
und einen geeigneten Ausgabealgorithmus zu finden.</p>
<h4><a name="c323"></a>3.2.3. Ein tabellengesteuertes Programm</h4>
<p>Wir greifen mit Programm <img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/> die Idee von der totalen
Zerlegung des Textes <img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/> in einzelne Zeichen aus 3.2.2. auf.
Diese Zerlegung wird aber nicht wie in <img src="/img/cache/4d50b474c7a8b790bdd18aa1ee199f42.gif" alt="\pi_1" valign="middle"/> explizit sichtbar,
sondern sie &auml;u&szlig;ert sich im verwendeten Algorithmus.
Dieser Algorithmus setzt den Text von <img src="/img/cache/4d50b474c7a8b790bdd18aa1ee199f42.gif" alt="\pi_1" valign="middle"/>, aus einzelnen
Zeichen zusammen. Die Menge der zul&auml;ssigen Zeichen steht
im Algorithmus in Form eines Feldes</p>
<pre><strong>character array</strong> C [0 : maxchar]</pre>
<p>zur Verf&uuml;gung. Jedes Element von C enth&auml;lt genau ein
Zeichen, das zur Erstellung von SIMULA-Programmen verwendet
werden darf. Alle derartigen Zeichen sind in C enthalten.</p>
<p><img src="/img/cache/7567b1a16997005774b583e3859b3806.gif" alt="
\text{\underline{character array } C [0 : maxchar];}\\
\vdots\\
\vdots\\
\left. C[0]:=\quote{A}\quote;\\C[1]:=\quote{B}\quote;\\\vdots\\\vdots\\C[25]=\quote{Z}\quote; \right}\text{Buchstaben}\\
\left. C[26]:=\quote 0 \quote;\\\vdots\\\vdots\\C[35]:=\quote 9 \quote; \right}\text{Ziffern}\\
\left. C[36]:=\quote ; \quote;\\C[37]:=\quote : \quote;\\\vdots\\\vdots\\C[\text{maxchar}]:=\quote*\quote; \right}\text{Sonderzeichen}
" valign="middle"/></p>
<p>Der Algorithmus hat die Aufgabe, sukzessive Komponenten
 
aus C auszugeben, so da&szlig; nsgesamt der Programmtext <img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/>,
gedruckt wird:</p>
<pre class="source"><strong>while not</strong> p <strong>do</strong>			| I ist vom Typ
<strong>begin</strong> &lt;berechne neues I>;	| <strong>integer</strong>, p ist
      OUTCHAR(C[I]);		| ein Pr&auml;dikat,
      &lt;setze  p>		| das den Algorithmus
  <strong>end</strong>				| stoppt, sobald
  				| der Text <img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/>,
				| gedruckt ist.
</pre>
<p><img src="/img/cache/a500e36a3933aff3fdd5415f19c78f9b.gif" alt="
\begin{array}{.rl.c.}
\hdash \text{\underline{begin}} &amp; \text{\underline{integer} I}\\ &amp; \vdots\\ &amp; \vdots &amp; \text{Ia}\\
\hdash				&amp; C[0]:=\quote A\quote;\\ &amp; C[1]:=\quote B\quote;\\ &amp;\vdots\\ &amp; \vdots\\ &amp; C[\text{maxchar}]=\quote*\quote; &amp; \text{II}\\
\hdash				&amp;
\begin{array}{rl}
	\text{\underline{while}}&amp; \text{\underline{not} p \underline{do}}\\
	\text{\underline{begin}}&amp; \text{&lt;berechne neues I&gt;;}\\
				&amp; \text{OUTCHAR(C[I]);}\\
				&amp; \text{&lt;setze p&gt;}\\
	\text{\underline{end}}
\end{array}
				&amp; \text{III}\\
\hdash \text{\underline{end}}	&amp; &amp; \text{Ib}\\
\hdash				&amp; &amp; 
\end{array}
" valign="middle"/></p>
<p>Das Programm <img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/>, gliedert sich in 4 Teile. Man erkennt
neben den initialisierenden und abschlie&szlig;enden Teilen
Ia und Ib einen Teil II, der den Aufbau der Druckzeichentabelle
vornimmt, und einen Teil III, der den Algorithmus
realisiert.</p>
 
<p>Die Programmteile Ia,Ib und II bereiten sicherlich keine
Schwierigkeiten. Auch der Algorithmus von Teil III macht
einen, durchsichtigen Eindruck. Es bleiben eigentlich nur
noch die beiden Anweisungen &lt;berechne neues I> und
&lt;setze p> durch SIMULA-statements zu ersetzen. Das
Ersetzen von &lt;berechne neues I> ist dabei sicherlich
die schwierigere Aufgabe.</p>
<p>Wir wollen zun&auml;chst genauer untersuchen, was der
Algorithmus aus Teil III und insbesondere die Anweisung
&lt;berechne neues I> leisten m&uuml;ssen.</p>
<p><strong>(3.2.3.1) Definition:</strong> Sei D die Menge aller in
SIMULA-Programmen zul&auml;ssigen Zeichen:</p>
<p>D := {a,b,...,z,0,1,...,9,;,:,...,*}</p>
<p>Dann ist <img src="/img/cache/0bc383ddb30ebfb47b8852fdd9a2073e.gif" alt="\forall\alpha\in D" valign="middle"/> die Zahl <img src="/img/cache/63a23f5c1ab832c1ab11496efb050e24.gif" alt="i_\alpha\in\mathbb{N}_0" valign="middle"/> der Index, unter
dem das Zeichen <img src="/img/cache/00b0e8694ab04a66095719994aa55b2c.gif" alt="\alpha\in D" valign="middle"/> in der Tabelle C abgelegt
ist: <img src="/img/cache/98db853351a107e17ce1b21502bf7af2.gif" alt="\alpha = C[i_\alpha]" valign="middle"/></p>
<p><strong>(3.2.3.2) Lemma:</strong> Die Abbildung <img src="/img/cache/3145a10f72e3ab24b144c62d785df32c.gif" alt="\delta\ :\ D^*\longr\mathbb{N}^*_0" valign="middle"/> mit</p>
<p><img src="/img/cache/6fdafb55768bbdf68f6f71ebeaf265dc.gif" alt="\delta(\varepsilon) = \varepsilon\\\delta(w\alpha) = \delta(w)i_\alpha\ \ \ \ \forall w\in D^*,\ \alpha\in D" valign="middle"/></p>
<p>ist Kodierung von <img src="/img/cache/af255aa3ff104dc957f68d630d88729e.gif" alt="D^*" valign="middle"/> durch <img src="/img/cache/7ae5ffbd44f6888800357baa239ea5c5.gif" alt="\mathbb{N}^*_0" valign="middle"/>.</p>
<p><strong>Beweis:</strong></p>
<ol type="i">
<li><img src="/img/cache/b26f41fd312f256efa76bced76ccce70.gif" alt="\delta(x)" valign="middle"/> ist f&uuml;r jedes <img src="/img/cache/62575534738129facc3e8975fcd71aae.gif" alt="x \in D^*" valign="middle"/> definiert. Also ist
<img src="/img/cache/77a3b715842b45e440a5bee15357ad29.gif" alt="\delta" valign="middle"/> total, <img src="/img/cache/77a3b715842b45e440a5bee15357ad29.gif" alt="\delta" valign="middle"/> ist trivialerweise berechenbar.</li>
<li>Da in der Tabelle C jedes Zeichen aus D genau
einmal gespeichert ist, folgt: <img src="/img/cache/77a3b715842b45e440a5bee15357ad29.gif" alt="\delta" valign="middle"/> ist injektiv.</li>
<li>Sei <img src="/img/cache/1432b53a4975b5593e6030b640835d40.gif" alt="\overline{j} = j_1\dots j_n" valign="middle"/> aus <img src="/img/cache/7ae5ffbd44f6888800357baa239ea5c5.gif" alt="\mathbb{N}^*_0" valign="middle"/>, <img src="/img/cache/522c83fef16bb027f2f74695a0da4f90.gif" alt="\overline{j}" valign="middle"/> ist genau dann
aus <img src="/img/cache/ff2378f2987e4b85e4329fc65655bc33.gif" alt="\delta(D^*)" valign="middle"/>, wenn jedes <img src="/img/cache/a23d9ff1dbda7f75b67a5d9ae55b2eb3.gif" alt="j_k, k\in[n]" valign="middle"/>, aus
{0,.....,maxchar} ist. Also ist <img src="/img/cache/ff2378f2987e4b85e4329fc65655bc33.gif" alt="\delta(D^*)" valign="middle"/> entscheidbar.</li>
<li>Sei <img src="/img/cache/1432b53a4975b5593e6030b640835d40.gif" alt="\overline{j} = j_1\dots j_n" valign="middle"/> aus <img src="/img/cache/ff2378f2987e4b85e4329fc65655bc33.gif" alt="\delta(D^*)" valign="middle"/>. Mit Hilfe der
Tabelle C l&auml;&szlig;t sich f&uuml;r jedes <img src="/img/cache/a23d9ff1dbda7f75b67a5d9ae55b2eb3.gif" alt="j_k, k\in[n]" valign="middle"/>, das
Zeichen aus D ermitteln, das durch <img src="/img/cache/a1cba1f93521e19e4c6b36a35c5959cc.gif" alt="j_k" valign="middle"/> kodiert
wird. Mit h&ouml;chstens <img src="/img/cache/e7c7d6cb2022d8d174fa207ccc07e088.gif" alt="\text{n \cdot maxchar}" valign="middle"/> Vergleichen
l&auml;&szlig;t sich so das Urbild von <img src="/img/cache/522c83fef16bb027f2f74695a0da4f90.gif" alt="\overline{j}" valign="middle"/> unter <img src="/img/cache/77a3b715842b45e440a5bee15357ad29.gif" alt="\delta" valign="middle"/> ermitteln.
Also ist <img src="/img/cache/5bf4c7ed9e759ef6cc5fbecdc6a1cdb8.gif" alt="\delta^{-1}" valign="middle"/>berechenbar.</li>
</ol>
<p>Aus (i) bis (iv) folgt: <img src="/img/cache/77a3b715842b45e440a5bee15357ad29.gif" alt="\delta" valign="middle"/> ist Kodierung (vgl.(2.5.2)).</p>
<div align="right">%</div>
 
<p><strong>(3.2.3.3) Bemerkung:</strong> Jedes SIMULA-Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> hat als endliches
Wort aus <img src="/img/cache/af255aa3ff104dc957f68d630d88729e.gif" alt="D^*" valign="middle"/> eine Kodierung <img src="/img/cache/baf9edaf25981614898fd937090dcb1b.gif" alt="\delta(\pi)" valign="middle"/> in <img src="/img/cache/7ae5ffbd44f6888800357baa239ea5c5.gif" alt="\mathbb{N}^*_0" valign="middle"/>.</p>
<p>Bei jedem Durchlauf durch die <strong>while</strong>-Schleife im Algorithmus
von <img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/> wird ein neuer Wert f&uuml;r I berechnet. I nimmt
also im Verlauf des Programms eine Folge von Werten an,
die sich als Wort aus <img src="/img/cache/7ae5ffbd44f6888800357baa239ea5c5.gif" alt="\mathbb{N}^*_0" valign="middle"/> auffassen l&auml;&szlig;t:</p>
<p><img src="/img/cache/ea95089062d6a088d8d537abe46c3c1b.gif" alt="I = i_1,i_2,\dots\ \dots,i_{l(\pi_2)}\ \ i_j \in \mathbb{N}_0\text{ f\ddo{u}r alle }j \in [l(\pi_2)]" valign="middle"/></p>
<p>Damit <img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/> seinen eigenen Text ausgeben kann, mu&szlig; gelten:</p>
<p><img src="/img/cache/a0470d90a9878259d94c5466cb170b3f.gif" alt="C[i_1]\ C[i_2] \dots\ \dots C[i_{l(\pi_2)}]\overset!=\pi_2" valign="middle"/></p>
<p>Es gilt daher:</p>
<ul>
<li>Die Funktion von &lt;berechne neues I> ist die sukzessive
Ermittlung der Kodierung von <img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/> bez&uuml;glich <img src="/img/cache/77a3b715842b45e440a5bee15357ad29.gif" alt="\delta" valign="middle"/>.</li>
<li>Die Funktion des gesamten Algorithmus von <img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/> ist die
Dekodierung der ermittelten Kodierung, also die Realisierung von <img src="/img/cache/5bf4c7ed9e759ef6cc5fbecdc6a1cdb8.gif" alt="\delta^{-1}" valign="middle"/>.</li>
</ul>
<p>Die Berechnung der <img src="/img/cache/74a20a54fdc7239651a54fa19e3b405e.gif" alt="i_j,\ j\in[l(\pi_2)]" valign="middle"/>, ist das noch verbleibende
Problem. Die <img src="/img/cache/81133077026f407c559b0037ea5a60af.gif" alt="i_j" valign="middle"/> m&uuml;ssen iterativ mittels einer Funktion
<img src="/img/cache/c231380b9ba1ea4d1b82cfd2748070e5.gif" alt="F\ :\ \mathbb{N}_0\longr\mathbb{N}_0" valign="middle"/> erzeugt werden:</p>
<p><img src="/img/cache/384528912a3fcca26d9ff4286e823b7f.gif" alt="\fbox{
\text{Setze i_1;\\
i_{j+1} := F(i_j);\ \ j\in[l(\pi_2)-1]
}}" valign="middle"/></p>
<p>Die Funktion F l&auml;&szlig;t sich als Funktionsprozedur realisieren
und innerhalb von Teil Ia von <img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/> vereinbaren. Die Anweisung
&lt;berechne neues I> wird dann zu der Prozeduranweisung</p>
<p>I := F(I)</p>
<p>Da es unser Ziel ist, ein selbstreproduzierendes SIMULA-Programm
anzugeben, das sich auch auf einer konkreten
Rechenmaschine implementieren l&auml;&szlig;t, m&uuml;ssen an F folgende
Forderungen gestellt werden:</p>
 
<ol type="a">
<li>F mu&szlig; in vertretbarer Zeit berechenbar sein und</li>
<li>die von F benutzten Zwischenergebnisse m&uuml;ssen
im darstellbaren Zahlenbereich der Rechenmaschine
liegen.</li>
</ol>
<p>Es ist m&ouml;glich, da&szlig; ein konkretes F nicht von I abh&auml;ngt.</p>
<h4><a name="c324"></a>3.2.4. Vahl der Iterationsfunktion F</h4>
<p>In diesem Abschnitt werden zwei Funktionen diskutiert, die
als Iterationsfunktion denkbar w&auml;ren.</p>
<h5><a name="c3241"></a>3.2.4.1. Eine Iterationsfunktion mittels Modulo-Bildung</h5>
<p>Wir erweitern die Kodierung <img src="/img/cache/77a3b715842b45e440a5bee15357ad29.gif" alt="\delta" valign="middle"/> zu einer G&ouml;delisierung
(vgl. (2.5.3)). Dazu definieren wir die Abbildung <img src="/img/cache/388bc514704443721949510f17febf7a.gif" alt="f_\delta" valign="middle"/>.</p>
<p><strong>(3.2.4.1.1) Definition:</strong> Die Abbildung <img src="/img/cache/e533991a704b534d6ea81379893b924d.gif" alt="f_\delta\ :\ \mathbb{N}^*_0\longr\mathbb{N}_0" valign="middle"/>
sei wie folgt definiert:</p>
<p><img src="/img/cache/b54da4543a6aaf2729f13812080cb055.gif" alt="
f_\delta(\overline{i}) = \left{
	\text{\emptyset, falls \overline{i} = \varepsilon\\
	\sum^k_{j=1} i_j(maxhar+1)^{j-1}\text{, falls \overline{i}=i_1\dots i_k}
	\right.
" valign="middle"/></p>
<p>Ist <img src="/img/cache/f3945cf52a396d022066bde3906f4b98.gif" alt="\overline{i}\in\delta(D^*)" valign="middle"/>, so ist jedes <img src="/img/cache/501088c5611eb089e923763cc72f1d49.gif" alt="i_j,\ j\in[k]" valign="middle"/>, kleiner oder gleich
(maxchar+1). Die Restriktion von <img src="/img/cache/388bc514704443721949510f17febf7a.gif" alt="f_\delta" valign="middle"/> auf <img src="/img/cache/ff2378f2987e4b85e4329fc65655bc33.gif" alt="\delta(D^*)" valign="middle"/> ist somit
injektiv und kodiert die Elemente von <img src="/img/cache/ff2378f2987e4b85e4329fc65655bc33.gif" alt="\delta(D^*)" valign="middle"/> durch <img src="/img/cache/f6da4851806d2190d2dda3541571573a.gif" alt="\mathbb{N}_0" valign="middle"/>. Es
folgt somit:</p>
<p><strong>(3.2.4.1.2) Lemma:</strong> Die Abbildung <img src="/img/cache/0bea148a143e2c35b08043f7af098582.gif" alt="f\ :\ D^*\longr\mathbb{N}_0" valign="middle"/> mit
<img src="/img/cache/5df6673efc3a1a403ab5d9e1e908e0e4.gif" alt="f := f_\delta\circ\delta" valign="middle"/> ist G&ouml;delisierung von <img src="/img/cache/af255aa3ff104dc957f68d630d88729e.gif" alt="D^*" valign="middle"/>.</p>
<p><strong>Beweis:</strong> Offensichtlich</p>
<div align="right">%</div>
<p>Von Interesse ist f&uuml;r uns die Tatsache, da&szlig; man aus der
Zahl f(x) f&uuml;r jedes <img src="/img/cache/d5bea5c9939214f65b653ba836337009.gif" alt="x\in D^*" valign="middle"/> effektiv die Komponenten von
 
<img src="/img/cache/b26f41fd312f256efa76bced76ccce70.gif" alt="\delta(x)" valign="middle"/> zur&uuml;ckberechnen kann. Dies gilt insbesondere f&uuml;r
<img src="/img/cache/cb57d032b4c86adfb26111bf02c6bc84.gif" alt="f(\pi_2)" valign="middle"/>, und wir gewinnen mit</p>
<p><img src="/img/cache/ab05893f8038f1169e324dd710316078.gif" alt="
\text{\underline{integer procedure} F;}\\
\begin{array}{rll}
	\text{\underline{begin}}&amp; \text{F := X}	&amp;\text{\underline{mod}(maxchar+1);}\\
				&amp; \text{X := X}//&amp;\text{(maxchar+1);}\\
	\text{\underline{end}}	&amp;		&amp;\searrow\\
				&amp;		&amp;\text{  ganzzahlige Division}
\end{array}
" valign="middle"/></p>
<p>eine Iterationsvorschrift zur Erzeugung von <img src="/img/cache/9d74d9583620b8cc09d95acb36a0bf1f.gif" alt="\delta(\pi_2)" valign="middle"/>, wenn
wir f&uuml;r X den Startwert <img src="/img/cache/cb57d032b4c86adfb26111bf02c6bc84.gif" alt="f(\pi_2)" valign="middle"/> w&auml;hlen.</p>
<p>Da der Startwert von X, also <img src="/img/cache/cb57d032b4c86adfb26111bf02c6bc84.gif" alt="f(\pi_2)" valign="middle"/>, von <img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/> nicht
eingelesen werden darf, mu&szlig; <img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/> die Zuweisung</p>
<p><img src="/img/cache/0943eb5d66e9731b0bb23e513428f94d.gif" alt="X := f(\pi_2)" valign="middle"/></p>
<p>enthalten. <img src="/img/cache/cb57d032b4c86adfb26111bf02c6bc84.gif" alt="f(\pi_2)" valign="middle"/> ist eine ganze Zahl und damit textueller
Bestandteil von <img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/>. Zum Zeitpunkt der Erstellung von <img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/>
ist die Zahl <img src="/img/cache/cb57d032b4c86adfb26111bf02c6bc84.gif" alt="f(\pi_2)" valign="middle"/> unbekannt, sie kann erst nachtr&auml;glich
ermittelt werden. Beim Aufschreiben des Programms <img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/> mu&szlig; in
der Anweisung <img src="/img/cache/92efd63e6892601f1398abb2796a83b8.gif" alt="X:=f(\pi_2);" valign="middle"/> die Zahl <img src="/img/cache/cb57d032b4c86adfb26111bf02c6bc84.gif" alt="f(\pi_2)" valign="middle"/> zun&auml;chst
ausgelassen werden. Erst nach Erstellung des Programms - das
<img src="/img/cache/cb57d032b4c86adfb26111bf02c6bc84.gif" alt="f(\pi_2)" valign="middle"/> immer noch nicht enth&auml;lt - l&auml;&szlig;t sich dann
q := f(<img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/> ohne den string <img src="/img/cache/cb57d032b4c86adfb26111bf02c6bc84.gif" alt="f(\pi_2)" valign="middle"/>") errechnen. Mit der
Zahl q als Startwert f&uuml;r X wird <img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/> nur seinen Text ohne
die Zahl q reproduzieren k&ouml;nnen. Diesen Mi&szlig;stand beseitigen
wir, indem wir den Algorithmus von <img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/>, ab&auml;ndern:</p>
<p>Es l&auml;&szlig;t sich leicht feststellen, nach dem wievielten
Schritt des Algorithmus die Zahl <img src="/img/cache/cb57d032b4c86adfb26111bf02c6bc84.gif" alt="f(\pi_2)" valign="middle"/> ausgegeben werden
mu&szlig;. Es sei dies der r-te Iterationsschritt. Die Zahl r
wird Bestandteil des Programms. Der Algorithmus von <img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/>
lautet dann:</p>
<pre class="source">
X:=q;
Y:=1;
<strong>while</strong> Y&lt;=l("<img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/> ohne den String q") <strong>do</strong>
<strong>begin</strong> I:=F;
      OUTCHAR(C[I]);
      <strong>if</strong> Y=r <strong>then</strong> OUTINT(q,...);
      Y:=Y+1;
  <strong>end</strong>
</pre>
<p>und das Gesamtprogramm ist</p>
 
<pre class="source"><img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/> = <strong>begin</strong>
      <strong>integer</strong> I,X,Y;
      <strong>character array</strong> C[1:maxchar];
      <strong>integer procedure</strong> F;
      <strong>begin</strong> F:=X <strong>mod</strong>(maxchar+1);
            X:=X//(maxchar+1)
        <strong>end</strong>;
      C[0]:="A";
      <img src="/img/cache/f750e0a797eedef801aaf50716fbd542.gif" alt="\vdots" valign="middle"/>
      
      <img src="/img/cache/f750e0a797eedef801aaf50716fbd542.gif" alt="\vdots" valign="middle"/>
      C[maxchar]:="*";
      X:=q;
      Y:=1;
      <strong>while</strong> Y&lt;=l("<img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/> ohne den String q") <strong>do</strong>
        <strong>begin</strong> I:=F;
              OUTCHAR(C[I]);
 	      <strong>if</strong> Y=r <strong>then</strong> OUTINT(q,...);
	      Y:=Y+1
          <strong>end</strong>
      <strong>end</strong>
</pre>
<p>Die Tabelle C braucht nat&uuml;rlich nur die Zeichen enthalten,
die auch wirklich in <img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/> vorkommen. Dementsprechend kann
die Zahl maxchar m&ouml;glichst klein gehalten werden. Die Zahlen
r,q und l("<img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/> ohne den String q") lassen sich ermitteln,
nachdem das &uuml;brige Programm erstellt wurde. Es ist
leicht einzusehen, da&szlig; gilt:</p>
<p><img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/> reproduziert sich selbst.</p>
<p>Das Programm <img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/> ist zwar ein syntaktisch richtiges
Programm, aber dennoch nicht auf Rechenmaschinen realisierbar,
Das liegt an der Gr&ouml;&szlig;enordnung der Zahl q. q liegt bei weitem
au&szlig;erhalb des darstellbaren Zahlenbereichs &uuml;blicher
Rechenmaschinen. Um dies einzusehen, sch&auml;tzen wir die Zahl q
nach unten ab.</p>
<p>Wie man leicht feststellt, kommen im Programm <img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/>
mindestens 32 verschiedene Zeichen vor. Damit gilt maxchar&ge;32.</p>
 
<p>F&uuml;r die L&auml;nge von <img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/> gilt, wenn man nur die unbedingt
n&ouml;tigen blanks, die als Trennzeichen fungieren, mitrechnet:</p>
<p>l("<img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/> ohne die Zahl q") > 700</p>
<p>Aus Definition (3.2.4.1.1) und der Definition von q folgt
damit: <img src="/img/cache/a420bfe81e743969f0b00b8ede6bcd16.gif" alt="q&gt;32^{700-1}" valign="middle"/></p>
<p>Trotz dieser sehr groben Absch&auml;tzung von q zeigt sich,
da&szlig; q in herk&ouml;mmlichen Rechnern nicht darstellbar ist.</p>
<h5><a name="c3242"></a>3.2.4.2. Eine Iterationsfunktion basierend auf der G&ouml;delisierung g aus 2.5.</h5>
<p>In Abschnitt 2.5. wurde die G&ouml;delisierung <img src="/img/cache/4f20c689efe75293f1b4201beeba4b3c.gif" alt="g\ :\ C^*\longr\mathbb{N}_0" valign="middle"/>
eingef&uuml;hrt. Auf v&ouml;llig analoge Weise kann man eine G&ouml;delisierung
<img src="/img/cache/ee7885a19a48f75bbbf6925a32a92645.gif" alt="g_D\ :\ D^*\longr\mathbb{N}_0" valign="middle"/> konstruieren, indem man C durch
D und die Abbildung <img src="/img/cache/574cb2bf72f8e560a1d919638ce68b56.gif" alt="H\ :\ C\longr\mathbb{N}_0" valign="middle"/> durch die Abbildung
<img src="/img/cache/c9527363252256b405884b89393d6c81.gif" alt="H_D\ :\ D\longr\mathbb{N}_0" valign="middle"/> mit <img src="/img/cache/ef364d18c5f71cdb3deee51800f59489.gif" alt="H_D(\alpha) : = i_\alpha" valign="middle"/> f&uuml;r alle <img src="/img/cache/00b0e8694ab04a66095719994aa55b2c.gif" alt="\alpha\in D" valign="middle"/>
ersetzt. Wie man aus jeder G&ouml;delnummer <img src="/img/cache/70965a90ab6cd7a719b3a3daa3c28f9b.gif" alt="g(w),\ w\in C^*" valign="middle"/>, effektiv
das Urbild w bestimmen kann, so kann man das gleiche
auch f&uuml;r jede G&ouml;delnummer <img src="/img/cache/4ca97ee556e4ecb57d91126dd5dc7070.gif" alt="g_D(v),\ v\in D^*" valign="middle"/>, durchf&uuml;hren.</p>
<p>Damit l&auml;&szlig;t sich wie in 3.2.4.1. eine Prozedur F' entwickeln,
mit deren Hilfe es m&ouml;glich ist, <img src="/img/cache/7ff0f360b7b94591714ddaf0a23facf8.gif" alt="\delta(\pi_2')" valign="middle"/> iterativ
zu berechnen, wenn <img src="/img/cache/636d6ae69be9b7a33d3b6d2c8ea66eab.gif" alt="q' := g_D(\quote\pi_2'\text{ ohne die Zahl \pi_2'\quote})" valign="middle"/>
als Startwert f&uuml;r die Iteration gew&auml;hlt wird. Sir erhalten
dann ein &auml;hnliches selbstreproduzierendes Programm <img src="/img/cache/c6ccd00368a1d0f023671e6c54485715.gif" alt="\pi_2'" valign="middle"/> wie
in 3.2.4.1.. Auch dieses Programm ist syntaktisch korrekt,
aber ebensowenig realisierbar wie das Programm aus 3.2.4.1.
Diese Tatsache liegt an der Nichtdarstellbarkeit der Zahl
q'. Wir sch&auml;tzen q' grob nach unten ab.</p>
<p>Die L&auml;nge von <img src="/img/cache/c6ccd00368a1d0f023671e6c54485715.gif" alt="\pi_2'" valign="middle"/> betr&auml;gt mindestens 650 Zeichen.
Dann ist</p>
<p><img src="/img/cache/979cdd09b120d9349d5dbcca4f092e47.gif" alt="q&gt;p_1^{i_B}\cdot p_2^{i_E}\cdot p_3^{i_G}\cdot p_4^{i_I}\cdot p_5^{i_N}\cdot\dots\cdot p_{588}^{i_\alpha+1} \overset.-1,\ \alpha\in D" valign="middle"/></p>
<p>Da schon die f&uuml;nfte Primzahl, n&auml;mlich 11, gr&ouml;&szlig;er als 10
ist und das Zeichen a mit <img src="/img/cache/3886dcae1778643547024d68e49d0c6b.gif" alt="i_a=0" valign="middle"/> nur wenig in <img src="/img/cache/c6ccd00368a1d0f023671e6c54485715.gif" alt="\pi_2'" valign="middle"/> auftritt,
gilt sicherlich:</p>
<p><img src="/img/cache/976d4c486445f9bbe49a70f2f9a28c1a.gif" alt="q' &gt; 10^{600}" valign="middle"/></p>
 
<p>Damit ist q' ebenso wie q nicht in &uuml;blichen Rechenanlagen
darstellbar</p>
<h4><a name="c325"></a>3.2.5. Ein textgesteuertes SIMULA-Programm <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/></h4>
<p>In Abschnitt 3.2.4. wurden selbstreproduzierende Programme
<img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/> und <img src="/img/cache/c6ccd00368a1d0f023671e6c54485715.gif" alt="\pi_2'" valign="middle"/> entworfen, die zwar syntaktisch richtig waren,
sich aber nicht auf konkreten Rechenanlagen realisieren
lie&szlig;en. Wir wollen keine weiteren Anstrengungen unternehmen,
realisierbare Iterationsfunktionen und Startwerte zu finden,
sondern &auml;ndern vielmehr Textzerlegung und Algorithmus der
Programme aus 3.2.4. ab. Wir gewinnen aus <img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/> das Programm
<img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/>, indem wir folgende &Auml;nderungen vornehmen:</p>
<ol type="i">
<li><strong>Zerlegung:</strong> Im Gegensatz zu <img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/> wird <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/> nicht in
einzelne Zeichen, sondern in gr&ouml;&szlig;ere Teilstrings zerlegt.
Aus <code><strong>character array</strong> C[1:maxchar]</code> wird
<code><strong>text array</strong> C[1:maxtext]</code>.
Damit findet erstmals das SIMULA-Textkonzept in unseren
&Uuml;berlegungen seine Anwendung.</li>
<li><strong>Algorithmus:</strong> Die Aufgabe des Algorithmus von <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/>
besteht darin, den Programmtext <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/> aus Teilstrings, die
in dem Feld C gespeichert sind, zusammenzusetzen. Jede
Feldkomponente wird durch ihren Index kodiert. Der Text
<img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/> l&auml;&szlig;t sich dann als Folge von Indizes kodieren:
<p><img src="/img/cache/0dc601bce30223b0f69ba765cbe0bcd3.gif" alt="\pi_3\longr i_1,\dots,i_k,\ \ i_j\in\{1,\dots,\text{maxtext}\}" valign="middle"/></p>
<p>Diese Folge von Indizes schreiben wir als Text in die
<strong>text</strong>-Variable X. Mittels der <strong>text</strong>-Prozeduren SUB und
GETINT<sup><a href="#p045_1" name="b045_1">1)</a></sup> ist der Zugriff auf die einzelnen Zahlen <img src="/img/cache/81133077026f407c559b0037ea5a60af.gif" alt="i_j" valign="middle"/> im
Text X gew&auml;hrleistet. Der Algorithmus von <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/> braucht
also nur noch den Text X sequentiell zu durchlaufen
und f&uuml;r jedes <img src="/img/cache/81133077026f407c559b0037ea5a60af.gif" alt="i_j" valign="middle"/> aus X den Text <img src="/img/cache/4a2e9b10a70309c57bd4824ce24931c2.gif" alt="C[i_j]" valign="middle"/> auszugeben.</p></li>
</ol>
<p>Durch eine derartige Ausnutzung des Text-Konzepts der
Programmiersprache SIMULA umgehen wir die Repr&auml;sentation von
<img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/> durch eine ganze Zahl, wie dies in <img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle"/> und <img src="/img/cache/c6ccd00368a1d0f023671e6c54485715.gif" alt="\pi_2'" valign="middle"/> der Fall
war, und damit auch die nicht mehr darstellbaren Startwerte
q bzw. q'.</p>
 
<p>Der Text X enth&auml;lt jedoch nicht seine eigene Kodierung. Aus
diesem Grund mu&szlig; das Ausdrucken des Textes X im Algorithmus
von <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/> eine Sonderstellung einnehmen. In Analogie zu
3.2.4.1. - dort machte die Ausgabe der <strong>Zahl</strong> X &auml;hnliche
Schwierigkeiten - wird die Ausgabe von X durch die einfach
zu ermittelnde Zahl r gesteuert:</p>
<pre class="source">
X:-COPY("<img src="/img/cache/ff0018c9dda6bdae611faf2506b41706.gif" alt="i_1" valign="middle"/>,...,<img src="/img/cache/f0807c8c623bbafb36dbdb9e24cdfc4d.gif" alt="i_k" valign="middle"/>");
<strong>for</strong> I:=1 <strong>step</strong> 1 <strong>until</strong> k <strong>do</strong>
<strong>begin</strong>
  &lt;ermittle  n&auml;chstes <img src="/img/cache/81133077026f407c559b0037ea5a60af.gif" alt="i_j" valign="middle"/> aus X>;
  OUTTEXT(C[<img src="/img/cache/81133077026f407c559b0037ea5a60af.gif" alt="i_j" valign="middle"/>]);
  <strong>if</strong> I=r <strong>then</strong> OUTTEXT(X)
<strong>end</strong>;
</pre>
<pre class="source"><img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/> =
 1) begin integer I,S,Z; text X;
 2)       text array C[1:34];
 3) C[1]:-COPY("BEGIN INTEGER I,S,Z; TEXT X;");
 4) C[2]:-COPY("TEXT ARRAY C[1:34];");
 5) C[3]:-COPY("X:-COPY(""");
 6) C[4]:-COPY("FOR I:=1 STEP 1 UNTIL 105 DO ");
 7) C[11]:-COPY("BEGIN S:=X.SUB(Z+1,2).GETINT;");
 8) C[12]:-COPY("OUTTEXT(C[S]));");
 9) C[13]:-COPY("Z:=IF S&lt;10 THEN 2 ELSE 3)+Z;");
10) C[14]:-COPY("IF I=99 THEN OUTTEXT(X) END END");
11) C[21]:-COPY("C[);
12) C[22]:-COPY("]:-COPY(""");
13) C[23]:-COPY(""");");			{ Die blanks sind nur
14) C[24]:-COPY("""");				{ zur besseren Gliederung
15) C[31]:-COPY("1");	  +-------------------- { eingef&uuml;gt. Der
16) C[32]:-COPY("2");	  |			{ Algorithmus beachtet
17) C[33]:-COPY("3");	  |			{ sie nicht.
18) C[34]:-COPY("4");     |
19) X:-COPY("1,2,         v
             21,   31,22,    1,   23,
	     21,   32,22,    2,   23,
	     21,   33,22,    3,24,23,
 
             21,   34,22,    4,   23,
             21,31,31,22,   11,   23,
             21,31,32,22,   12,   23,
             21,31,33,22,   13,   23,
             21,31,34,22,   14,   23,
             21,32,31,22,   21,   23,
             21,32,32,22,   22,24,23,
             21,32,33,22,24,23,   23,
             21,32,34,22,24,24,   23,
             21,33,31,22,   31,   23,
             21,33,32,22,   32,   23,
             21,33,33,22,   33,   23,
             21,33,34,22,   34,   23,
             3,23,4,11,12,13,14,");
20) <strong>for</strong> I:=1 <strong>step</strong> 1 <strong>until</strong> 105 <strong>do</strong>
21) <strong>begin</strong> S:=X.SUB(<span class="green">Z+1</span>,2).GETINT;		<span class="green">[ Bewirkt das</span>
22)       OUTTEXT(C[S]);                        <span class="green">[      scannen</span>
23)       Z:=(<strong>if</strong> S&lt;10 <strong>then</strong> 2 <strong>else</strong> 3)+<span class="green">Z</span>;		<span class="green">[ des Textes X</span>
24)       <strong>if</strong> I=99 <strong>then</strong> OUTTEXT(X) <strong>end end</strong>
</pre>
<p><strong>Verifikation von <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/></strong></p>
<p>Der algorithmische Teil des Programms arbeitet sequentiell
eine Folge von Zahlen ab. Diese Zahlen sind in dem Text X
gespeichert. Es sind genau 105 Zahlen. Jede Zahl j bewirkt
das Ausdrucken eines Textes C[j]. Zun&auml;chst werden die Texte
C[1] und C[2] ausgedruckt. Damit sind die ersten beiden
Programmzeilen kopiert. Mit den folgenden 96 Zahlen werden die
Programmzeilen 3 bis 18 ausgedruckt. Diese 96 Zahlen bestehen
aus 16 Gruppen. Jede Gruppe ist durch das Zahlenpaar
21,...,23 begrenzt und druckt genau eine Programmzeile aus.
Jede dieser Gruppen hat folgenden allgemeinen Aufbau:</p>
<pre>
21,	<img src="/img/cache/f7a5d162a03dd05e03147acd5c9f5037.gif" alt="\hat=" valign="middle"/>	C[
[Zahl,]	<img src="/img/cache/f7a5d162a03dd05e03147acd5c9f5037.gif" alt="\hat=" valign="middle"/>	<strong>Ziffer</strong> 1 bzw. 2 bzw. 3
Zahl,	<img src="/img/cache/f7a5d162a03dd05e03147acd5c9f5037.gif" alt="\hat=" valign="middle"/>	<strong>Ziffer</strong> 1 bzw. 2 bzw. 3 bzw 4.
22,	<img src="/img/cache/f7a5d162a03dd05e03147acd5c9f5037.gif" alt="\hat=" valign="middle"/>	]:-copy("
[24,]	<img src="/img/cache/f7a5d162a03dd05e03147acd5c9f5037.gif" alt="\hat=" valign="middle"/>	"
Zahl,	<img src="/img/cache/f7a5d162a03dd05e03147acd5c9f5037.gif" alt="\hat=" valign="middle"/>	<strong>text</strong>
[24,]	<img src="/img/cache/f7a5d162a03dd05e03147acd5c9f5037.gif" alt="\hat=" valign="middle"/>	"
 
23,	<img src="/img/cache/f7a5d162a03dd05e03147acd5c9f5037.gif" alt="\hat=" valign="middle"/>	");
</pre>
<p>Damit entspricht der Aufbau der Zahlengruppen genau dem
allgemeinen Aufbau einer der Programmzeilen 3 bis 18.
Ber&uuml;cksichtigt man die im Programm vorkommende Kodierung, so
ist klar, da&szlig; diese Zahlengruppen die Prograramzeilen 3 bis
18 ausdrucken.</p>
<p>Nach diesen 96 Zahlen wird die Zahl 3 abgearbeitet.
Dadurch wird das Drucken von <code>x:-copy("</code> bewirkt. Gleichzeitig
hat die Laufvariable I der <strong>for</strong>-Schleife nun den
Wert 99 (99 Zahlen sind ja abgearbeitet). Deshalb wird nun
der Text X gedruckt. Die Abarbeitung der Zahl 23 schlie&szlig;t
Prograramzeile 19 ab. Die restlichen Programmzeilen 20 bis
24 werden durch Abarbeitung der restlichen Zahlen 4,11,12,
13 und 14 kopiert. Die Laufvariable hat dann den Wert 105,
und der Algorithmus bricht ab.</p>
<p><strong>Verbesserung von <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/></strong></p>
<ol type="i">
<li>Die Textvariablen C[1],...,C[33] und X enthalten die
Teilstrings des Programms. Besonders wichtig sind dabei die
mehrfach auftretenden Teilstrings. Es sind dies:
<pre class="source">
C[21]	=	C[
C[22]	=	]:-copy("
C[23]	=	");
C[24l	=	"
C[31]	=	1
C[32]	=	2
C[33]	=	3
C[34]	=	4
</pre>
<p>Diese Strings stellen in ihrer Gesamtheit die "Bauelemente"
dar, aus denen das Gerippe von <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/> aufgebaut ist. Auf sie
kann nicht verzichtet werden. Bei den anderen Teilstrings
ist eigentlich nicht einzusehen, warum sie gerade so aufgeteilt
sind. So k&ouml;nnten zum Beispiel C[1] und C[2] zusammengelegt
werden. Grunds&auml;tzlich ist zu sagen, da&szlig; maximale
Teilstrings gebildet werden k&ouml;nnen, die kein " enthalten.
Der String xxx"xxx m&uuml;&szlig;te z.B. als</p>
<pre class="source">k) C[j]J:-copy("xxx""xxx");</pre>
<p>vereinbart werden. Die Zahl j in dem Text X bewerkstelligt
 
dann zwar das Ausdrucken von xxx"xxx, aber es l&auml;&szlig;t
sich keine Zahlenfolge finden, die die Zeile k) druckt:</p>
<pre class="source">21,......22,j,23</pre>
<p>bewirkt</p>
<pre class="source">
C[j]:-copy("xxx"xxx") ;
               <img src="/img/cache/65532efbf8fbd662e6ab99f1bfb0bbf7.gif" alt="\uparrow" valign="middle"/>
        Hier fehlt ein ". Es kann nicht
	durch Ausgabe des Textes C[24]
	eingef&uuml;gt werden, da es mitten
	im Text von C[j] fehlt.
</pre>
<p>Das Einf&uuml;gen der Zahl 24 in X kann nur dann zum Erfolg f&uuml;hren,
wenn das Hochkomma am Anfang oder am Ende von C[j]
steht. Vergleiche dazu die Programmzeilen 12),13) und 14)
und die dazugeh&ouml;renden Zahlengruppen im Text X.</p></li>
<li>Das obige Programm arbeitet mit einem <code><strong>text arrsy</strong> C</code>
und einem <code><strong>text</strong> X</code>. Sowohl die Komponenten von C als auch X
enthalten nur Textkonstanten. Eine Sonderstellung von X
ist also nicht aufrechtzuerhalten. Die Konsequenz: Wir
erweitern das Feld C um eine Komponente C[x]. C[x] bekommt
den Wert von X zugewiesen. Damit wird auch die algorithmische
Sonderstellung des Textes X aufgegeben. Die <strong>if</strong>-Anweisung
in der <strong>for</strong>-Schleife entf&auml;llt. Der ehemalige Text X,
der jetzt in C[x] steht, wird einfach durch Abarbeitung
der Zahl x ausgedruckt. x ist dabei selbst Element von
C[x].</li>
<li>Die Punkte (i) und (ii) deuten schon an, da&szlig; sich
viel Programmtext und Komponenten von C einsparen lassen.
Weniger Komponenten bedeutet aber, da&szlig; wir mit weniger
Ziffern auskommen, um die Komponenten zu adressieren.
M&ouml;glicherweise kann die Programmzeile 18 weggelassen
werden, da die Ziffer 4 gar nicht zur Adressierung ben&ouml;tigt
wird.
<p>F&uuml;hrt man die Verbesserungen (i) bis (iii) an Programm <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/>
konsequent durch, so erh&auml;lt man das folgende Programm <img src="/img/cache/9a345e0e2a1c73f1da4b1b44bef3a3f7.gif" alt="\pi_3'" valign="middle"/>.
Die Feldkomponenten C[1] und C[3l] zeigen insbesondere
 
sehr sch&ouml;n die Bildung "maximaler" Texte (vgl.(i)).</p>
<pre class="source"><img src="/img/cache/d2c69fed561cb54975c92adc4aa3449f.gif" alt="\pi_3' = " valign="middle"/>
begin integer I,S,Z; text array C[1:31];
C[1]:-COPY("BEGIN INTEGER I,S,Z; TEXT ARRAY C[1:31]; C[1]:-COPY(""");
C[2]:-COPY("C[");
C[3]:-COPY("]:-COPY(""");
C[11]:-COPY(""");");
C[12]:-COPY("""");
C[13]:-COPY("1");
C[21]:-COPY("2");
C[22]:-COPY("3");
C[23]:-COPY("1,1,12,11,
             2,   21,3,    2,   11,
	     2,   22,3,    3,12,11,
	     2,13,13,3,12,11,   11,
	     2,13,21,3,12,12,   11,
	     2,13,22,3,   13,   11,
	     2,21,13,3,   21,   11,
	     2,21,21,3,   22,   11,
	     2,21,22,3,   23,   11,
	     2,22,13,3,   31,   11,31,");
C[31]:-COPY("FOR I:=1 STEP 1 UNTIL 60 DO BEGIN S:=C[23].SUB
             (Z+1,2).GETINT;OUTTEXT(C[S]);Z:=(IF S&lt;10 THEN
	     2 ELSE 3)+Z END END");
<strong>for</strong> I:=1 <strong>step</strong> 1 <strong>until</strong> 60 <strong>do</strong>
<strong>begin</strong> S:=C[23].SUB(Z+1,2).GETINT;
      OUTTEXT(C[S]);
      Z:=(<strong>if</strong> S&lt;10 <strong>then</strong> 2 <strong>else</strong> 3)+Z
  <strong>end</strong>
<strong>end</strong>
</pre>
<p>Diese Version von <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/>ist in ihrer logischen Funktionalit&auml;t
nicht mehr zu verbessern. Strebt man aber <strong>"textuell"</strong> kurze
Programme an, so gibt es noch eine weitere Verbesserungsm&ouml;glichkeit:</p></li>
<li>Die Komponenten von C k&ouml;nnen so adressiert werden,
da&szlig; die in C[23] h&auml;ufig auftretenden Adressen m&ouml;glichst
kurz sind.
 
<table border="1" summary="">
<tr><th>Adresse</th><th>Auftreten in C[23]</th><th>Zeichen insgesamt</th></tr>
<tr><td>1</td><td>2</td><td>1 &times; 2 = 2</td></tr>
<tr><td>2</td><td>10</td><td>1 &times; 10 = 10</td></tr>
<tr><td>3</td><td>10</td><td>1 &times; 10 = 10</td></tr>
<tr><td>11</td><td>10</td><td>2 &times; 10 = 20</td></tr>
<tr><td>12</td><td>4</td><td>2 &times; 4 = 8</td></tr>
<tr><td>13</td><td>6</td><td>2 &times; 6 = 12</td></tr>
<tr><td>21</td><td>8</td><td>2 &times; 8 = 16</td></tr>
<tr><td>22</td><td>5</td><td>2 &times; 5 = 10</td></tr>
<tr><td>23</td><td>1</td><td>2 &times; 1 = 2</td></tr>
<tr><td>31</td><td>2</td><td>2 &times; 2 = 4</td></tr>
</table>
<p>Um "optimal" zu adressieren, m&uuml;ssen wir erreichen, da&szlig;
die 3 einstelligen Adressen am h&auml;ufigsten auftreten. Wie
die Tabelle zeigt, ist das bisher nicht, der Fall. Adresse 1
tritt nur 2-mal auf, w&auml;hrend die zweistellige Adresse 11
10-mal auftritt. Wir erreichen eine "optimale" Adressierung,
wenn wir die Inhalte von C[1] und G [11] vertauschen
und den Inhalt von C[23] entsprechend korrigieren.
Ersparnis: 8 Zeichen.</p></li>
</ol>
<h4><a name="c326"></a>3.2.6. Implementierung des Programms <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/></h4>
<p>Das Programm <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/> gibt seinen Programmtext &uuml;ber die
Standarddatei SYSOUT aus. Da diese Ausgabe in Form eines
einzigen Strings ohne jede Blockung erfolgt, reicht die
voreingestellte Pufferl&auml;nge von SYSOUT nicht aus. Die Pufferl&auml;nge
mu&szlig; im Programm <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/> erh&ouml;ht werden, damit keine
Laufzeitfehler auftreten. <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/> wird daher um die Anweisung</p>
<pre class="source">SYSOUT.IMAGE:-BLANKS(200);</pre>
<p>erg&auml;nzt. Entsprechend wird die Textkonstante C[31] erweitert.
Das resultierende Programm <img src="/img/cache/9a345e0e2a1c73f1da4b1b44bef3a3f7.gif" alt="\pi_3'" valign="middle"/> zeigt Anhang A.1..</p>
<p>Der zur Verf&uuml;gung stehende SIMULA-Compiler hat die
Eingabel&auml;nge 72. Die Ausgabe von <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/> bzw. <img src="/img/cache/9a345e0e2a1c73f1da4b1b44bef3a3f7.gif" alt="\pi_3'" valign="middle"/> lie&szlig;e sich nur
dann kompilieren, wenn sie in Bl&ouml;cke zu jeweils h&ouml;chstens
72 Zeichen unterteilt w&auml;re. Dies ist aber weder bei <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/>
noch bei <img src="/img/cache/9a345e0e2a1c73f1da4b1b44bef3a3f7.gif" alt="\pi_3'" valign="middle"/> der Fall. Anhang A.2. zeigt eine Version
 
<img src="/img/cache/8af35811a37629b6d4068dbe4d48b3a2.gif" alt="\pi_3''" valign="middle"/> von <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/>, deren Ausgabe in Zeilen a 72 Zeichen unterteilt
ist. Dies wird durch einen komplizierten Anweisungsteil
erreicht. Die Ausgabe von <img src="/img/cache/8af35811a37629b6d4068dbe4d48b3a2.gif" alt="\pi_3''" valign="middle"/> l&auml;&szlig;t sich erneut &uuml;bersetzen.
Sie stellt ein lauff&auml;higes SIMULA-Programm dar,
das gleich <img src="/img/cache/8af35811a37629b6d4068dbe4d48b3a2.gif" alt="\pi_3''" valign="middle"/> ist.</p>
<h4><a name="c327"></a>3.2.7. Ein prozedurgesteuertes Programm <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/></h4>
<p>In 3.2.5. wurde ein selbstreproduzierendes Programm <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/>,
konstruiert, das seinen Text in Teilstrings zerlegt enthielt.
Diese Teilstrings brauchten von <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/> nur noch in der
richtigen Reihenfolge ausgedruckt zu werden. In Form von
Programm <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/> lernen wir nun ein selbstreproduzierendes
SIMULA-Programm kennen, das die Abspeicherung seiner Teilstrings
direkt mit der Ausgabe dieser Strings koppelt. Statt <code>C[Adresse]:-<strong>copy</strong>("text");</code> in <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/>
schreiben wir <code><strong>procedure</strong> name;OUTTEXT("text");</code> in <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/>,
Die Zerlegung des Programmtextes von <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/>, entspricht dabei
der Zerlegung des Programmtextes von <img src="/img/cache/5c65925f7761e05b8e9c7887246a532a.gif" alt="\pi_5" valign="middle"/>. Der Algorithmus
von <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/> besteht nur noch aus einer Folge von Prozeduraufrufen.
Mit Programm <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/> l&ouml;sen wir uns wieder vom eigentlichen
SIMUIA-Textkonzept. Wir ben&ouml;tigen lediglich die
M&ouml;glichkeit, Textkonstanten als Argumente f&uuml;r Ausgabeanweisungen
zu benutzen.</p>
<pre class="source">
 1) <strong>begin</strong>
 2) <strong>procedure</strong> AA;OUTTEXT("BEGIN ");
 3) <strong>procedure</strong> C;OUTTEXT("PROCEDURE ");
 4) <strong>procedure</strong> A;OUTTEXT(";OUTTEXT(""");
 5) <strong>procedure</strong> B;OUTTEXT(""");");
 6) <strong>procedure</strong> AC;OUTTEXT("""");
 7) <strong>procedure</strong> BA;OUTTEXT("A");
 8) <strong>procedure</strong> BB;OUTTEXT("B");
 9) <strong>procedure</strong> BC;OUTTEXT("C");
10) <strong>procedure</strong> AB;OUTTEXT("AA;C;BA;BA;A;AA;B;C;BC;A;C;B;C;BA
 
                          ;A;A;AC;B;C;BB;A;AC;B;B;C;BA;BC;A;AC;AC;B;C;BB;BA;A;
 		          BA;B;C;BB;BB;A;BB;B;C;BB;BC;A;BC;B;C;BA;BB;A;AB;B;AB
                           END");
11) AA;
12) C;BA;BA;A;   AA;   B;
13) C;BC;   A;    C;   B;
14) C;BA;   A;    A;AC;B;
15) C;BB;   A;AC; B;   B;
16) C;BA;BC;A;AC;AC;   B;
17) C;BB;BA;A;   BA;   B;
18) C;BB;BB;A;   BB;   B;
19) C;BB;BC;A;   BC;   B;
20) C;BA;BB;A;   AB;   B;
21) AB
22) <strong>end</strong>
</pre>
<p><strong>Verifikation von <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/></strong></p>
<p><code>AA;</code> ist das erste statement des Anweisungsteils von <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/>.
Es bewirkt die Ausgabe der ersten Programmzeile. Die n&auml;chsten
9 Programmzeilen werden durch, die Prozeduraufrufe der
9 Programmzeilen 12) bis 20) ausgegeben, was sich mit Hilfe
der tabellarischen Schreibweise des Anweisungsteils von <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/>
leicht nachvollziehen l&auml;&szlig;t. Das folgende und gleichzeitig
letzte statement ist ein Aufruf der Prozedur <code>AB</code>. Dieser Aufruf
bewirkt die Ausgabe der restlichen Programmzeilen 11)
bis 22), da die Textkonstante der Prozedur <code>AB</code> den algorithmischen
Teil, von <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/> enth&auml;lt. Durch Ausf&uuml;hrung der Prozedur
<code>AB</code> holt die <strong>Ausgabe</strong> des Programms <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/> die <strong>Ausf&uuml;hrung</strong> von
<img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/> ein.</p>
<p><strong>(3.2.7.1) Bemerkung:</strong> Das selbstreproduzierende SIMULA-Program
<img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/> ben&ouml;tigt als Daten nur Textkonstanten. Zur
Strukturierung verwendet <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/> neben der Hintereinanderausf&uuml;hrung
von Anweisungen nur das Prozedurkonzept. Insgesamt gesehen verwendet <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/> nur
Elemente, die die meisten h&ouml;heren Programmiersprachen
zur Verf&uuml;gung stellen. Daher gesehen m&uuml;ssen dem
 
Programm <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/> &auml;hnelde selbstreproduzierende Programme
in fast allen h&ouml;heren Programmiersprachen
existieren.</p>
<h4><a name="c328"></a>3.2.8. Implementierung des Programms <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/></h4>
<p>F&uuml;r die Implementierung des Programms <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/> gelten die gleichen
Bemerkungen, die zur Implementierung von <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/> in 3.2.6.
gemacht wurden. Aus <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/> l&auml;&szlig;t sich mit geringem Aufwand ein
<strong>lauff&auml;higes</strong> selbstreproduzierendes Programm <img src="/img/cache/dfeaa18be0544dd058f3ad59b6248a1a.gif" alt="\pi_4'" valign="middle"/> gewinnen,
indem die Anweisung</p>
<pre class="source">SYSOUT.IMAGE:-BLANKS(200);</pre>
<p>in den Anweisungsteil von <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/> bzw. in die Textkonstante der
Prozedur <code>AB</code> engef&uuml;gt wird.</p>
<p>Aus <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/> l&auml;&szlig;t sich wie in 3.2.6. ein selbstreproduzierendes
Programm <img src="/img/cache/178761f1a7abc129cb7122be791059be.gif" alt="\pi_4''" valign="middle"/> ableiten, dessen Ausgabe so formatiert ist,
da&szlig; ein lauff&auml;higes Programm entsteht. Erreicht wird dies
durch</p>
<ul>
<li>Einf&uuml;hrung der Prozedur <pre class="source">procedure Q;OUTIMAGE;</pre></li>
<li>Aufspalten der Textkonstanten der Prozedur <code>AB</code> auf die Prozeduren <code>AB,CA,CB,CC,AAA</code> und <code>AAB</code></li>
</ul>
<p>Die Ausgabe der zus&auml;tzlichen Prozeduren <code>CA</code> bis <code>AAB</code> bewirkt
einen vergr&ouml;&szlig;erten Anweisungsteil in <img src="/img/cache/178761f1a7abc129cb7122be791059be.gif" alt="\pi_4''" valign="middle"/>.</p>
<p>Anhang A.3. und Anhang A.4. demonstrieren die aus <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/>
resultierenden Programme <img src="/img/cache/dfeaa18be0544dd058f3ad59b6248a1a.gif" alt="\pi_4'" valign="middle"/> bzw. <img src="/img/cache/178761f1a7abc129cb7122be791059be.gif" alt="\pi_4''" valign="middle"/>.</p>
<h3><a name="c33"></a>3.3. Selbstreproduzierende Programme in PASCAL<sup><a href="#p054_1" name="b054_1">1)</a></sup></h3>
<p>In diesem Abschnitt sollen selbstreproduzierende Programme
in der Programmiersprache PASCAL vorgestellt werden. PASCAL
ist neben der Tatsache, da&szlig; es nicht blockorientiert ist,
eine Programmiersprache, die keine Textvariablen kennt;
PASCAL sieht nur Textkonstanten vor. Von daher gesehen ist
 
es nicht ohne weiteres m&ouml;glich, aus dem SIMULA-Programm <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/>
aus 3.2.5. ein entsprechendes selbstreproduzierendes PASCAL-programm
zu gewinnen. Auf Grund von Bemerkung (3.2.7.1) wird
es jedoch keine Schwierigkeiten bereiten, das Programm <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/>
aus 3.2.6. nach PASCAL zu &uuml;bertragen.</p>
<h4><a name="c331"></a>3.3.1. Ein textgesteuertes PASCAL-Programm <img src="/img/cache/5c65925f7761e05b8e9c7887246a532a.gif" alt="\pi_5" valign="middle"/></h4>
<p>Wir versuchen trotz des Fehlens von Textvariablen in PASCAL,
das Programm <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/> in ein selbstreproduzierendes PASCAL-Programm
<img src="/img/cache/5c65925f7761e05b8e9c7887246a532a.gif" alt="\pi_5" valign="middle"/> zu &uuml;bertragen. Dazu gibt es verschiedene M&ouml;glichkeiten,
von denen zwei genannt sein sollen:</p>
<ol type="i">
<li>Wir simulieren die in <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/> vorkommenden Texte durch
<strong>character arrays</strong>. Auf diese Weise wird das Feld C zweidimensional
<pre class="source"><strong>var</strong> C : <strong>array</strong> [1..maxtext,1..maxlength] <strong>of char</strong>,</pre>
wobei maxlength gleich der L&auml;nge des l&auml;ngsten Teilstrings
ist, in die wir das PASCAL-Programm <img src="/img/cache/5c65925f7761e05b8e9c7887246a532a.gif" alt="\pi_5" valign="middle"/> zerlegen.
Jede Zeile von C beinhaltet genau einen String
der Zerlegung von <img src="/img/cache/5c65925f7761e05b8e9c7887246a532a.gif" alt="\pi_5" valign="middle"/>.
<p>Nachdem die textuelle Speicherung der Zerlegung
gekl&auml;rt ist, k&ouml;nnen wir uns dem algorithmischen Teil von
<img src="/img/cache/5c65925f7761e05b8e9c7887246a532a.gif" alt="\pi_5" valign="middle"/> zuwenden. Da keine Texte und somit auch keine
Prozedur <code>GETINT</code> zur Verf&uuml;gung stehen, behelfen wir uns wie
folgt:</p>
<p>Wir kodieren jeden "Text" C[j,...] durch einen Buchstaben
des Alphabets in der folgenden Weise:</p>
<p><img src="/img/cache/a1989ff6967007a06cc83b987f10a499.gif" alt="
\begin{array}{lcl}
	\text{C[1,\dots]}&amp;\longr&amp;a\\
	\text{C[2,\dots]}&amp;\longr&amp;b\\
	\text{C[3,\dots]}&amp;\longr&amp;c\\
	\text{C[4,\dots]}&amp;\longr&amp;d\\
	\vdots&amp;&amp;\vdots\\
	\text{C[maxtext,..]}&amp;\longr&amp;\text{maxtext-ter Buchstabe.}
\end{array}
" valign="middle"/></p>
<p>Der Programmtext <img src="/img/cache/5c65925f7761e05b8e9c7887246a532a.gif" alt="\pi_5" valign="middle"/> l&auml;&szlig;t sich mittels der Zeilen von
C zusammensetzen und daher auf eindeutige Weise durch
eine endliche Folge von Buchstaben beschreiben. Diese
 
Buchstabenfolge ist der Inhalt von C[maxtext,...].
Der Algorithmus braucht dann nur noch diese Buchstabenfolge
in eine Folge von Druckanweisungen umzusetzen:</p>
<pre class="source"><strong>for</strong> I: = 1 <strong>to</strong> &lt;L&auml;nge von C[maxtext,...]> <strong>do</strong>
<strong>begin case</strong> C[maxtext,I] <strong>of</strong>
      'a' : &lt;Ausgabe von C[1,...]>
      'b' : &lt;Ausgabe von C[2,...]>
          .
	  .
	  .
	  .
	  .
  <strong>end</strong>
</pre>
<p>Leider treten auf den linken Seiten der <strong>case</strong>-Alternativen
viele Hochkommata ' auf. Das Zeichen ' spielt in
PASCAL die gleiche Rolle wie das Zeichen " in der
Programmiersprache SIMULA. Der Algorithmus m&uuml;&szlig;te also als
Text in sehr viele Teilstrings zerlegt werden (vgl.
3.2.5.), was zu einem un&uuml;berschaubaren Programm f&uuml;hren
w&uuml;rde. Einen Ausweg bietet die Transferfunktion <code>ORD</code>
von <strong>char</strong> nach <strong>integer</strong>:</p>
<pre class="source"><strong>for</strong> I: = 1 <strong>to</strong> &lt;L&auml;nge von C[maxtext,...]> <strong>do</strong>
<strong>begin</strong> HELP:=ORD(C[maxtext,I])
      <strong>case</strong> HELP <strong>of</strong>
      &lt;ORD(a)> : &lt;Ausgabe von C[1,...]>
      &lt;ORD(b)> : &lt;Ausgabe von C[2,...]>
               .
	       .
	       .
	       .
	       .
  <strong>end</strong>
</pre>
<p>Die Realisierung von <img src="/img/cache/5c65925f7761e05b8e9c7887246a532a.gif" alt="\pi_5" valign="middle"/> nach der bisher entworfenen
Methode enth&auml;lt noch einige Schwierigkeiten. Z.B.:</p>
<ul>
<li>Es m&uuml;&szlig;te eigens eine Ausgabeprozedur f&uuml;r die
statements vom Typ &lt;Ausgabe C[I,...]> in <img src="/img/cache/5c65925f7761e05b8e9c7887246a532a.gif" alt="\pi_5" valign="middle"/>,
enthalten sein.</li>
<li>Die Zeilen von C sind in der Regel mit blank-Zeichen
aufgef&uuml;llt. Die Ausgabe dieser blanks ist zu
vermeiden.</li>
</ul>
<p>Insgesamt w&uuml;rde ein durchaus korrektes, aber auch
un&uuml;bersichtliches Programm <img src="/img/cache/5c65925f7761e05b8e9c7887246a532a.gif" alt="\pi_5" valign="middle"/> entstehen.</p></li>
 
<li>Um die in (i) entstandenen Schwierigkeiten zu vermeiden,
speichern wir die Teilstrings von <img src="/img/cache/5c65925f7761e05b8e9c7887246a532a.gif" alt="\pi_5" valign="middle"/> nicht in
einem, zweidimensionalen <strong>character array</strong>, sondern wir
verwenden die implizite Speicherung mittels Ausgabeprozeduren
wie im SIMULA-Programm <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/> aus 3.2.7.
<p>Der Algorithmus von <img src="/img/cache/5c65925f7761e05b8e9c7887246a532a.gif" alt="\pi_5" valign="middle"/> bleibt der gleiche wie der
Algorithmus unter (i), wenn man statt der Zeilen von
C nur die Ausgabeprozeduren durch Buchstaben kodiert.</p></li>
</ol>
<p>Bei der Realisierung von <img src="/img/cache/5c65925f7761e05b8e9c7887246a532a.gif" alt="\pi_5" valign="middle"/> durch Alternative (ii) bleibt
das Programm &uuml;berschaubar. Mit</p>
<p><img src="/img/cache/66e3c21cd95a37ce514bc17bcade51e4.gif" alt="
\left.
\begin{eqnarray}
ORD(a)&amp;=&amp;193\\
ORD(b)&amp;=&amp;194\\
ORD(c)&amp;=&amp;195\\
ORD(d)&amp;=&amp;196\\
ORD(e)&amp;=&amp;197\\
ORD(f)&amp;=&amp;198\\
ORD(g)&amp;=&amp;199\\		
ORD(h)&amp;=&amp;200\\		
ORD(i)&amp;=&amp;201\\		
ORD(j)&amp;=&amp;202\\		
ORD(k)&amp;=&amp;203\\
\end{eqnarray}
\right} \text{bezogen auf die zur\\Verf\ddot{u}gung stehende\\PASCAL-Implementierung}
" valign="middle"/></p>
<p>und der Kodierung</p>
<p><img src="/img/cache/bba3d4b5ced11f7be1c9744f4314129c.gif" alt="
\begin{eqnarray}
\text{\underline{procedure}\ \ A\ } &amp;\longr&amp; a\\
\text{\underline{procedure}\ \ B\ } &amp;\longr&amp; b\\
\text{\underline{procedure}\ \ C\ } &amp;\longr&amp; c\\
\text{\underline{procedure} AA} &amp;\longr&amp; d\\
\text{\underline{procedure} AB} &amp;\longr&amp; e\\
\text{\underline{procedure} AC} &amp;\longr&amp; f\\
\text{\underline{procedure} BA} &amp;\longr&amp; g\\
\text{\underline{procedure} BB} &amp;\longr&amp; h\\
\text{\underline{procedure} BC} &amp;\longr&amp; i\\
\text{\underline{procedure} CA} &amp;\longr&amp; j\\
\text{\underline{procedure} CB} &amp;\longr&amp; k\\
\end{eqnarray}
" valign="middle"/></p>
<p>ergibt sich:</p>
 
<pre class="source"><img src="/img/cache/5c65925f7761e05b8e9c7887246a532a.gif" alt="\pi_5" valign="middle"/> =
<strong>program</strong> SELF(OUTPUT);
  <strong>var</strong> I,HELP : <strong>integer</strong>;
           X : <strong>array</strong> [1..72] <strong>of char</strong>;
  <strong>procedure</strong> A; <strong>begin</strong> WRITE('PROGBAM SELF(OUTPUT);VAR I,HELP
                           : INTEGER; X : ARRAY [1..72] OF CHAR;') <strong>end</strong>;
  <strong>procedure</strong> B; <strong>begin</strong> WRITE(''';F0R I:=1 TO 72 DO BEGIN HELP
                           :=ORD(X[I]); CASE HELP OF 193:A;194:B;195:C;196:AA;197
			   :AB;198:AC;199:BA;200:BB;201:BC;202:CA;203:CB; END; END;
			   WRITELN END.') <strong>end</strong>;
  <strong>procedure</strong> C; <strong>begin</strong> WRITE('PROCEDURE ') <strong>end</strong>;
  <strong>procedure</strong> AA;<strong>begin</strong> WRITE('; BEGIN WRITE(''') <strong>end</strong>;
  <strong>procedure</strong> AB;<strong>begin</strong> WRITE(''') END;') <strong>end</strong>;
  <strong>procedure</strong> AC;<strong>begin</strong> WRITE('''') <strong>end</strong>;
  <strong>procedure</strong> BA;<strong>begin</strong> WRITE('A') <strong>end</strong>;
  <strong>procedure</strong> BB;<strong>begin</strong> WRITE('B') <strong>end</strong>;
  <strong>procedure</strong> BC;<strong>begin</strong> WBITE('C') <strong>end</strong>;
  <strong>procedure</strong> CA;<strong>begin</strong> WRITE('BEGIN X:=''') <strong>end</strong>;
  <strong>procedure</strong> CB;<strong>begin</strong> WRITE('ACGDAECHDFBECIDCECGGDDFECGHDFEE
                            CGIDFFECHGDGECHHDHECHIDIECIGDJF
			    ECIHDKEJKB') <strong>end</strong>;
<strong>begin</strong>
  X:='ACGDAECHDFBECIDCECGGDDFECGHDFEECGIDFFECHGDGECHHDHECHIDIECIGDJFECIHDKEJKB';
  <strong>for</strong> I: = 1 <strong>to</strong> 72 <strong>do</strong>
  <strong>begin</strong> HELP:=ORD(X[I]);
        <strong>case</strong> HELP of
        193 : A;
        194 : B;
        195 : C;
        196 : AA;
        197 : AB;
        198 : AC;
        199 : BA;
        200 : BB;
        201 : BC;
        202 : CA;
        203 : CB;
        <strong>end</strong>;
<strong>end</strong>; WRITELN
<strong>end</strong>.
</pre>
 
<p><strong>Verifikation von <img src="/img/cache/5c65925f7761e05b8e9c7887246a532a.gif" alt="\pi_5" valign="middle"/></strong></p>
<p>Die Bedeutung der <strong>for</strong>-Schleife von Programm <img src="/img/cache/5c65925f7761e05b8e9c7887246a532a.gif" alt="\pi_5" valign="middle"/> wurde oben
erl&auml;utert. F&uuml;r jeden Buchstaben der Textkonstanten X wird
eine Alternative der <strong>case</strong>-Anweisung ausgef&uuml;hrt und somit
ein String der Zerlegung des Programmtextes von <img src="/img/cache/5c65925f7761e05b8e9c7887246a532a.gif" alt="\pi_5" valign="middle"/> ausgegeben.
Einfaches Nachvollziehen der Abarbeitung von X
best&auml;tigt, da&szlig; <img src="/img/cache/5c65925f7761e05b8e9c7887246a532a.gif" alt="\pi_5" valign="middle"/> sich, selbst reproduziert (vgl. Verifikation
von <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle"/>).</p>
<h4><a name="c332"></a>3.3.2. Implementierung des Programms <img src="/img/cache/5c65925f7761e05b8e9c7887246a532a.gif" alt="\pi_5" valign="middle"/></h4>
<p><img src="/img/cache/5c65925f7761e05b8e9c7887246a532a.gif" alt="\pi_5" valign="middle"/> wird so implementiert, da&szlig; die Ausgabe von <img src="/img/cache/5c65925f7761e05b8e9c7887246a532a.gif" alt="\pi_5" valign="middle"/> in
Zeilen zu h&ouml;chstens 132 Zeichen formatiert ist. Daher wird
zun&auml;chst die Prozedur</p>
<pre class="source"><strong>procedure</strong> Q; <strong>begin</strong> WRITELN <strong>end</strong>;</pre>
<p>in <img src="/img/cache/1022fbdc48e8d5d5d6f6dd4d483250f8.gif" alt="\pi5" valign="middle"/> eingef&uuml;gt.</p>
<p>Die Prozeduren A und B werden wegen ihrer relativ langen
Textkonstanten in mehrere Prozeduren aufgespalten:</p>
<p><img src="/img/cache/2ce95724261eca308016241131033b6c.gif" alt="
\begin{array}{cc}
  \begin{array}{ccl}
    &amp;  &amp; A\\
    &amp;\nearrow&amp; \\
   A&amp;  &amp;\\
    &amp;\searrow&amp;\\
    &amp;  &amp; CC 
  \end{array}
&amp;
  \begin{array}{ccl}
    &amp;  &amp; B\\
    &amp;\nearrow&amp; \\
   B&amp;\rightarrow &amp; AAA\\
    &amp;\searrow&amp;\\
    &amp;  &amp; AAC 
  \end{array}
\end{array}
" valign="middle"/></p>
<p>Die zus&auml;tzlichen Prozeduren bewirken eine Verl&auml;ngerung
der Kodierung von <img src="/img/cache/5c65925f7761e05b8e9c7887246a532a.gif" alt="\pi_5" valign="middle"/>. Dadurch wird eine Aufspaltung der
Prozedur CB ebenfalls notwendig:</p>
<p><img src="/img/cache/7511b64d893ccb8929fac95e028c9601.gif" alt="
  \begin{array}{ccl}
    &amp;  &amp; CB\\
    &amp;\nearrow&amp; \\
  CB&amp;  &amp;\\
    &amp;\searrow&amp;\\
    &amp;  &amp; AAB 
  \end{array}
" valign="middle"/></p>
<p>In <img src="/img/cache/5c65925f7761e05b8e9c7887246a532a.gif" alt="\pi_5" valign="middle"/> enth&auml;lt die Variable X die Kodierung des Programms.
Die neu hinzugekommenen Prozeduren verursachen eine solche
Zunahme der Kodierung, da&szlig; eine Variable (bedingt durch
die vorhandene PASCAL-Implementierung) nicht mehr ausreicht,
um die Kodierung aufzunehmen. Es wird neben X die Variable
<code>Y : <strong>array</strong> [1..68] <strong>of char</strong></code> zur Aufnahme der Kodierung von
<img src="/img/cache/5c65925f7761e05b8e9c7887246a532a.gif" alt="\pi_5" valign="middle"/> notwendig, was die Einf&uuml;hrung der Prozedur <code>CCA</code> bewirkt.
Der Algorithmus wird entsprechend ge&auml;ndert. Anhang A.5.
zeigt das so ver&auml;nderte Programm <img src="/img/cache/5c65925f7761e05b8e9c7887246a532a.gif" alt="\pi_5" valign="middle"/> im einzelnen. Die
 
neuen Prozeduren sind dort wie folgt kodiert:</p>
<p><img src="/img/cache/01fa453a96f288d902e333d965d1ae3d.gif" alt="
\begin{array}{rclcrcl}
 CC &amp; \longr &amp; l &amp;\ &amp; AAB &amp; \longr &amp; n\\
AAA &amp; \longr &amp; m &amp;\ &amp; CCA &amp; \longr &amp; q\\
AAC &amp; \longr &amp; p &amp;\ &amp; Q   &amp; \longr &amp; o\\
\text{mit}\\
ORD(l) &amp; = &amp; 211 &amp;\ &amp; ORD(o) &amp; = &amp; 214\\
ORD(m) &amp; = &amp; 212 &amp;\ &amp; ORD(p) &amp; = &amp; 215\\
ORD(n) &amp; = &amp; 213 &amp;\ &amp; ORD(q) &amp; = &amp; 216\\
\end{array}
" valign="middle"/></p>
<h4><a name="c333"></a>3.3.3. Ein prozedurgesteuertes PASCAL-Prograjam <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/></h4>
<p>Alle in Programm <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/> aus Abschnitt 3.2.7. verwendeten
Sprachelemente finden sich auch in der Programmiersprache
PASCAL. Damit l&auml;&szlig;t sich <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/> direkt in ein selbstreproduzierendes
PASCAL-Programm <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> &uuml;bersetzen.</p>
<pre class="source"><img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> = 
<strong>program</strong> PI6(OUTPUT);
  <strong>procedure</strong> AA;<strong>begin</strong> WRITE('PROGRAM PI6(OUTPUT); PROCEDURE AA; BEGIN WRITE(''') <strong>end</strong>;
  <strong>procedure</strong>  C;<strong>begin</strong> WRITE('PROCEDURE ') <strong>end</strong>;
  <strong>procedure</strong>  A;<strong>begin</strong> WRITE('; BEGIN WRITE(''') <strong>end</strong>;
  <strong>procedure</strong>  B;<strong>begin</strong> WRITE(''') END;') <strong>end</strong>;
  <strong>procedure</strong> AC;<strong>begin</strong> WRITE('''') <strong>end</strong>;
  <strong>procedure</strong> BA;<strong>begin</strong> WRITE('A') <strong>end</strong>;
  <strong>procedure</strong> BB;<strong>begin</strong> WRITE('B') <strong>end</strong>;
  <strong>procedure</strong> BC;<strong>begin</strong> WRITE('C') <strong>end</strong>;
  <strong>procedure</strong> AB;<strong>begin</strong> WRITE('BEGIN AA;AA;AC;B;C;BC;A;C;B;C;BA
    ;A;A;AC;B;C;BB;A;AC;B;B;C;BA;BC;A;AC;AC;B;C;BB;BA;A;BA;B
    ;C;BB;BB;A;BB;B;C;BB;BC;A;BC;B;C;BA;BB;A;AB;B;AB;WRITELN
     END') <strong>end</strong>;
<strong>begin</strong> AA;              AA;AC;B;
         C;BC;   A;    C;   B;
	 C;BA;   A;    A;AC;B;
	 C;BB;   A;AC; B;   B;
	 C;BA;BC;A;AC;AC;   B;
	 C;BB;BA;A;   BA;   B;
	 C;BB;BB;A;   BB;   B;
	 C;BB;BC;A;   BC;   B;
	 C;BA;BB;A;   AB;   B;AB;WRITELN <strong>end</strong>.
</pre>
 
<p><strong>Verifikation von <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/></strong></p>
<p>Die Verifikation von <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> ergibt sich direkt aus der
Verifikation von <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/> in 3.2.7.</p>
<h4><a name="c334"></a>3.3.4. Implementierung des Programms <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/></h4>
<p>Programm <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> schreibt seinen Text hintereinander ohne
Blockung auf die Ausgabedatei <code>OUTPUT</code>. Das Ergebnis von <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/>
ist ein einziger String. Dieser String ist sowohl f&uuml;r den
Puffer des SIEMENS-Schnelldruckers, als auch f&uuml;r den Puffer
des PASCAL-Compilers zu lang. Der String kann also weder
ausgedruckt noch erneut kompiliert werden.</p>
<p>Um ein sichtbares Ergebnis zu erhalten, ben&ouml;tigen wir
eine Ausgabe, die in Bl&ouml;cke von h&ouml;chstens 132 (=Pufferl&auml;nge
des Schnelldruckers) Zeichen unterteilt ist. Es mu&szlig; also in
das Programm <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> wiederholt die Prozedur <code>WRITELN</code> eingef&uuml;gt
werden. Wir k&uuml;rzen die Prozedur wie folgt ab:</p>
<pre class="source"><strong>procedure</strong> Q; <strong>begin</strong> WRITELN <strong>end</strong>;</pre>
<p>Da mit dieser Prozedurvereinbarung der Vereinbarungsteil von
<img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> gr&ouml;&szlig;er wird, mu&szlig; die Prozedur <code>AA</code> entsprechend
age&auml;ndert werden. Die lange Textkonstante von Prozedur <code>AB</code>
wird auf zwei Prozeduren verteilt. Zu diesem Zweck mu&szlig; eine
weitere Prozedur <code>CA</code> in das Programm aufgenommen werden.
Anhang A.6. protokolliert das so ver&auml;nderte Programm <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/>.</p>
<h3><a name="c34"></a>3.4. Selbstreproduzierende Programme in SIEMENS-Assembler</h3>
<p>In diesem Abschnitt werden Beispiele f&uuml;r selbstreproduzierende
Programme in einer Assembler-Sprache angegeben. Die
Beispiele verwenden den SIEMENS-Asserabler. Die Tatsache,
da&szlig; Assembler-Programme in der Lage sind, den Speicherbereich,
in dem sie sich befinden, zu adressieren und zu
lessen, vereinfach das Schreiben selbstreproduzierender
Assembler-Programme bedeutend. Selbstreproduzierende Proramme
 
in Assembler brauchen nicht ihren Programmtext
ebenfalls in Assembler auszugeben, sondern k&ouml;nnen direkt
ihren Maschinenkode im Arbeitsspeicher kopieren (vgl.1.2.).</p>
<p>Alle in den folgenden Beispielen vorkommenden Adressierungen
beziehen sich auf den Programmz&auml;hler PCR und sind
somit relativ. Dadurch wird gew&auml;hrleistet, da&szlig; die
Funktionen der Kopien die gleichen sind wie die der jeweiligen
Ursprungsprogramme. Die Kopien sind daher ebenfalls
selbstreproduzierend.</p>
<p>Die Beispielprogramme sind soweit erl&auml;utert, wie es
der Rahmen dieser Arbeit zul&auml;&szlig;t. N&auml;here Angaben bzgl. des
SIEMENS-Assemblers entnehme man den Schriften [22] und
[23].</p>
<dl>
<dt><strong>(3.4.1) Beispiel:</strong></dt>
<dd>Das selbstreproduzierende Assembler-Programm
PROG1 legt eine Kopie seines Maschinenkodes
ab dem 64-ten auf den ersten Befehl von
PROG1 folgenden Byte im Arbeitsspeicher an.
<table summary="" style="border: solid thin black;">
<tr><th>Zeilennummer</th><th>Name</th><th>mnemot. Op.-Kode</th><th>Operanden</th><th>Befehlsformat</th><th>Befehlsl&auml;nge (in Byte)</th></tr>
<tr><td>01</td><td>PROG1</td><td>START</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>02</td><td>&nbsp;</td><td>BALR</td><td>1,00</td><td>RR</td><td>2</td></tr>
<tr><td>03</td><td>&nbsp;</td><td>LA</td><td>2,2(0,0)</td><td>RX</td><td>4</td></tr>
<tr><td>04</td><td>&nbsp;</td><td>SR</td><td>1,2</td><td>RR</td><td>2</td></tr>
<tr><td>05</td><td>&nbsp;</td><td>LM</td><td>4,8,0(1)</td><td>RS</td><td>4</td></tr>
<tr><td>06</td><td>&nbsp;</td><td>STM</td><td>4,8,64(1)</td><td>RS</td><td>4</td></tr>
<tr><td>07</td><td>&nbsp;</td><td>SVC</td><td>X'5B'</td><td>RR</td><td>2</td></tr>
<tr><td>08</td><td>&nbsp;</td><td>END</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><th colspan="6">Programml&auml;nge in Byte 18</th></tr>
</table>
 
<p>Die beiden Assembler-Anweisungen <code>START</code> und <code>END</code>
erzeugen keinen Maschinenkode und brauchen daher beim
Kopierproze&szlig; nicht ber&uuml;cksichtigt zu werden.</p>
<p>Der erste ausf&uuml;hrbare Befehl des Programms ist</p>
<pre class="source">BALR	1,00</pre>
<p>Dieser Befehl l&auml;dt in das Mehrsweckregister R1 den
aktuellen Wert des Befehlsz&auml;hlers PCR. Da der
Befehlsz&auml;hler <strong>vor</strong> Ausf&uuml;hrung eines Befehls um die
L&auml;nge des betreffenden Befehls hochgez&auml;hlt wird,
enth&auml;lt Register R1 <strong>nach</strong> Ausf&uuml;hrung des
BALR-Befehls die Startadresse von PROG1 im Arbeitsspeicher
plus der L&auml;nge des BALR-Befehls. Der BALR-Befehl
hat das Format RR und somit die L&auml;nge 2. Der
Befehl</p>
<pre class="source">LA	2,2(0,0)</pre>
<p>stellt in Register R2 die Zahl 2 bereit. Der SR
(Subtrahieren Register)-Befehl</p>
<pre class="source">SR	1,2</pre>
<p>subtrahiert den Inhalt des Registers R2 vom Inhalt
des Registers R1. Nach Ausf&uuml;hrung dieses Befehls
enth&auml;lt demnach Register R1 genau die Startadresse
des Programms. R1 wird nachfolgend als Basisregister
verwendet. Der Befehl in Zeile 05 ist ein
LM(Laden mehrfach)-Befehl</p>
<pre class="source">LM	4,8,0(1)</pre>
<p>LM-Befehle k&ouml;nnen aufeinanderfolgende Mehrzweckregister -
also h&ouml;chstens 16 - mit aufeinanderfolgenden
Worten aus dem Arbeitsspeicher laden.
Die ersten beiden Operanden bezeichnen das erste
und das letzte der benutzten Mehrzweckregister.
Der letzte Operand stellt die Adresse des ersten
der zu transferierenden Arbeitsspeicherworte dar.
In unserem Fall ist diese Adresse die Startadresse
von PROG1. Deshalb wird der dritte Operand aus der
Distanzadresse 0 und dem Register R1 als Basisregister
zusammengesetzt. Das Programm PPOG1 umfa&szlig;t
 
18 Bytes. Da ein Arbeitsspeicherwort 4 Bytes umfa&szlig;t,
gen&uuml;gen also die 5 Mehrzweckregister R4 bis R8, um
das gesamte Programm zu laden. Der n&auml;chste Befehl</p>
<pre class="source">STM	4,8,64(1)</pre>
<p>ist ein STM(Speichern mehrfach)-Befehl. Dieser Befehl
ist das Gegenst&uuml;ck zum LM-Befehl und legt die
Inhalte der Register R4 bis R8 beginnend bei der Adresse,
die der dritte Operand angibt, hintereinander im
Arbeitsspeicher ab. Der dritte Operand des STM-Befehls
benutzt wieder das Register R1 als Basisregister,
die Distanzadresse ist 64. Nach Ausf&uuml;hrung des
STM-Befehls liegt also die Kopie von PROG1 bereits
im Arbeitsspeicher vor. Sie ist 64 Bytes vom
Ursprungsprogramm entfernt. Der letzte Befehl</p>
<pre class="source">SVC	X'5B'</pre>
<p>dient nur dazu, PROG1 ordnungsgem&auml;&szlig; zu beenden. Ein
ausf&uuml;hrliches Protokoll von PPOG1 befindet sich in
Anhang B.1..</p>
</dd></dl>
<p>Das folgende Beispielprogramm PROG2 ist um 2 Bytes k&uuml;rzer
als PROG1. Erreicht wird dies durch Ersetzung des LM- und
des STM-Befehls durch einen MVC(&uuml;bertragen Zeichenfolge)-Befehl.
PPOG2 ist in der Lage, au&szlig;er sich selbst noch einen
gewissen, auf das Programm folgenden Speicherbereich mitzukopieren.</p>
<dl>
<dt><strong>(3.4.2.) Beispiel:</strong></dt>
<dd>
<table summary="" style="border: solid thin black;">
<tr><th>Zeilennummer</th><th>Name</th><th>mnemot. Op.-Kode</th><th>Operanden</th><th>Befehlsformat</th><th>Befehlsl&auml;nge (in Byte)</th></tr>
<tr><td>01</td><td>PROG2</td><td>START</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>02</td><td>&nbsp;</td><td>BALR</td><td>1,00</td><td>RR</td><td>2</td></tr>
<tr><td>03</td><td>&nbsp;</td><td>LA</td><td>2,2(0,0)</td><td>RX</td><td>4</td></tr>
 
<tr><td>04</td><td>&nbsp;</td><td>SR</td><td>1,2</td><td>RR</td><td>2</td></tr>
<tr><td>05</td><td>&nbsp;</td><td>MVC</td><td>64(60,1),0(1)</td><td>SS</td><td>6</td></tr>
<tr><td>06</td><td>&nbsp;</td><td>SVC</td><td>X'5B'</td><td>RR</td><td>2</td></tr>
<tr><td>07</td><td>&nbsp;</td><td>END</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><th colspan="6">Programml&auml;nge in Byte 16</th></tr>
</table>
<p>Die Programmzeilen 01 bis 04 sind mit denen von
PROG1 identisch. Sie bewirken, da&szlig; die Startadresse
in das Register R1 geladen wird. Der MVC-Befehl in
Zeile 05 bewirkt, da&szlig; beginnend bei der Adresse</p>
<pre>
   Inhalt des Basisregisters R1 }	vgl. 2-ter
   plus Distanzadresse 0        }  	Operand
60 aufeinanderfolgende Bytes des  }
Arbeitsspeichers in den mit der   }
Adresse                           } 	vgl. 1-ter
   Inhalt des Basisregisters R1	  }	Operand
   plus Distanzadresse 64         }
</pre>
<p>beginnenden Arbeitsspeicherbereich geschrieben
werden. Da PROG2 selbst nur 16 Bytes lang ist,
werden durch den MVC-Befehl 44 zus&auml;tzliche Bytes
mitkopiert. Mit einem MVC-Befehl lassen sich sogar
maximal <img src="/img/cache/b6e88755e42c2c1e895de7cb3bb09cf6.gif" alt="2^8" valign="middle"/> Bytes transferieren, wenn die Operandenl&auml;nge
entsprechend angegeben wird (im Beispiel:
60).</p>
<p>Die Programmzeilen 06 und 07 entsprechen
den Zeilen 07 und 08 in PROG1. Rechnerprotokoll siehe
Anhang B.2..</p>
</dd>
</dl>
<p>Die Zeilen 02 bis 05 von PROG2 stellen einen Programmteil
dar, durch den sich andere Assemblerprogrammabschnitte
(oder ganze Programme) zu selbstreproduzierenden Programmen
(bzw. Programmabschnitten) erg&auml;nzen lassen (siehe
 
Abb. 4.4.A). Die L&auml;nge des resultierenden Programmabschnitts
in Byte) wird als Operandenl&auml;nge f&uuml;r den MVC-Befshl
verwendet. Auf diese Weise k&ouml;nnen Programmabschnitte (bzw.
Programme) bis zu einer L&auml;nge von <img src="/img/cache/18d5fada118b7a6ae959da4d75118745.gif" alt="2^8-16" valign="middle"/> Bytes im Arbeitsspeicher
kopiert werden. Entsprechend der L&auml;nge des Programmabschnitts
mu&szlig; die Distanzadresse, die die Lage der Kopie
bestimmt, gew&auml;hlt werden.</p>
<p><img src="/img/cache/0e00e57594a083bf3c8d0d74f26e7036.gif" alt="
\begin{array}{llll}
01 &amp; PROGRAM	&amp; CSECT\\
02 &amp;		&amp; BALR	&amp; 1,00\\
03 &amp;		&amp; LA	&amp; 2,2,(0,0)\\
04 &amp;		&amp; SR	&amp; 1,2\\
05 &amp;		&amp; MVC	&amp;
		\begin{array}{cc}
			\left\langle
				\text{Distanzadresse\\der kopie}
			\right\rangle &amp;
			\left(\left\langle
				\text{Anzahl der zu\\kopierenden Bytes}
			\right\rangle, 1\right),0,(1)\\
		\end{array}\\
{06\\07\\\vdots\\\vdots\\\vdots}
		&amp;	&amp;
			\left. {\vdots \\ \vdots \\ \vdots\\ \vdots} \right\} &amp;
			\text{Der zu kopierende Programmabschnitt\\(maximal 2^8-16 Bytes)}\\
		
\end{array}\\
" valign="middle"/></p>
<p>Abb. 3.4.A.</p>
<p>Das folgende Beispielprogramm PPOG3 ist ein selbstreproduzierendes
Assembler-Programm, das nach seiner Abarbeitung
 
die Kontrolle an die Kopie &uuml;bergibt. Erreicht wird dies
durch einen unbedingten Sprung zur Startadresse der Kopie.
Da die Kopie das gleiche Verhalten zeigt wie PROG3, iteriert
sich dieser Proze&szlig;. Der zur Verf&uuml;gung stehende
Arbeitsspeicher wird also mit Kopien von PPOG3 vollgeschrieben.
Die einzelnen Kopien folgen mit konstantem
Abstand aufeinander.</p>
<dl><dt><strong>(3.4.3) Beispiel:</strong></dt>
<dd>
<table summary="" style="border: solid thin black;">
<tr><th>Zeilennummer</th><th>Name</th><th>mnemot. Op.-Kode</th><th>Operanden</th><th>Befehlsformat</th><th>Befehlsl&auml;nge (in Byte)</th></tr>
<tr><td>01</td><td>PROG3</td><td>START</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>02</td><td>&nbsp;</td><td>BALR</td><td>1,00</td><td>RR</td><td>2</td></tr>
<tr><td>03</td><td>&nbsp;</td><td>LA</td><td>2,2(0,0)</td><td>RX</td><td>4</td></tr>
<tr><td>04</td><td>&nbsp;</td><td>SR</td><td>1,2</td><td>RR</td><td>2</td></tr>
<tr><td>05</td><td>&nbsp;</td><td>MVC</td><td>64(60,1),0(1)</td><td>SS</td><td>6</td></tr>
<tr><td>06</td><td>&nbsp;</td><td>LA</td><td>2,64(0,0)</td><td>RX</td><td>4</td></tr>
<tr><td>07</td><td>&nbsp;</td><td>AR</td><td>1,2</td><td>RR</td><td>2</td></tr>
<tr><td>08</td><td>&nbsp;</td><td>BR</td><td>1</td><td>RR</td><td>2</td></tr>
<tr><td>09</td><td>&nbsp;</td><td>END</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><th colspan="6">Programml&auml;nge in Byte 22</th></tr>
</table>
<p>Die Zeilen 01 bis 05 sind mit denen von Programm
PROG2 identisch und bewirken bereits das Kopieren
von PPOG3. Die Kopie wird beginnend beim 64-ten
auf den ersten Befehl von PROG3 folgenden Byte im
Arbeitsspeicher abgelegt. Der LA(Laden Adresse)-Befehl
 
in Zeile 06</p>
<pre class="source">LA	2,64(0,0)</pre>
<p>stellt in Register R1 die Zahl 64 bereit. Der folgende
AR(Addierer Register)-Befehl</p>
<pre class="source">AR	1,2</pre>
<p>erh&ouml;ht den Inhalt des Basisregisters R1 um 64. R1
enth&auml;lt nach Abarbeitung des AR-Befehls die Startadresse
der Kopie. Daher erfolgt durch den BR(Spribgen
unbedingt)-Befehl</p>
<pre class="source">BR	1</pre>
<p>ein Sprung zum ersten Befehl der Kopie und damit
die Abarbeitung der Kopie. Die Kopie legt darauf
eine erneute Kopie an u.s.w.</p>
<p>Anhang B.3. demonstriert PROG3. Da PROG3 eine
nicht abbrechende Programmfolge erzeugt, kommt es
wegen Speicherersch&ouml;pfung zu einem Fehlerabbruch.</p>
</dd></dl>
<p>In den vorangegangenen Beispielprogrammen erfolgte das
Kopieren der Programme en bloc mit Hilfe des MVC-Befehls bzw.
des LM- und des STM-Befehls. Das folgende Beispiel zeigt
ein Programm, das seinen Kode explizit in Abschnitten zu je
4 Bytes kopiert. Dieses Programm ist algorithmisch etwas
aufwendiger und dementsprechend l&auml;nger als die bisherigen
Beispielprogramme dieses Abschnitts.</p>
<dl><dt><strong>(3.4.4) Beispiel:</strong></dt>
<dd>
<table summary="" style="border: solid thin black;">
<tr><th>Zeilennummer</th><th>Name</th><th>mnemot. Op.-Kode</th><th>Operanden</th><th>Befehlsformat</th><th>Befehlsl&auml;nge (in Byte)</th></tr>
<tr><td>01</td><td>PROG4</td><td>START</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
 
<tr><td>02</td><td>&nbsp;</td><td>BALR</td><td>1,00</td><td>RR</td><td>2</td></tr>
<tr><td>03</td><td>&nbsp;</td><td>LA</td><td>2,2(0,0)</td><td>RX</td><td>4</td></tr>
<tr><td>04</td><td>&nbsp;</td><td>SR</td><td>1,2</td><td>RR</td><td>2</td></tr>
<tr><td>05</td><td>&nbsp;</td><td>LA</td><td>3,4(0,0)</td><td>RX</td><td>4</td></tr>
<tr><td>06</td><td>&nbsp;</td><td>LA</td><td>4,48(0,0)</td><td>RX</td><td>4</td></tr>
<tr><td>07</td><td>&nbsp;</td><td>LA</td><td>10,22(0,0)</td><td>RX</td><td>4</td></tr>
<tr><td>08</td><td>&nbsp;</td><td>AR</td><td>10,1</td><td>RR</td><td>2</td></tr>
<tr><td>09</td><td>&nbsp;</td><td>MVC</td><td>64(4,1),0(1)</td><td>SS</td><td>6</td></tr>
<tr><td>10</td><td>&nbsp;</td><td>AR</td><td>1,3</td><td>RR</td><td>2</td></tr>
<tr><td>11</td><td>&nbsp;</td><td>SR</td><td>4,3</td><td>RR</td><td>2</td></tr>
<tr><td>12</td><td>&nbsp;</td><td>BRP</td><td>10</td><td>RR</td><td>2</td></tr>
<tr><td>13</td><td>&nbsp;</td><td>SVC</td><td>X'5B</td><td>RR</td><td>2</td></tr>
<tr><td>14</td><td>&nbsp;</td><td>END</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><th colspan="6">Programml&auml;nge in Byte 36</th></tr>
</table>
<p>Die Befehle der Programmzeilen 02 bis 04 bewirken,
da&szlig; das Register R1 die Anfangsadresse von PROG4
im Arbeitsspeicher enth&auml;lt. Register R1 wird fortan
als Basisregister benutzt. Die Befehle der Zeilen
05 bis 07 stellen in den Mehrzweckregistern R3,
R4 und R10 die Werte 4, 48 und 22 bereit. 48 ist
die Gesamtzahl der Bytes, die das Programm PPOG4
im Arbeitsspeicher kopiert. Der Befehl</p>
<pre class="source">AR	10,1</pre>
<p>erh&ouml;ht den Inhalt des Registers R10 um die Startadresse
des Programms PROG4. Nach Ausf&uuml;hrung dieses
AR-Befehls enth&auml;lt Register R10 die Sprungadresse,
zu der der BRP(Springen, falls positiv)-Befehl
in Zeile 12 verzweigt. Es handelt sich dabei
um die Adresse des MVC-Befehls</p>
<pre class="source">MVC	64(4,1)0(1)</pre>
 
<p>in Programmzeile 09. Der MVC-Befenl kopiert die
ersten 4 Bytes des Maschinenkodes von PROG4 im
Arbeitsspeicher. Die Kopie wird 64 Bytes vom
ersten Befehl von PROG4 entfernt angelegt. Der
MVC-Befehl benutzt zur Adressierung das Basisregister
R1. Der Inhalt von R1 wird im darauffolgenden
Befehl</p>
<pre class="source">AR	1,3</pre>
<p>um den Inhalt des Registers R3, also nur den Wert
4, erh&ouml;ht. Der n&auml;chste Befehl</p>
<pre class="source">SR	4,3</pre>
<p>subtrahiert vom Inhalt des Registers R4, der gleich
der momentanen Anzahl der noch, zu kopierenden Bytes
ist, den Wert 4. Hat diese Subtraktion einen positiven
Wert ergeben, so sind noch nicht alle der
insgesamt 48 Bytes kopiert, und es wird mittels</p>
<pre class="source">BRP	10	(s.o.)</pre>
<p>zum MVC-Befehl in Zeile 09 zur&uuml;ckgesprungen. Der
MVC-Befehl kopiert dann die n&auml;chsten 4 Bytes von
PROG4, da das Basisregister R1 bereits um 4 Bytes
erh&ouml;ht worden ist. Das Programm bricht ab, nachdem
alle 48 Bytes kopiert worden sind. Da PROG4
nur 36 Bytes lang ist, werden also 12 zus&auml;tzliche,
sich an PROG4 anschlie&szlig;ende Bytes mitkopeirt.
Der Befehl</p>
<pre class="source">SVC	X'5B'</pre>
<p>in Zeile 13 beendet PROG4. Anhang B.4. demonstriert PROG4.</p>
</dd></dl>
<p>Entsprechend PROG2 in Beispiel (3.4.2) lassen sich durch
die Zeilen 01 bis 12 gr&ouml;&szlig;ere Abschnitte anderer Assembler-Programme
(bzw. ganze Programme) zu selbstreproduzierenden
Programmabschnitten (bzw. Programmen) erg&auml;nzen (siehe Abb.
 
3.4.B. Die Selbstreproduktion erfolgt jedoch nicht en
sondern in Abschnitten zu je 4 Bytes. Die L&auml;nge des
erg&auml;nzten Abschnitts (bzw. Programms) in Byte braucht dann
nur durch den Befehl in Zeile 06 in Register R4 bereitgestellt
zu werden. Entsprechend der L&auml;nge des zu kopierenden
Programmabschnitts (bzw. Programms) mu&szlig; die Distanzadresse,
die die Lage der Kopie im Arbeitsspeicher bestimmt,
in Zeile 09 (MVC-Befehl) gesetzt werden.</p>
<p><img src="/img/cache/ac43093c01598767c2d82f1f7698addc.gif" alt="
\begin{array}{lllll}
01 &amp; PROGRAM	&amp; CSECT\\
02 &amp;		&amp; BALR	&amp; 1,00\\
03 &amp;		&amp; LA	&amp;2,2(0,0)\\
\vdots &amp;	&amp; \vdots\\
06 &amp;		&amp; LA	&amp; 4, &lt;L\ddot{a}nge des Gesamtabschnitts&gt; (0,0)\\
07 &amp;		&amp; LA	&amp; 10,22(0,0)\\
\vdots &amp;	&amp; AR	&amp; 10,1\\
\vdots &amp;	&amp; MVC	&amp; &lt;Distanzzadresse der Kopie&gt;(4,1),0(1)\\
\vdots &amp;	&amp; \vdots\\
\vdots &amp;	&amp; \vdots\\
12 &amp;		&amp; BRP	&amp; 10\\
{13\\\vdots\\\vdots\\\vdots\\\vdots} &amp; &amp;
\left. {\\\vdots\\\vdots\\\vdots\\\vdots} \right\} &amp; \text{Der zu kopierende Programmabschnitt}\\
\vdots &amp;	&amp; END
\end{array}
" valign="middle"/></p>
<p>Abb 3.4.B</p>
<p>Im Gegensatz zu der aus PPOG2 abgeleiteten Methode zur
Selbstreproduktion gr&ouml;&szlig;erer Programmabschnitte lieg keine
Begrenzung auf <img src="/img/cache/18d5fada118b7a6ae959da4d75118745.gif" alt="2^8-16" valign="middle"/> Bytes vor.</p>
 
<h2><a name="c4"></a>4. Varianten zur Selbstreproduktion von Programmen</h2>
<p>In diesem Kapitel sei S eine beliebige h&ouml;here Programmiersprache
im &uuml;blichen Sinn (vgl. 1.2.).</p>
<h3><a name="c41"></a>4.1. Motivation</h3>
<p>In Abschnitt 1.2. haben wir eine Definition selbstreproduzierender
Programme angegeben. Diese Definition lautete singem&auml;&szlig;:</p>
<p>Sei <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> aus S. <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> hei&szlig;t selbstreproduzierend, wenn <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> ohne
Benutzung von Eingabe seinen Programmtext in S ausgibt.</p>
<p>Betrachtet man diese Definition etwas differenzierter, so
ergeben sich zwei. Anforderungen an die Ausgabe eines selbstreproduzierenden.
Programms <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> aus S:</p>
<ol type="a">
<li>Die Ausgabe von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> mu&szlig; ein syntaktisch korrektes Programm
<img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> aus der Programmiersprache S enthalten.</li>
<li><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> mu&szlig; gleich <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> sein.</li>
</ol>
<p>L&auml;&szlig;t man die Forderung b) fallen, so ist das Programm i.a.
nicht mehr selbstreproduzierend; es ist allenfalls als "reproduzierend"
zu bezeichnen.</p>
<p>Sei nun <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> "reproduzierend", dann sind zum Beispiel folgende
M&ouml;glichkeiten denkbar:</p>
<ol type="i">
<li>Das Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> gibt das Programm <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> aus. <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/>
seinerseits gibt das Programm <img src="/img/cache/f3504a88b06003c45759175764d2e525.gif" alt="\pi''" valign="middle"/> aus, und es gilt <img src="/img/cache/c1ccbae106c1d8c6aaaccb6d8b50a471.gif" alt="\pi''=\pi" valign="middle"/>.
<img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> und <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> sind dann sicher f&uuml;r sich nicht selbstreproduzierend.
Trotzdem liegt aber ein gewisser Selbstreproduktionsmechanismus mit "Zwischenstufe" vor.</li>
<li>Das Programm <img src="/img/cache/62aca1365efde4c451f6b138372e4088.gif" alt="\pi=\pi^0" valign="middle"/> gibt das Programm <img src="/img/cache/8c3e799630d7d054284c0dcde00c6b25.gif" alt="\pi^1" valign="middle"/> aus, <img src="/img/cache/8c3e799630d7d054284c0dcde00c6b25.gif" alt="\pi^1" valign="middle"/>
seinerseits das Programm <img src="/img/cache/49d3c2995cbe6a567aff4da6c29e2607.gif" alt="\pi^2" valign="middle"/> u.s.w.. Allgemein: <img src="/img/cache/31fb3f8e97bdd4f08e5794158180b42c.gif" alt="\pi^i" valign="middle"/> gibt <img src="/img/cache/188cf7eb0fd113a4be27541ddee277b1.gif" alt="\pi^{i+1}" valign="middle"/> aus, <img src="/img/cache/5f107a1af984f2ad676995a66c6b96d4.gif" alt="j\ge0" valign="middle"/>.
F&uuml;r alle <img src="/img/cache/d5a0900c04ab32b157777ba9425cf2b6.gif" alt="i,j\ge0" valign="middle"/> gilt <img src="/img/cache/0f2c499ddf7018ec0f5312ab5aa6fd2a.gif" alt="\pi^i\ne\pi^j" valign="middle"/>, falls <img src="/img/cache/7934733651f3f672baceb5765b0826ac.gif" alt="i\ne j" valign="middle"/>.</li>
</ol>
<p>Andererseits k&ouml;nnte man die obige Definition der Selbstreproduktion
versch&auml;rfen, indem man gewisse Zusatzforderungen
stellt.</p>
 
<p>Insgesamt sind also einige interessante Varianten zur
Selbstreproduktion denkbar. Einige dieser Varianten sollen
in diesem Kapitel pr&auml;sentiert und in bezug auf die realen
Programmiersprachen SIMULA und PASCAL an Hand von Beispielen
erl&auml;utert werden.</p>
<h3><a name="c42"></a>4.2. Unendlich reproduzierende Programme</h3>
<p><strong>(4.2.1) Definition:</strong> Sei <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> ein (syntaktisch korrektes)
Programm aus S.</p>
<ol type="a">
<li><ol type="i">
<li>Weist <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> keine Eingabe auf, so hei&szlig;t <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/>
(streng) <strong>reproduzierend</strong>, wenn <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> (genau)
ein syntaktisch korrektes Programm <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> aus
S ausgibt.</li>
<li>Weist <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> Eingabe auf, so hei&szlig;t <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> (streng)
<strong>reproduzierend</strong>, wenn <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> bei <strong>jeder</strong> zul&auml;ssigen
Eingabe (genau) ein syntaktisch korrektes Programm <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> aus S ausgibt.</li>
</ol></li>
<li>R(S) bezeichnet die Menge aller reproduzierenden
Programme aus S.</li>
</ol>
<p><strong>(4.2.2) Bemerkung:</strong> Jedes (streng) selbstreproduzierende
Programm ist selbstverst&auml;ndlich (streng) reproduzierend.</p>
<p>Aus (4.2.2) folgt, da&szlig; es in den Programmiersprachen SIMULA
und PASCAL reproduzierende Programme gibt, da in diesen
Sprachen selbstreproduzierende Programme existieren.</p>
<p><strong>(4.2.3) Lemma:</strong> In den Programmiersprachen SIMULA und PASCAL
existieren unendlich viele reproduzierende Programme,
die nicht selbstreproduzierend sind.</p>
 
<p><strong>Beweis:</strong></p>
<ol type="i">
<li>F&uuml;r Jedes <img src="/img/cache/29f652dbaae7e55c583525f9a8815b8a.gif" alt="k\in\mathbb{N}" valign="middle"/> ist das SIMULA-Programm
<pre class="source"><img src="/img/cache/39ce52d8a758241340f367ecb1280f1a.gif" alt="\pi_{\text{SIM(k)}}" valign="middle"/> = 
<strong>begin</strong>
OUTTEXT("BEGIN INTEGER I;
         I:=k;
         OUTINT(k, &lt;Stelligkeit von k>)
         END")
<strong>end</strong>
</pre>
reproduzierend, da die Textkonstante, die von
<img src="/img/cache/39ce52d8a758241340f367ecb1280f1a.gif" alt="\pi_{\text{SIM(k)}}" valign="middle"/> ausgegeben wird, ein g&uuml;ltiges SIMULA-Programm
darstellt.</li>
<li>Ein analoges Programm l&auml;&szlig;t sich in PASCAL angeben:
<pre class="source"><img src="/img/cache/ce3affd30a6d726d9842701c41fcff0e.gif" alt="\pi_{\text{PAS(k)}}" valign="middle"/> = 
<strong>program</strong> T(OUTPUT);
<strong>begin</strong>
WRITE('PROGRAM T(OUTPUT);
       BEGIN
       WRITE(k)
       END.')
<strong>end</strong>.
</pre>
</li>
</ol>
<div align="right">%</div>
<p><strong>(4.2.4) Definition:</strong> Sei <img src="/img/cache/6e68cde5e897257c73afd3329222ed37.gif" alt="(\pi_i)_{i\in\mathbb{N}_0}=\pi_0,\pi_1,\pi_2,\dots" valign="middle"/> eine
(unendliche) Folge von Programmen aus der Programmiersprache
S. <img src="/img/cache/74d856e6ef483ef016c03b87880673a9.gif" alt="(\pi_i)_{i\in\mathbb{N}_0}" valign="middle"/> hei&szlig;t <strong>Reproduktionsfolge</strong>,
falls gilt <img src="/img/cache/68df4fedda3a6ee42485d71ce568ba2e.gif" alt="\pi_j" valign="middle"/> reproduziert <img src="/img/cache/d86426e3a00985a8a21d37f4abec93ef.gif" alt="\pi_{j+1}" valign="middle"/> f&uuml;r alle <img src="/img/cache/1509b3a18c6a312ddc8952df3fa169fc.gif" alt="j\in\mathbb{N}_0" valign="middle"/>.</p>
<p>Aus (4.2.4) folgt, da&szlig; jedes Programm einer Reproduktionsfolge
als Startprogramm einer neuen Reproduktionsfolge aufgefa&szlig;t
werden kann. Man braucht nur die entsprechende Teilfolge
zu bilden. Dies rechtfertigt die folgende Definition.</p>
 
<p><strong>(4.2.5) Definition:</strong> Sei <img src="/img/cache/74d856e6ef483ef016c03b87880673a9.gif" alt="(\pi_i)_{i\in\mathbb{N}_0}" valign="middle"/> eine Reproduktionsfolge
aus der Programmiersprache S. Sei <img src="/img/cache/c0a6f28692d6c04c48293048eb745413.gif" alt="\pi_j,\ j\in\mathbb{N}_0" valign="middle"/>, ein
Element dieser Folge.</p>
<ol type="i">
<li><img src="/img/cache/68df4fedda3a6ee42485d71ce568ba2e.gif" alt="\pi_j" valign="middle"/> hei&szlig;t <strong>unendlich reproduzierend</strong>.</li>
<li>Die Teilfolge <img src="/img/cache/a111bf27f7503e309d22ad6f9665ea98.gif" alt="(\pi_k)^j_{k\in\mathbb{N}_0}" valign="middle"/> von <img src="/img/cache/74d856e6ef483ef016c03b87880673a9.gif" alt="(\pi_i)_{i\in\mathbb{N}_0}" valign="middle"/> mit
<img src="/img/cache/2ee1ed0e1362e75c7c4874df9a69df3e.gif" alt="\pi_k=\pi_{j+k}" valign="middle"/> f&uuml;r alle <img src="/img/cache/081af7411e6dd4fc46a9d1d59cb5aa42.gif" alt="k\in\mathbb{N}_0" valign="middle"/> hei&szlig;t die
<strong>Reproduktionsfolge von <img src="/img/cache/68df4fedda3a6ee42485d71ce568ba2e.gif" alt="\pi_j" valign="middle"/></strong>.</li>
<li>U(S) bezeichnet die Menge aller unendlich
reproduzierenden Programme aus S.</li>
</ol>
<p><img src="/img/cache/eba2bac4cbbf5e6a0cba2ab523179bbb.gif" alt="
\begin{array}{r}
\text{Reproduktionsfolge von \pi_0}\\
\pi_0\longr\dots\longr\pi_{j-1}\longr\pi_j\longr\pi_{j+1}\longr\dots\\
\text{Reproduktionsfolge von \pi_j}\\
\pi_j\longr\pi_{j+1}\longr\dots\\
\end{array}
" valign="middle"/></p>
<p>Abb.: 4.2.A</p>
<p><strong>(4.2.6) Bemerkung:</strong> Jedes selbstreproduzierende Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/>
ist unendlich reproduzierend. Die Reproduktionsfolge
von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> ist konstant.</p>
<p><strong>(4.2.7) Satz:</strong> Es existiert ein unendlich reproduzierendes
PASCAL-Programm, in dessen Reproduktionsfolge kein
Programm mehrfach vorkommt.</p>
<p>Satz (4.2.7) wird durch das folgende Beispielprogramm <img src="/img/cache/0db27294a048f7c594b396ec7f277e30.gif" alt="\overset\infty\pi_0" valign="middle"/>,
das den Forderungen des Satzes gen&uuml;gt, bewiesen.</p>
<p><strong>(4.2.8) Beispiel:</strong></p>
<pre class="source"><img src="/img/cache/0db27294a048f7c594b396ec7f277e30.gif" alt="\overset\infty\pi_0" valign="middle"/>  = <strong>program</strong> UR(OUTTPUT);
       <strong>var</strong> I,K : <strong>integer</strong>;
       <strong>procedure</strong> Z(J : <strong>integer</strong>); <strong>begin</strong> WRITE(J+1) <strong>end</strong>;
 
       <strong>procedure</strong> AA; <strong>begin</strong> WRITE('PROGRAM UR(OUTPUT); VA
          R I,K : INTEGER; PROCEDURE Z(J : INTEGER); BEG
	  IN WRITE(J+1) END; PROCEDURE AA; BEGIN WRITE('
	  '') <strong>end</strong>;
       <strong>procedure</strong> C; <strong>begin</strong> WRITE('PROCEDURE ') <strong>end</strong>;
       <strong>procedure</strong> A; <strong>begin</strong> WRITE('; BEGIN WRITE(''') <strong>end</strong>;
       <strong>procedure</strong> B; <strong>begin</strong> WRITE(''') END;') <strong>end</strong>;
       <strong>procedure</strong> AC; <strong>begin</strong> WRITE('''') <strong>end</strong>;
       <strong>procedure</strong> BA; <strong>begin</strong> WRITE('A') <strong>end</strong>;
       <strong>procedure</strong> BB; <strong>begin</strong> WRITE('B') <strong>end</strong>;
       <strong>procedure</strong> BC; <strong>begin</strong> WRITE('C') <strong>end</strong>;
       <strong>procedure</strong> CA; <strong>begin</strong> WRITE('BEGIN K:=') <strong>end</strong>;
       <strong>procedure</strong> AB; <strong>begin</strong> WRITE(';FOR I:=1 TO K DO BEGI
          N WRITELN(I,I*I,I*I*I) END;AA;AA;AC;B;C;BC;A;C
	  ;B;C;BA;A;A;AC;B;C;BB;A;AC;B;B;C;BA;BC;A;AC;AC
	  ;B;C;BB;BA;A;BA;B;C;BB;BB;A;BB;B;C;BB;BC;A;BC;
	  B;C;BC;BA;A;CA;B;C;BA;BB;A;AB;B;CA;Z(K);AB;WRI
	  TELN END.') <strong>end</strong>;
       <strong>begin</strong>
       K:=0;
       <strong>for</strong> I:=1 <strong>to</strong> K <strong>do</strong>
       <strong>begin</strong> WRITELN(I,I*I,I*I*I) <strong>end</strong>;
       AA;AA;AC;B;
       C;BC;   A;   C;   B;
       C;BA;   A;   A;AC;B;
       C;BB;   A;AC;B;   B;
       C;BA;BC;A;AC;AC;  B;
       C;BB;BA;A;   BA;  B;
       C;BB;BB;A;   BB;  B;
       C;BB;BC;A;   BC;  B;
       C;BC;BA;A;   CA;  B;
       C;BA;BB;A;   AB;  B;CA;Z(K);AB;
       WRITELN
       <strong>end</strong>.
</pre>
<p><img src="/img/cache/0db27294a048f7c594b396ec7f277e30.gif" alt="\overset\infty\pi_0" valign="middle"/> ist ein unendlich reproduzierendes Programm, in dessen
Reproduktionsfolge kein Programm mehrfach auftritt.</p>
 
<p><strong>Verifikation:</strong></p>
<p><img src="/img/cache/0db27294a048f7c594b396ec7f277e30.gif" alt="\overset\infty\pi_0" valign="middle"/> entspricht im wesentlichen dem selbstreproduzierenden
programm <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> aus 3.3.2. Da&szlig; <img src="/img/cache/0db27294a048f7c594b396ec7f277e30.gif" alt="\overset\infty\pi_0" valign="middle"/> nicht ebenfalls selbstreproduzierend
ist, wird durch Erh&ouml;hung der Obergrenze der Laufvariablen
I um 1 in der Kopie <img src="/img/cache/0871d863fbffb6ab41e6a274c41492fe.gif" alt="\overset\infty\pi_1" valign="middle"/> von <img src="/img/cache/0db27294a048f7c594b396ec7f277e30.gif" alt="\overset\infty\pi_0" valign="middle"/> verhindert. Diese
Erh&ouml;hung wird durch Aufruf der Prozedur Z erreicht, deren
Text in den Programmkopf integriert ist. Durch die Erh&ouml;hung
der Obergrenze der Laufvariablen, ist die Kopie von <img src="/img/cache/0db27294a048f7c594b396ec7f277e30.gif" alt="\overset\infty\pi_0" valign="middle"/> sowohl
textuell, als auch im Hinblick auf die Bedeutung des
Programms, von <img src="/img/cache/0db27294a048f7c594b396ec7f277e30.gif" alt="\overset\infty\pi_0" valign="middle"/> verschieden. Da die Kopie sich lediglich
in einer <strong>integer</strong>-Konstanten von <img src="/img/cache/0db27294a048f7c594b396ec7f277e30.gif" alt="\overset\infty\pi_0" valign="middle"/> unterscheidet, bleibt
sie ein lauff&auml;higes reproduzierendes Programm. In gleicher
Weise unterscheidet sich die Kopie <img src="/img/cache/74cb4c7b2e7a64febb46d8500ffaa7d2.gif" alt="\overset\infty\pi_2" valign="middle"/> des Programms <img src="/img/cache/0871d863fbffb6ab41e6a274c41492fe.gif" alt="\overset\infty\pi_1" valign="middle"/>
von <img src="/img/cache/0871d863fbffb6ab41e6a274c41492fe.gif" alt="\overset\infty\pi_1" valign="middle"/>. Die Obergrenze der Laufvariablen I hat in <img src="/img/cache/74cb4c7b2e7a64febb46d8500ffaa7d2.gif" alt="\overset\infty\pi_2" valign="middle"/> einen
um 2 gr&ouml;&szlig;eren Wert als in <img src="/img/cache/0db27294a048f7c594b396ec7f277e30.gif" alt="\overset\infty\pi_0" valign="middle"/>. Insgesamt gilt:</p>
<p><img src="/img/cache/0db27294a048f7c594b396ec7f277e30.gif" alt="\overset\infty\pi_0" valign="middle"/> ist ein unendlich reproduzierendes Programm. In jedem
Element <img src="/img/cache/a93c77c9dd9ac53231ea3d5464048cf0.gif" alt="\overset\infty\pi_j" valign="middle"/>, der Reproduktionsfolge von<img src="/img/cache/0db27294a048f7c594b396ec7f277e30.gif" alt="\overset\infty\pi_0" valign="middle"/> hat die Obergrenze
der Laufvariablen I den Wert j.</p>
<p><strong>(4.2.9) Bemerkung:</strong></p>
<ol type="I">
<li>Die Programme <img src="/img/cache/f71dbc36eca7f2b66d4bad9656c17369.gif" alt="\overset\infty\pi_j,\ j\in\mathbb{N}_0" valign="middle"/> sind reproduzierend, aber
nicht streng reproduzierend. Aus den Programmen <img src="/img/cache/a93c77c9dd9ac53231ea3d5464048cf0.gif" alt="\overset\infty\pi_j" valign="middle"/>
lassen sich aber durch Streichung der Anweisung
<pre class="source">WRITELN(I,I*I,I*I*I)</pre>
streng reproduzierende Programme gewinnen.
Satz (4.2.7) lie&szlig;e sich also in dieser Hinsicht
auch sch&auml;rfer formulieren.</li>
<li>Die Programme der mittels <img src="/img/cache/0db27294a048f7c594b396ec7f277e30.gif" alt="\overset\infty\pi_0" valign="middle"/> gewonnenen Reproduktionsfolge
enthalten alle den kompletten Selbstreproduktionsmechanismus
von Programm <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> aus 3.3.2. Gefordert
war jedoch nur eine schw&auml;chere Eigenschaft,
n&auml;mlich Reproduktion. Um nur Reproduktion zu erhalten,
hatten wir den Selbstreproduktionsmechanismus
durch Hinzunahme des zus&auml;tzlichen Programmteils
<pre class="source">
	<strong>for</strong> I:=1 <strong>to</strong> ... <strong>do</strong>
	<strong>begin</strong> ... <strong>end</strong>
</pre>
 
abgeschw&auml;cht. Diese Vorgehensweise erscheint auf
den ersten Blick widersinnig zu sein. Die Programme
der Folge <img src="/img/cache/c59d3d70be93b60381936d301b9cb3be.gif" alt="(\overset\infty\pi_i)_{i\in\mathbb{N}_0}" valign="middle"/> ben&ouml;tigen aber anscheinend den
Selbstreproduktionsmechanismus, um <strong>unendlich viele</strong>
voneinander verschiedene syntaktisch korrekte
Programme zu erzeugen. W&uuml;nschenswert w&auml;re eine
Reproduktionsfolge mit Programmen, die mit schw&auml;cheren
Mechanismen als dem Selbstreproduktionsmechanismus
auskommen. Die Schwierigkeit, solche Folgen zu finden,
kann als Hinweis darauf interpretiert werden,
da&szlig; <strong>unendlich viele</strong> sukzessive auseinander hervorgehende
Programme irgendwie "dicht" beieinander
liegen m&uuml;ssen; so dicht, da&szlig; "Quasi-Selbstreproduktion"
n&ouml;tig ist, um sie &uuml;berhaupt zu erzeugen.</li>
<li>Programm <img src="/img/cache/0db27294a048f7c594b396ec7f277e30.gif" alt="\overset\infty\pi_0" valign="middle"/> enth&auml;lt nur Sprachkonzepte, die auch
in der Programmiersprache SIMULA enthalten sind.
Daher l&auml;&szlig;t sich Satz (4.2.7) auch entsprechend f&uuml;r
die Programmiersprache SIMULA formulieren.</li>
<li>Satz (4.2.7) hat in erster Linie theoretische
Bedeutung. In der Praxis gibt es zwar unendlich
reproduzierende Programme, aber nicht die entsprechenden
Folgen, denn bei endlicher Speicherkapazit&auml;t
lassen sich auch nur endlich viele verschiedene
Programme darstellen.</li>
</ol>
<h4><a name="c421"></a>4.2.1. Implementierung des Programms <img src="/img/cache/0db27294a048f7c594b396ec7f277e30.gif" alt="\overset\infty\pi_0" valign="middle"/></h4>
<p>Programm <img src="/img/cache/0db27294a048f7c594b396ec7f277e30.gif" alt="\overset\infty\pi_0" valign="middle"/> schreibt seine gesamte Ausgabe unformatiert in
eine Zeile. Diese Zeile ist sowohl f&uuml;r den Puffer des
Schnelldruckers als auch f&uuml;r den Eingabepuffer des PASCAL-Compilers
zu lang. F&uuml;r eine ausreichende Demonstration des
Programms <img src="/img/cache/0db27294a048f7c594b396ec7f277e30.gif" alt="\overset\infty\pi_0" valign="middle"/> ist es aber w&uuml;nschenswert, die Ausgabe von
<img src="/img/cache/0db27294a048f7c594b396ec7f277e30.gif" alt="\overset\infty\pi_0" valign="middle"/>, n&auml;mlich <img src="/img/cache/0871d863fbffb6ab41e6a274c41492fe.gif" alt="\overset\infty\pi_1" valign="middle"/>, zu &uuml;bersetzen und auszuf&uuml;hren. Wir
verfahren deshalb wie in 3.3.3. und f&uuml;hren zur Formatierung
der Eingabe die Prozedur Q ein:</p>
<pre class="source"><strong>procedure</strong> Q; <strong>begin</strong> WRITELN <strong>end</strong>;</pre>
<p>Die relativ lange Textkonstante aus Prozedur AB wird auf
4 Prozeduren aufgespalten. Zu diesem Zweck werden die
 
Prozeduren AAA, CB und CC zus&auml;tzlich in das Programm aufgenommen.
Anhang A.7. demonstriert das so ver&auml;nderte Programm <img src="/img/cache/0db27294a048f7c594b396ec7f277e30.gif" alt="\overset\infty\pi_0" valign="middle"/>.</p>
<h3><a name="c43"></a>4.3. Zyklisch selbstreproduzierende Programme</h3>
<p><strong>(4.3.1) Definition:</strong> Sei <img src="/img/cache/d4c98d75e25f5d28461f1da221eb7a95.gif" alt="\pi_0" valign="middle"/> ein unendlich reproduzierendes
Programm aus der Programmiersprache S. Sei <img src="/img/cache/74d856e6ef483ef016c03b87880673a9.gif" alt="(\pi_i)_{i\in\mathbb{N}_0}" valign="middle"/>
die Reproduktionsfolge von <img src="/img/cache/d4c98d75e25f5d28461f1da221eb7a95.gif" alt="\pi_0" valign="middle"/>.</p>
<ol type="i">
<li>Existiert <img src="/img/cache/8d5fc72e100fbfad497a9aa29b1ed49b.gif" alt="j\ge1" valign="middle"/> mit <img src="/img/cache/e0b8ae23f98cfb403b9a9c973886e4f2.gif" alt="\pi_j=\pi_0" valign="middle"/>, so hei&szlig;t <img src="/img/cache/d4c98d75e25f5d28461f1da221eb7a95.gif" alt="\pi_0" valign="middle"/> <strong>zyklisch
selbstreproduzierend</strong>.</li>
<li>Ist <img src="/img/cache/d4c98d75e25f5d28461f1da221eb7a95.gif" alt="\pi_0" valign="middle"/> zyklisch selbstreproduzierend, so hei&szlig;t das
kleinste <img src="/img/cache/8d5fc72e100fbfad497a9aa29b1ed49b.gif" alt="j\ge1" valign="middle"/> mit <img src="/img/cache/e0b8ae23f98cfb403b9a9c973886e4f2.gif" alt="\pi_j=\pi_0" valign="middle"/> die <strong>Zyklusl&auml;nge</strong> von <img src="/img/cache/d4c98d75e25f5d28461f1da221eb7a95.gif" alt="\pi_0" valign="middle"/>.</li>
<li>Die Menge aller zyklisch selbstreprodusierenden
Programme aus S wird mit Z(S) bezeichnet.</li>
</ol>
<div align="center"><img src="/img/cache/e659844f7acc1a0375fab45711be6995.gif" alt="
\begin{array}{lcr}
\pi_0 &amp; \longr \pi_1 \longr \dots \longr &amp; \pi_{j-1}\\
\uparrow &amp; &amp; \downarrow\\
\hline
\end{array}
" valign="middle"/></div>
<p>Abb.: 4.3.A</p>
<p><strong>(4.3.2) Bemerkung:</strong> Jedes Programm <img src="/img/cache/68df4fedda3a6ee42485d71ce568ba2e.gif" alt="\pi_j" valign="middle"/> aus der Reproduktionsfolge
eines zyklisch selbstreproduzierenden Programms
<img src="/img/cache/d4c98d75e25f5d28461f1da221eb7a95.gif" alt="\pi_0" valign="middle"/> ist zyklisch selbstreproduzierend und
hat die gleiche Zyklusl&auml;nge wie <img src="/img/cache/d4c98d75e25f5d28461f1da221eb7a95.gif" alt="\pi_0" valign="middle"/>.</p>
 
<p><strong>(4.3.3) Satz:</strong> In der Programmiersprache PASCAL existiert f&uuml;r
jedes <img src="/img/cache/fdfa4c01526aef4b03bc39afbd7fd7ea.gif" alt="k\ge1" valign="middle"/> ein zyklisch selbstreproduzierendes Programm
<img src="/img/cache/798fdb0eb9d3269e79587fef7cd66dc3.gif" alt="\overset{k}\pi" valign="middle"/> mit der Zyklusl&auml;nge k.</p>
<p><strong>Beweis:</strong> Das PASCAL-Programm <img src="/img/cache/0db27294a048f7c594b396ec7f277e30.gif" alt="\overset\infty\pi_0" valign="middle"/> aus 4.3. ist unendlich
reproduzierend. Man kann aber sehr einfach aus <img src="/img/cache/0db27294a048f7c594b396ec7f277e30.gif" alt="\overset\infty\pi_0" valign="middle"/> ein
zyklisch selbstreproduzierendes Programm <img src="/img/cache/5207187530e2a06035973be6353e8c95.gif" alt="\overset{k}\pi_0" valign="middle"/> f&uuml;r
jedes <img src="/img/cache/fdfa4c01526aef4b03bc39afbd7fd7ea.gif" alt="k\ge1" valign="middle"/> herleiten, indem man</p>
<pre class="source"><strong>procedure</strong> Z(J : integer); <strong>begin</strong> WRITE(J+1) <strong>end</strong>;</pre>
<p>durch</p>
<pre class="source"><strong>procedure</strong> Z(J : integer); <strong>begin</strong> WRITE((J+1) mod k) <strong>end</strong>;</pre>
<p>ersetzt.</p>
<p>Die Programme aus der Reproduktionsfolge von <img src="/img/cache/0db27294a048f7c594b396ec7f277e30.gif" alt="\overset\infty\pi_0" valign="middle"/>
unterscheiden sich gerade in dem von Z ausgegebenen
Wert. Die ge&auml;nderte Prozedur Z stellt sicher, da&szlig;
f&uuml;r jedes <img src="/img/cache/fdfa4c01526aef4b03bc39afbd7fd7ea.gif" alt="k\ge1" valign="middle"/> gilt <img src="/img/cache/9b567bc6eb1fe6bac1dfb067aec3999f.gif" alt="\overset{k}\pi_0=\overset{k}\pi_k" valign="middle"/>. Mit
<img src="/img/cache/5207187530e2a06035973be6353e8c95.gif" alt="\overset{k}\pi_0" valign="middle"/> als <img src="/img/cache/798fdb0eb9d3269e79587fef7cd66dc3.gif" alt="\overset{k}\pi" valign="middle"/> gilt der Satz.</p>
<div align="right">%</div>
<p>Wir wollen noch ein Beispiel f&uuml;r zyklisch selbstreproduzierende
Programme angeben.</p>
<p><strong>(4.3.4)</strong> Beispiel: Das folgende Programm <img src="/img/cache/fe7fb103354181c4ccda624e5d41eb9b.gif" alt="\pi_0^{\text{zyk}}" valign="middle"/> ist, abgesehen
von einigen Umbenennungen, eine Abwandlung von <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/>
aus Abschnitt 3.3.2. <img src="/img/cache/fe7fb103354181c4ccda624e5d41eb9b.gif" alt="\pi_0^{\text{zyk}}" valign="middle"/> soll sich erst nach einem
Zyklus von N = 9 Schritten selbstreproduzieren. Dies
wird dadurch erreicht, da&szlig; <img src="/img/cache/fe7fb103354181c4ccda624e5d41eb9b.gif" alt="\pi_0^{\text{zyk}}" valign="middle"/> einige seiner
Prozeduren in einer anderen Reihenfolge ausgibt. Das
resultierende Programm <img src="/img/cache/1d3f48087667bb8e74160207e6b01beb.gif" alt="\pi_1^{\text{zyk}}" valign="middle"/> verf&auml;hrt mit den
Prozeduren in analoger Weise. Erst nach 9 Schritten
ist die Ausgangskonstellation der Prozeduren erreicht
und <img src="/img/cache/fe7fb103354181c4ccda624e5d41eb9b.gif" alt="\pi_0^{\text{zyk}}" valign="middle"/> liegt wieder vor.</p>
<p><img src="/img/cache/fe7fb103354181c4ccda624e5d41eb9b.gif" alt="\pi_0^{\text{zyk}}" valign="middle"/> hat gegen&uuml;ber <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> einen erweiterten
Vereinbarungsteil durch:</p>
<ol type="i">
<li>
<pre class="source"><strong>integer</strong> I,K;
<strong>procedure</strong> Z(J : integer); <strong>begin</strong> WRITE(J) <strong>end</strong>;
</pre></li>
 
<li>Aufspaltung der den Algorithmus von <img src="/img/cache/fe7fb103354181c4ccda624e5d41eb9b.gif" alt="\pi_0^{\text{zyk}}" valign="middle"/>
druckenden Prozedur in zwei Prozeduren BC
und CA.</li>
</ol>
<p>Der Anweisungsteil von <img src="/img/cache/fe7fb103354181c4ccda624e5d41eb9b.gif" alt="\pi_0^{\text{zyk}}" valign="middle"/> mu&szlig; bewirken, da&szlig; sich
die direkte Kopie <img src="/img/cache/1d3f48087667bb8e74160207e6b01beb.gif" alt="\pi_1^{\text{zyk}}" valign="middle"/> von <img src="/img/cache/fe7fb103354181c4ccda624e5d41eb9b.gif" alt="\pi_0^{\text{zyk}}" valign="middle"/> unterscheidet.
Erst nach 9 Schritten darf <img src="/img/cache/fe7fb103354181c4ccda624e5d41eb9b.gif" alt="\pi_0^{\text{zyk}}" valign="middle"/> wieder hergestellt
sein. Der Anweisungsteil von <img src="/img/cache/fe7fb103354181c4ccda624e5d41eb9b.gif" alt="\pi_0^{\text{zyk}}" valign="middle"/> mu&szlig; in allen
Kopien "fast" der gleiche, aber doch variabel sein.
Daher kann der Anweisungsteil von <img src="/img/cache/fe7fb103354181c4ccda624e5d41eb9b.gif" alt="\pi_0^{\text{zyk}}" valign="middle"/> nicht en
bloc kopiert werden. Daraus resultiert auch die
unter (ii) angegebene Aufspaltung. Mit den folgenden
Prozeduraufrufen wird der Algorithmus von <img src="/img/cache/fe7fb103354181c4ccda624e5d41eb9b.gif" alt="\pi_0^{\text{zyk}}" valign="middle"/>
und seiner Kopien angegeben.</p>
<p><img src="/img/cache/dc46ce75fad9a2b1d4e2d4adf080bf23.gif" alt="
\begin{array}{ccc}
 \underbrace{\text{BC ; Z((}} &amp; k &amp; \underbrace{\text{+2) mod 9) ; CA}}\\
 \uparrow &amp; \uparrow &amp; \uparrow\\
 \text{konstant} &amp; | &amp; \text{konstant}\\
\end{array}\\
\text{\ \ \ \ variabel}
" valign="middle"/></p>
<pre class="source"><img src="/img/cache/fe7fb103354181c4ccda624e5d41eb9b.gif" alt="\pi_0^{\text{zyk}}" valign="middle"/> = 
<strong>program</strong> ZYKLUS(OUTPUT);
<strong>var</strong> I,K : <strong>integer</strong>;
<strong>procedure</strong> Z(J : integer); <strong>begin</strong> WRITE(J) <strong>end</strong>;
<strong>procedure</strong> A; <strong>begin</strong> WRITE('PROGRAM ZYKLUS(OUTPUT); VAR I,K :
   INTEGER;PROCEDURE Z(J : INTEGER); BEGIN WRITE(J) END; PRO
   CEDURE A; BEGIN WRITE('') <strong>end</strong>;
<strong>procedure</strong> B; <strong>begin</strong> WRITE(PROCEDURE ') <strong>end</strong>;
<strong>procedure</strong> C; <strong>begin</strong> WRITE('; BEGIN WRITE(''') <strong>end</strong>;
<strong>procedure</strong> AA; <strong>begin</strong> WRITE(''') END;') <strong>end</strong>;
<strong>procedure</strong> AB; <strong>begin</strong> WRITE('''') <strong>end</strong>;
<strong>procedure</strong> AC; <strong>begin</strong> WRITE('A') <strong>end</strong>;
<strong>procedure</strong> BA; <strong>begin</strong> WRITE('B') <strong>end</strong>;
<strong>procedure</strong> BB; <strong>begin</strong> WRITE('C') <strong>end</strong>;
<strong>procedure</strong> BC; <strong>begin</strong> WRITE(BEGIN A;A;AB;AA;K:=') <strong>end</strong>;
<strong>procedure</strong> CA; <strong>begin</strong> WRITE('; FOR I:=1 TO 9 DO BEGIN B;CASE K
   OF 0:BEGIN BA;C;B END;1:BEGIN BB;C;C;BA END;2:BEGIN AC;AC
   ;C;AB;AA END;3:BEGIN AC;BA;C;AB;AB END;4:BEGIN AC;BB;C;AC
   END;5:BEGIN BA;AC;C;BA END;6:BEGIN BA;BA;C;BB END;7:BE
 
   GIN BA;BB;C;BC END;8:BEGIN BB;AC;C;CA END END;AA;K:=(K+1) MO
   D 9 END;BC;Z((K+1) MOD 9);CA;WRITELN END.') <strong>end</strong>;
<strong>begin</strong>
A;A;AB;AA;
K:=1;
<strong>for</strong> I:=1 <strong>to</strong> 9 <strong>do</strong>
<strong>begin</strong> B;
  case K of
0:<strong>begin</strong> BA;C;B <strong>end</strong>;
1:<strong>begin</strong> BB;C;C;BA <strong>end</strong>;
2:<strong>begin</strong> AC;AC;C;AB;AA <strong>end</strong>;
3:<strong>begin</strong> AC;BA;C;AB;AB <strong>end</strong>;
4:<strong>begin</strong> AC;BB;C;AC <strong>end</strong>;
5:<strong>begin</strong> BA;AC;C;BA <strong>end</strong>;
6:<strong>begin</strong> BA;BA;C;BB <strong>end</strong>;
7:<strong>begin</strong> BA;BB;C;BC <strong>end</strong>;
8:<strong>begin</strong> BB;AC;C;CA <strong>end</strong>
  <strong>end</strong>;
  AA;
  K:=(K+1) mod 9
<strong>end</strong>;
BC;Z((K+1) <strong>mod</strong> 9);CA;
WRITELN
<strong>end</strong>.
</pre>
<p><strong>Verifikation</strong></p>
<p>Die Programme <img src="/img/cache/05c0542847bce99dedebe709e9a21c5e.gif" alt="\pi_0^{\text{zyk}},\pi_1^{\text{zyk}},\dots,\pi_8^{\text{zyk}}" valign="middle"/> stimmen bis auf
die Reihenfolge der Prozeduren B,...,CA und den Startwert
von K textuell &uuml;berein. Die Ausgabefolge dieser Prozeduren
wird &uuml;ber die Variable k gesteuert. Wir betrachten dazu
die folgende Tabelle:</p>
 
<table summary="" border="1" width="50%">
<tr><th colspan="11">
<span style="float:left"><img src="/img/cache/42ae4615838c20bda1769756b7078922.gif" alt="\downarrow" valign="middle"/>Startwert k in <img src="/img/cache/8c88f7b55d99d5400d18d997ddb2822e.gif" alt="\pi_i^{\text{zyk}}" valign="middle"/></span>
<span style="float:right">Startwert k, der von <img src="/img/cache/8c88f7b55d99d5400d18d997ddb2822e.gif" alt="\pi_i^{\text{zyk}}" valign="middle"/><br/>an <img src="/img/cache/6b2b323a3c0e1d8dd54f43ab5f0ab6e7.gif" alt="\pi_{i+1}^{\text{zyk}}" valign="middle"/> weitergegeben wird<img src="/img/cache/42ae4615838c20bda1769756b7078922.gif" alt="\downarrow" valign="middle"/></span>
<br clear="all"/>
<center>Die Wertefolge, die k in <img src="/img/cache/8c88f7b55d99d5400d18d997ddb2822e.gif" alt="\pi_i^{\text{zyk}}" valign="middle"/> durchl&auml;uft</center>
</th></tr>
<tr><th>&nbsp;</th><th>I=1</th><th>I=2</th><th>I=3</th><th>I=4</th><th>I=5</th><th>I=6</th><th>I=7</th><th>I=8</th><th>I=9</th><th>&nbsp; &nbsp;</th></tr>
<tr><td><img src="/img/cache/fe7fb103354181c4ccda624e5d41eb9b.gif" alt="\pi_0^{\text{zyk}}" valign="middle"/></td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>0</td><td>1</td><td>2</td></tr>
<tr><td><img src="/img/cache/1d3f48087667bb8e74160207e6b01beb.gif" alt="\pi_1^{\text{zyk}}" valign="middle"/></td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>0</td><td>1</td><td>2</td><td>3</td></tr>
<tr><td><img src="/img/cache/7173951b0ff95e10583ab86f4f995c82.gif" alt="\pi_2^{\text{zyk}}" valign="middle"/></td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr>
<tr><td><img src="/img/cache/c48c4824cd4289d6e8472b8ba475f12f.gif" alt="\pi_3^{\text{zyk}}" valign="middle"/></td><td>5</td><td>6</td><td>7</td><td>8</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr>
<tr><td><img src="/img/cache/a5d03bbd9319b38ea46db05a503ffd7a.gif" alt="\pi_4^{\text{zyk}}" valign="middle"/></td><td>6</td><td>7</td><td>8</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td></tr>
<tr><td><img src="/img/cache/9835a2436628d47f87f3e6fae7c8a329.gif" alt="\pi_5^{\text{zyk}}" valign="middle"/></td><td>7</td><td>8</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr>
<tr><td><img src="/img/cache/ca8eb0cdb8c3d0fb8ac75936fc1a568a.gif" alt="\pi_6^{\text{zyk}}" valign="middle"/></td><td>8</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td></tr>
<tr><td><img src="/img/cache/48902cb8f55b7e8be7cf6cd80cf49dde.gif" alt="\pi_7^{\text{zyk}}" valign="middle"/></td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>0</td></tr>
<tr><td><img src="/img/cache/5a5eff660dccb2a2f759b5fc1a8719fd.gif" alt="\pi_8^{\text{zyk}}" valign="middle"/></td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>0</td><td>1</td></tr>
</table>
 
<p>In jeder Zeile der Tabelle kommen alle Werte von 0 bis 8
¦n den Spalten "I=1" bis "I=8" genau einmal vor. Damit ist
auf Grund der <strong>case</strong>-Anweisung sichergestellt, da&szlig; jedes <img src="/img/cache/8c88f7b55d99d5400d18d997ddb2822e.gif" alt="\pi_i^{\text{zyk}}" valign="middle"/>
alle Prozeduren B bis CA ausgibt. Aus der letzten Spalte
folgt, da&szlig; der Startwert von k in jeder Kopie <img src="/img/cache/5bf62aebdb65b7fca8e5ec7dd01849b8.gif" alt="\pi_i^{\text{zyk}},\ i=0,\dots,8" valign="middle"/>
verschieden ist. Ebenfalls aus der letzten Spalte folgt,
da&szlig; der Startwert von k in der Kopie von <img src="/img/cache/5a5eff660dccb2a2f759b5fc1a8719fd.gif" alt="\pi_8^{\text{zyk}}" valign="middle"/> gleich dem
Startwert von k in <img src="/img/cache/fe7fb103354181c4ccda624e5d41eb9b.gif" alt="\pi_0^{\text{zyk}}" valign="middle"/> ist. Da sich die Anweisungsteile
der <img src="/img/cache/8c88f7b55d99d5400d18d997ddb2822e.gif" alt="\pi_i^{\text{zyk}}" valign="middle"/> nur in dem Startwert von k unterscheiden, gilt:</p>
<div align="center"><img src="/img/cache/f6ef767adbd726c68301a253ae0c43c1.gif" alt="\pi_9^{\text{zyk}}=\pi_0^{\text{zyk}}" valign="middle"/>.</div>
<p><strong>(4.3.5) Bemerkung:</strong></p>
<ol type="I">
<li>Im wesentlichen gilt auch im Falle des zyklisch
selbstreproduzierenden Programms <img src="/img/cache/fe7fb103354181c4ccda624e5d41eb9b.gif" alt="\pi_0^{\text{zyk}}" valign="middle"/> Bemerkung
(4.2.9)II. f&uuml;r das unendlich reproduzierende Programm
<img src="/img/cache/0db27294a048f7c594b396ec7f277e30.gif" alt="\overset\infty\pi_0" valign="middle"/>. &Uuml;berhaupt haben unsere Beispielprogramme
f&uuml;r unendlich reproduzierende und zyklisch selbstreproduzierende
Programme keine Vereinfachung des
Selbstreproduktionsmechanismus von Programm <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/>
gebracht.</li>
<li>Satz (4.3.3) l&auml;&szlig;t sich nat&uuml;rlich analog f&uuml;r die
Programmiersprache SIMULA formulieren.</li>
</ol>
<p><strong>(4.3.6) Beispiel:</strong> Als Beispiel f&uuml;r ein zyklisch selbstreproduzierendes
SIMULA-Programm sei hier die SIMULA-Version
des Programms <img src="/img/cache/fe7fb103354181c4ccda624e5d41eb9b.gif" alt="\pi_0^{\text{zyk}}" valign="middle"/> angegeben.</p>
<pre class="source"><strong>begin</strong>
<strong>integer</strong> I,K;
<strong>procedure</strong> Z(J); <strong>integer</strong> J; OUTINT(J,1);
<strong>procedure</strong> A; OUTTEXT("BEGIN INTEGER I,K; PROCEDURE
   Z(J); INTEGER J; OUTINT(J,1); PROCEDURE A; OUTTE
   XT(""");
<strong>procedure</strong> B; OUTTEXT("PROCEDURE ");
<strong>procedure</strong> C; OUTTEXT("; OUTTEXT(""");
<strong>procedure</strong> AA; OUTTEXT(""");");
<strong>procedure</strong> AB; OUTTEXT("""");
<strong>procedure</strong> AC; OUTTEXT("A");
 
<strong>procedure</strong> BA; OUTTEXT("B");
<strong>procedure</strong> BB; OUTTEXT("C");
<strong>procedure</strong> BC; OUTTEXT("A;A;AB;AA;K:=");
<strong>procedure</strong> CA; OUTTEXT(";FOR I:=1 STEP 1 UNTIL 9 DO
   BEGIN B;IF K=0 THEN BEGIN BA;C;B END ELSE IF K=1
   THEN BEGIN BB;C;C;AB END ELSE IF K=2 THEN BEGIN
   AC;AC;C;AB;AA END ELSE IF K=3 THEN BEGIN AC;BA;C
   ;AB;AB END ELSE IF K=4 THEN BEGIN AC;BB;C;AC END
   ELSE IF K=5 THEN BEGIN BA;AC;C;BA END ELSE IF K=
   6 THEN BEGIN BA;BA;C;BB END ELSE IF K=7 THEN BEG
   IN BA;BB;C;BC END ELSE BEGIN BB;AC;C;CA END;");
A;A;AB;AA;
K:=1 ;
<strong>for</strong> I:=1 <strong>step</strong> 1 <strong>until</strong> 9 <strong>do</strong>
<strong>begin</strong> B;
     <strong>if</strong> K=0 <strong>then begin</strong> BA;C;B <strong>end</strong>
<strong>else if</strong> K=1 <strong>then begin</strong> BB;C;C;AB <strong>end</strong>
<strong>else if</strong> K=2 <strong>then begin</strong> AC;AC;C;AB;AA <strong>end</strong>
<strong>else if</strong> K=3 <strong>then begin</strong> AC;BA;C;AB;AB <strong>end</strong>
<strong>else if</strong> K=4 <strong>then begin</strong> AC;BB;C;AC <strong>end</strong>
<strong>else if</strong> K=5 <strong>then begin</strong> BA;AC;C;BA <strong>end</strong>
<strong>else if</strong> K=6 <strong>then begin</strong> BA;BA;C;BB <strong>end</strong>
<strong>else if</strong> K=7 <strong>then begin</strong> BA;BB;C;BC <strong>end</strong>
            <strong>else begin</strong> BB;AC;C;CA <strong>end</strong>;
AA;
K:=(K+1) <strong>mod</strong> 9;
end;
BC;Z((K+1) <strong>mod</strong> 9);CA
<strong>end</strong>;
</pre>
<p><strong>Verifikation</strong></p>
<p>Die Verifikation dieses SIMULA-Programms ist identisch mit
der des PASCAL-Programms <img src="/img/cache/fe7fb103354181c4ccda624e5d41eb9b.gif" alt="\pi_0^{\text{zyk}}" valign="middle"/>.</p>
 
<h4><a name="c431"></a>4.3.1. Implementierung des Programms <img src="/img/cache/5207187530e2a06035973be6353e8c95.gif" alt="\overset{k}\pi_0" valign="middle"/></h4>
<p>F&uuml; die Implementierung von <img src="/img/cache/5207187530e2a06035973be6353e8c95.gif" alt="\overset{k}\pi_0" valign="middle"/> gelten die gleichen
Bemerkungen wie in Abschnitt 4.2.1. zur Implementierung von Programm
<img src="/img/cache/0db27294a048f7c594b396ec7f277e30.gif" alt="\overset\infty\pi_0" valign="middle"/>. N&auml;heres ist aus Anhang A.8. ersichtlich.</p>
<h4><a name="c432"></a>4.3.2. Implementierung des Programms <img src="/img/cache/fe7fb103354181c4ccda624e5d41eb9b.gif" alt="\pi_0^{\text{zyk}}" valign="middle"/></h4>
<p>Auch f&uuml;r die Implementierung von <img src="/img/cache/fe7fb103354181c4ccda624e5d41eb9b.gif" alt="\pi_0^{\text{zyk}}" valign="middle"/> gelten die Bemerkungen
von Abschnitt 4.2.1. Die Textkonstante, die den Algorithmus
von <img src="/img/cache/fe7fb103354181c4ccda624e5d41eb9b.gif" alt="\pi_0^{\text{zyk}}" valign="middle"/> darstellt, mu&szlig; aus Gr&uuml;nden der Formatierung
auf noch mehr Prozeduren aufgespalten werden, als dies
etwa in <img src="/img/cache/0db27294a048f7c594b396ec7f277e30.gif" alt="\overset\infty\pi_0" valign="middle"/> der Fall ist. Alles Weitere siehe Anhang A.9.</p>
<h3><a name="c44"></a>4.4. Unter Wechsel der Programmiersprache sich zyklisch selbstreproduzierende Programme</h3>
<p>In Abschnitt 4.3. haben wir zyklisch selbstreproduzierende
Programme als spezielle unendlich reproduzierende Programme
kennengelernt. Unendlich reproduzierende Programme sind
ihrerseits reproduzierende Programme. Nach Definition (4.2.1)
gibt ein reproduzierendes Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> ein Programm <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> aus.
Dabei sind <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> und <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> Programme aus derselben
Programmiersprache S. Wir h&auml;tten reproduzierende Programme auch anders
definieren k&ouml;nnen, indem wir <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> aus einer Programmiersprache
<img src="/img/cache/78845f8d5ac0caf0ed98df25bd3caca8.gif" alt="S'\ne S" valign="middle"/> zugelassen h&auml;tten. Eine solche Definition w&auml;re
allgemeiner als Definition (4.2.1). Entsprechend allgemeiner
w&auml;ren dann auch die Definitionen f&uuml;r unendlich reproduzierende
und zyklisch selbstreproduzierende Programme ausgefallen.
Da&szlig; eine solche Verallgemeinerung durchaus sinnvoll
w&auml;re, soll das folgende Beispiel demonstrieren. Beispiel
(4.4.1) stellt ein Programm vor, das nicht nur ein Programm
in einer anderen Programmiersprache ausgibt, sondern sich
auch noch zyklisch selbstreproduziert.</p>
 
<p><strong>(4.4.1) Beispiel:</strong> Wir gehen aus von dem SIMULA-Programm <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/>
aus 3.2.6. und dem PASCAL-Programm <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> aus 3.3.2..
Beide Programme sind nahezu identisch, da sie praktisch
ihre gegenseitigen &Uuml;bersetzungen darstellen.
Aus beiden Programmen kombinieren wir jeweils ein
PASCAL-Programm <img src="/img/cache/f9e512694aac3d136918da0975151944.gif" alt="\pi_{\text{PAS}}" valign="middle"/> und ein SIMULA-Programm <img src="/img/cache/6bd78e374ca302371461b480aeb1452d.gif" alt="\pi_{\text{SIM}}" valign="middle"/> mit:</p>
<p><img src="/img/cache/3645c60595a2cd19de7ff4168f3bd988.gif" alt="
\pi_{\text{PAS}}\text{ gibt }\pi_{\text{SIM}}\text{ aus }\\
\pi_{\text{SIM}}\text{ gibt }\pi_{\text{PAS}}\text{ aus }\\
" valign="middle"/></p>
<p><img src="/img/cache/6bd78e374ca302371461b480aeb1452d.gif" alt="\pi_{\text{SIM}}" valign="middle"/> und <img src="/img/cache/f9e512694aac3d136918da0975151944.gif" alt="\pi_{\text{PAS}}" valign="middle"/> sind also zyklisch
selbstreproduzierende Programme mit Wechsel der Programmiersprachen.</p>
<pre class="source"><img src="/img/cache/f9e512694aac3d136918da0975151944.gif" alt="\pi_{\text{PAS}}" valign="middle"/> = 
<strong>program</strong> X(OUTPUT);
<strong>var</strong> T,F:<strong>boolean</strong>;
<strong>procedure</strong> A(Z:<strong>boolean</strong>);<strong>begin if</strong> Z
  <strong>then</strong> WRITE('BEGIN BOOLEAN T,F;')
  <strong>else</strong> WRITE('PROGRAM X(OUTPUT);VAR T,F:BOOLEAN;') <strong>end</strong>;
<strong>procedure</strong> B(Z:<strong>boolean</strong>);<strong>begin if</strong> Z
  <strong>then</strong> WRITE('PROCEDUEE ')
  <strong>else</strong> WRITE('PROCEDURE ') <strong>end</strong>;
<strong>procedure</strong> C(Z:<strong>boolean</strong>);<strong>begin if</strong> Z
  <strong>then</strong> WRITE('(Z);BOOLEAN Z;IF Z THEM OUTTEX("')
  <strong>else</strong> WRITE('(Z: BOOLEAN);BEGIN IF Z THEN WRITE(''') <strong>end</strong>;
<strong>procedure</strong> AA(Z:<strong>boolean</strong>);<strong>begin if</strong> Z
  <strong>then</strong> WRITE('") ELSE OUTTEXT("')
  <strong>else</strong> WRITE(''') ELSE WRITE(''') <strong>end</strong>;
<strong>procedure</strong> AB(Z;<strong>boolean</strong>);<strong>begin if</strong> Z
  <strong>then</strong> WRITE('");')
  <strong>else</strong> WRITE(''') END;') <strong>end</strong>;
<strong>procedure</strong> CB(Z:<strong>boolean</strong>);<strong>begin if</strong> Z
  <strong>then</strong> WRITE('"')
  <strong>else</strong> WRITE('''') <strong>end</strong>;
<strong>procedure</strong> BA(Z:<strong>boolean</strong>);<strong>begin if</strong> Z
  <strong>then</strong> WRITE('A')
  <strong>else</strong> WRITE('A') <strong>end</strong>;
 
<strong>procedure</strong> BB(Z:<strong>boolean</strong>);<strong>begin if</strong> Z
  <strong>then</strong> WRITE('B')
  <strong>else</strong> WRITE('B') <strong>end</strong>;
<strong>procedure</strong> BC(Z:<strong>boolean</strong>);<strong>begin if</strong> Z
  <strong>then</strong> WRITE('C')
  <strong>else</strong> WRITE('C') <strong>end</strong>;
<strong>procedure</strong> AC(Z:<strong>boolean</strong>);<strong>begin if</strong> Z
  <strong>then</strong> WRITE('T:=TRUE;F:=FALSE; <img src="/img/cache/678614555c8184bb905e8808b2692c69.gif" alt="\sout[+1]\otimes" valign="middle"/> END')
  <strong>else</strong> WRITE('BEGIN T:=TRUE;F:=FALSE; <img src="/img/cache/678614555c8184bb905e8808b2692c69.gif" alt="\sout[+1]\otimes" valign="middle"/> ; WRITELN END.') <strong>end</strong>;
<strong>begin</strong> T:=true;F:=false;
A(T);								 \
B(T);BA(T);      C(T); A(F);AA(T);       A(T);      AB(T);	  \
B(T);BB(T);      C(T); B(T);AA(T);       B(T);      AB(T);	   \
B(T);BC(T);      C(T); C(F);AA(T);       C(T);CB(T);AB(T);	    \
B(T);BA(T);BA(T);C(T);AA(F);AA(T);CB(T);AA(T);CB(T);AB(T);	     \
B(T);BA(T);BB(T);C(T);AB(F);AA(T);CB(T);AB(T);      AB(T);	      \
B(T);BC(T);BB(T);C(T);CB(F);AA(T);      CB(T);      AB(T);	      / <img src="/img/cache/678614555c8184bb905e8808b2692c69.gif" alt="\sout[+1]\otimes" valign="middle"/>
B(T);BB(T);BA(T);C(T);BA(T);AA(T);      BA(T);      AB(T);	     /
B(T);BB(T);BB(T);C(T);BB(T);AA(T);      BB(T);      AB(T);	    /
B(T);BB(T);BC(T);C(T);BC(T);AA(T);      BC(T);      AB(T);	   /
B(T);BA(T);BC(T);C(T);AC(F);AA(T);      AC(T);      AB(T);	  /
AC(T)								 /
;WRITELN
<strong>end</strong>.
</pre>
<p><img src="/img/cache/f9e512694aac3d136918da0975151944.gif" alt="\pi_{\text{PAS}}" valign="middle"/> gibt das SIMULA-Programm <img src="/img/cache/6bd78e374ca302371461b480aeb1452d.gif" alt="\pi_{\text{SIM}}" valign="middle"/> aus:</p>
<pre class="source"><img src="/img/cache/6bd78e374ca302371461b480aeb1452d.gif" alt="\pi_{\text{SIM}}" valign="middle"/> =
<strong>begin</strong>
<strong>boolean</strong> T,F;
<strong>procedure</strong> A(Z);<strong>boolean</strong> Z;<strong>if</strong> Z <strong>then</strong>
   OUTTEXT("PROGRAM X(OUTPUT);VAR T,F:BOOLEAN;")
   <strong>else</strong> OUTTEXT("BEGIN BOOLEAN T,F;");
<strong>procedure</strong> B(Z);<strong>boolean</strong> Z;<strong>if</strong> Z
   <strong>then</strong> OUTTEXT("PROCEDURE ")
   <strong>else</strong> OUTTEXT("PROCEDURE ");
<strong>procedure</strong> C(Z);<strong>boolean</strong> Z;<strong>if</strong> Z
   <strong>then</strong> OUTTEXT("(Z:BO0LEAN);BEGIN IF Z THEN WRITE('")
 
   <strong>else</strong> OUTTEXT("(Z);BOOLEAN Z; IF Z THEN OUTTEXT(""");
<strong>procedure</strong> AA(Z);<strong>boolean</strong> Z;<strong>if</strong> Z
   <strong>then</strong> OUTTEXT("') ELSE WRITE('")
   <strong>else</strong> OUTTEXT(""") ELSE OOTTEXT(""");
<strong>procedure</strong> AB(Z);<strong>boolean</strong> Z;<strong>if</strong>
   <strong>then</strong> OUTTEXT("') END;")
   <strong>else</strong> OUTTEXT(""");");
<strong>procedure</strong> CB(Z);<strong>boolean</strong> Z;<strong>if</strong> Z
   <strong>then</strong> OUTTEXT("'")
   <strong>else</strong> OUTTEXT("""");
<strong>procedure</strong> BA(Z);<strong>boolean</strong> Z;<strong>if</strong> Z
   <strong>then</strong> OUTTEXT("A")
   <strong>else</strong> OOTTEXT("A");
<strong>procedure</strong> BB(Z);<strong>boolean</strong> Z;<strong>if</strong> Z
   <strong>then</strong> OUTTEXT("B")
   <strong>else</strong> OUTTEXT("B");
<strong>procedure</strong> BC(Z);<strong>boolean</strong> Z;<strong>if</strong> Z
   <strong>then</strong> OUTTEXT("C")
   <strong>else</strong> OUTTEXT("C");
<strong>procedure</strong> AC(Z);<strong>boolean</strong> Z;<strong>if</strong> Z
   <strong>then</strong> OUTTEXT("BEGIN T:=TBUE;F:=FALSE; <img src="/img/cache/678614555c8184bb905e8808b2692c69.gif" alt="\sout[+1]\otimes" valign="middle"/> ;WRITELN END.")
   <strong>else</strong> OUTTEXT("T:=TRUE;F:=FALSE; <img src="/img/cache/678614555c8184bb905e8808b2692c69.gif" alt="\sout[+1]\otimes" valign="middle"/> END");
T:=true;F:=false; <img src="/img/cache/678614555c8184bb905e8808b2692c69.gif" alt="\sout[+1]\otimes" valign="middle"/>
<strong>end</strong>
</pre>
<p><strong>Verifikation</strong></p>
<p><img src="/img/cache/f9e512694aac3d136918da0975151944.gif" alt="\pi_{\text{PAS}}" valign="middle"/> und <img src="/img/cache/6bd78e374ca302371461b480aeb1452d.gif" alt="\pi_{\text{SIM}}" valign="middle"/> enthalten jeweils alle Teilstrings -
sowohl der Zerlegung von <img src="/img/cache/f9e512694aac3d136918da0975151944.gif" alt="\pi_{\text{PAS}}" valign="middle"/> als auch der Zerlegung von
<img src="/img/cache/6bd78e374ca302371461b480aeb1452d.gif" alt="\pi_{\text{SIM}}" valign="middle"/> - in den Prozeduren A bis AC. Da sich die Teilstrings
der Zerlegungen von <img src="/img/cache/f9e512694aac3d136918da0975151944.gif" alt="\pi_{\text{PAS}}" valign="middle"/> und <img src="/img/cache/6bd78e374ca302371461b480aeb1452d.gif" alt="\pi_{\text{SIM}}" valign="middle"/> eins zu eins
entsprechen, k&ouml;nnen die Teilstrings alternativ in den
Prozeduren abgelegt werden. Jede Prozedur von <img src="/img/cache/f9e512694aac3d136918da0975151944.gif" alt="\pi_{\text{PAS}}" valign="middle"/> hat dann
den allgemeinen Aufbau:</p>
<pre class="source"><strong>procedure</strong> &lt;name> (Z:<strong>boolean</strong>);
<strong>begin if</strong> Z <strong>then</strong> WRITE('&lt;Teilstring s aus <img src="/img/cache/6bd78e374ca302371461b480aeb1452d.gif" alt="\pi_{\text{SIM}}" valign="middle"/>>')
           <strong>else</strong> WRITE('&lt;dem Teilstring s entsprechender Teilstring s' aus <img src="/img/cache/f9e512694aac3d136918da0975151944.gif" alt="\pi_{\text{PAS}}" valign="middle"/>>')
<strong>end</strong>;
</pre>
 
<p>Einige Teilstrings von <img src="/img/cache/f9e512694aac3d136918da0975151944.gif" alt="\pi_{\text{PAS}}" valign="middle"/> sind gleich ihren Entsprechungen
¦n <img src="/img/cache/6bd78e374ca302371461b480aeb1452d.gif" alt="\pi_{\text{SIM}}" valign="middle"/>. Die Prozeduren, die diese Teilstrings bearbeiten,
enthalten nat&uuml;rlich Redundanz. Beispiel:</p>
<pre class="source"><strong>procedure</strong> BA(Z:<strong>boolean</strong>);
<strong>begin if</strong> Z <strong>then</strong> WRITE('A') <strong>else</strong> WRITE('A') <strong>end</strong>;
</pre>
<p>Die Redundanz, wird aber zugunsten eines einheitlichen
Prozedurschemas in Kauf genommen. Die Auswahl, welche Alternative
ausgegeben werden soll, wird beim Aufruf der Prozeduren durch
ihren aktuellen Parameter getroffen. Das PASCAL-Programm enth&auml;lt
die SIMULA-Teilstrings <strong>immer</strong> im <strong>then</strong>-Zweig der Prozeduren
und die PASCAL-Teilstrings <strong>immer</strong> im <strong>else</strong>-Zweig. Beim
SIMULA-Programm sind die Verh&auml;ltnisse genau umgekehrt.
Dadurch wird erreicht, da&szlig; eine Prozedur, die im PASCAL-Programm mit
<strong>true</strong> aufgerufen wird, auch im SIMULA-Programm mit
<strong>true</strong> aufgerufen werden kann. Daraus folgt, da&szlig; die Anweisungsteile
von <img src="/img/cache/6bd78e374ca302371461b480aeb1452d.gif" alt="\pi_{\text{SIM}}" valign="middle"/> und <img src="/img/cache/f9e512694aac3d136918da0975151944.gif" alt="\pi_{\text{PAS}}" valign="middle"/> im wesentlichen identisch sind. Aus
dem bisher Gesagten und der Tatsache, da&szlig; <img src="/img/cache/6bd78e374ca302371461b480aeb1452d.gif" alt="\pi_{\text{SIM}}" valign="middle"/> und <img src="/img/cache/f9e512694aac3d136918da0975151944.gif" alt="\pi_{\text{PAS}}" valign="middle"/> bis
auf die alternativen Prozeduren in <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle"/> und <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> identisch sind,
folgt: <img src="/img/cache/f9e512694aac3d136918da0975151944.gif" alt="\pi_{\text{PAS}}" valign="middle"/> reproduziert <img src="/img/cache/6bd78e374ca302371461b480aeb1452d.gif" alt="\pi_{\text{SIM}}" valign="middle"/> und umgekehrt.</p>
<h3><a name="c45"></a>4.5. k-fach selbstreproduzierende Programme</h3>
<p>In Abschnitt 4.2. haben wir Reproduktion als Abschw&auml;chung
der Selbstreproduktion kennengelernt. Wir wollen nun die
k-fache Selbstreproduktion von Programmen als Versch&auml;rfung
der einfachen Selbstreproduktion einf&uuml;hren:</p>
<p><strong>(4.5.1) Definition:</strong> Sei k>1. Sei <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> aus S. (syntakt. korrekt).</p>
<ol type="a">
<li><ol type="i">
<li>Weist <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> keine Eingabe auf, so hei&szlig;t <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> k-fach
selbstreproduzierend, falls <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> seinen Programmtext
in S k-mal ausgibt.</li>
<li>Weist <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> Eingabe auf, so hei&szlig;t <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> k-fach
selbstreproduzierend, falls <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> bei <strong>jeder</strong> zul&auml;ssigen
Eingabe seinen Programmtext in S k-mal ausgibt.</li>
</ol></li>
<li><img src="/img/cache/31826e11061b9285a63ab7212e99afb7.gif" alt="\text{SR^k(S)}" valign="middle"/> bezeichnet die Menge aller k-fach
selbstreproduzierenden Programme aus S.</li>
</ol>
 
<div align="center"><img src="/img/cache/8d6ff6beb00c94e69b1d2f74387c2b60.gif" alt="
\begin{array}{cccccc}
	&amp;	&amp;	&amp;	&amp;		&amp;	&amp; \vdots\\
	&amp;	&amp;	&amp;	&amp;		&amp; \pi	&amp; \vdots\\
	&amp;	&amp;	&amp;	&amp;\nearrow	&amp; \vdots&amp; \vdots\\
	&amp;	&amp;	&amp;\pi	&amp;		&amp;\text{k-mal}&amp; \vdots\\
	&amp;	&amp;	&amp;\vdots&amp;\searrow	&amp; \vdots&amp; \vdots\\
	&amp;\nearrow&amp;	&amp;\vdots	&amp;		&amp; \pi	&amp; \vdots\\
\pi	&amp;	&amp;	&amp;\text{k-mal}	&amp;	&amp;\vdots &amp; \vdots\\
	&amp;\searrow&amp;	&amp;\vdots	&amp;		&amp; \vdots&amp; \vdots\\
	&amp;	&amp;	&amp;\vdots&amp;		&amp; \pi	&amp; \vdots\\
	&amp;	&amp;	&amp;\vdots	&amp;\nearrow	&amp; \vdots&amp; \vdots\\
	&amp;	&amp;	&amp;\pi	&amp;		&amp;\text{k-mal}&amp; \vdots\\
	&amp;	&amp;	&amp;	&amp;\searrow	&amp; \vdots&amp; \vdots\\
	&amp;	&amp;	&amp;	&amp;		&amp; \pi	&amp; \vdots\\
\end{array}
" valign="middle"/></div>
<p>Abb.: 4.5.A</p>
<p>Die Existenz k-fach selbstreproduzierender Programme folgt
bereits aus Korollar (2.8.9).</p>
<p><strong>(4.5.2) Satz:</strong> Die Programmiersprache PASCAL enth&auml;lt f&uuml;r
jedes k>1 ein k-fach selbstreproduzierendes Programm
<img src="/img/cache/ffe6b5cce0427aeca812533ebe028417.gif" alt="\pi(k)" valign="middle"/>.</p>
<p>Wir geben ein Beispiel eines fUr jedes k>1 k-fach selbstreproduzierenden
Programms an. Dieses Beispiel beweist
Satz (4.5.2).</p>
<p><strong>(4.5.3) Beispiel:</strong></p>
<pre class="source"><img src="/img/cache/ffe6b5cce0427aeca812533ebe028417.gif" alt="\pi(k)" valign="middle"/> =
<strong>program</strong> PIK(OUTPUT);
<strong>var</strong> I:<strong>integer</strong>;
<strong>procedure</strong> AA;<strong>begin</strong> WRITE('PROGRAM PIK(OUTPUT);VAR I:INTEGER
    ;PROCEDURE AA;BEGIN WRITE(''') <strong>end</strong>;
<strong>procedure</strong> C;<strong>begin</strong> WRITE('PROCEDURE ') <strong>end</strong>;
<strong>procedure</strong> A;<strong>begin</strong> WRITE(';BEGIN WRITE(''') <strong>end</strong>;
<strong>procedure</strong> B;<strong>begin</strong> WRITE(''') END;') <strong>end</strong>;
<strong>procedure</strong> AC;<strong>begin</strong> WRITE('''') <strong>end</strong>;
<strong>procedure</strong> BA;<strong>begin</strong> WRITE('A') <strong>end</strong>;
 
<strong>procedure</strong> BB;<strong>begin</strong> WRITE('B') <strong>end</strong>;
<strong>procedure</strong> BC;<strong>begin</strong> WRITE('C') <strong>end</strong>;
<strong>procedure</strong> AB;<strong>begin</strong> WRITE('BEGIN FOR I:=1 TO 5 DO BEGIN AA;A
   A;AC;B;C;BC;A;C;B;C;BA;A;A;AC;B;C;BB;A;AC;B;B;C;BA;BC;A;
   AC;AC;B;C;BB;BA;A;BA;B;C;BB;BB;A;BB;B;C;BB;BC;A;BC;B;C;B
   A;BB;A;AB;B;AB;WRITELN END END.') <strong>end</strong>;
<strong>begin</strong>
<strong>for</strong> I:=1 <strong>to</strong> 5 <strong>do</strong>
<strong>begin</strong>
AA;             AA;AC;B;
   C;BC;   A;    C;   B;
   C;BA;   A;    A;AC;B;
   C;BB;   A;AC; B;   B;
   C;BA;BC;A;AC;AC;   B;
   C;BB;BA;A;   BA;   B;
   C;BB;BB;A;   BB;   B;
   C;BB;BC;A;   BC;   B;
   C;BA;BB;A;   AB;   B;AB;WRITELN
<strong>end</strong>
<strong>end</strong>.
</pre>
<p><strong>Verifikation</strong></p>
<p>Die Verifikation von <img src="/img/cache/ffe6b5cce0427aeca812533ebe028417.gif" alt="\pi(k)" valign="middle"/> ergibt sich direkt aus der Verifikation
von Programm <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> aus 3.3.2.. Der Unterschied zwischen
<img src="/img/cache/ffe6b5cce0427aeca812533ebe028417.gif" alt="\pi(k)" valign="middle"/> und <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> besteht im wesentlichen nur in der <strong>for</strong>-Schleife</p>
<pre class="source">
	<strong>for</strong> I:=1 <strong>to</strong> k <strong>do</strong>
	<strong>begin</strong> ... <strong>end</strong>,
</pre>
<p>in die der Ausgabealgorithmus eingebettet ist. Der Ausgabealgorithmus
von <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> wird also in <img src="/img/cache/ffe6b5cce0427aeca812533ebe028417.gif" alt="\pi(k)" valign="middle"/> gerade k-mal ausgef&uuml;hrt.
Dadurch wird <img src="/img/cache/ffe6b5cce0427aeca812533ebe028417.gif" alt="\pi(k)" valign="middle"/> zum k-fach reproduzierenden Programm.</p>
 
<p><strong>(4.5.4) Bemerkung</strong></p>
<ol type="I">
<li>Jedes k-fach selbstreproduzierende Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> ist
nat&uuml;rlich selbstreproduzierend, aber nicht streng
selbstreproduzierend. Au&szlig;erdem ist ein k-fach
selbstreproduzierendes Programm zyklisch selbstreproduzierend
mit der Zyklusl&auml;nge 1.</li>
<li>Satz (4.5.2) gilt in analoger Formulierung f&uuml;r die
Programmiersprache SIMULA. Zum Beweis &uuml;bersetzt man
das Programm <img src="/img/cache/ffe6b5cce0427aeca812533ebe028417.gif" alt="\pi(k)" valign="middle"/> in ein entsprechendes SIMULA-Programm.
Das geht ohne Schwierigkeiten, da <img src="/img/cache/ffe6b5cce0427aeca812533ebe028417.gif" alt="\pi(k)" valign="middle"/> keine
pascalspezifischen Konstruktionen enth&auml;lt.</li>
</ol>
<h4><a name="c451"></a>4.5.1. Implementierung von <img src="/img/cache/ffe6b5cce0427aeca812533ebe028417.gif" alt="\pi(k)" valign="middle"/></h4>
<p>Zur Implementierung von <img src="/img/cache/ffe6b5cce0427aeca812533ebe028417.gif" alt="\pi(k)" valign="middle"/> sind die gleichen Bemerkungen
wie in Abschnitt 3.3.3. zu machen. Anhang A.10. zeigt die
Implementierung von <img src="/img/cache/ffe6b5cce0427aeca812533ebe028417.gif" alt="\pi(k)" valign="middle"/> mit k=5.</p>
<h3><a name="c46"></a>4.6. Reproduktionshierarchie bei Programmen</h3>
<p>In den vorangegangenen Abschnitten haben wir f&uuml;r eine
beliebige Programmiersprache S die Mengen</p>
<pre><img src="/img/cache/d91739e020c97ff716d004feb3c88829.gif" alt="\text{R(S), U(S), Z(S) und SR^kS}" valign="middle"/></pre>
<p>definiert. F&uuml;r diese Mengen gilt</p>
<pre><img src="/img/cache/929e29c623844fee0669416042e0a0a0.gif" alt="\text{(1)   SR^k(S)\sub SR(S) \sub Z(S) \sub U(S) \sub R(S)" valign="middle"/>,</pre>
<p>wobei SR(S) die Menge der selbstreproduzierende Programme
aus S ist. Im allgemeinen werden die Inklusionen echt sein,
wie wir am Beispiel der Programmiersprache PASCAL gesehen
haben. Es gilt n&auml;mlich</p>
<dl>
<dt><img src="/img/cache/ce3affd30a6d726d9842701c41fcff0e.gif" alt="\pi_{\text{PAS(k)}}" valign="middle"/></dt><dd>aus Abschnitt 4.2. ist reproduzierend, aber nicht
unendlich reproduzierend.</dd>
<dt><img src="/img/cache/0db27294a048f7c594b396ec7f277e30.gif" alt="\overset\infty\pi_0" valign="middle"/></dt><dd>aus Abschnitt 4.2. ist unendlich reproduzierend,
aber nicht zyklisch selbstreproduzierend.</dd>
<dt><img src="/img/cache/fe7fb103354181c4ccda624e5d41eb9b.gif" alt="\pi_0^{\text{zyk}}" valign="middle"/></dt><dd>aus Abschnitt 4.3. ist zyklisch selbstreproduzierend,
aber nicht selbstreproduzierend.</dd>
 
<dt><img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/></dt><dd>aus Abschnitt 3.3.2. ist selbstreproduzierend,
aber nicht k-fach selbstreproduzierend f&uuml;r ein
k > 1.</dd>
</dl>
<p>Daraus folgt:
<img src="/img/cache/eca028b52a5cfa6b4673962fdb6aed99.gif" alt="\text{SR^k(PASCAL)\overset\sub{\rotate{-90}\dagger}SR(PASCAL)\overset\sub{\rotate{-90}\dagger}Z(PASCAL)\overset\sub{\rotate{-90}\dagger}U(PASCAL)\overset\sub{\rotate{-90}\dagger}R(PASCAL)}" valign="middle"/>
Abbildung 4.6.A erl&auml;utert dieses Ergebnis graphisch.</p>
<div align="center">
<img src="img/mjk00/abb46a.gif" alt="Abb.: 4.6.A"/>
<p>Abb.: 4.6.A</p>
</div>
<p><strong>(4.6.1) Definition:</strong> F&uuml;r jede Programmiersprache S hei&szlig;t die
Inklusionenreihe (1) <strong>Reproduktionshierarchie von S</strong>.</p>
 
<h2><a name="c5"></a>5. Selbstreproduzierende Programme mit Zusatzegeinschaften</h2>
<h3><a name="c51"></a>5.1. Einleitung</h3>
<p>In Kapitel 3 haben wir einige Beispiele f&uuml;r selbstreproduzierende
Programme kennengelernt. Diesen Beispielprogrammen
ist gemeinsam, da&szlig; sie au&szlig;er der Ausgabe ihres eigenen Textes
keinerlei Funktion ausf&uuml;hren. Eine interessante Fragestellung
ist aber etwa:</p>
<ol type="1" start="1">
<li>"Gibt es in der Programmiersprache S Programme, die
mehr leisten als nur Selbstreproduktion?"
<p>oder konkreter</p>
<p>Gibt es in S selbstreproduzierende Programme, die
zus&auml;tzlich einen Suchalgorithmus realisieren, oder die
Primzahlzerlegung ausf&uuml;hren, oder ein Datenbanksystem
verwalten, oder ... ?"</p></li>
</ol>
<p>Angenommen, Frage (1) lie&szlig;e sich f&uuml;r die Programmiersprache
S positiv beantworten, so k&ouml;nnte man etwas sch&auml;rfer fragen:</p>
<ol type="1" start="2">
<li>"Existiert zu jedem Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> aus S ein selbstreproduzierendes
Programm <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> aus S, das die gleiche Funktion
realisiert wie <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/>?"</li>
</ol>
<p>Ist die letzte Frage f&uuml;r die Programmiersprache S zu bejahen,
so ist intuitiv klar, da&szlig; ein selbstreproduzierendes Programm
<img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/>, das eine gegebene Funktion realisiert, umfangreicher und
komplizierter ist als ein nicht selbstreproduzierendes Programm
<img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/>, das die gleiche Funktion realisiert. Daher ist es
vielleicht einfacher, auf der Suche nach <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> zun&auml;chst ein nicht
selbstreproduzierendes Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> zu entwickeln, und dieses
anschlie&szlig;end in eine selbstreproduzierende Version <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> zu
transformieren. In diesem Zusammenhang dr&auml;ngt sich die folgende
Frage auf:</p>
 
<ol type="1" start="3">
<li>"Gibt es f&uuml;r eine gegebene Programmiersprache S einen
<strong>Algorithmus</strong>, der zu jedem Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> aus S ein
selbstreproduzierendes Programm <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> aus S liefert, das die
gleiche Funktion realisiert wie <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/>?"</li>
</ol>
<p>Will man die Beantwortung der Fragen (1) bis (3) in Angriff
nehmen, so mu&szlig; zun&auml;chst gekl&auml;rt werden, was unter der "von
einem Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> aus S realisierten Funktion" zu verstehen
ist. Wegen der Vielfalt an realen Programmiersprachen, deren
unterschiedlichen Datentypen und der unterschiedlichen
Interpretation auf verschiedenen Rechenanlagen d&uuml;rfte es
unm&ouml;glich sein, den obigen Begriff formal exakt und zudem
noch allgemeing&uuml;ltig zu definieren. F&uuml;r unsere Zwecke sollen
jedoch die folgenden &Uuml;berlegungen und Definitionen
gen&uuml;gen.</p>
<p>Auf realen Rechenanlagen verarbeiten Programme aus konkreten
Programmiersprachen in der Regel Daten, die auf mehreren
<strong>Eingabedateien</strong> stehen, und geben Ergebnisse auf mehrere
<strong>Ausgabedateien</strong> aus. Auf jeder dieser Dateien stehen
Zeichenketten, die als ganze Zahlen, reelle Zahlen, Texte
u.s.w. von einem Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> aus der Sprache S interpretiert
werden k&ouml;nnen. Diese Interpretation kann nat&uuml;rlich nur dann
erfolgen, wenn die Zeichen, die auf den Dateien stehen, aus
dem f&uuml;r Daten f&uuml;r Programme aus S zul&auml;ssigen endlichen
Alphabet <img src="/img/cache/fc1f169d5c31dc01ab77b36e716d2021.gif" alt="A_S" valign="middle"/> stammen. Der Inhalt einer Datei kann als Wort aus
<img src="/img/cache/2c9baa5854ef6f40f9cc9500ab973e07.gif" alt="A_S^*" valign="middle"/> aufgefa&szlig;t werden. Dieser Sichtweise entspricht die
folgende Definition, die zudem den Fall zul&auml;&szlig;t, da&szlig; w&auml;hrend
der Laufzeit von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> einige Dateien sowohl als Eingabe- als
auch als Ausgabedatei benutzt werden.</p>
<p><strong>(5.1.1) Definition:</strong> Sei <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> ein Programm aus S mit <img src="/img/cache/cb577de83add94a9cbff0500a42b5ee3.gif" alt="p\ge0" valign="middle"/>
Einund Ausgabedateien, von denen <img src="/img/cache/67b836b402ca3655e20ea252130466c9.gif" alt="q,\ 0\le q \le p" valign="middle"/>, Dateien
als Ausgabedateien benutzt werden. Die von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> realisierte
Funktion <img src="/img/cache/a60c99e3150ea63217295a3e9d817eec.gif" alt="f_\pi" valign="middle"/> ist eine partielle Funktion von
<img src="/img/cache/f459e4a3025e4682628b3099e4180e28.gif" alt="(A_S^p)^*" valign="middle"/> nach <img src="/img/cache/392dff3cbee3d611c3872f2aa49262a5.gif" alt="(A_S^q)^*" valign="middle"/>, die jeder Belegung der p Ein- und
 
Ausgabedateien mit Worten aus <img src="/img/cache/d8b0245a79efc060cfbc93731a89f702.gif" alt="(A_S^*)" valign="middle"/> genau eine Belegung
der q Ausgabedateien mit Worten aus <img src="/img/cache/d8b0245a79efc060cfbc93731a89f702.gif" alt="(A_S^*)" valign="middle"/> zuordnet.</p>
<p><strong>(5.1.2) Beispiel:</strong> Gegeben sei das PASCAL-Programm</p>
<pre class="source"><img src="/img/cache/d4c98d75e25f5d28461f1da221eb7a95.gif" alt="\pi_0" valign="middle"/> =
<strong>program</strong> X(INPUT,OUTPUT);
<strong>var</strong> I : <strong>integer</strong>;
    Y : <strong>real</strong>;
<strong>begin</strong>
<strong>for</strong> I:=1 <strong>to</strong> 10 <strong>do</strong>
<strong>begin</strong> READ(Y); WRITELN(SQRT(Y)) <strong>end</strong>
<strong>end</strong>.
</pre>
<p><img src="/img/cache/d4c98d75e25f5d28461f1da221eb7a95.gif" alt="\pi_0" valign="middle"/> liest also 10 reelle Zahlen aus der Eingabedatei
INPUT ein und gibt deren Quadratwurzeln auf die Ausgabedatei
OUTPUT aus. Sei <img src="/img/cache/a5b2821c9bf2ae2f3e4fd35cd58d9852.gif" alt="A_{\text{PAS}}" valign="middle"/> die Menge aller Zeichen,
die ein PASCAL-Programm verarbeiten kann.</p>
<p>Dann liefert Definition (5.1.1):</p>
<p><img src="/img/cache/3b2f0f7fe2850abdd1c6a2528324086c.gif" alt="
\begin{eqnarray}
\pi_0\text{ realisiert die Funktion }f_{\pi_0} &amp;:&amp; A_{\text{PAS}}^* \mapsto A_{\text{PAS}}^*\\
						&amp;&amp; x \mapsto f_{\pi_0}(x),\ x \in A_{\text{PAS}}^*
\end{eqnarray}
" valign="middle"/></p>
<p>L&auml;&szlig;t sich der Anfang von x nicht als Folge von 10
reellen Zahlen interpretieren, so ist <img src="/img/cache/2e511c7048ef05ae10f7eab30486ce9b.gif" alt="f_{\pi_0}(x)" valign="middle"/> undefiniert.
Andernfalls ist <img src="/img/cache/2e511c7048ef05ae10f7eab30486ce9b.gif" alt="f_{\pi_0}(x)" valign="middle"/> ein Wort aus <img src="/img/cache/2977aafc7f8814d8d1cbf7bc1491af1f.gif" alt="A_{\text{PAS}}^*" valign="middle"/>,
dessen Anfang sich als Folge von ebenfalls 10 reellen
Zahlen interpretieren l&auml;&szlig;t. Diese Folge ist
gleich der Folge der Quadratwurzeln der reellen Zahlen
der Eingabefolge.</p>
<p>Eine exakte Beschreibung von <img src="/img/cache/bb75c524d9e36209b1c39b88c040606c.gif" alt="f_{\pi_0}" valign="middle"/> w&uuml;rde die explizite
Einf&uuml;hrung von Konvertierungsfunktionen von <img src="/img/cache/2369a2488f59aa39a3fca53e0eff9f88.gif" alt="\mathbb{R}" valign="middle"/> nach
<img src="/img/cache/2977aafc7f8814d8d1cbf7bc1491af1f.gif" alt="A_{\text{PAS}}^*" valign="middle"/> und von <img src="/img/cache/2977aafc7f8814d8d1cbf7bc1491af1f.gif" alt="A_{\text{PAS}}^*" valign="middle"/> nach <img src="/img/cache/2369a2488f59aa39a3fca53e0eff9f88.gif" alt="\mathbb{R}" valign="middle"/> voraussetzen.</p>
<p><strong>(5.1.3) Bemerkung:</strong></p>
<ol type="I">
<li>Definition (5.1.1) ist nat&uuml;rlich nicht formal exakt,
sondern eher als "praxisnah" zu bezeichnen.</li>
<li>Definition (5.1.1) entspricht im wesentlichen der Definition
der von PL(A)-Programmen realisierten Funktion
in (2.4.1). Im Falle p und/oder q gleich 0
 
ist wie unter (2.4.2) zu verfahren.</li>
</ol>
<p>Aus Definition (5.1.1) folgt, da&szlig; ein selbstreproduzierendes
Programm <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> aus S, das ohne zus&auml;tzliche Eingabe die
"gleiche" Funktion realisiert wie ein anderes, nicht selbstreproduzierendes
Programm <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> aus S, nat&uuml;rlich eine ganz andere
Funktion realisiert als <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/>, da die Ausgaben von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> und
<img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> verschieden sind. Um diesen verwirrenden Sprachgebrauch
zu umgehen, geben wir Definition (5.1.4) an. Zuvor sei jedoch
bemerkt, da&szlig; man jede Funktion <img src="/img/cache/e72c1c1144a632c007839b7a8fca652c.gif" alt="F\ :\ M^n \mapsto M^m,\ m,n\in\mathbb{N}_0" valign="middle"/>,
als m-Tupel <img src="/img/cache/c031e5ec61637174fd1e80efec6e3810.gif" alt="F = (F_1,\dots,F_m)" valign="middle"/> von Funktionen <img src="/img/cache/2ba7110ce709b1a4add17514e94692ef.gif" alt="F_i\ :\ M^n \mapsto M" valign="middle"/>,
i=1,...,m, auffassen kann. Dabei ist M eine beliebige Menge.
Es gilt: <img src="/img/cache/57768b51c20b635dfc3fb1146ee324ad.gif" alt="F(x) = (F_1(x),\dots,F_m(x))" valign="middle"/> f&uuml;r alle <img src="/img/cache/d9da4899184137240135b81939e25f80.gif" alt="x\in M^n" valign="middle"/>.</p>
<p><strong>(5.1.4) Definition:</strong> Sei <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> ein Programm aus S. Ein Programm
<img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> aus S hei&szlig;t <strong>selbstreproduzierende Version von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/></strong>,
falls f&uuml;r die von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> und <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> realisierten Funktionen
<img src="/img/cache/d17d1786eaf7a413faaf45bea84a023c.gif" alt="f_\pi\ :\ (A^*_S)^{p_1} \mapsto (A^*_S)^{q_1}" valign="middle"/> und <img src="/img/cache/8c0036c83a52f2a8681da9ffa487111f.gif" alt="f_{\tilde\pi}\ :\ (A^*_S)^{p_2} \mapsto (A^*_S)^{q_2}" valign="middle"/>
(i) oder (ii) gilt</p>
<ol type="i">
<li><img src="/img/cache/0023c250d7374bd8d6cec3b306e3c490.gif" alt="p_1 = p_2" valign="middle"/> und <img src="/img/cache/267aaab8d29888cb1c5e457ed7c0303b.gif" alt="q_1 = q_2" valign="middle"/> und <img src="/img/cache/297f1fa5c65487468338851aa8b5b0aa.gif" alt="\exist" valign="middle"/> genau ein <img src="/img/cache/633af4ec6f5c0102c4a2ef052ff784b5.gif" alt="j\in\{1,\dots,q_2\}" valign="middle"/> mit
<p><img src="/img/cache/e7975660d045c49365fbc0674633bf6f.gif" alt="(f_{\tilde\pi})_i(\overline{x})=(f_{\pi})_i(\overline{x})\ \ \ \text{f\ddot{u}r }i \ne j" valign="middle"/></p>
<p><img src="/img/cache/898e6080624fee746afb6e17ed838cbc.gif" alt="(f_{\tilde\pi})_j(\overline{x})=(f_{\pi})_j(\overline{x})\circ\alpha\circ\tilde\pi\circ\beta" valign="middle"/><sup><a href="#p098_1" name="b098_1">1)</a></sup></p>
<p>wobei <img src="/img/cache/5fa9b0129b64f01e8109d5cecfacb4bb.gif" alt="\overline{x}\in(A^*_S)^{p_1},\ \alpha,\beta\in A^*_S" valign="middle"/></p></li>
<li><img src="/img/cache/0483dc911bf42672bf2984004dc9564c.gif" alt="p_2 = p_1" valign="middle"/> und <img src="/img/cache/1e8bafdc52c8467d1c3b554e28c4d5ab.gif" alt="q_2 = q_1+1" valign="middle"/> und
<p><img src="/img/cache/7106e28be4be695ccfd1ebda64d3c1ef.gif" alt="(f_{\tilde\pi})_i(\overline{x}) = (f_\pi)_i(\overline{x})\ \ \ \text{f\ddot{u}r }i\in\{1,\dots,q_1\}\\
		(f_{\tilde\pi})_{q_2}(\overline{x}) = \alpha\circ\tilde\pi\circ\beta\text{, wobei }\overline{x}\in(A^*_S)^{p_1},\ \alpha,\beta\in A^*_S" valign="middle"/></p></li>
</ol>
<p>Definition (5.1.4) stellt sicher, da&szlig; <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> unabh&auml;ngig von der
Eingabe seinen eigenen Text ausgibt. <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> h&auml;ngt seinen Text
entweder an ein Ausgabewort, das auch <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> ausgibt (Fall(i)),
oder <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> gibt seinen Text als zus&auml;tzliches Wort aus (Fall(ii)).</p>
 
<p><strong>(5.1.5) Bemerkung:</strong> I.a. ist die selbstreproduzierende Version
<img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> eines Programms <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> aus S nicht eindeutig.</p>
<p>Mit Hilfe von Definition (5.1.4) sind wir in der Lage, die
Fragestellungen (2) und (3) exakter zu formulieren:</p>
<ol type="1" start="2">
<li>"Existiert zu jedem Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> aus einer gegebenen
Programmiersprache S eine selbstreproduzierende Version
von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/>?"</li>
<li>"Gibt es f&uuml;r eine gegebene Programmiersprache S einen
Algorithmus, der f&uuml;r jedes Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> aus S eine
selbstreproduzierende Version <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> liefert?"</li>
</ol>
<p>Wir werden im folgenden die Fragen (1) bis (3) f&uuml;r die
Programmiersprachen SIMULA und PASCAL explizit beantworten.</p>
<h3><a name="c52"></a>5.2. Selbstreproduktionssatz f&uuml;r die Programmiersprache PASCAL</h3>
<p>Frage (1) aus 5.1. l&auml;&szlig;t sich f&uuml;r die Programmiersprache
PASCAL durch das folgende Beispiel beantworten.</p>
<p><strong>(5.2.1) Beispiel:</strong> Wir geben eine selbstreproduzierende
Version <img src="/img/cache/58d8d2e22dffc2d4e621ca48134450f5.gif" alt="\tilde\pi_0" valign="middle"/> zu dem Programm <img src="/img/cache/d4c98d75e25f5d28461f1da221eb7a95.gif" alt="\pi_0" valign="middle"/> aus Beispiel (5.1.2) an.
Wir gehen dabei aus von unserem k&uuml;rzesten PASCAL-Programm
<img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> aus Abschnitt 3.3.2. und versuchen,
<img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> und <img src="/img/cache/d4c98d75e25f5d28461f1da221eb7a95.gif" alt="\pi_0" valign="middle"/> zu einer selbstreproduzierenden Version <img src="/img/cache/58d8d2e22dffc2d4e621ca48134450f5.gif" alt="\tilde\pi_0" valign="middle"/>
zu kombinieren. Zu diesem Zweck vergegenw&auml;rtigen
wir uns noch einmal das Programm <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/>. <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> enth&auml;lt
in den Prozeduren A,...,AC seinen eigenen Text in
Form von Teilstrings. Mehrfach vorkommende Teilstrings
sind nat&uuml;rlich nur einmal gespeichert.
Der Text von <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> l&auml;&szlig;t sich aber durch Aneinanderreihen
dieser Teilstrings zusammensetzen. Der
erste Teilstring <img src="/img/cache/54dbe5ef61d2f9977c7be03737833609.gif" alt="s_1" valign="middle"/> von <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> enth&auml;lt die das
Programm einleitenden Phrasen bis zum ersten '. Der
letzte, in der Prozedur AB enthaltene Teilstring
<img src="/img/cache/912864edd44ea0ce6d5d6e9daf199545.gif" alt="s_9" valign="middle"/> beinhaltet den kompletten Anweisungsteil von
<img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/>. Abbildung 5.2.A verdeutlicht diesen
Zusammenhang.</p>
 
<p><img src="/img/cache/d69d8e8585d18f9fef4d76fec376d673.gif" alt="
\begin{array}{ccc}
\text{\pi_6 = \\\ }&amp; \fbox{\text{\underline{program} PI6(OUTPUT);\\\underline{procedure} AA \underline{begin} WRITE('}} &amp; \text{= s_1\\\ \ \ s_1   '')\underline{end}}
\end{array}\\
\begin{array}{cclc}
\text{\underline{procedure}}	&amp; C;	&amp; \text{\underline{begin}} \dots\dots\dots\dots\dots\dots &amp; \text{\underline{end};}\\
				&amp; \vdots&amp; 						&amp; \vdots\\
				&amp; \vdots&amp; 						&amp; \vdots\\
				&amp; \vdots&amp; 						&amp; \vdots\\
\text{\underline{procedure}}	&amp; BC;	&amp; \text{\underline{begin}} \dots\dots\dots\dots\dots\dots &amp; \text{\underline{end};}\\
\text{\underline{procedure}}	&amp; AB;	&amp; \text{\underline{begin} WRITE('  s_9  ')} &amp; \text{\underline{end};}\\
\end{array}\\
\fbox{
\text{\underline{begin}\\
AA;AA;AC;B;\\
AB;WRITELN\\
\underline{end\\
end.}
}} = s_9
" valign="middle"/></p>
<p>Abb.: 5.2.A</p>
<p><strong>Idee:</strong> Wir integrieren den Programmkopf von <img src="/img/cache/d4c98d75e25f5d28461f1da221eb7a95.gif" alt="\pi_0" valign="middle"/></p>
<pre class="source">
	<strong>program</strong> X(INPUT,OUTPUT);
	<strong>var</strong> I : <strong>integer</strong>;
	    Y : <strong>real</strong>;
</pre>
<p>in den String <img src="/img/cache/54dbe5ef61d2f9977c7be03737833609.gif" alt="s_1" valign="middle"/> und den Anweisungsteil von <img src="/img/cache/d4c98d75e25f5d28461f1da221eb7a95.gif" alt="\pi_0" valign="middle"/></p>
<pre class="source">
	<strong>for</strong> I:=1 <strong>to</strong> 10 <strong>do</strong>
	<strong>begin</strong> READ(Y); WRITELN(SQRT(Y)) <strong>end</strong>;
</pre>
<p>in den String <img src="/img/cache/912864edd44ea0ce6d5d6e9daf199545.gif" alt="s_9" valign="middle"/>.</p>
<p>Wir erhalten die Teilstrings <img src="/img/cache/95f734bb48619a271699123734f0bb2c.gif" alt="s_1'" valign="middle"/> und <img src="/img/cache/b63c1cdfc83048e200c66120322f9c35.gif" alt="s_9'" valign="middle"/> mit</p>
<pre class="source"><img src="/img/cache/95f734bb48619a271699123734f0bb2c.gif" alt="s_1'" valign="middle"/> =
	<strong>program</strong> PI6X(INPUT,OUTPUT);
	<strong>var</strong> I : <strong>integer</strong>; Y : <strong>real</strong>; <strong>procedure</strong> AA;
	<strong>begin</strong> WRITE('
<img src="/img/cache/b63c1cdfc83048e200c66120322f9c35.gif" alt="s_9'" valign="middle"/> = 
	<strong>begin</strong>
	<strong>for</strong> I:=1 <strong>to</strong> 10 <strong>do</strong>
	<strong>begin</strong> READ(Y); WRITELN(SQRT(Y)) <strong>end</strong>;
 
	AA;AA;AC;B; .......... AB; WRITELN
	<strong>end end</strong>.
</pre>
<p>Es liegt auf der Hand, da&szlig; die Ersetzung von <img src="/img/cache/54dbe5ef61d2f9977c7be03737833609.gif" alt="s_1" valign="middle"/> und <img src="/img/cache/912864edd44ea0ce6d5d6e9daf199545.gif" alt="s_9" valign="middle"/> durch
<img src="/img/cache/95f734bb48619a271699123734f0bb2c.gif" alt="s_1'" valign="middle"/> bzw. <img src="/img/cache/b63c1cdfc83048e200c66120322f9c35.gif" alt="s_9'" valign="middle"/> in Programm <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> wieder zu einem syntaktisch
korrekten selbstreproduzierenden Programm <img src="/img/cache/58d8d2e22dffc2d4e621ca48134450f5.gif" alt="\tilde\pi_0" valign="middle"/> f&uuml;hrt. <img src="/img/cache/58d8d2e22dffc2d4e621ca48134450f5.gif" alt="\tilde\pi_0" valign="middle"/> f&uuml;hrt
zuerst die <strong>for</strong>-Schleife von <img src="/img/cache/d4c98d75e25f5d28461f1da221eb7a95.gif" alt="\pi_0" valign="middle"/> aus und reproduziert sich
anschlie&szlig;end selbst. Es gilt f&uuml;r die von <img src="/img/cache/58d8d2e22dffc2d4e621ca48134450f5.gif" alt="\tilde\pi_0" valign="middle"/> realisierte
Funktion <img src="/img/cache/9f90d28437e4bcd5cd01c86ac5e051d5.gif" alt="f_{\tilde\pi_0}\ :\ A^*_{\text{PAS}} \mapsto A^*_{\text{PAS}}" valign="middle"/>:<br/>
<img src="/img/cache/b52634688d076cb2f319b2e34d713da6.gif" alt="f_{\tilde\pi_0}(x) = f_{\pi_0}(x)\circ\pi_0" valign="middle"/> f&uuml;r alle <img src="/img/cache/c21c017c4c53c89422071829cc3a45fe.gif" alt="x\in A^*_{\text{PAS}}" valign="middle"/></p>
<p>Damit gen&uuml;gt <img src="/img/cache/58d8d2e22dffc2d4e621ca48134450f5.gif" alt="\tilde\pi_0" valign="middle"/> Definition (5.1.4)(i), und es gilt: <img src="/img/cache/58d8d2e22dffc2d4e621ca48134450f5.gif" alt="\tilde\pi_0" valign="middle"/> ist
eine selbstreproduzierende Version von <img src="/img/cache/d4c98d75e25f5d28461f1da221eb7a95.gif" alt="\pi_0" valign="middle"/>. Anhang A.11.
zeigt Programm <img src="/img/cache/a91c17812951dbb12757a0879bb860af.gif" alt="\pi_6'" valign="middle"/> in implementierter Form, die aus der
implementierten Form von Programm <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> abgeleitet ist.</p>
<p>Die Konstruktion von <img src="/img/cache/58d8d2e22dffc2d4e621ca48134450f5.gif" alt="\tilde\pi_0" valign="middle"/> aus den beiden Programmen <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> und
<img src="/img/cache/d4c98d75e25f5d28461f1da221eb7a95.gif" alt="\pi_0" valign="middle"/> zeigte keine Aspekte, die darauf hindeuten, da&szlig; diese
Konstruktion von irgendwelchen speziellen Eigenschaften von
<img src="/img/cache/d4c98d75e25f5d28461f1da221eb7a95.gif" alt="\pi_0" valign="middle"/> abh&auml;ngt. Die Konstruktion m&uuml;&szlig;te sich also f&uuml;r beliebige
PASCAL-Programme verallgemeinern lassen. Um diese Verallgemeinerung
komfortabel durchf&uuml;hren zu k&ouml;nnen, ben&ouml;tigen wir
noch zwei Vereinbarungen:</p>
<p>In [10] ist eine kontextfreie Grammatik <img src="/img/cache/34abd7bcc9548570b8cdc0452553cdfa.gif" alt="G_{\text{PAS}}" valign="middle"/> soweit
dies &uuml;berhaupt m&ouml;glich ist (vergleiche 2.3.), f&uuml;r die
Programmiersprache PASCAL angegeben worden. Wir werden uns
im folgenden an dieser Grammatik orientieren.</p>
<p><strong>(5.2.2) Vereinbarung:</strong> Sei <img src="/img/cache/4fdefba26320686bb2bd0579a0df421c.gif" alt="\nu" valign="middle"/> ein nichtterminales Zeichen
aus <img src="/img/cache/34abd7bcc9548570b8cdc0452553cdfa.gif" alt="G_{\text{PAS}}" valign="middle"/> und <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> ein g&uuml;ltiges PASCAL-Programm, so bezeichnen
wir mit <img src="/img/cache/2659dbe8f98db250d3232134e9a8e025.gif" alt="\nu\pi" valign="middle"/> den Teilstring des Programmtextes <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/>,
der sich aus dem nichtterminalen Zeichen <img src="/img/cache/4fdefba26320686bb2bd0579a0df421c.gif" alt="\nu" valign="middle"/> ableiten
l&auml;&szlig;t. Kommt das Zeichen <img src="/img/cache/4fdefba26320686bb2bd0579a0df421c.gif" alt="\nu" valign="middle"/> im Ableitungsbaum von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/>
nicht vor, so identifizieren wir <img src="/img/cache/2659dbe8f98db250d3232134e9a8e025.gif" alt="\nu\pi" valign="middle"/> mit dem leeren Wort.</p>
<p>Der Teilstring <img src="/img/cache/2659dbe8f98db250d3232134e9a8e025.gif" alt="\nu\pi" valign="middle"/> ist nat&uuml;rlich abh&auml;ngig von der
Position von <img src="/img/cache/4fdefba26320686bb2bd0579a0df421c.gif" alt="\nu" valign="middle"/> im Ableitungsbaum von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/>. Dieser
 
Umstand wird f&uuml;r uns aber keine Bedeutung erlangen.</p>
<p>Durch die hier eingef&uuml;hrte Schreibweise lassen
sich aus den Produktionen der Grammatik <img src="/img/cache/34abd7bcc9548570b8cdc0452553cdfa.gif" alt="G_{\text{PAS}}" valign="middle"/>
Gleichungen gewinnen.</p>
<p><strong>Beispiel:</strong></p>
<p><img src="/img/cache/34abd7bcc9548570b8cdc0452553cdfa.gif" alt="G_{\text{PAS}}" valign="middle"/> enth&auml;lt die Produktion</p>
<pre>&lt;program>::=&lt;program heading>&lt;block></pre>
<p>F&uuml;r jedes g&uuml;ltige PASCAL-Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> gilt
damit die Gleichung</p>
<pre><img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> = &lt;program> <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/>
   = &lt;program heading> <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> &lt;block> <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/>
</pre>
<p>Bei der Kombination von Programm <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> und Programm <img src="/img/cache/d4c98d75e25f5d28461f1da221eb7a95.gif" alt="\pi_0" valign="middle"/> zu <img src="/img/cache/58d8d2e22dffc2d4e621ca48134450f5.gif" alt="\tilde\pi_0" valign="middle"/>
waren keine Konflikte mit Bezeichnern aufgetreten. Das
hei&szlig;t, s&auml;mtliche Prozedurnamen von <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> waren von den
Variablennamen aus <img src="/img/cache/d4c98d75e25f5d28461f1da221eb7a95.gif" alt="\pi_0" valign="middle"/> verschieden. Dies kann i.a. jedoch nicht
vorausgesetzt werden. Um den Test, ob in einem PASCAL-Programm
<img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> Bezeichner auftreten, die mit einem Prozedurnamen
aus <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> identisch sind, zu vereinfachen, normieren wir die
Prozedurnamen aus <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/>, indem wir festlegen, da&szlig; jeder
Prozedurname aus <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> nur mit Hilfe des Buchstaben A gebildet
werden darf. Alle Prozedurnamen aus <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> sind also Elemente
aus <img src="/img/cache/64b1713211785efe1f94689613b4cf92.gif" alt="\{A\}^+" valign="middle"/> und unterscheiden sich nur in ihrer L&auml;nge. Wir
werden sp&auml;ter sehen, da&szlig; es bei einigen Programmen n&ouml;tig ist,
neue Prozeduren zu generieren. Die Namen dieser Prozeduren
werden wir ebenfalls aus <img src="/img/cache/64b1713211785efe1f94689613b4cf92.gif" alt="\{A\}^+" valign="middle"/> w&auml;hlen. Durch diese Normierung
der Prozedurnamen werden einige Namen sehr lang. Um
Schreibarbeit zu sparen, treffen wir die folgende Vereinbarung.</p>
<p><strong>(5.2.3) Vereinbarung:</strong></p>
<ol type="i">
<li>Sei <img src="/img/cache/3313694a4af103905d7c231395df2fd3.gif" alt="\underbrace{A \dots A}\\\text{k-mal}" valign="middle"/> ein Element aus <img src="/img/cache/64b1713211785efe1f94689613b4cf92.gif" alt="\{A\}^+" valign="middle"/>,
dann schreiben wir statt dessen k&uuml;rzer <img src="/img/cache/7db832ff86676e218b287d83e89e16e4.gif" alt="A^k" valign="middle"/>.</li>
 
<li>Wir k&uuml;rzen r aufeinanderfolgende Aufrufe
<img src="/img/cache/8786451dc0263244e96c2e0159591ec7.gif" alt="\underbrace{A^j; \dots ;A^j;}\\\text{r-mal}" valign="middle"/> der Prozedur <img src="/img/cache/cf7420bde1791f4bf31d2bd2c1c3fd74.gif" alt="A^j" valign="middle"/> ab durch <img src="/img/cache/f37612486a2e7bbb3eef5306ecf9bd6f.gif" alt="(A^j;)^r" valign="middle"/>.</li>
</ol>
<p>Unter Benutzung von Vereinbarung (5.2.3) pr&auml;sentiert sich
<img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> nach der Umbenennung der Prozedurnamen in der folgenden
Weise:</p>
<pre class="source"><strong>program</strong> PI6(OUTPUT);
<strong>procedure</strong> A;<strong>begin</strong> WRITE('PROGRAM PI6(OUTPUT);PROCEDURE A;BE
   GIN WRITE(''') <strong>end</strong>;
<strong>procedure</strong> <img src="/img/cache/372c8c0974114a670f97d71577e77b98.gif" alt="A^2" valign="middle"/>;<strong>begin</strong> WRITE('PROCEDURE ') <strong>end</strong>;
<strong>procedure</strong> <img src="/img/cache/b4cddc5b73d75b560a023245d529dc11.gif" alt="A^3" valign="middle"/>;<strong>begin</strong> WRITE(';BEGIN WRITE(''') <strong>end</strong>;
<strong>procedure</strong> <img src="/img/cache/043aced3ddc3a4f1404af4429a3d1f0b.gif" alt="A^4" valign="middle"/>;<strong>begin</strong> WRITE(''') END;') <strong>end</strong>;
<strong>procedure</strong> <img src="/img/cache/a5c0ac33cf92038d4a2aa773e2cb482b.gif" alt="A^5" valign="middle"/>;<strong>begin</strong> WRITE('''') <strong>end</strong>;
<strong>procedure</strong> <img src="/img/cache/e945a87750e6965a1bdbfeeaf4fe2db9.gif" alt="A^6" valign="middle"/>;<strong>begin</strong> WRITE('A') <strong>end</strong>;
<strong>procedure</strong> <img src="/img/cache/343bb72223d7f76edf7cf61c53b59d07.gif" alt="A^7" valign="middle"/>;<strong>begin</strong> WRITE('BEGIN <img src="/img/cache/0900412f9025c5e749205110c78b5383.gif" alt="A;A;A^5;A^4;A^2;(A^6;)^2A^3;A^2;A^4" valign="middle"/>
   <img src="/img/cache/c0744a3417c9ad62422e7213a7f253a8.gif" alt=";A^2;(A^6;)^3A^3;A^3;A^5;A^4;A^2;(A^6;)^4A^3;A^5;A^4;A^4;A^2;(A^6;)^5A^3;A^5;" valign="middle"/>
   <img src="/img/cache/0b2912dd1da2589bb48f9f3a400e41c0.gif" alt="A^5;A^4;A^2;(A^6;)^6A^3;A^6;A^4;A^2;(A^6;)^7A^3;A^7;A^4;A^7;" valign="middle"/>WRITELN END.') <strong>end</strong>;
<strong>begin</strong>
<img src="/img/cache/113d763b01905b7a3a800db1b1ee5ab8.gif" alt="A;A;A^5;A^4;" valign="middle"/>
<img src="/img/cache/c08d21d374639cc3d52291b5436f7664.gif" alt="A^2;(A^6;)^2A^3;A^2;A^4;" valign="middle"/>
<img src="/img/cache/5d594a87c9483a8f8727e60f7ecf8b95.gif" alt="A^2;(A^6;)^3A^3;A^3;A^5;A^4;" valign="middle"/>
<img src="/img/cache/5cb7c0e8791bce78e9d699115a673ceb.gif" alt="A^2;(A^6;)^4A^3;A^5;A^4;A^4;" valign="middle"/>
<img src="/img/cache/2dfbb5be621d619599f92ae0d957abc1.gif" alt="A^2;(A^6;)^5A^3;A^5;A^5;A^4;" valign="middle"/>
<img src="/img/cache/7623610b1858cd859e57af3b74cd69a4.gif" alt="A^2;(A^6;)^6A^3;A^6;A^4;" valign="middle"/>
<img src="/img/cache/c0908c83c776b63205f957e3d12aaed6.gif" alt="A^2;(A^6;)^7A^3;A^7;A^4;A^7;" valign="middle"/>
WRITELN
<strong>end</strong>.
</pre>
<p>Nach diesen Vorbemerkungen sind wir nun in der Lage, den
Selbstreproduktionssatz f&uuml;r PASCAL-Programme zu beweisen.</p>
 
<p><strong>(5.2.4) Satz (Selbstreproduktionssatz f&uuml;r PASCAL-Programme)</strong></p>
<p>Zu jedem syntaktisch, korrekten PASCAL-Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/>
existiert eine selbstreproduzierende Version <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/>.</p>
<p><strong>Beweis</strong></p>
<p>Der Beweis gliedert sich in zwei Teile. In Teil A
wird eine Konstruktion f&uuml;r ein Programm <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> f&uuml;r
beliebiges <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> angegeben. In Teil B wird gezeigt, da&szlig;
das so konstruierte <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> eine selbstreproduzierende
Version von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> ist. Der Beweis setzt die Grammatik
<img src="/img/cache/34abd7bcc9548570b8cdc0452553cdfa.gif" alt="G_{\text{PAS}}" valign="middle"/> voraus.</p>
<p>Sei nun <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> ein beliebiges g&uuml;ltiges PASCAL-Programm.
Enth&auml;lt <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> Bezeichner aus <img src="/img/cache/64b1713211785efe1f94689613b4cf92.gif" alt="\{A\}^+" valign="middle"/>, so werden
diese Bezeichner durch andere Bezeichner ersetzt,
die nicht aus <img src="/img/cache/64b1713211785efe1f94689613b4cf92.gif" alt="\{A\}^+" valign="middle"/> sind. Das resultierende Programm
ist textuell von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> verschieden und wird mit
<img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> bezeichnet. Enth&auml;lt <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> keine Bezeichner aus <img src="/img/cache/64b1713211785efe1f94689613b4cf92.gif" alt="\{A\}^+" valign="middle"/>, <sup><a href="#p104_1" name="b104_1">1)</a></sup>
so wird <img src="/img/cache/300a38a669c9ab5a4dbd6943a0b3db9f.gif" alt="\pi':=\pi" valign="middle"/> gesetzt.</p>
<p><em>Teil A</em></p>
<p>Nach <img src="/img/cache/34abd7bcc9548570b8cdc0452553cdfa.gif" alt="G_{\text{PAS}}" valign="middle"/> hat <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> den folgenden Aufbau:</p>
<pre><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> = &lt;programm heading> <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> &lt;block> <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/>,</pre>
<p>wobei &lt;program heading><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> und &lt;block><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> ungleich dem leeren
Wort sind. Entsprechendes gilt f&uuml;r <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> und das zu konstruierende <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/>:</p>
<pre>
	<img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> = &lt;program heading> <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> &lt;block> <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/>
	<img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> = &lt;program heading> <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> &lt;block> <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/>
</pre>
<p>Wir erhalten das Programm <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/>, indem wir</p>
<pre>
&lt;program heading><img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> aus &lt;program heading> <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/>
                    und &lt;program heading> <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/>
</pre>
<p>bzw.</p>
<pre>
&lt;block> <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> aus &lt;block> <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/>
           und &lt;block> <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/>
</pre>
<p>kombinieren.</p>
 
<ol type="i">
<li><strong>Kombination von &lt;program heading><img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/></strong>
<p>Aus <img src="/img/cache/34abd7bcc9548570b8cdc0452553cdfa.gif" alt="G_{\text{PAS}}" valign="middle"/> folgt, da&szlig; f&uuml;r &lt;program heading><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> die allgemeine
Beziehung</p>
<pre>&lt;program heading)<img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> = program <img src="/img/cache/ed146a1397eb53c99683a97c539ef467.gif" alt="\mu(\mu_1,\dots,\mu_r)" valign="middle"/>;</pre>
<p>wobei <img src="/img/cache/70f7feadbca13b6087133b00c15c4937.gif" alt="\mu,\mu_1,\dots,\mu_r,r\ge0" valign="middle"/> PASCAL-g&uuml;ltige Bezeichner sind,
gilt. <img src="/img/cache/c9faf6ead2cd2c2187bd943488de1d0a.gif" alt="\mu" valign="middle"/> stellt den Namen des Programms dar, die <img src="/img/cache/262d5ec61d4727236470a56c2e8433ef.gif" alt="\mu_i" valign="middle"/> bezeichnen
die von <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> benutzten Dateien. Benutzt <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> die Standarddatei
OUTPUT, so sei o.B.d.A. <img src="/img/cache/4242968b9f08bce37f3e6a702db37498.gif" alt="\mu_r" valign="middle"/> = OUTPUT.</p>
<p>F&uuml;r <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> gilt:</p>
<pre>&lt;program heading><img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> = <strong>program</strong> Pl6(OUTPUT);</pre>
<p>Damit kombinieren wir:</p>
<pre>&lt;program heading><img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> = <strong>program</strong> P(<img src="/img/cache/1d0fddfd0ff640932e4368a965c2afb9.gif" alt="\mu_1,\dots,\mu_k" valign="middle"/>,OUTPUT);</pre>
<p>mit
<img src="/img/cache/59cb00ce561d56982747ccc87942d71d.gif" alt="k = \left\{r-1,\text{ falls \mu_r = OUTPUT}\\r\text{ sonst.}\right." valign="middle"/></p></li>
<li><strong>Kombination von &lt;block><img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/></strong>
<p>Aus <img src="/img/cache/34abd7bcc9548570b8cdc0452553cdfa.gif" alt="G_{\text{PAS}}" valign="middle"/> folgt, da&szlig; f&uuml;r &lt;block><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> gilt:</p>
<pre>
&lt;block><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> =
	&lt;label declaration part><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/>
	&lt;constant declaration part><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/>
	&lt;type definition part><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/>
	&lt;variable declaration part><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/>
	&lt;procedure and function declaration part><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/>
	&lt;statement part><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/>
</pre>
<p>Alle Strings bis auf &lt;statement part><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> k&ouml;nnen leer sein.
Die Programme <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> und <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> haben einen entsprechenden Aufbau.
Da &lt;label declaration part><img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/>,...,&lt;variable declaration
part><img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> gleich dem leeren Wort sind, setzen wir:</p>
<pre>
&lt;label declaration part><img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/>	:= &lt;label declaration part><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/>
&lt;konstant declaration part><img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/>	:= &lt;konstant declaration part><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/>
&lt;type definition part><img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/>		:= &lt;type definition part><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/>
&lt;variable declaration part><img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/>	:= &lt;variable declaration part><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/>
</pre></li>
</ol>
 
<p>In 3.2.5. war bemerkt worden, da&szlig; es in SIMULA nicht m&ouml;glich
ist, Texte, die das Zeichen " enthalten, en bloc auszudrucken.
Die gleichen Schwierigkeiten macht in PASCAL das
Zeichen '. Enth&auml;lt <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> das Zeichen ' ein- oder mehrmals, so
mu&szlig; der Text <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> entsprechend zerlegt werden.</p>
<p>Es wird gesetzt:</p>
<pre>
S := &lt;label declaration part><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/>
     &lt;constant declaration part><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/>
     &lt;type definition part><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/>
     &lt;procedure and function declaration part><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/>
T := (&lt;statement part><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> ohne die klammernden, terminalen
     Zeichen <strong>begin</strong> und <strong>end</strong>.)
</pre>
<p>Mittels der Strings S und T l&auml;&szlig;t sich der Programmtext <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/>
wie folgt darstellen:</p>
<pre><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> = &lt;program heading)<img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> <img src="/img/cache/1b3c1a40f9cb094d47e8c6f9b0df773f.gif" alt="\circ" valign="middle"/> S <img src="/img/cache/1b3c1a40f9cb094d47e8c6f9b0df773f.gif" alt="\circ" valign="middle"/> <strong>begin</strong> <img src="/img/cache/1b3c1a40f9cb094d47e8c6f9b0df773f.gif" alt="\circ" valign="middle"/> T <img src="/img/cache/1b3c1a40f9cb094d47e8c6f9b0df773f.gif" alt="\circ" valign="middle"/> <strong>end</strong>.</pre>
<p><strong>1. Fall:</strong> S ist ungleich dem leeren Wort (d.h. <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> hat einen
nichtleeren Vereinbarungsteil)</p>
<p>Zerlegung von S in eine Folge von <img src="/img/cache/faf1b3a30453e631b14c4b627225001e.gif" alt="n\ge1" valign="middle"/> Teilstrings <img src="/img/cache/804f14414dab2297b600211a82c39fa8.gif" alt="S_i" valign="middle"/> mit</p>
<ol type="i">
<li><img src="/img/cache/eadfe10c8f918a1351d2920c3149a029.gif" alt="s_i = \ ' \text{ oder } s_i \not\ni \ ',\ i\in[n]" valign="middle"/></li>
<li><img src="/img/cache/dfbd5beb98ff965358b514150be77658.gif" alt="s_i \not\ni \ ' \Rightarrow s_{i+1} = \ ',\ i\in[n-1]" valign="middle"/></li>
<li><img src="/img/cache/c58444e43cf74c9914fb8b75934223a8.gif" alt="s_1\circ s_2\circ\dots\circ s_n = S" valign="middle"/></li>
</ol>
<p>Sei p die Anzahl der Teilstrings von S, die ungleich '
sind. Es gilt: <img src="/img/cache/e693016db011c504f13330993241c98a.gif" alt="1 \le p \lt n" valign="middle"/></p>
<p>F&uuml;r jeden Teilstring ungleich ' , mit Ausnahme von <img src="/img/cache/54dbe5ef61d2f9977c7be03737833609.gif" alt="s_1" valign="middle"/>,
wird eine Prozedur generiert:</p>
<pre><strong>procedure</strong> <img src="/img/cache/de66baf9626db482db6466142d1d0e91.gif" alt="A^{7+j-1}" valign="middle"/>;<strong>begin</strong> WRITE('<img src="/img/cache/e406ac4d7c470823a8619c13dd7101be.gif" alt="s_i" valign="middle"/>') <strong>end</strong>;   j = 2,...,p</pre>
<p>wobei <img src="/img/cache/e406ac4d7c470823a8619c13dd7101be.gif" alt="s_i" valign="middle"/> der j-te Teilstring ungleich ' ist.</p>
<p>Sei AP die Menge der Namen der generierten Prozeduren.
Dann gilt:<br/>
<img src="/img/cache/2f2b79b02e8559a67053974483e63806.gif" alt="AP=\{A^{7+1},A^{7+2},\dots,A^{7+p-1}\}" valign="middle"/>.</p>
 
<p>Sei <img src="/img/cache/e0eb204fbdccbd62dd091c1629685e77.gif" alt="\cal{J}=\{s_1,\dots,s_n\}" valign="middle"/> die <strong>Menge</strong> der Teilstrings der
Zerlegung von S.</p>
<p>Einf&uuml;hrung der Funktionen <img src="/img/cache/314f0036b33aa1148cbe231f83182879.gif" alt="\cal{G}" valign="middle"/> und <img src="/img/cache/fa9ccee3ce81a8706729246943f573f9.gif" alt="\tilde{\cal{G}}" valign="middle"/>:</p>
<p><img src="/img/cache/774c897556643a7496235a253a23fac3.gif" alt="
\begin{array}{cccl}
\cal{G}:&amp; [p]	&amp; \mapsto &amp; \cal{J}\\
	&amp; j	&amp; \mapsto &amp; \text{s_k, mit s_k ist der j-te Teilstring \ne '}\\
\tilde{\cal{G}}:&amp;[n]&amp;\mapsto&amp;AP\cup\{A^5\}\\
	&amp; j	&amp; \mapsto  &amp;
		{\left\{
			\perp\text{, falls j=1}\\
			A^{7+i-1}\text{, falls s_j der i-te Teilstring von S\ne\ ' ist}\\
			A^5\text{, falls s_j=\ '}
		\right.}
\end{array}
" valign="middle"/><sup><a href="#p107_1" name="b107_1">1)</a></sup></p>
<p>(Zur Erinnerung: <img src="/img/cache/a5c0ac33cf92038d4a2aa773e2cb482b.gif" alt="A^5" valign="middle"/> ist die Prozedur, die in <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle"/> das Zeichen
' ausgibt.)</p>
<pre>
Da weder &lt;label declaration part><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/>
   noch  &lt;konstant declaration part><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/>
   noch  &lt;type definition part><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/>
   noch  &lt;procedure and function declaration part><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/>
</pre>
<p>mit dem Zeichen ' anfangen oder enden k&ouml;nnen, gilt:<br/>
<img src="/img/cache/0ac0268973dcf7265eeaadd1e3a77151.gif" alt="\cal{G}(1) = s_1\text{ und }\cal{G}(p) = s_n" valign="middle"/></p>
<p>Der String T wird in einen String T' transformiert, indem
T mit dem Zeichen ; konkateniert wird: T' := T;
T' wird analog zu S in <img src="/img/cache/2955901c369ec45c4bef6a1e822b631e.gif" alt="m\ge1" valign="middle"/> Teilstrings <img src="/img/cache/f406db9a09c0430f7e54c1a3bb217c3e.gif" alt="t_i" valign="middle"/> zerlegt. F&uuml;r
die Zerlegung von T' gilt:</p>
<ol>
<li><img src="/img/cache/8bbc738084687cad7b6106b3f731cbcd.gif" alt="t_i=\ '\text{ oder } t_i\not\ni\ ',\ i\in[m]" valign="middle"/></li>
<li><img src="/img/cache/f06974098850c6049b909b0e04193ffd.gif" alt="t_i\not\ni\ '\Rightarrow t_{i+1}=\ '\ i\in[m-1]" valign="middle"/></li>
<li><img src="/img/cache/ff19765403f7c093bd27139dc434120d.gif" alt="t_1\circ t_2\circ\dots\circ t_m=T'" valign="middle"/></li>
</ol>
<p>Sei q die Anzahl der Teilstrings von T', die ungleich '
sind. Es gilt: <img src="/img/cache/c99dd6b4db131f791f33496e40e3232c.gif" alt="1\le q \lt m" valign="middle"/>.
F&uuml;r jeden Teilstring <img src="/img/cache/f406db9a09c0430f7e54c1a3bb217c3e.gif" alt="t_i" valign="middle"/> ungleich ', mit Ausnahme von <img src="/img/cache/7c913e757e40b090b073cacd4511a152.gif" alt="t_m" valign="middle"/>,
wird eine Prozedur generiert:</p>
 
<pre class="source"><strong>procedure</strong> <img src="/img/cache/6132801a5400eb2410154d71a8e8d889.gif" alt="A^{7+j+p-1}" valign="middle"/>; <strong>begin</strong> WRITE('<img src="/img/cache/f406db9a09c0430f7e54c1a3bb217c3e.gif" alt="t_i" valign="middle"/>') <strong>end</strong>;</pre>
<p>f&uuml;r j=2,...,q-1, wobei <img src="/img/cache/f406db9a09c0430f7e54c1a3bb217c3e.gif" alt="t_i" valign="middle"/> der j-te Teilstring <img src="/img/cache/f9bb70af966a4abbd08b776e6c5971ad.gif" alt="\ne" valign="middle"/> ' ist
bzw.</p>
<pre class="source"><strong>procedure</strong> <img src="/img/cache/557504adc8cd385ec07478d773a7ac66.gif" alt="A^{7+p}" valign="middle"/>;<strong>begin</strong> WRITE('BEGIN <img src="/img/cache/e81cfd62d282334e315e27a783b578cd.gif" alt="t_j" valign="middle"/>') <strong>end</strong>;</pre>
<p>f&uuml;r j=1.</p>
<p>Dabei ist <img src="/img/cache/e81cfd62d282334e315e27a783b578cd.gif" alt="t_j" valign="middle"/> der j-te Teilstring von T' ungleich '.
Entsprechend <img src="/img/cache/7ec640dbddcde8db0c78f1f1ecd35fd3.gif" alt="AP,\cal{J},\cal{G}" valign="middle"/> und <img src="/img/cache/c178aa4732741466656db1bcd1cdef96.gif" alt="\tilde\cal{G}" valign="middle"/> werden <img src="/img/cache/02655824365c96bc45c1b3b2182e2b8a.gif" alt="AQ,\cal{T},\tau" valign="middle"/> und <img src="/img/cache/c80dc7396cddee2e3b36211de213b695.gif" alt="\tilde\tau" valign="middle"/> definiert:</p>
<img src="/img/cache/408e481aeb7d459177908ceda5e3e489.gif" alt="
\begin{array}{clcl}
AQ	&amp;:=&amp;   &amp; \{A^{7+p},\dots,A^{7+p+q-1}\} \\
\cal{T}	&amp;:=&amp;   &amp; \{t1,\dots,t_m\}\\
\tau	&amp;: &amp;[q]&amp; \longr \{t_i\}_{i\in[n]}\\
	&amp;  &amp; j &amp; \longr t_k\text{, mit t_k ist der j-te Teilstring von T' \ne '}\\
\tilde\tau &amp;:&amp;[m]&amp;\longr AQ\cup\{A^5\}\\
	&amp;  &amp; j &amp; \longr
	{\left\{
	    \perp\text{, falls j = q}\\
	    A^{7+p+i-1}\text{, falls t_j der i-te Teilstring \ne ' ist}\\
	    A^5\text{, falls t_j = '}
	\right.}
\end{array}
" valign="middle"/>
<p>Das erste Zeichen nach dem einleitenden <strong>begin</strong> von
&lt;statement part><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/> kann nicht gleich ' sein. Daraus ergibt
sich nach Definition von <img src="/img/cache/e3f7b1212f91ef4e85649afb61612dc1.gif" alt="T'\ :\ \tau(1)=t_1" valign="middle"/><br/>
Das letzte Zeichen von T' ist ; . Daraus folgt: <img src="/img/cache/7d6168e23ba220c8f473854ddbd1c143.gif" alt="\tau(q)=t_m" valign="middle"/></p>
<p>Es ist nun m&ouml;glich, die beiden noch fehlenden Programmteile
von <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/>, n&auml;mlich</p>
<pre>
&lt;procedure and function declaration part><img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/>   und
&lt;statement pari><img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/>
</pre>
<p>abzugeben:</p>
 
<pre>
   &lt;procedure and function declaration part><img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/>
 = &lt;procedure and fuuction declaration part><img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle"/>
   <strong>procedure</strong> <img src="/img/cache/2492ac3d9c30ee5642299a56d3f88e44.gif" alt="A^{7+1}" valign="middle"/>;<strong>begin</strong> ..... <strong>end</strong>;
   <img src="/img/cache/f750e0a797eedef801aaf50716fbd542.gif" alt="\vdots" valign="middle"/>
   <img src="/img/cache/f750e0a797eedef801aaf50716fbd542.gif" alt="\vdots" valign="middle"/>
   <strong>procedure</strong> <img src="/img/cache/2d6b7f7733b7eaf46609e6d0459c3801.gif" alt="A^{7+p+q-1}" valign="middle"/>;<strong>begin</strong> ..... <strong>end</strong>;
   <strong>procedure</strong> A;<strong>begin</strong> WRITE('&lt;program heading><img src="/img/cache/ba19d808cacd362ba626a8abd470a5d0.gif" alt="\tilde\pi\cal{G}(1)" valign="middle"/>') <strong>end</strong>;
   <img src="/img/cache/f750e0a797eedef801aaf50716fbd542.gif" alt="\vdots" valign="middle"/>
   <img src="/img/cache/f750e0a797eedef801aaf50716fbd542.gif" alt="\vdots" valign="middle"/>   
   <strong>procedure</strong> <img src="/img/cache/343bb72223d7f76edf7cf61c53b59d07.gif" alt="A^7" valign="middle"/>;<strong>begin</strong> WRITE('<img src="/img/cache/13a77e6c1486c8ebc2bcf9af23fd4afc.gif" alt="\tau(q)\ \sout[+1]\otimes" valign="middle"/> END.') <strong>end</strong>;
   &lt;statement part><img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/>
 = <strong>begin</strong> <img src="/img/cache/1c4da5ca6d44dc389e3f34aefd2eef85.gif" alt="t_1,\dots,t_m\ \sout[+1]\otimes" valign="middle"/> <strong>end</strong>.
</pre>
<img src="/img/cache/678614555c8184bb905e8808b2692c69.gif" alt="\sout[+1]\otimes" valign="middle"/> steht dabei als Abk&uuml;rzung f&uuml;r die Aufruffolge der Prozeduren
A bis <img src="/img/cache/b18de09bd284605209a39911ce5b254e.gif" alt="A^{p+q+2}" valign="middle"/>, die die Ausgabe von <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> bewirkt.
Damit ergibt sich insgesamt:
<pre class="source"><img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> = <strong>program</strong> P(<img src="/img/cache/1d0fddfd0ff640932e4368a965c2afb9.gif" alt="\mu_1,\dots,\mu_k" valign="middle"/>,,OUTPUT);
     <img src="/img/cache/0993ce08f80645e64340f28abaf71541.gif" alt="s_1\ \dots\ \dots\ s_n" valign="middle"/>
<strong>procedure</strong> <img src="/img/cache/2492ac3d9c30ee5642299a56d3f88e44.gif" alt="A^{7+1}" valign="middle"/>;<strong>begin</strong> WRITE('<img src="/img/cache/cdcdf67fa29258e11f70aafe47988d46.gif" alt="\cal{G}(2)" valign="middle"/>') <strong>end;</strong>
<strong>procedure</strong> <img src="/img/cache/889fca977d8063a091d1d1e90ecd52e7.gif" alt="A^{7+2}" valign="middle"/>;<strong>begin</strong> WRITE('<img src="/img/cache/b7109d72308bbd94d37c45cee73b7cfe.gif" alt="\cal{G}(3)" valign="middle"/>') <strong>end;</strong>
..........................................
<strong>procedure</strong> <img src="/img/cache/e3ac2f0eb2ee204cea0fbdc6642b552b.gif" alt="A^{7+p-1}" valign="middle"/>;<strong>begin</strong> WRITE('<img src="/img/cache/4aeb16433845da740f769988c5fe3abe.gif" alt="\cal{G}(p)" valign="middle"/>' ) <strong>end;</strong>
<strong>procedure</strong> <img src="/img/cache/557504adc8cd385ec07478d773a7ac66.gif" alt="A^{7+p}" valign="middle"/>;<strong>begin</strong> WRITE(BEGIN <img src="/img/cache/7f7c01de695d5a11979006e1e1e3ffc7.gif" alt="\tau(1)" valign="middle"/>' ) <strong>end;</strong>
<strong>procedure</strong> <img src="/img/cache/97586811fa539c01e5a6d8a8549ffa6f.gif" alt="A^{7+p+1}" valign="middle"/>;<strong>begin</strong> WRITE('<img src="/img/cache/ad30ea1ffc8907f0948900910e0cb3c7.gif" alt="\tau(2)" valign="middle"/>') <strong>end;</strong>
..........................................
<strong>procedure</strong> <img src="/img/cache/73ed7ddd79352424362a36dcac7ea564.gif" alt="A^{7+p+q-2}" valign="middle"/>;<strong>begin</strong> WRITE('<img src="/img/cache/c0f66fd5e817ae5c0941a52ceeaf59a1.gif" alt="\tau(q-1)" valign="middle"/>') <strong>end;</strong>
<strong>procedure</strong> A;<strong>begin</strong> WRITE('PROGEAM P(<img src="/img/cache/1d0fddfd0ff640932e4368a965c2afb9.gif" alt="\mu_1,\dots,\mu_k" valign="middle"/>,OUTPUT);<img src="/img/cache/9859c9fe7706daa925a536c63b4dfecb.gif" alt="\cal{G}(1)" valign="middle"/>') <strong>end;</strong>
<strong>procedure</strong> <img src="/img/cache/372c8c0974114a670f97d71577e77b98.gif" alt="A^2" valign="middle"/>;<strong>begin</strong> WRITE('PROCEDURE ') <strong>end;</strong>
<strong>procedure</strong> <img src="/img/cache/b4cddc5b73d75b560a023245d529dc11.gif" alt="A^3" valign="middle"/>;<strong>begin</strong> WRITE(';BEGIN WRITE(''') <strong>end;</strong>
<strong>procedure</strong> <img src="/img/cache/043aced3ddc3a4f1404af4429a3d1f0b.gif" alt="A^4" valign="middle"/>;<strong>begin</strong> WRITE(''') END;') <strong>end;</strong>
<strong>procedure</strong> <img src="/img/cache/a5c0ac33cf92038d4a2aa773e2cb482b.gif" alt="A^5" valign="middle"/>;<strong>begin</strong> WRITE('''') <strong>end;</strong>
<strong>procedure</strong> <img src="/img/cache/e945a87750e6965a1bdbfeeaf4fe2db9.gif" alt="A^6" valign="middle"/>;<strong>begin</strong> WRITE('A') <strong>end;</strong>
<strong>procedure</strong> <img src="/img/cache/343bb72223d7f76edf7cf61c53b59d07.gif" alt="A^7" valign="middle"/>;<strong>begin</strong> WRITE('<img src="/img/cache/13a77e6c1486c8ebc2bcf9af23fd4afc.gif" alt="\tau(q)\ \sout[+1]\otimes" valign="middle"/> END.') <strong>end;</strong>
<strong>begin</strong>
<img src="/img/cache/73fedf9361037483d38a8ec312bc08fc.gif" alt="t_1 \dots t_m" valign="middle"/>
 
<img src="/img/cache/9d5ec7b04e8043e6e6171392ae345d5e.gif" alt="
\begin{array}{lcl}
{ \left.
A;\\
\tilde\cal{G}(2);\ \dots\ \dots\ \tilde\cal{G}(n);\\
A^2;(A^6);^{7+1}A^3;A^{7+1};A^4;\\
A^2;(A^6);^{7+2}A^3;A^{7+2};A^4;\\
\dots\ \dots\ \dots\ \dots\ \dots\ \dots\ \dots\\
A^2;(A^6;)^{7+p-1}A^3;A^{7+p-1};A^4;\\
A^2;(A^6;)^{7+p}A^3;A^{7+p};A^4;\\
A^2;(A^6;)^{7+p+1}A^3;A^{7+p+1};A^4;\\
\dots\ \dots\ \dots\ \dots\ \dots\ \dots\ \dots\\
A^2;(A^6;)^{7+p+q-2}A^3;A^{7+p+q-2};A^4;\\
A^2;A^6;A^3;A;A^4;\\
A^2;(A^6;)^2A^3;A^2;A^4;\\
A^2;(A^6;)^3A^3;A^3;A^5;A^4;\\
A^2;(A^6;)^4A^3;A^5;A^4;A^4;\\
A^2;(A^6;)^5A^3;A^6;A^5;A^4;\\
A^2;(A^6;)^6A^3;A^6;A^4;\\
A^2;(A^6;)^7A^3;A^7;A^4;\\
\tilde\tau(1);\dots;\tilde\tau(m-1);\\
A^7;\text{WRITELN}\\
\text{\underline{end}}.
\right\}} \sout[+1]\otimes &amp; 
{
    \text{Zeilennummer}\\
    \downarrow\\
    \ \\
    k_{7+1}\\
    k_{7+2}\\
    \dots\\
    k_{7+p-1}\\
    k_{7+p}\\
    k_{7+p+1}\\
    \dots\ \dots\\
    k_{7+p+q-2}\\
    k_1\\
    \vdots\\
    \vdots\\
    \vdots\\
    \vdots\\
    \vdots\\
    k_7\\
    \ \\
    \ \\
    \ \\
    \ \\
    \ \\
    \ \\
    \ \\
    \ \\
    \ \\
    \ \\
    \ \\
    \ \\
    \ \\
    \ \\
    \ \\                
}
\end{array}
" valign="middle"/>
</pre>
<p><strong>2. Fall:</strong> Der String S ist gleich dem leeren Wort (d.h. der
Vereinbarungsteil von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> ist leer)</p>
<p>Dieser Fall ist ein Spezialfall von Fall 1. Wir erhalten
das resultierende Programm aus dem in Fall 1 angegebenen
Programm <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> durch Streichung der den String S betreffenden
Konstruktion. Im Einzelnen</p>
<ul>
<li>Streichung der Prozeduren <img src="/img/cache/2492ac3d9c30ee5642299a56d3f88e44.gif" alt="A^{7+1}" valign="middle"/> bis <img src="/img/cache/e3ac2f0eb2ee204cea0fbdc6642b552b.gif" alt="A^{7+p-1}" valign="middle"/></li>
<li>&Auml;nderung der Prozedur A in
<pre class="source"><strong>procedure</strong> A;<strong>begin</strong> WRITE('PROGRAM P(<img src="/img/cache/1d0fddfd0ff640932e4368a965c2afb9.gif" alt="\mu_1,\dots,\mu_k" valign="middle"/>,OUTPUT);')
            <strong>end</strong>;</pre></li>
<li>Streichung der Programmzeile mit dem Inhalt<br/>
<img src="/img/cache/5a554578f1a170226d226366469e479d.gif" alt="\tilde{\cal{G}}(2);\dots;\tilde{\cal{G}}(n);" valign="middle"/></li>
<li>Streichung der Programmzeilen<br/>
<img src="/img/cache/8a4b3997602f41fa8f199f82cfa2df93.gif" alt="k_{7+1}" valign="middle"/> bis <img src="/img/cache/62eaac27f4c808f5a1ee1723aa472229.gif" alt="k_{7+p-1}" valign="middle"/></li>
</ul>
 >
<p><em>Teil B</em></p>
<p><strong>1. Fall:</strong> S ist ungleich dem leeren Wort.</p>
<p>Die Konstruktion in Teil A liefert ein syntaktisch korrektes
PASCAL-Programm <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/>. Es bleibt zu zeigen, da&szlig; <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> eine
selbsreproduzierende Version von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> ist.</p>
<p><img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> realisiert eine Funktion<br/>
<img src="/img/cache/83b654415382dde9fe511a6306781b33.gif" alt="f_\pi\ :\ (A^*_{\text{PAS}})^r \longr (A^*_{\text{PAS}})^u\text{ mit }o\le u\le r" valign="middle"/>.</p>
<p>Der Vereinbarungsteil von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> wird in Form des Textes
<img src="/img/cache/951cc121092db5fe483cadf27004c0de.gif" alt="S = s_1\ \dots\ s_n" valign="middle"/> in das Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> unver&auml;ndert aufgenommen.
Im Anweisungsteil von <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> wird der in der Form
<img src="/img/cache/396b99f7b0a3edd086b151b48bba0c85.gif" alt="T'=t_1\ \dots\ t_m" valign="middle"/> &uuml;bernommene Anweisungsteil von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> zuerst
ausgef&uuml;hrt. Alle anderen Anweisungen sind nur Aufrufe von
Prozeduren, die nicht in S vereinbart sind. Bei jedem Aufruf
dieser Prozeduren wird genau eine Textkonstante auf die
Datei OUTPUT ausgegeben. Da <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> nur endlich viele Prozeduraufrufe
aufweist, wird insgesamt ein endlicher Text, also
ein Wort y aus <img src="/img/cache/a31ca22571d2a5a5831b987249565711.gif" alt="A^*_{\text{PAS}}" valign="middle"/>, auf die Datei OUTPUT ausgegeben. Die
Aufrufe dieser Ausgabeprozeduren erfolgen jedoch erst,
nachdem der Anweisungsteil T' abgearbeitet worden ist. <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/>
realisiert also die folgende Funktion:</p>
<p><img src="/img/cache/302703a7306010b98980bf979327408b.gif" alt="
f_{\tilde\pi}\ :\ (A^*_{\text{PAS}})^r \longr (A^*_{\text{PAS}})^u\ o\le u\le r\\
\text{mit}\\
(f_{\tilde\pi})_i(\overline{x}) = \left\{
    \begin{array}{ll}
	(f_\pi)_i(\overline{x}) &amp; \text{f\ddot{u}r }i\in[r-1]\\
        (f_\pi)_i\circ y	&amp; \text{f\ddot{u}r }i = r
    \end{array} \right\} {\overline{x}\in(A^*_{\text{PAS}})^r}
" valign="middle"/><br/>
falls <img src="/img/cache/4242968b9f08bce37f3e6a702db37498.gif" alt="\mu_r" valign="middle"/> = OUTPUT, d.h. <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> gibt y auf eine Ausgabedatei
aus, die auch <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> benutzt.<br/>
<img src="/img/cache/979ea44e4aab4a439ded7f4d641d5156.gif" alt="
\text{bzw.}\\
f_{\tilde\pi}\ :\ (A^*_{\text{PAS}})^{r+1} \longr (A^*_{\text{PAS}})^u\ o\le u\le r+1\\
\text{mit}\\
(f_{\tilde\pi})_i(\overline{x}) = \left\{
    \begin{array}{ll}
	(f_\pi)_i(\overline{x}) &amp; \text{f\ddot{u}r }i\in[r]\\
        y			&amp; \text{f\ddot{u}r }i = r+1
    \end{array} \right\} {\overline{x}\in(A^*_{\text{PAS}})^{r+1}}
" valign="middle"/><br/>
falls <img src="/img/cache/4242968b9f08bce37f3e6a702db37498.gif" alt="\mu_r" valign="middle"/> = OUTPUT, d.h. <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> gibt y auf die Datei OUTPUT
 
aus, die von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> nicht als Ausgabedatei benutzt wird.</p>
<p><img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> erf&uuml;llt also genau dann Definition (5.1.4), wenn der
Text <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> Teilstring von y ist.</p>
<p>Es gilt aber sogar <img src="/img/cache/1e397dd5fd74e0af90a50e893aed5d7d.gif" alt="y=\tilde\pi" valign="middle"/>, denn:<br/>
Nach Abarbeitung von <img src="/img/cache/499b85a606dd7de3788cc0c12fde40ef.gif" alt="t_1\ \dots\ t_m" valign="middle"/> gibt <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> zun&auml;chst durch
Aufruf der Prozedur A seinen eigenen Programmkopf
&lt;programm heading><img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> und <img src="/img/cache/54dbe5ef61d2f9977c7be03737833609.gif" alt="s_1" valign="middle"/> aus. Die n&auml;chsten Prozeduraufrufe</p>
<pre>
   <img src="/img/cache/2c1372371bd6b05ca0fe6089d6394bb7.gif" alt="\tilde\cal{G}(2);" valign="middle"/> ... bis ... <img src="/img/cache/d5ae8ade23aeb280d28d5342d1ba6333.gif" alt="\tilde\cal{G}(n);" valign="middle"/> erledigen die Ausgabe von
   <img src="/img/cache/59a121181a335c1b069426960cc2fbae.gif" alt="s_2" valign="middle"/>    ... bis ... <img src="/img/cache/effb8304d535bcb6e9e858a75593e93e.gif" alt="s_n" valign="middle"/>.
</pre>
<p>Die Prozeduraufrufe der Zeilen <img src="/img/cache/8a4b3997602f41fa8f199f82cfa2df93.gif" alt="k_{7+1}" valign="middle"/> bis <img src="/img/cache/a3d1054b1588356d0c8a72b85a36a51e.gif" alt="k_{7+p+q-2}" valign="middle"/> und <img src="/img/cache/5816a3210bbbab1d8dc57a0850a78101.gif" alt="k_1" valign="middle"/>
bis <img src="/img/cache/6ce40603ad98f764efc31bf42e4dbb2a.gif" alt="k_7" valign="middle"/> bewirken die Ausgabe der Prozedurvereinbarungen von
<img src="/img/cache/2492ac3d9c30ee5642299a56d3f88e44.gif" alt="A^{7+1}" valign="middle"/> bis <img src="/img/cache/73ed7ddd79352424362a36dcac7ea564.gif" alt="A^{7+p+q-2}" valign="middle"/> bzw. von A bis <img src="/img/cache/343bb72223d7f76edf7cf61c53b59d07.gif" alt="A^7" valign="middle"/>. Es fehlt nur noch de
Ausgabe von &lt;statement part><img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/>. Diese Ausgabe wird jedoch
durch die Folge
<img src="/img/cache/d000da134759af352fc3a8843471d285.gif" alt="\tilde\tau(1);\dots;\tilde\tau(m-1);A^7;" valign="middle"/> bewirkt. Das nachfolgende
WRITELN leert nur den Puffer der Datei OUTPUT.</p>
<p>Es gilt also <img src="/img/cache/1e397dd5fd74e0af90a50e893aed5d7d.gif" alt="y=\tilde\pi" valign="middle"/>. Damit ist <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> selbstreproduzierende
Version von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/>.</p>
<p><strong>2. Fall:</strong> S ist gleich dem leeren Wort</p>
<p>Fall 2 ergibt sich als Spezialfall von Fall 1. Es gilt
somit auch in diesem Fall, da&szlig; das erhaltene Programm <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/>
selbstreproduzierende Version von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> ist.</p>
<p>Damit ist der Satz vollst&auml;ndig bewiesen.</p>
<div align="right">%</div>
<p>Dem Beweis von Satz (5.2.4) la&szlig;t sich direkt ein
Algorithmus entnehmen, der zu jedem beliebigen PASCAL-Programm
<img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> eine selbstreproduzierende Version <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> findet.</p>
<p><strong>(5.2.5) Algorithmus:</strong></p>
<ul>
<li><strong>Eingabe:</strong> Das PASCAL-Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/>.</li>
<li><strong>1. Schritt:</strong> Test, ob keiner der in <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> vorkommenden
Bezeichner aus <img src="/img/cache/64b1713211785efe1f94689613b4cf92.gif" alt="\{A\}^+" valign="middle"/> ist. Gegebenenfalls
Umbenennung vornehmen.</li>
 
<li><strong>2. Schritt:</strong> Formulierung von &lt;program heading><img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> aus
&lt;program heading><img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> unter Verwendung der
Standarddatei OUTPUT.</li>
<li><strong>3. Schritt:</strong> Zerlegung von
<pre>
S = &lt;label declaration part><img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/>
    &lt;constant declaration part><img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/>
    &lt;type definition part><img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/>
    &lt;variable declaration part><img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/>
</pre>
in Teilstrings <img src="/img/cache/8ee103dda3356bece7c302d0a042c79b.gif" alt="s_1,\dots,s_n" valign="middle"/> und Ermittlung der
Anzahl p der Teilstrings <img src="/img/cache/14730a16e7ffd22066fda608764658c0.gif" alt="s_j" valign="middle"/> ungleich ' .
Anschlie&szlig;end Formulierung der p-1 Prozeduren
<img src="/img/cache/2492ac3d9c30ee5642299a56d3f88e44.gif" alt="A^{7+1}" valign="middle"/> bis <img src="/img/cache/e3ac2f0eb2ee204cea0fbdc6642b552b.gif" alt="A^{7+p-1}" valign="middle"/> und Aufstellung der Wertetabellen
von <img src="/img/cache/314f0036b33aa1148cbe231f83182879.gif" alt="\cal{G}" valign="middle"/> und <img src="/img/cache/fa9ccee3ce81a8706729246943f573f9.gif" alt="\tilde{\cal{G}}" valign="middle"/>.</li>
<li><strong>4. Schritt:</strong> ist das letzte Zeichen von
T=(&lt;statement part><img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> ohne klammerndes <strong>begin</strong>
<strong>end</strong>.) gleich ; , so wird T':=T gesetzt,
andernfalls T':=T;.
<p>Zerlegung von T' in <img src="/img/cache/499b85a606dd7de3788cc0c12fde40ef.gif" alt="t_1\ \dots\ t_m" valign="middle"/> und Ermittlung der
Zahl q. Anschlie&szlig;end Formulierung der q-1 Prozeduren
<img src="/img/cache/557504adc8cd385ec07478d773a7ac66.gif" alt="A^{7+p}" valign="middle"/> bis <img src="/img/cache/73ed7ddd79352424362a36dcac7ea564.gif" alt="A^{7+p+q-2}" valign="middle"/> und Aufstellung der
Wertetabellen von <img src="/img/cache/a6f317b268ae825d94f832f970af607c.gif" alt="\tau" valign="middle"/> und <img src="/img/cache/c80dc7396cddee2e3b36211de213b695.gif" alt="\tilde\tau" valign="middle"/>.</p></li>
<li><strong>5. Schritt:</strong> Einsetzen der erhaltenen Funktionswerte,
Prozedurenund Teilstrings <img src="/img/cache/9546ba864a28d8062281cb67e6d4eef7.gif" alt="s_1,\dots,s_n,t_1,\dots,t_m" valign="middle"/>
in das im Beweis angegebene Programmschema.</li>
<li><strong>Aufwand:</strong> Der Algorithmus verh&auml;lt sich linear zur
L&auml;nge <img src="/img/cache/813ad0a277235ece42a2f3ad9b395a09.gif" alt="l(\pi)" valign="middle"/> des Programms <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/>.</li>
</ul>
<p><strong>(5.2.6) Beispiel:</strong> Gegeben sei das in [28] Seite 17
zu findende Programm.</p>
<pre class="source"><img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> =
<strong>program</strong> CONVERT(OUTPUT);
<strong>const</strong> ADDIN=32;MULBY=1.8;LOW=0;HIGH=39;
      SEPARATOR='__________';
<strong>var</strong> DEGREE : LOW .. HIGH;
<strong>begin</strong>
WRITELN(SEPARATOR);
<strong>for</strong> DEGRSE:=LOW <strong>to</strong> HIGH <strong>do</strong>
 
<strong>begin</strong> WRITE(DEGREE,'C',ROUND(DEGREE*MULBY+ADDIN),'F');
      <strong>if</strong> ODD(DEGREE) <strong>then</strong> WRITELN
<strong>end</strong>;
WRITELN;
WRITELN(SEPARATOR)
<strong>end</strong>.
</pre>
<p><strong>Anwendung von Algorithmus (5.2.5):</strong></p>
<ul>
<li><strong>1. Schritt:</strong> <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> enth&auml;lt keinen Bezeichnen aus <img src="/img/cache/64b1713211785efe1f94689613b4cf92.gif" alt="\{A\}^+" valign="middle"/>. Es sind
also keine Umbenennungen n&ouml;tig.</li>
<li><strong>2. Schritt:</strong> &lt;program heading><img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> wird auf
<pre class="source"><strong>program</strong> CONVERT(OUTPUT);</pre>
gesetzt.</li>
<li><strong>3. Schritt:</strong>
<pre>
S = <img src="/img/cache/36a6a247456f373eb4f3842a8a71f4d4.gif" alt="s_1 s_2 s_3 s_4 s_5" valign="middle"/> mit
<img src="/img/cache/54dbe5ef61d2f9977c7be03737833609.gif" alt="s_1" valign="middle"/> = <strong>const</strong> ADDIN=32;MULBY=1.8;LOW=0;HIHG=39;
     SEPARATOR=
<img src="/img/cache/59a121181a335c1b069426960cc2fbae.gif" alt="s_2" valign="middle"/> = '
<img src="/img/cache/5189df23f3e0b16d8671cff34c29839a.gif" alt="s_3" valign="middle"/> = ----------
<img src="/img/cache/ac56fe358e3e76db7c6f848a3accdbfb.gif" alt="s_4" valign="middle"/> = '
<img src="/img/cache/14c5a6d3c71c2d70016f32182568b1c4.gif" alt="s_5" valign="middle"/> = ;<strong>var</strong> DEGREE:LOW..HIGH;
</pre>
Es gilt n=5, p=3<br/>
Die resultierenden Prozeduren sind:
<pre class="source"><strong>procedure</strong> <img src="/img/cache/165dec0dfcdb7734a56af84dbff6c005.gif" alt="A^8" valign="middle"/>;<strong>begin</strong> WRITE('__________') <strong>end</strong>;
<strong>procedure</strong> <img src="/img/cache/27d6469ade1248040c4c501d23bb1402.gif" alt="A^9" valign="middle"/>;<strong>begin</strong> WRITE(';VAR DEGREE:L0W..
    HIGH;') <strong>end</strong>;</pre>
Wertetabellen von <img src="/img/cache/e3556d90f5424558d9b8d28fae296683.gif" alt="\calG" valign="middle"/> und <img src="/img/cache/9ee7ebd7ca9329b9d4039f04132b5c5d.gif" alt="\tilde\calG" valign="middle"/>:<br/>
<img src="/img/cache/12a4b12ac6bc32038b8221b1b870492d.gif" alt="
\begin{align}
\calG(1) = s_1	&amp; \tilde\calG(1) = \perp\\
\calG(2) = s_3	&amp; \tilde\calG(2) = A^5\\
\calG(3) = s_5	&amp; \tilde\calG(3) = A^8\\
		&amp; \tilde\calG(4) = A^5\\
		&amp; \tilde\calG(5) = A^9\\
\end{align}
" valign="middle"/></li>
<li><strong>4. Schritt</strong>
<pre>
T=<img src="/img/cache/c48dd7e23f912414a4395f413498c955.gif" alt="t_1t_2t_3t_4t_5t_6t_7t_8t_9" valign="middle"/> mit
<img src="/img/cache/69ac49315fb75559bc7125a373ed5735.gif" alt="t_1" valign="middle"/> = WRITELN(SEPARATOR);FOR DEGREE:=LOW TO
     HIGH DO BEGIN WRITE('DEGREE,
<img src="/img/cache/76a9c0f8e913d97ec097e88ed8232da5.gif" alt="t_2" valign="middle"/> = '
<img src="/img/cache/990bbd241420ec38a3a9ce341c2838e9.gif" alt="t_3" valign="middle"/> = C
 
<img src="/img/cache/364e0a98fc167ee2428b1da6b2b0485f.gif" alt="t_4" valign="middle"/> = '
<img src="/img/cache/7aa0f72579aa595b7f0a5f1550442459.gif" alt="t_5" valign="middle"/> = ROUND(DEGBEE*MULBY+ADDIN),
<img src="/img/cache/4f9c24198b783482e2b320d0dba78124.gif" alt="t_6" valign="middle"/> = '
<img src="/img/cache/f458fe91c24fe1349bcf774c12aa8a31.gif" alt="t_7" valign="middle"/> = F
<img src="/img/cache/b409b63d32faf9ae549e1eb08ce8b46f.gif" alt="t_8" valign="middle"/> = '
<img src="/img/cache/9a1460ddffd61f790e772db37afdbd6f.gif" alt="t_9" valign="middle"/> = );IF ODD(DEGREE) THEN WRITELN END;
         WRITELN;WRITELN(SEPARATOR);
</pre>
Es gilt: m=9, q=5<br/>
Die resultierenden Prozeduren sind:
<pre class="source">    
<strong>procedure</strong> <img src="/img/cache/f417b90aee61277e00a03da59dc63b65.gif" alt="A^{10}" valign="middle"/>;<strong>begin</strong> WRITE('BEGIN WRITELN(SEPARATOR);
   FOR DEGREE:=LOW TO HIGH DO BEGIN WRITE(DEGREE),') <strong>end</strong>;
<strong>procedure</strong> <img src="/img/cache/bd21b51ceadb2b755901a044302d1c2e.gif" alt="A^{11}" valign="middle"/>;<strong>begin</strong> WRITE('C') <strong>end</strong>;
<strong>procedure</strong> <img src="/img/cache/a63af878505c3a28c5d5b41215e6c6d2.gif" alt="A^{12}" valign="middle"/>;<strong>begin</strong> WRITE('ROUND(DEGREE*MULBY+ADDIN),') <strong>end</strong>;
<strong>procedure</strong> <img src="/img/cache/ba4e8fb899c1b838d16087d3a4b5c7ef.gif" alt="A^{13}" valign="middle"/>;<strong>begin</strong> WRITE('F') <strong>end</strong>;
</pre>
Wertetabellen von <img src="/img/cache/a6f317b268ae825d94f832f970af607c.gif" alt="\tau" valign="middle"/> und <img src="/img/cache/c80dc7396cddee2e3b36211de213b695.gif" alt="\tilde\tau" valign="middle"/>:<br/>
<img src="/img/cache/298391a6b5b28defb2c52e33adf196fd.gif" alt="
\begin{array}{lll}
    \tau(1)=t_1 &amp; \tilde\tau(1)=A^{10}	&amp; \tilde\tau(6)=A^5	\\
    \tau(2)=t_3 &amp; \tilde\tau(1)=A^5	&amp; \tilde\tau(7)=A^{13}	\\
    \tau(3)=t_5 &amp; \tilde\tau(1)=A^{11}	&amp; \tilde\tau(8)=A^5	\\
    \tau(4)=t_7 &amp; \tilde\tau(1)=A^5	&amp; \tilde\tau(9)=\perp	\\
    \tau(5)=t_9 &amp; \tilde\tau(1)=A^{12}	&amp;			\\
\end{array}
" valign="middle"/></li>
<li><strong>5. Schritt:</strong>
<pre class="source"><img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> =
<strong>program</strong> CONVERTX(OUTPUT);
<strong>const</strong> ADDIN=32;MULBT=1.8;LOW=0;HIGH=39;SEPARATOR='__________';
<strong>var</strong> DEGREE:LOW..HIGH;
<strong>procedure</strong> <img src="/img/cache/165dec0dfcdb7734a56af84dbff6c005.gif" alt="A^8" valign="middle"/>;<strong>begin</strong> WRITE('__________') <strong>end</strong>;
<strong>procedure</strong> <img src="/img/cache/27d6469ade1248040c4c501d23bb1402.gif" alt="A^9" valign="middle"/>;<strong>begin</strong> WRITE(';VAR DEGREE:LOW..HIGH;') <strong>end</strong>;
<strong>procedure</strong> <img src="/img/cache/f417b90aee61277e00a03da59dc63b65.gif" alt="A^{10}" valign="middle"/>;<strong>begin</strong> WRITE('BEGIN WEITELN(SEPARATOR);FOR
   DEGREE:=LOW TO HIGH DO BEGIN WRITE(DEGREE)') <strong>end</strong>;
<strong>procedure</strong> <img src="/img/cache/bd21b51ceadb2b755901a044302d1c2e.gif" alt="A^{11}" valign="middle"/>;<strong>begin</strong> WRITE('C') <strong>end</strong>;
<strong>procedure</strong> <img src="/img/cache/a63af878505c3a28c5d5b41215e6c6d2.gif" alt="A^{12}" valign="middle"/>;<strong>begin</strong> WRITE(,ROUND(DEGREE*MULBY+ADDIN),'
   ) <strong>end</strong>;
<strong>procedure</strong> <img src="/img/cache/ba4e8fb899c1b838d16087d3a4b5c7ef.gif" alt="A^{13}" valign="middle"/>;<strong>begin</strong> WRITE('F') <strong>end</strong>;
<strong>procedure</strong> A;<strong>begin</strong> WRITE('PROGRAM CONVERTX(OUTPUT);CONST
   ADDIN=32;MULBY=1.8;LOW=0;HIGH=39;SEPARATOR=') <strong>end;</strong>
 
<strong>procedure</strong> <img src="/img/cache/372c8c0974114a670f97d71577e77b98.gif" alt="A^2" valign="middle"/>;<strong>begin</strong> WRITE('PROCEDURE ') <strong>end</strong>;
<strong>procedure</strong> <img src="/img/cache/b4cddc5b73d75b560a023245d529dc11.gif" alt="A^3" valign="middle"/>;<strong>begin</strong> WRITE(';BEGIN WRITE(''') <strong>end</strong>;
<strong>procedure</strong> <img src="/img/cache/043aced3ddc3a4f1404af4429a3d1f0b.gif" alt="A^4" valign="middle"/>;<strong>begin</strong> WRITE(''') END;') <strong>end</strong>;
<strong>procedure</strong> <img src="/img/cache/a5c0ac33cf92038d4a2aa773e2cb482b.gif" alt="A^5" valign="middle"/>;<strong>begin</strong> WBITE('''') <strong>end</strong>;
<strong>procedure</strong> <img src="/img/cache/e945a87750e6965a1bdbfeeaf4fe2db9.gif" alt="A^6" valign="middle"/>;<strong>begin</strong> WRITE('A') <strong>end</strong>;
<strong>procedure</strong> <img src="/img/cache/343bb72223d7f76edf7cf61c53b59d07.gif" alt="A^7" valign="middle"/>;<strong>begin</strong> WRITE(');IF ODD(DEGREE) THEN WRITELN
   END;WRITELN;WRITELN(SEPARATOR); <img src="/img/cache/678614555c8184bb905e8808b2692c69.gif" alt="\sout[+1]\otimes" valign="middle"/> END.') <strong>end</strong>;
<strong>begin</strong>
WRITELN(SEPARATOR);
<strong>for</strong> DEGREE:=LOW <strong>to</strong> HIGH <strong>do</strong>
<strong>begin</strong> WRITE(DEGREE,'C',ROUND(DEGREE*MULBY+ADDIN),'F');
      <strong>if</strong> ODD(DEGREE) <strong>then</strong> WRITELN
<strong>end</strong>;
WRITELN;
WRITELN(SEPARATOR);
<img src="/img/cache/f389863c93bbf8421436208251fe1eaf.gif" alt="
\left.
A;\\
A^5;A^8;A^5;A^9;\\
A^2;(A^6;)^8 A^3;A^8;A^4;\\
A^2;(A^6;)^9 A^3;A^9;A^4;\\
A^2;(A^6;)^{10} A^3;A^{10};A^4;\\
A^2;(A^6;)^{11} A^3;A^{11};A^4;\\
A^2;(A^6;)^{12} A^3;A^{12};A^4;\\
A^2;(A^6;)^{13} A^3;A^{13};A^4;\\
A^2;A^6;A^3;A;A^4;\\
A^2;(A^6;)^2 A^3;A^2;A^4;\\
A^2;(A^6;)^3 A^3;A^5;A^3;A^4;\\
A^2;(A^6;)^4 A^3;A^5;A^4;A^4;\\
A^2;(A^6;)^5 A^3;A^5;A^5;A^4;\\
A^2;(A^6;)^6 A^3;A^6;A^4;\\
A^2;(A^6;)^7 A^3;A^7;A^4;\\
A^{10};A^5;A^{11};A^5;A^{12};A^5;A^{13};A^5;A^7;\\
\text{WRITELN}\\
\right\}\sout[+1]\otimes
" valign="middle"/>
<strong>end</strong>.
</pre>
<p>Die Bedeutung von Satz (5.2.4) ist in erster Linie theoretischer
und nicht praktischer Art. Satz (5.2.4) beweist
zwar die Existenz einer selbstreproduzierenden Version <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/>
f&uuml;r jedes g&uuml;ltige PASCAL-Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle"/> und gibt auch eine
Konstruktion f&uuml;r ein syntaktisch richtiges <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> an, jedoch
 
garantiert die syntaktische Korrektheit noch, nicht die Realisierbarkeit
von <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> auf einer konkreten Rechenmaschine.</p>
<p>Die Implementierung eines von Algorithmus (5.2.5) gelieferten
Programms <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> kann zu folgenden Schwierigkeiten
f&uuml;hren:</p>
<ol type="i">
<li>Der l&auml;ngste Prozedurname von <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> ist <img src="/img/cache/73ed7ddd79352424362a36dcac7ea564.gif" alt="A^{7+p+q-2}" valign="middle"/>. <img src="/img/cache/73ed7ddd79352424362a36dcac7ea564.gif" alt="A^{7+p+q-2}" valign="middle"/>
ist p+q+5 Zeichen lang. Jedes dieser Zeichen ist
signifikant, da auch, der Prozedurname <img src="/img/cache/dd6d0bd4996696dbd0374aed302d6974.gif" alt="A^{7+p+q-3}" valign="middle"/> mit der
L&auml;nge p+q+4 in <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> vorkommt. Die zul&auml;ssige Signifikanz
von Bezeichnern ist bei implementierten PASCAL-Compilern
aber beschr&auml;nkt. Die Zahlen p und q sind jedoch
nur endlich, was zur Folge hat, da&szlig; bei gro&szlig;en
p und q einige Prozeduren nicht unterschieden werden
k&ouml;nnen.</li>
<li>Die L&auml;nge der durch (5.2.5) entstehenden Textkonstanten
in den Prozeduren <img src="/img/cache/438d7a9df7ad0230c8923534d633abc7.gif" alt="A^j,\ j\in[p+q-2]" valign="middle"/>, ist f&uuml;r die
Gesamtheit aller PASCAL-Programme <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> nicht beschr&auml;nkt.
Damit ist auch die L&auml;nge einer Programmzeile nicht
beschr&auml;nkt. Die L&auml;nge einer Programmzeile ist auf
realen Rechenanlagen aber oft durch die L&auml;nge des
Eingabepuffers des implementierten PASCAL-Compilers
beschr&auml;nkt.</li>
</ol>
<p>Die Schwierigkeiten (i) und (ii) lassen sich bei vielen in
der Praxis vorkommenden Programmen vermeiden, indem man
Algorithmus (5.2.5) um zwei "praxisorientierte" Schritte
erg&auml;nzt.</p></li>
<li><strong>6. Schritt:</strong> Sei g die Anzahl der signifikanten Zeichen von
Bezeichnern bei dem vorliegenden PASCAL-Compiler. Sei
a:=7+p+q-2=p+q+5 die L&auml;nge des Prozedurnamen <img src="/img/cache/4a7d3b5f1e2de2721876ceeb1a4c19dd.gif" alt="A^{p+q+5}" valign="middle"/>.
a ist gleichzeitig die Anzahl der Prozedurnamen vom
Typ <img src="/img/cache/01e339ead58f2760175d1955b17c63a4.gif" alt="A^j,\ j\in[a]" valign="middle"/>. Dann w&auml;hle manzwei nat&uuml;rliche Zahlen
<img src="/img/cache/9d9f4349c0dd6d569b2695cbffcbfc98.gif" alt="c\le26" valign="middle"/> und <img src="/img/cache/8c1ce7b95fe0f6bcffa58799c0f77df3.gif" alt="b\le g" valign="middle"/> mit<br/>
<img src="/img/cache/8af14e16d82516f256b50332df2c43db.gif" alt="(1)\hspace{100} \sum_{k=1}^b c^k \ge a" valign="middle"/>
<p>Nun k&ouml;nnen die Prozedurnamen <img src="/img/cache/2afa7b60f5ed3fcef2120f6c3a7f59b8.gif" alt="A^1" valign="middle"/> bis <img src="/img/cache/73ed7ddd79352424362a36dcac7ea564.gif" alt="A^{7+p+q-2}" valign="middle"/> durch
neue Namen ersetzt werden, die maximal b Zeichen lang
 
sind und aus den c ersten Buchstaben des Alphabets
zusammengesetzt sind. Au&szlig;er dem Buchstaben A k&ouml;nnen
also c-1 weitere Buchstaben zur Bildung von Prozedurnamen
herangezogen werden. Zu diesen c-1 Buchstaben
m&uuml;ssen aber c-1 neue Prozeduren generiert werden, die
jeweils einen neuen Buchataben ausdrucken:<br/>
<img src="/img/cache/1b0d17fef1464bb28932bf39382d1c9f.gif" alt="
\left.
\begin{eqnarray}
    \text{\underline{procedure}} &amp;\dots&amp;;\text{\underline{begin} WRITE ('B') \underline{end};}\\
    \text{\underline{procedure}} &amp;\dots&amp;;\text{\underline{begin} WRITE ('C') \underline{end};}\\
				&amp;\vdots&amp;\\
				&amp;\vdots&amp;\\
\end{eqnarray} \right\}{c-1}
" valign="middle"/></p>
<p>F&uuml;r diese Prozeduren werden aber auch Namen ben&ouml;tigt.
Daher m&uuml;ssen die Zahlen c und b auch die Relation<br/>
<img src="/img/cache/38a7f60c7e0306c74c6d60d82ff6b8c1.gif" alt="(1')\hspace{100}\sum_{k=1}^b c^k \ge a+c-1" valign="middle"/> erf&uuml;llen.</p></li>
<li><strong>7. Schritt:</strong> Sei d die Eingabepufferi&auml;nge des zur Verf&uuml;gung
stehenden PASCAL-Compilers. Seien <img src="/img/cache/759f73cd95d2669c8ddc6fb07473d8f8.gif" alt="v_i,\ i\in[p+q-2]" valign="middle"/>, die
Textkonstanten der Prozeduren <img src="/img/cache/437d10b7b333561f6ed1ea82e913c015.gif" alt="A^i" valign="middle"/> (diese Prozeduren
sind m&ouml;glicherweise in Schritt 6 bereits umbenannt
worden). F&uuml;r jedes <img src="/img/cache/89d8e9ebe5db17774319ad3c56ae5e41.gif" alt="i\in[p+q-2]" valign="middle"/> mu&szlig; die folgende
Berechnung ausgef&uuml;hrt werden:
<p>Ist <img src="/img/cache/6dd0c1dff5c1c859691d7537c96fb729.gif" alt="\text{l(WRITE(\'v_i\'))\le d}" valign="middle"/><sup><a href="#p118_1" name="b118_1">1)</a></sup>, so bleibt <img src="/img/cache/437d10b7b333561f6ed1ea82e913c015.gif" alt="A^i" valign="middle"/> unver&auml;ndert.
Andernfalls wird <img src="/img/cache/1df181eaa1bb40a0067c06ead197170d.gif" alt="v_i" valign="middle"/> in <img src="/img/cache/34c1d173d638ceb8fb5bec184c055549.gif" alt="k_i" valign="middle"/> Teilstrings <img src="/img/cache/96507940e913e1b455642ab64e9ef0c9.gif" alt="v_{¦j}" valign="middle"/> zerlegt mit
<img src="/img/cache/98cda9ce91df7a8fa351e295e1f84cda.gif" alt="\text{l(WRITE(\'v_{ij}\'))\le d,\ \forall j\in[k_i]}" valign="middle"/>. Dabei sei <img src="/img/cache/34c1d173d638ceb8fb5bec184c055549.gif" alt="k_i" valign="middle"/> minimal
gew&auml;hlt.</p>
<p>Die Prozedur <img src="/img/cache/437d10b7b333561f6ed1ea82e913c015.gif" alt="A^i" valign="middle"/> wird durch <img src="/img/cache/34c1d173d638ceb8fb5bec184c055549.gif" alt="k_i" valign="middle"/> neue Prozeduren ersetzt:<br/>
<img src="/img/cache/cf40e05bcd5a614f469a663f8b2ff57a.gif" alt="
\begin{array}{lclc}
\text{\underline{procedure}}&amp; \dots&amp; ;\text{\underline{begin} WRITE(\'v_{i1}\')}&amp; \text{\underline{end};}\\
			    &amp;\vdots&amp;						&amp; \vdots\\
			    &amp;\vdots&amp;						&amp; \vdots\\
\text{\underline{procedure}}&amp; \dots&amp; ;\text{\underline{begin} WRITE(\'v_{ik_i}\')}&amp; \text{\underline{end};}
\end{array}
" valign="middle"/></p>
<p>Entsprechend der neu eingef&uuml;hrten Prozeduren wird die
Aufruffoige der Prozeduren, die die Ausgabe von <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/>
bewirkt, erg&auml;nzt.</p></li>
</ul>
 
<p>Die schritte 6 und 7 f&uuml;hren jedoch nicht immer zum Ziel.</p>
<p>Ist die Eingabepufferl&auml;nge d des zur Verf&uuml;gung stehenden
PASCAL-Compilers relativ gering, so werden in Schritt 7
in der Regel sehr viele neue Prozeduren generiert. Sicherlich
wird dabei auch die Textkonstante der - m&ouml;glicherweise
in Schritt 6 umbenannten - Prozedur <img src="/img/cache/343bb72223d7f76edf7cf61c53b59d07.gif" alt="A^7" valign="middle"/>, die den
Ausgabealgoritnmus f&uuml;r <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> enth&auml;lt, auf mehrere neue
Prozeduren aufgespalten. Neue Prozeduren bedingen einen l&auml;ngeren
Ausgabealgorithmus, wenn <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> selbstreprcduzierend bleiben
soll. Das bedeutet aber, da&szlig; noch mehr Prozeduren zur Aufnahme
des Ausgabealgorithmus n&ouml;tig sind. Noch mehr Prozeduren
bewirken aber eine erneute Verl&auml;ngerung des Ausgabealgorithmus,
was noch mehr Prozeduren bewirkt, u.s.w.
Ist d nun relativ gering, so kann es geschehen, da&szlig; sich
dieser Proze&szlig; nicht stabilisiert und Schritt 7 zu einem
unendlichen Programm f&uuml;hrt. Das ist genau dann der Fall, wenn
die Textkonstanten der den Ausgabealgorithmus enthaltenden
Prozeduren durchschnittlich weniger Prozeduraufrufe enthalten,
als zur Ausgabe der Prozedurvereinbarung einer Ausgabeprozedur
erforderlich ist. Das sprunghafte Anwachsen der
Anzahl der Ausgabeprozeduren kann zu einer wiederholten
Durchf&uuml;hrung von Schritt 6 f&uuml;hren. Noch komplizierter werden
die Verh&auml;ltnisse, wenn die Ausgabe von <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> formatiert werden
soll.</p>
<p><strong>(5.2.7) Beispiel:</strong> Das in Beispiel (5.2.6) enthaltene
Programm <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle"/> soll implementiert werden.</p>
<ul>
<li><strong>6. Schritt:</strong> Programm <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /> weist 13 Prozedurnamen vom Typ <img src="/img/cache/437d10b7b333561f6ed1ea82e913c015.gif" alt="A^i" valign="middle" /> auf.
    Der vorhandene PASCAL-Compiler wertet nur die
    ersten 8 Zeichen eines Bezeichners als signifikant.
    Einige der <img src="/img/cache/437d10b7b333561f6ed1ea82e913c015.gif" alt="A^i" valign="middle" /> m&uuml;ssen also umbenannt werden.
    Die Prozeduren <img src="/img/cache/bd21b51ceadb2b755901a044302d1c2e.gif" alt="A^{11}" valign="middle" /> und <img src="/img/cache/826622f5ae8e4148c22d6275b607f36b.gif" alt="A^13" valign="middle" /> stellen zuf&auml;llig
    die beiden Buchstaben C und F zur Verf&uuml;gung. Zur
    Umbenennung der 13 Prozeduren <img src="/img/cache/425aea61859f2d5fd55140ee26a9700d.gif" alt="A^1,\dots,A^{13}" valign="middle" /> sollen
    aber insgesamt 4, Buchstaben herangezogen werden.
    Es wird deshalb zus&auml;tzlich die Prozedur
    <pre class="source"><strong>procedure</strong> BB;<strong>begin</strong> WRITE('B') <strong>end</strong>;</pre>
    in das Programm <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /> aufgenommen.
<!--p.119-->
    <p>Mit den 4 Buchstaben A,B,C und F lassen sich<br />
     4 verschiedene Namen der L&auml;nge 1,<br />
    16 verschiedene Namen der L&auml;nge 2 und<br />
    64 verschiedene Namen der L&auml;nge 3 bilden.</p>
    <p>Auch wenn Schritt 7 weitere Prozeduren liefern
    sollte, ist anzunehmen, da&szlig; mit c=4 und b=3
    gen&uuml;gend viele Namen zur Verf&uuml;gung stehen. Wir
    werden versuchen, mit Namen der L&auml;ngen 1 und 2
    auszukommen.</p>
    <p>Die Prozeduren <img src="/img/cache/961934bec3582f0bd4d566aed7f65b0b.gif" alt="A^i,\ i\in[13]" valign="middle" />, werden wie folgt
    umbenannt:</p>
<pre><img src="/img/cache/2afa7b60f5ed3fcef2120f6c3a7f59b8.gif" alt="A^1" valign="middle" />	in	AA		<img src="/img/cache/165dec0dfcdb7734a56af84dbff6c005.gif" alt="A^8" valign="middle" />	in	AF
<img src="/img/cache/372c8c0974114a670f97d71577e77b98.gif" alt="A^2" valign="middle" />	in	A		<img src="/img/cache/27d6469ade1248040c4c501d23bb1402.gif" alt="A^9" valign="middle" />	in	CB
<img src="/img/cache/b4cddc5b73d75b560a023245d529dc11.gif" alt="A^3" valign="middle" />	in	B		<img src="/img/cache/f417b90aee61277e00a03da59dc63b65.gif" alt="A^{10}" valign="middle" />	in	CC
<img src="/img/cache/043aced3ddc3a4f1404af4429a3d1f0b.gif" alt="A^4" valign="middle" />	in	C		<img src="/img/cache/bd21b51ceadb2b755901a044302d1c2e.gif" alt="A^{11}" valign="middle" />	in	BC
<img src="/img/cache/a5c0ac33cf92038d4a2aa773e2cb482b.gif" alt="A^5" valign="middle" />	in	F		<img src="/img/cache/a63af878505c3a28c5d5b41215e6c6d2.gif" alt="A^{12}" valign="middle" />	in	CF
<img src="/img/cache/043aced3ddc3a4f1404af4429a3d1f0b.gif" alt="A^4" valign="middle" />	in	BA		<img src="/img/cache/ba4e8fb899c1b838d16087d3a4b5c7ef.gif" alt="A^{13}" valign="middle" />	in	BF
<img src="/img/cache/343bb72223d7f76edf7cf61c53b59d07.gif" alt="A^7" valign="middle" />	in	AC
</pre></li>
    <li><strong>7. Schritt:</strong> Die L&auml;nge jeder Programmzeile sei auf 132 Zeichen
    beschr&auml;nkt. Damit braucht nur die Textkonstante
    der Prozedur AC auf mehrere Prozeduren
    aufgespalten zu werden. Der f&uuml;r diese Prozeduren
    notwendige Verwaltungsaufwand im Algorithmus
    von <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /> bewirkt, da&szlig; insgesamt 4 neue Prozeduren
    FA,FB,FC und FF eingef&uuml;hrt werden m&uuml;ssen.
    <p>Anhang A.12. zeigt das durch die Schritte 6
    und 7 ver&auml;nderte Programm <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" />. Zur Formatierung
    der Ausgabe wurde in das Programm die aus 3.3.4.
    bekannte Prozedur Q eingef&uuml;gt.</p></li>
</ul>
<h3><a name="c53"></a>5.3. Selbstreproduktionssatz f&uuml;r die Programmiersprache SIMULA</h3>
<p>Die in den Kapiteln 3 und 4 vorgestellten Beispielprogramme
in SIMULA und PASCAL entsprechen sich weitgehend. Zum
selbstreproduzierenden PASCAL-Programm <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle" /> aus (3.3.2.)
<!--p.119-->
existiert ein nahezu identisches SIMULA-Programm <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle" /> in
3.2.7. . Da der Beweis von Satz (5.2.4) in wesentlichen
auf der Existenz von <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle" /> beruht, ist anzunehmen, da&szlig; bez&uuml;glich
der Programmiersprache SIMULA ein entsprechender Satz
gilt. Der Beweis dieses Satzes wird sich wie der Beweis
von (5.2.4) in zwei Teile A und B gliedern. In Teil A wird
die Konstruktion der selbstreproduzierenden Version <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /> eines
beliebigen SIMULA-Programms <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> erfolgen. Trotz der Entsprechung
von <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle" /> und <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle" /> mu&szlig; diese Konstruktion explizit angegeben
werden, da SIMULA im Gegensatz zu PASCAL eine blockorientierte
Programmiersprache ist. Das aus Teil A resultierende
Programm <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /> wird aber weitgehend dem in Teil A von
dem Beweis zu (5.2.4) konstruierten Programm entsprechen.
Zum Nachweis, da&szlig; <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /> selbstreproduzierende Version von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> ist,
wird in Teil B ein Verweis auf Teil B vom Beweis zu (5.2.4)
gen&uuml;gen. Der Beweis wird sich an der in [19] angegebenen
SIMULA-Grammatik orientieren. Diese Grammatik sei mit <img src="/img/cache/bbad39b525d5e08b0c4ac8661f75ce86.gif" alt="G_{\text{SIM}}" valign="middle" />
bezeichnet. F&uuml;r <img src="/img/cache/bbad39b525d5e08b0c4ac8661f75ce86.gif" alt="G_{\text{SIM}}" valign="middle" /> &uuml;bernehmen wir die Vereinbarung (5.2.2).
Au&szlig;erdem &uuml;bernehmen wir Vereinbarung (5.2.3) f&uuml;r die
Prozedurnamen von <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle" />. Damit pr&auml;sentiert sich <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle" />, in der Form:</p>
<pre class="source"><img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle" /> = 
<strong>begin</strong>
<strong>procedure</strong> A;OUTTEXT("BEGIN PROCEDURE A;OUTTEXT(""");
<strong>procedure</strong> <img src="/img/cache/372c8c0974114a670f97d71577e77b98.gif" alt="A^2" valign="middle" />;OUTTEXT("PROCEDURE  ");
<strong>procedure</strong> <img src="/img/cache/b4cddc5b73d75b560a023245d529dc11.gif" alt="A^3" valign="middle" />;OUTTEXT(" ;OUTTEXT(""");
<strong>procedure</strong> <img src="/img/cache/043aced3ddc3a4f1404af4429a3d1f0b.gif" alt="A^4" valign="middle" />;OUTTEXT(""");");
<strong>procedure</strong> <img src="/img/cache/a5c0ac33cf92038d4a2aa773e2cb482b.gif" alt="A^5" valign="middle" />;OUTTEXT("""");
<strong>procedure</strong> <img src="/img/cache/e945a87750e6965a1bdbfeeaf4fe2db9.gif" alt="A^6" valign="middle" />;OUTTEXT("A");
<strong>procedure</strong> <img src="/img/cache/343bb72223d7f76edf7cf61c53b59d07.gif" alt="A^7" valign="middle" />;OUTTEXT("<img src="/img/cache/41ad1a8ac73ec765661457f926292597.gif" alt="A;A;A^5;A^4;A^2;(A^6;)^2 A^3;A^2;A^4;A^2;(A^6;)^3" valign="middle" />
   <img src="/img/cache/2f11290b114f4b65bd18edf65813f941.gif" alt="A^3;A^3;A^5;A^4;A^2;(A^6;)^4 A^3;A^5;A^4;A^4;A^2;(A^6;)^5 A^3;A^5;A^5;A^4" valign="middle" />
   <img src="/img/cache/637591c899e1442ec588270afddda83f.gif" alt=";A^2;(A^6;)^6 A^3;A^6;A^4;A^2;(A^6;)^7 A^3;A^7;A^4;A^7" valign="middle" /> END");
<img src="/img/cache/6437886ffe1417836eef0a389e84f5bd.gif" alt="
A;A;A^5;A^4;\\
A^2;(A^6;)^2 A^3;A^2;A^4;\\
A^2;(A^6;)^3 A^3;A^3;A^5;A^4;\\
A^2;(A^6;)^4 A^3;A^5;A^4;A^4;\\
A^2;(A^6;)^5 A^3;A^5;A^5;A^4;\\
A^2;(A^6;)^6 A^3;A^6;A^4;" valign="middle" />
<!--p.121-->
<img src="/img/cache/bd19fc9943aeb2419de43882d799a97b.gif" alt="A^2;(A^6;)^7 A^3;A^7;A^4;A^7" valign="middle" />
<strong>end</strong>
</pre>
<p><strong>(5.3.1) Satz (Selbstreproduktionssatz f&uuml;r SIMULA-Programme)</strong></p>
<p>Zu jedem syntaktisch korrekten SIMULA-Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" />
existiert eine selbstreproduzierende Version <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" />.</p>
<p><strong>Beweis</strong></p>
<p><em>Teil A</em></p>
<p>Das Programm <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle" /> hat laut Grammatik <img src="/img/cache/bbad39b525d5e08b0c4ac8661f75ce86.gif" alt="G_{\text{SIM}}" valign="middle" /> den folgenden
Aufbau:</p>
<pre>
  <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle" /> = <strong>begin</strong> &lt;Vereinbarung> -Folge <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle" />
              &lt;Anweisung> -Folge <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle" /> <strong>end</strong>
</pre>
<p>Sei <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> ein beliebiges SIMULA-Programm. Dann hat <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> den
Aufbau:</p>
<pre>
  <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> = &lt;Klassenbezeichnung><img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" />
       &lt;akt. Parameterteil> -option <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" />
       <strong>begin</strong> &lt;Vereinbarung> -Folge <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" />
             &lt;Anweisung> -Folge <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> <strong>end</strong>
</pre>
<p>Dabei k&ouml;nnen</p>
<pre>
       &lt;Klassenbezeichnung,<img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" />,
       &lt;akt. Parameterteil> -option <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" />
  bzw. &lt;Vereinbarung> -Folge <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" />
</pre>
<p>leer sein (vgl. <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle" />).</p>
<p>Besteht <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> nur aus</p>
<pre><strong>begin</strong> &lt;Anweisung> -Folge<img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> <strong>end</strong>,</pre>
<p>so nennt man <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> eine Verbundanweisung. Andernfalls ist <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> ein
Block. Sowohl Verbundanweisungen als auch Bl&ouml;cke sind an jeder
Stelle von &lt;Anweisung> -Folge <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle" /> zul&auml;ssig, an der eine
Anweisung zul&auml;ssig ist. Dies wird im folgenden ausgenutzt.</p>
<p><strong>Kombination von <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /> aus <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle" />, und <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /></strong></p>
<p>Ist &lt;Klassenbezeichnung><img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> nicht leer, so ist zun&auml;chst zu
testen, ob &lt;Klassenbezeichnung><img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> aus <img src="/img/cache/64b1713211785efe1f94689613b4cf92.gif" alt="\{A\}^+" valign="middle" /> ist. Ist dies
<!--p.122-->
der Fall, so wird &lt;Klassenbezeichnung><img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> umbenannt. Es
resultiert das Programm <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle" />, das die gleiche Funktion
realisiert wie <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" />. Andernfalls wird <img src="/img/cache/300a38a669c9ab5a4dbd6943a0b3db9f.gif" alt="\pi':=\pi" valign="middle" /> gesetzt. Wegen
des Konzepts der lokalen G&uuml;ltigkeit von Bezeichnern ist
eine Umbenennung der in - falls vorhanden - &lt;Vereinbarung> -Folge<img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" />
und &lt;Anweisung> -Folge<img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> vorkommenden
Beseichner auf jeden Fall nicht n&ouml;tig.</p>
<p><img src="/img/cache/94fa7cb0f8136eb03b8de4a9dd9527f8.gif" alt="
\begin{array}{ll}
\tilde\pi = &amp; \text{\underline{procedure}} A; \dots ;\\
&amp; \text{(zus\ddot{a}tzliche Vereinbarungen)}\\
&amp; { \left.
    \begin{array}{lcl}
        \text{\underline{procedure}}&amp; A^2; &amp; \dots;\\
				    &amp;\vdots&amp; \\
				    &amp;\vdots&amp; \\	
	\text{\underline{procedure}}&amp; A^7; &amp; \dots;\\
    \end{array}    
\right\}
    {\longl
	\{
	    \text{mit ge\ddot{a}nderter\\Prozedur A^7 aus \pi_4}
    }
   }\\
&amp; \pi';\\
&amp; \text{(zus\ddot{a}tzliche Anweisungen)}\\
&amp; \text{&lt;Anweisung&gt; -Folge \pi_4}\\
&amp; \text{\underline{end}}
\end{eqnarray}
" valign="middle" /></p>
<p>Es brauchen nur noch die Programmteile</p>
<pre>
    (zus&auml;tzliche Vereinbarungen)
und (zus&auml;tzliche Anweisungen)</pre>
<p>realisiert zu werden.</p>
<p>Sei T gleich <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle" /> mit angef&uuml;gtem ; . Also <img src="/img/cache/1b3ab5ac77ed0406372147f2630eceb2.gif" alt="T=\pi';" valign="middle" />. Der String
T wird analog zum String T' aus dem Beweis zu (5.2.4) in
eine Folge von <img src="/img/cache/2955901c369ec45c4bef6a1e822b631e.gif" alt="m\ge1" valign="middle" /> Teilstrings <img src="/img/cache/f406db9a09c0430f7e54c1a3bb217c3e.gif" alt="t_i" valign="middle" /> zerlegt. F&uuml;r diese
Zerlegung von T gilt:</p>
<ol type="i">
    <li><img src="/img/cache/57538bf985eea91a4cc789c499f4a0db.gif" alt="t_i=\quot\text{ oder }t_i\not\ni\quot\ ,\ \ i\in[m]" valign="middle" /></li>
    <li><img src="/img/cache/13b2e212b881ff5168d7580bad74df4e.gif" alt="t_i\not\ni\quot\ \Rightarrow t_{i+1}=\quot\ ,\ \ i\in[m-1]" valign="middle" /></li>
    <li><img src="/img/cache/24aadf925ef1a202bbc54fcf3391d9b0.gif" alt="t_1\circ t_2\circ\dots\circ t_m=T" valign="middle" /></li>
</ol>
<p>Sei q die Anzahl der Teilstrings <img src="/img/cache/e81cfd62d282334e315e27a783b578cd.gif" alt="t_j" valign="middle" /> von T, die ungleich "
sind. Es gilt: <img src="/img/cache/c99dd6b4db131f791f33496e40e3232c.gif" alt="1\le q \lt m" valign="middle" />.<br />
F&uuml;r jeden Teilstring <img src="/img/cache/e81cfd62d282334e315e27a783b578cd.gif" alt="t_j" valign="middle" /> ungleich ", mit Ausnahme von <img src="/img/cache/7c913e757e40b090b073cacd4511a152.gif" alt="t_m" valign="middle" />,
wird eine Prozedur generiert:</p>
<pre><strong>procedure</strong> <img src="/img/cache/5d4cec0ebf8d836be71c14932f90b806.gif" alt="A^{7+j}" valign="middle" />;OUTTEXT("<img src="/img/cache/f406db9a09c0430f7e54c1a3bb217c3e.gif" alt="t_i" valign="middle" />");     <img src="/img/cache/b4288b9b6fe98cf870d38a7767017863.gif" alt="j\in[q-1]" valign="middle" /></pre>
<!--p.123-->
<p>wobei <img src="/img/cache/f406db9a09c0430f7e54c1a3bb217c3e.gif" alt="t_i" valign="middle" /> der j-te Teilstring von T ungleich " ist.</p>
<p>Die Menge der erzeugten Prozedurnamen ist
<img src="/img/cache/f52f254ef1cd272f1fe751c1e9d411a1.gif" alt="AQ=\{A^{7+1},\dots,A^{7+q-1}\}" valign="middle" />. Sei <img src="/img/cache/d204adad3a43dc2c948a9d8915db320e.gif" alt="\calT=\{t_1,\dots,t_m\}" valign="middle" />.
Wie im Beweis zu (5.2.4) werden die Funktionen <img src="/img/cache/a6f317b268ae825d94f832f970af607c.gif" alt="\tau" valign="middle" /> und <img src="/img/cache/c80dc7396cddee2e3b36211de213b695.gif" alt="\tilde\tau" valign="middle" />
definiert</p>
<p><img src="/img/cache/37de1ab75c77bc58efac83fa8d4d7f84.gif" alt="
\begin{array}{lcl}
\tau\ :	&amp; [q]	&amp; \longr \calT\\
	&amp; j	&amp; \longr t_k\text{, mit t_k = j-ter Teilstring \ne\quot}\\
\tilde\tau\ :
	&amp; [m]	&amp; \longr AQ\cup\{A^5\}\\
	&amp; j	&amp; \longr {
	\left\{
	    \perp\text{, falls j=q}\\
	    A^{7+i}\text{, falls t_j = i_ter Teilstring \ne\quot}\\
	    A^5\text{, falls t_j = \quot}
	\right.
	}
\end{array}
" valign="middle" /></p>
<p><img src="/img/cache/69ac49315fb75559bc7125a373ed5735.gif" alt="t_1" valign="middle" /> ist ungleich ", da <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> nicht mit " anfangen kann. Da das
letzte Zeichen von T gleich ; ist, ist auch <img src="/img/cache/361dfbaa1fc0a25681ea8db52662b3b3.gif" alt="t_m=t_q" valign="middle" />
ungleich ". <img src="/img/cache/7c913e757e40b090b073cacd4511a152.gif" alt="t_m" valign="middle" /> wird in die Prozedur <img src="/img/cache/343bb72223d7f76edf7cf61c53b59d07.gif" alt="A^7" valign="middle" /> integriert.</p>
<p>Der Programmteil (zus&auml;tzliche Vereinbarungen) besteht aus
den q-1 Prozedurvereinbarungen von <img src="/img/cache/2492ac3d9c30ee5642299a56d3f88e44.gif" alt="A^{7+1}" valign="middle" /> bis <img src="/img/cache/c09f89258bb1e62a4012d0a1f8a10afc.gif" alt="A^{7+q-1}" valign="middle" />.
Der Programmteil (zus&auml;tzliche Anweisungen) besteht aus der
Folge von Prozeduraufrufen, die n&ouml;tig sind, die q-1 zus&auml;tzlichen
Prozedurvereinbarungen auszugeben. Die Prozedur <img src="/img/cache/343bb72223d7f76edf7cf61c53b59d07.gif" alt="A^7" valign="middle" />
wird entsprechend erweitert.</p>
<pre class="source"><img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /> = 
<strong>begin</strong>
<strong>procedure</strong> A;OUTTEXT("BEGIN PROCEDURE A; OUTTEXT(""");
<strong>procedure</strong> <img src="/img/cache/2492ac3d9c30ee5642299a56d3f88e44.gif" alt="A^{7+1}" valign="middle" />;OUTTEXT("<img src="/img/cache/7f7c01de695d5a11979006e1e1e3ffc7.gif" alt="\tau(1)" valign="middle" />");
.................................
<strong>procedure</strong> <img src="/img/cache/c09f89258bb1e62a4012d0a1f8a10afc.gif" alt="A^{7+q-1}" valign="middle" />;OUTTEXT("<img src="/img/cache/c0f66fd5e817ae5c0941a52ceeaf59a1.gif" alt="\tau(q-1)" valign="middle" />");
<strong>procedure</strong> <img src="/img/cache/372c8c0974114a670f97d71577e77b98.gif" alt="A^2" valign="middle" />;OUTTEXT("PROCEDURE ");
<strong>procedure</strong> <img src="/img/cache/b4cddc5b73d75b560a023245d529dc11.gif" alt="A^3" valign="middle" />;OUTTEXT(" ;OUTTEXT(""");
<strong>procedure</strong> <img src="/img/cache/043aced3ddc3a4f1404af4429a3d1f0b.gif" alt="A^4" valign="middle" />;OUTTEXT(""");");
<strong>procedure</strong> <img src="/img/cache/a5c0ac33cf92038d4a2aa773e2cb482b.gif" alt="A^5" valign="middle" />;OUTTEXT("""");
<strong>procedure</strong> <img src="/img/cache/e945a87750e6965a1bdbfeeaf4fe2db9.gif" alt="A^6" valign="middle" />;OUTTEXT("A");
<strong>procedure</strong> <img src="/img/cache/343bb72223d7f76edf7cf61c53b59d07.gif" alt="A^7" valign="middle" />;OUTTEXT("<img src="/img/cache/07088a0b5664ba3433b48edaa0647502.gif" alt="\tau(m);A;A;A^5;A^4;A^2;(A^6;)^{7+1} A^3;A^{7+1};A^4" valign="middle" />
   <img src="/img/cache/14debb835594ace131dd26b42a440ed7.gif" alt=";\dots\ \dots A^2;(A^6;){7+q-1} A^3;A^{7+q-1};A^4;A^2;(A^6;)^2 A^3;A^2;A^4" valign="middle" />
<!--p.124-->
   <img src="/img/cache/6c671e21ab91e3e3fd31224d3a75a94d.gif" alt=";A^2;(A^6;)^3 A^3;A^3;A^5;A^4;A^2;(A^6;)^4 A^3;A^5;A^4;A^4;A^2;(A^6;)^5" valign="middle" />
   <img src="/img/cache/9823ec18da1e9df59619920e18ca6c9e.gif" alt="A^3;A^5;A^5;A^4;A^2;(A^6;)^6 A^3;A^6;A^4;A^2;(A^6;)^7 A^3;A^7;A^4;\tilde\tau(1);" valign="middle" />
   <img src="/img/cache/68310e3d433d67c315255c1a4a5762cc.gif" alt="\dots\ \dots\ \tilde\tau(m-1);A^7" valign="middle" /> END");
<img src="/img/cache/f2bf7f105ff895f9e84616e7046b3eed.gif" alt="
t_1\ \dots\ \dots\ t_m\\
A;A;A^5;A^4;\\
A^2;(A^6;)^{7+1} A^3;A^{7+1};A^4;\\
\dots\ \dots\ \dots\ \dots\\
A^2;(A^6;)^{7+q-1} A^3;A^{7+q-1};A^4;\\
A^2;(A^6;)^2 A^3;A^2;A^4;\\
A^2;(A^6;)^3 A^3;A^3;A^5;A^4;\\
A^2;(A^6;)^4 A^3;A^5;A^4;A^4;\\
A^2;(A^6;)^5 A^3;A^5;A^5;A^4;\\
A^2;(A^6;)^6 A^3;A^6;A^4;\\
A^2;(A^6;)^7 A^3;A^7;A^4;\\
\tilde\tau(1);\ \dots\ \dots\ \tilde\tau(m-1);A^7
" valign="middle" />
<strong>end</strong>
</pre>
<p><em>Teil B</em></p>
<p>Die Konstruktion von <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /> in Teil A f&uuml;hrt zu einem syntaktisch
korrekten SIMULA-Programm. Wegen der sehr engen Entsprechung
von den SIMULA-Programm <img src="/img/cache/c0c4d5806b58d7c7224dd3d0559203e7.gif" alt="\pi_4" valign="middle" /> und dem PASCAL-Programm <img src="/img/cache/54361c50d74cb73471ff9b05f12a08a4.gif" alt="\pi_6" valign="middle" />
entspricht <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /> dem im Beweis von (5.2.4) erzeugten PASCAL-Programm
weitgehend. Zum Nachweis, da&szlig; <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /> wirklich selbstreproduzierende
Version von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> ist, kann wegen der v&ouml;lligen Analogie
auf den Beweis von (5.2.4), Fall 2, verwiesen werden.</p>
<div align="right">%</div>
<p>Aus dem Beweis zu Satz (5.3.1) l&auml;&szlig;t sich direkt ein Algorithmus
herleiten, der zu jedem g&uuml;ltigen SIMULA-Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" />
eine selbstreproduzierende Version <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /> angibt.</p>
<p><strong>(5.3.2) Algorithmus:</strong></p>
<ul>
    <li><strong>Eingabe:</strong> Das SIMULA-Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" />.</li>
    <li><strong>1. Schritt:</strong> Test, ob &lt;Klassenbezeichnung><img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> - falls
    &uuml;berhaupt vorhanden - ein Bezeichner
    aus <img src="/img/cache/64b1713211785efe1f94689613b4cf92.gif" alt="\{A\}^+" valign="middle" /> ist. Gegebenenfalls Umbenennung
<!--p.125-->
    vornehmen.</li>
    <li><strong>2. Schritt:</strong> Zerlegung von <img src="/img/cache/9af7caed565b0c2fdc62c44597a707d5.gif" alt="T:=\pi;" valign="middle" /> in Teilstrings
    <img src="/img/cache/7ae4140751ea4e012a1aa53e64cc3a6e.gif" alt="t_1,\dots,t_m" valign="middle" /> und Ermittlung der Anzahl q
    der Teilstrings <img src="/img/cache/e81cfd62d282334e315e27a783b578cd.gif" alt="t_j" valign="middle" /> ungleich ".<br />
    Anschlie&szlig;end Formulierung der q-1
    Prozeduren <img src="/img/cache/2492ac3d9c30ee5642299a56d3f88e44.gif" alt="A^{7+1}" valign="middle" /> bis <img src="/img/cache/c09f89258bb1e62a4012d0a1f8a10afc.gif" alt="A^{7+q-1}" valign="middle" /> und Aufstellung
    der Wertetabellen von <img src="/img/cache/a6f317b268ae825d94f832f970af607c.gif" alt="\tau" valign="middle" /> und <img src="/img/cache/c80dc7396cddee2e3b36211de213b695.gif" alt="\tilde\tau" valign="middle" />.</li>
    <li><strong>3. Schritt:</strong> Einsetzen der erhaltenen Prozeduren,
    der Funktionswerte und des Programms <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" />
    in das im Beweis angegebene Programmschema.</li>
    <li><strong>Aufwand:</strong> Der Aufwand des Algorithmus verh&auml;lt
    sich linear zur L&auml;nge <img src="/img/cache/813ad0a277235ece42a2f3ad9b395a09.gif" alt="l(\pi)" valign="middle" /> des
    Programms <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" />.</li>
</ul>
<p>Wegen der Analogie zu (5.2.5) sei an dieser Stelle auf ein
Beispiel f&uuml;r die Anwendung von Algorithmus (5.3.2) verzichtet.
Zur Gewinnung <strong>implementierbarer</strong> selbstreproduzierender
Versionen mu&szlig; (5.3.2) analog zu (5.2.5) um zwei
"praxisorientierte" Schritte erweitert werden.</p>
<p>Kapitel 5 hat insgesamt ergeben, da&szlig; sich die eingangs
(s.o. 5.1.) gestellten Fragen (1), (2) und (3) bez&uuml;glich
der Programmiersprachen SIMULA und PASCAL positiv beantworten
lassen. Bei der Beantwortung werden keine simula- bzw.
pascalspezifischen Sprachelemente bem&uuml;ht. Diese Tatsache
l&auml;&szlig;t den Schlu&szlig; zu, da&szlig; sich die Fragen (1) bis (3) im
Falle jeder h&ouml;heren Programmiersprache, die &uuml;ber</p>
<ul>
    <li>Textkonstanten und</li>
    <li>Prozedurkonzept</li>
</ul>
<p>verf&uuml;gt, positiv beantworten lassen.</p>
<p>Auch bez&uuml;glich der in 3.4. behandelten SIEMENS-Assemblersprache
fallen die Antworten auf die drei Fragen positiv
<!--p.126-->
aus. Die Antworten wurden bereits durch Beispiel (3.4.1)
geliefert. Wenige Zeilen Assembler-Kode gen&uuml;gen, um aus
einem beliebigen Assembler-Programmabschnitt einen
selbstreproduzierenden Programmabschnitt zu machen. Die die
Selbstreproduktion ausmachenden Zeilen sind im wesentlichen
immer gleich.</p>
<!--p.127-->
<h2><a name="c6"></a>6. Selbstreproduktion bei loop-Programmen</h2>
<h3><a name="c61"></a>6.1. Einleitung</h3>
<p>In den Kapiteln 3,4 und 5 haben wir Beispiele f&uuml;r
selbstreproduzierende Programme in h&ouml;heren Programmiersprachen
kennengelernt. Alien Beispielen ist gemeinsam, da&szlig; sie
algorithmisch nicht sehr aufwendig sind. Der jeweilige
Kontrollflu&szlig; alier bisherigen Belspielpragramme ist recht
einfach. Es w&auml;re also interessant zu kl&auml;ren, wie einfach
Programmiersprachen strukturiert sein k&ouml;nnen, um noch
selbstreproduzierende Programme zu erm&ouml;glichen. Die folgenden
Betrachtungen werden also in erster Linie den in Programmiersprachen
&uuml;blichen Kontrollstrukturen gelten und sich
nicht auf <strong>eine</strong> konkrete Programmiersprache beziehen. Die
Losl&ouml;sung von konkreten Programmiersprachen wird dadurch
zum Ausdruck gebracht, da&szlig; wir unsere &Uuml;berlegungen auf der
Basis der fiktiven Programmiersprache PL(A) aus Kapitel 2
durchf&uuml;hren.</p>
<p>In Kapitel 2 wurde die Menge der durch PL(A)-Programme
realisierbaren Funktionen mit <img src="/img/cache/1de3af6d030b90c9d333be8a2de8dde8.gif" alt="\calP" valign="middle" /> bezeichnet. Schr&auml;nkt man
die in PL(A) zur Verf&uuml;gung stehenden Grundanweisungen und
Kontrollstrukturen etwa auf<br />
<img src="/img/cache/cc418f9d400bb90236e5bcb576875dca.gif" alt="
\begin{array}{ll}
    \gamma_1,\gamma_2,\gamma_3,\gamma_5 \overline{\ \ \ \ } &amp; \chi_1\ :\ P;Q\\
							    &amp; \chi_2\ :\ \text{\underline{if} p \underline{then goto} L}
\end{array}
" valign="middle" /><br />
oder auf<br />
<img src="/img/cache/a42c3df046271208536adbab37614fb8.gif" alt="
\begin{array}{ll}
    \gamma_1,\gamma_2,\gamma_3,\gamma_5 \overline{\ \ \ \ } &amp; \chi_1\ :\ P;Q\\
							    &amp; \chi_2\ :\ \text{\underline{if} p \underline{then} P \underline{else} Q \underline{fi}}\\
							    &amp; \chi_4\ :\ \text{\underline{while} X=\varepsilon \underline{do} P \underline{od}}
\end{array}
" valign="middle" /><br />
ein, so erh&auml;lt man Programmiersprachen, die nur "<strong>goto</strong>-Programme"
bzw. nur "<strong>while</strong>-Programme" erm&ouml;glichen. Die Theorie
zeigt jedoch (vgl. dazu etwa [5]), da&szlig; die Menge der
mit <strong>while</strong>-Programmen realisierbaren Funktionen gleich der
Menge der mit <strong>goto</strong>-Programmen realisierbaren Funktionen
gleich der Menge <img src="/img/cache/1de3af6d030b90c9d333be8a2de8dde8.gif" alt="\calP" valign="middle" /> ist. (Unsere bisherigen Beispielprogramme
<!--p.128-->
f&uuml;r selbstreproduzierende Programme in SIMULA und
PASCAL benutzen Prozeduren. Wollte man diese Programme in
PL(A)-Programme transformieren, so w&uuml;rden <strong>goto</strong>-Programme
entstehen.) Erst die Einschr&auml;nkung von PL(A) auf<br />
<img src="/img/cache/48ca51bfdf64e0a9d5b3de0ae1e43931.gif" alt="
\begin{array}{ll}
\gamma_1,\gamma_2,\gamma_3,\gamma_4\overline{\ \ \ \ }	&amp; \chi_1\ :\ P;Q\\
							&amp;
    \begin{array}{llllcl}
	\chi_5\ :\ \text{\underline{loop} X}	&amp;\text{\underline{case}}&amp; a_1	&amp; \longr&amp; P_1,\\
						&amp;			&amp; \vdots&amp;	&amp;\vdots\\
						&amp;			&amp; \vdots&amp; 	&amp;\vdots\\
						&amp;			&amp; a_n	&amp; \longr&amp; P_n,\\
						&amp;\text{\underline{end}   ,}
    \end{array}
\end{array}
" valign="middle" /><br />
also auf reine "<strong>loop</strong>-Programme", f&uuml;hrt zu Programmen, mit
denen sich nicht mehr alle Funktionen aus <img src="/img/cache/1de3af6d030b90c9d333be8a2de8dde8.gif" alt="\calP" valign="middle" /> realisieren
lassen. Wir werden im folgenden untersuchen, unter welchen
Voraussetzungen selbstreproduzierende <strong>loop</strong>-Programme
m&ouml;glich sind.</p>
<h3><a name="c62"></a>6.2. Definition der Programmiersprache LP(A)</h3>
<p><strong>(6.2.1) Definition:</strong> Sei <img src="/img/cache/3e5f3cdf4693cd8f757447e96f886065.gif" alt="A=\{a_1,\dots,a_n\}" valign="middle" /> ein endliches
Alphabet. Sei PL(A) die in 2.2. definierte, zu A
geh&ouml;rige Programmiersprache. LP(A) ist die
Programmiersprache, die entsteht, indem man aus PL(A)
alle Programme streicht, die Grundanweisungen vom
Typ <img src="/img/cache/acbc2543aa1703ffc51b61729ee299f9.gif" alt="\gamma_5\ :\ X:=\rho(X),\ X\in VR" valign="middle" />, oder eine der
Kontrollstrukturen<br />
<img src="/img/cache/efef0638a485447776e3e2ab78548aec.gif" alt="
\begin{array}{ll}
	    &amp;\chi_2\ :\ \text{\underline{if} p \underline{then goto} L  ,}\\
	    &amp;\chi_3\ :\ \text{\underline{if} p \underline{then} P \underline{else} Q \underline{fi}}\\
\text{oder} &amp;\chi_4\ :\ \text{\underline{while} X=\varepsilon\ \underline{do} P \underline{od}
\end{array}
" valign="middle" /><br />
enthalten.</p>
<p><strong>(6.2.2) Bezeichnung:</strong></p>
<ol type="I">
    <li>Neben der Hintereinanderausf&uuml;hrung von Anweisungen
    stellt die <strong>loop</strong>-Schleife <img src="/img/cache/ebe0bb3dfbd23c5c966b1381c166dbcf.gif" alt="\chi_5" valign="middle" /> das einzige
    Konstruktionselement f&uuml;r Programme aus LP(A) dar. Die Programme
    aus LP(A) werden daher auch als <strong>loop</strong>-Programme
<!--p.129-->
    bezeichnet.</li>
    <li>Die Menge aller durch Programme aus LP(A) realisierbaren
    Wortfunktionen<br />
    <img src="/img/cache/5e646ea36af04594cb641680522d812c.gif" alt="f\ :\ (A^*)^r\longr(A^*)^s,\ r,s\ge0" valign="middle" /><br />
    wird mit <img src="/img/cache/b1e0e854ba825d1bce7f6c92a6ad81b9.gif" alt="\calZ" valign="middle" /> bezeichnet. <img src="/img/cache/b1e0e854ba825d1bce7f6c92a6ad81b9.gif" alt="\calZ" valign="middle" /> hei&szlig;t auch Menge der
    <strong>primitiv rekursiven</strong> Funktionen. [5]</li>
</ol>
<p>Aus (6.2.1) ergibt sich, da&szlig; LP(A) eine echte Teilmenge von
PL(A) ist. Da&szlig; auch <img src="/img/cache/b1e0e854ba825d1bce7f6c92a6ad81b9.gif" alt="\calZ" valign="middle" /> eine echte Teilmenge von <img src="/img/cache/1de3af6d030b90c9d333be8a2de8dde8.gif" alt="\calP" valign="middle" /> ist,
ergibt sich schon aus der Tatsache, da&szlig; <strong>loop</strong>-Programme immer
halten und somit die von <strong>loop</strong>-Programmen realisierten
Funktionen total sind. Es l&auml;&szlig;t sich aber auch zeigen, da&szlig; <img src="/img/cache/b1e0e854ba825d1bce7f6c92a6ad81b9.gif" alt="\calZ" valign="middle" /> eine
echte Teilmenge von <img src="/img/cache/0bbff11c428eb92ed802aac93a141369.gif" alt="\calR" valign="middle" /> (vgl. (2.4.6)) ist, indem man die
Existenz einer total rekursiven Funktion, die nicht primitiv
rekursiv ist, nachweist (vgl. [5] Seite 41).</p>
<h3><a name="c63"></a>6.3. Eine kontextfreie Grammatik f&uuml;r LP(A)</h3>
<p>Der Vollst&auml;ndigkeit halber sei hier eine kontextfreie Grammatik
G'(A) f&uuml;r LP(A) angegeben. G'(A) entsteht durch Einschr&auml;nkung
der Grammatik G(A) f&uuml;r PL(A)-Programme aus 2.3..</p>
<p><strong>(6.3.1) Angabe der Grammatik <img src="/img/cache/1b07278c6117f4c5d783aa17add5696b.gif" alt="G'(A)=(V_T',V_N',s_0,P')" valign="middle" /></strong></p>
<p>Die Menge der Terminalzeichen ist<br />
<img src="/img/cache/b243d28d56a0fc79f2cd84a518e9651e.gif" alt="
\begin{array}{ll}
V_T'=&amp;A\cup VR\cup\{\text{\underline{input},\underline{output},\underline{loop},\underline{case},\underline{end},}\\
     &amp;\longr\ ,\ ;\ ,\ ,\ ,\ \tiny{\rotate{-90}]}\ ,\ \varepsilon,\ \overline\varepsilon\ ,\ :\ ,\ =\ \},
\end{array}
" valign="middle" /><br />
wobei VR die Menge der zul&auml;ssigen Variablennamen ist.</p>
<p>Die Menge der nicht terminalen Zeichen ist<br />
<img src="/img/cache/c4207a38614f4a95253009c9645d68aa.gif" alt="
\begin{array}{ll}
V_N'=&amp;\{\text{\underline{&lt;program&gt;},\underline{&lt;statement&gt;},\underline{&lt;simple statement&gt;}},\\
    &amp;\text{\underline{&lt;identifier&gt;},\underline{&lt;identifier list&gt;}} \}
\end{array}
" valign="middle" /></p>
<p>Das Startsymbol <img src="/img/cache/8320d1005489da544f0244dd5ee9af63.gif" alt="s_0" valign="middle" /> ist &lt;program></p>
<p>Die Menge P' der Produktionen ist gleich der Menge P
der Produktionen der Grammatik G(A) aus (2.3.1) ohne
die Produktionen mit den Nummern 6,8,9,10,13,14,15 und 20.</p>
<!--p.130-->
<h3><a name="c64"></a>6.4. Erweiterung der Sprache LP(A)</h3>
<p>In Kapitel 2 wurde die Existenz selbstreproduzierender
Programme in PL(A) theoretisch bewiesen. Sin analoger Beweis
f&uuml;r die Existenz von selbstreproduzierenden Programmen in
LP(A) scheitert daran, da&szlig; es in <img src="/img/cache/b1e0e854ba825d1bce7f6c92a6ad81b9.gif" alt="\calZ" valign="middle" /> keine universelle
Funktion gibt (siehe [5] Seite 47). Wir werden uns daher dem
Problem der Existenz selbstreproduzierender Programme in
LP(A) von der praktischen Seite aus n&auml;hern. Das bedeutet
allerdings nicht, da&szlig; es prinzipiell unm&ouml;glich ist, die
Existenz selbstreproduzierender LP(A)-Programme auf
theoretischem Wege zu beweisen.</p>
<p>Um das praktische Schreiben von selbstreproduzierenden
LP(A)-Programmen f&uuml;r uns zu erm&ouml;glichen, erweitern wir die
Programmiersprache LP(A) um eine zus&auml;tzliche Grundanweisung.
Diese Erweiterung soll aber nicht bedeuten, da&szlig; es ohne sie
prinzipiell unm&ouml;glich ist, selbstreproduzierende
LP(A)-Programme zu schreiben.</p>
<ol type="I">
    <li>Sei A ein endliches Alphabet. In der zu A geh&ouml;rigen Sprache
    LP(A) soll es die M&ouml;glichkeit geben, Variable mit jedem
    beliebigen Wert aus <img src="/img/cache/1304435c8bc4c0f5b8ecbe7f16727d75.gif" alt="A^*" valign="middle" /> und nicht nur mit <img src="/img/cache/f8b1c5a729a09649c275fca88976d8dd.gif" alt="\varepsilon" valign="middle" /> zu
    initialisieren. Wir f&uuml;hren daher die Grundanweisung <img src="/img/cache/5b6f0f60c37ff5ffce55a023aa65079e.gif" alt="\gamma_6" valign="middle" /> ein:<br />
<img src="/img/cache/cdfa724514363198adedd9685b8f489f.gif" alt="
\begin{array}{ll}
\gamma_6\ :\ &amp; X:=\ 'a_{i_1} \dots a_{i_k}\ ',\ k\ge1\\
	     &amp; X\in VR,\ a_{i_j}\in A\text{ f\ddot{u}r }j\in[k] .
\end{array}" valign="middle" />
<p>Es soll nicht ausgeschlossen werden, da&szlig; <img src="/img/cache/77c28a97c52444a6979b607588b5d7e7.gif" alt="'\in A" valign="middle" />  sein darf.
Damit ist aber auch <img src="/img/cache/92f053582a7c5f9cb52ece59ba2f667d.gif" alt="a_{i_j}=\ '" valign="middle" /> f&uuml;r beliebiges <img src="/img/cache/d73da4c951fbbf4a89fe3413b443bce4.gif" alt="j\in[k]" valign="middle" /> zul&auml;ssig.</p>
<p>In h&ouml;heren Programmiersprachen ist es &uuml;blich, da&szlig;
Texttrennzeichen, wenn sie innerhalb von Textkonstanten vorkommen,
doppelt geschrieben werden m&uuml;ssen. Dieser Umstand
hatte uns in den Kapiteln 3 und 5 das Schreiben von
selbstreproduzierenden Programmen in PASCAL und SIMULA
sehr erschwert. Wir treffen daher eine andere Vereinbarung:</p>
<p>Auf eine Grundanweisung <img src="/img/cache/5b6f0f60c37ff5ffce55a023aa65079e.gif" alt="\gamma_6" valign="middle" /> mu&szlig; zwingend ein Semikolon folgen.
<!--p.131-->
Das Ende einer Textkonstanten wird demnach durch
'; angezeigt. Der Einfachheit halber verbieten wir das
Auftreten des Strings '; als Teil einer Textkonstanten.
Um die Koppelung des Semikolons an Textkonstanten
deutlich zu machen, beziehen wir das Semikolon in die
Definition von <img src="/img/cache/5b6f0f60c37ff5ffce55a023aa65079e.gif" alt="\gamma_6" valign="middle" /> ein.</p>
<p><img src="/img/cache/cdfa724514363198adedd9685b8f489f.gif" alt="
\begin{array}{ll}
\gamma_6\ :\ &amp; X:=\ 'a_{i_1} \dots a_{i_k}\ ',\ k\ge1\\
	     &amp; X\in VR,\ a_{i_j}\in A\text{ f\ddot{u}r }j\in[k] .
\end{array}" valign="middle" /></p>
</li>
    <li>Ist <img src="/img/cache/b8ee23d2cfffbf0f40fc731fe59a7938.gif" alt="X \in VR" valign="middle" />, so ist folgende Anweisung vom Typ <img src="/img/cache/cc1d987f0e659c1d3be7ee161d4b9265.gif" alt="\gamma_4" valign="middle" /> m&ouml;glich:<br />
    <img src="/img/cache/c1fe02fdc16ca703a161cec83fe69c03.gif" alt="\hspace{100}X:=X" valign="middle" /><br />
    Auf eine solche Anweisung wird in der Regel ein Semikolon
    folgen.<br />
    <img src="/img/cache/e3dd2dd615ca0ecf4a0d0d91fe95ea66.gif" alt="\dots\ \dots\ \dots\ X:=X;\ \dots\ \dots\ \dots" valign="middle" /><br />
    Da wir nicht ausschlie&szlig;en wollen, da&szlig; das Semikolon ein
    Element aus A ist, k&ouml;nnte der String<br />
    <img src="/img/cache/903179e752ab87639f8eba4731ebd182.gif" alt="\hspace{100}X:=X;" valign="middle" /><br />
    auch als Anweisung vom Typ <img src="/img/cache/6da6e433b686fbd8c803ce43927d6ac6.gif" alt="\gamma_3" valign="middle" /> interpretiert werden. Um
    Doppeldeutigkeiten<sup><a href="#p132_1" name="b132_1">1)</a></sup> zu vermeiden, ersetzen wir <img src="/img/cache/6da6e433b686fbd8c803ce43927d6ac6.gif" alt="\gamma_3" valign="middle" /> durch
    die Grundanweisung <img src="/img/cache/6b362d1b588c3abdd9c41933926fa747.gif" alt="\gamma_3'" valign="middle" />:<br />
    <img src="/img/cache/6f2f5ad9cc763bfcf8525e18e582ef04.gif" alt="\hspace{50}\gamma_3'\ :\ X:=X|a\hspace{50}\forall X \in VR,\ a\in A" valign="middle" /><br />
    Die Bedeutung von <img src="/img/cache/6b362d1b588c3abdd9c41933926fa747.gif" alt="\gamma_3'" valign="middle" /> ist die gleiche wie die von <img src="/img/cache/6da6e433b686fbd8c803ce43927d6ac6.gif" alt="\gamma_3" valign="middle" />.</li>
</ol>
<p><strong>(6.4.2.) Definition:</strong> Sei A ein endliches Alphabet. LP(a) ist
diejenige Programmiersprache, die durch Erweiterung
um die Grundanweisung <img src="/img/cache/5b6f0f60c37ff5ffce55a023aa65079e.gif" alt="\gamma_6" valign="middle" /> und durch Ersetzung der
Grundanweisung <img src="/img/cache/6da6e433b686fbd8c803ce43927d6ac6.gif" alt="\gamma_3" valign="middle" /> durch <img src="/img/cache/6b362d1b588c3abdd9c41933926fa747.gif" alt="\gamma_3'" valign="middle" /> aus der Sprache LP(A)
entsteht.</p>
<p>Aus der Grammatik G'(A) f&uuml;r die Sprache LP(A) la&szlig;t sich
leicht eine kontextfreie Grammatik <img src="/img/cache/912a8b9b6aefa4659d763a77f318dde1.gif" alt="\overline{G'(A)}" valign="middle" /> f&uuml;r die Sprache
<img src="/img/cache/edd25afc0ad473b16119c88c5420034e.gif" alt="\overline{LP(A)}" valign="middle" /> herleiten:</p>
<ul>
    <li>Die Menge der terminalen Zeichen <img src="/img/cache/b684cff72868b5efd32128f278d0aeb4.gif" alt="V_T'" valign="middle" /> wird um ' und
    | erweitert.</li>
<!--p.132-->
    <li>Die Produktion<br />
<img src="/img/cache/5cfc3cea87016cc3ff4575e64f63658d.gif" alt="
\begin{array}{ll}
\text{&lt;simple statement&gt;}\longr	&amp;X:=\ 'a_{i_1}\ \dots\ a_{i_k}\ ';\\
				&amp;\text{f\ddot{u}r alle X\in VR,\ a_{i_j}\in A}
\end{array}
" valign="middle" /><br />
wird der Menge P' hinzugef&uuml;gt.</li>
<li>Die Produktion<br />
<img src="/img/cache/12e435f421314d582e2c6ecaf3f6be03.gif" alt="\text{&lt;simple statement&gt;\longr X:=Xa, f\ddot{u}r alle X \in VR, a \in A}" valign="middle" /><br />
wird ersetzt durch<br />
<img src="/img/cache/31149cdc9bf8f29867b030ddcac585d3.gif" alt="\text{&lt;simple statement&gt;\longr X:=X|a, f\ddot{u}r alle X \in VR, a \in A}" valign="middle" /></li>
</ul>
<p><strong>(6.4.3) Definition:</strong> (<strong>loop</strong>-Hierarchie der <img src="/img/cache/edd25afc0ad473b16119c88c5420034e.gif" alt="\overline{LP(A)}" valign="middle" />-Programme)</p>
<p>Sei A ein endliches Alphabet.</p>
<ol type="i">
    <li>Es sei <img src="/img/cache/6f4a1e09be18c1482c525272fe50b002.gif" alt="\overline{L_0(A)}" valign="middle" /> die Klasse der Programme<br />
<img src="/img/cache/d8bdab3e266f298b82d35e9cda662fa0.gif" alt="
\begin{array}{rcll}
\pi	&amp; =	&amp;\text{\underline{input}}&amp; X_1,\dots,X_r;\\
        &amp;	&amp;			&amp; AW_\pi;\\
	&amp;	&amp;\text{\underline{output}}&amp;Y_1,\dots,Y_s\ \ \ ,\ r,s\ge0
\end{array}" valign="middle" /><br />
aus <img src="/img/cache/edd25afc0ad473b16119c88c5420034e.gif" alt="\overline{LP(A)}" valign="middle" />, deren Anweisungsteil <img src="/img/cache/aafc0430452071887da8c26f9bfa060c.gif" alt="AW_\pi" valign="middle" /> durch beliebiges
Hintereinanderschreiben von Anweisungen vom Typ
<img src="/img/cache/e97334d33450f85e939ea5734d0fe745.gif" alt="\gamma_1,\gamma_2,\gamma_3,\gamma_4" valign="middle" /> und <img src="/img/cache/5b6f0f60c37ff5ffce55a023aa65079e.gif" alt="\gamma_6" valign="middle" /> ersteht.</li>
    <li>Die Klasse <img src="/img/cache/572ad4549847516d5f2714f15bc9ab5d.gif" alt="\overline{L_{i+1}(A)" valign="middle" /> enthalte alle Programme <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" />, deren
Anweisungsteile <img src="/img/cache/aafc0430452071887da8c26f9bfa060c.gif" alt="AW_\pi" valign="middle" /> durch Hintereinandersetzen von
Anweisungsteilen von Programmen aus <img src="/img/cache/fe196f6e86a8b8bcc33994899a03d626.gif" alt="\overline{L_i(A)}" valign="middle" /> und
Anweisungsteilen der Form<br />
<img src="/img/cache/06169913c73bd671fad901c5e4b1ee05.gif" alt="
\fbox{
    \begin{array}{rlccc}
	\text{\underline{loop} X} &amp; \text{\underline{case}} &amp;a_1	&amp;\longr	&amp; AW_{\pi_1},\\
				&amp;			    &amp; \vdots	&amp;	&amp; \vdots\\
    				&amp;			    &amp; \vdots 	&amp; 	&amp; \vdots\\
				&amp;			    &amp;a_n	&amp;\longr &amp; AW_{\pi_n},\\
				&amp; \text{\underline{end}}\\
    \end{array}\\
    \text{a_j \in A f\ddot{u}r jedes j \in [n]}
}
" valign="middle" /><br />
wobei <img src="/img/cache/4c83473a454fb8ecf9b02db8ed30ce8a.gif" alt="AW_{\pi_1}\ \dots\ AW_{\pi_n}" valign="middle" /> Anweisungsteile von
Programmen aus <img src="/img/cache/fe196f6e86a8b8bcc33994899a03d626.gif" alt="\overline{L_i(A)}" valign="middle" /> sind, entstehen (<img src="/img/cache/43930ac4119fb1528d6d835cbc7b5870.gif" alt="i\ge0" valign="middle" />).</li>
</ol>
<!--p.133-->
<h3><a name="c65"></a>6.5. Selbstreproduzierende Programme in <img src="/img/cache/edd25afc0ad473b16119c88c5420034e.gif" alt="\overline{LP(A)}" valign="middle" /></h3>
<p>Sei <img src="/img/cache/7336e978511cc6b18b92984ab6c2eb22.gif" alt="\pi_{\text{rep}}" valign="middle" /> ein - falls es existiert - selbstreproduzierendes
<img src="/img/cache/edd25afc0ad473b16119c88c5420034e.gif" alt="\overline{LP(A)}" valign="middle" />-Programm. Im Anweisungsteil von <img src="/img/cache/7336e978511cc6b18b92984ab6c2eb22.gif" alt="\pi_{\text{rep}}" valign="middle" /> mu&szlig;
schrittweise der <strong>Text</strong> <img src="/img/cache/7336e978511cc6b18b92984ab6c2eb22.gif" alt="\pi_{\text{rep}}" valign="middle" /> aufgebaut werden. Die einzelnen
Buchstaben von <img src="/img/cache/7336e978511cc6b18b92984ab6c2eb22.gif" alt="\pi_{\text{rep}}" valign="middle" /> m&uuml;ssen auf der rechten Seite von
Wertzuweisungen auftreten. Auf den rechten Seiten von Wertzuweisungen
stehen aber au&szlig;er Variablennamen nur Buchstaben aus
A. Es mu&szlig; also gelten: <img src="/img/cache/8383540a789e93ed2e01767b56e6c2a3.gif" alt="\pi_{\text{rep}}\in A" valign="middle" />. Um dies zu gew&auml;hrleisten,
wird folgende Forderung an das Alphabet A gestellt:</p>
<p><strong>Forderung (1):</strong> F&uuml;r jedes Programm <img src="/img/cache/1623c801fd1f0ff3038caa795ad85937.gif" alt="\pi\in\overline{LP(A)}" valign="middle" /> gilt:<br />
<img src="/img/cache/5f95f45ba2ef1641e35ac7a756da9867.gif" alt="\hspace{100}\pi \in A^*" valign="middle" /></p>
<p>Jedes Alphabet, das Forderung (1) erf&uuml;llt, mu&szlig; alle Zeichen
enthalten, die zur Konstruktion von <img src="/img/cache/edd25afc0ad473b16119c88c5420034e.gif" alt="\overline{LP(A)}" valign="middle" />-Programmen
zul&auml;ssig sind. Das kleinste, Forderung (1) erf&uuml;llende Alphabet
ist demnach</p>
<pre><img src="/img/cache/5a9b6cb6b5a0aed5cc079fc95b4e2283.gif" alt="A_{\text{min}}" valign="middle" /> := { a,c,d,e,i,l,n,o,p,s,t,u,<img src="/img/cache/f8b1c5a729a09649c275fca88976d8dd.gif" alt="\varepsilon" valign="middle" />,<img src="/img/cache/59c30128bffef32225a57aa54baccdb6.gif" alt="\overline\varepsilon" valign="middle" />,<img src="/img/cache/4527477fa76c31fa71829b04a10cce76.gif" alt="\rotate{-90}]" valign="middle" />,:,=,;,,,<img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" />,|,'}</pre>
<p>Die Definition von <img src="/img/cache/edd25afc0ad473b16119c88c5420034e.gif" alt="\overline{LP(A)}" valign="middle" /> schr&auml;nkt die Wahl der Variablenmenge
VR in keiner Weise ein. Aus Forderung (1) ergibt sich
jedoch, da&szlig; auch f&uuml;r die Variablennamen eines selbstreproduzierenden
Programms <img src="/img/cache/f4b4b8e212bff848219a29ddf42216a5.gif" alt="\pi_{\text{rep}}\in\overline{LP(A)}" valign="middle" /> nur Buchstaben aus A in
Frage kommen.</p>
<p><strong>Forderung (2):</strong> <img src="/img/cache/5ecf0cb3bdef3f1817eac6c72ef92534.gif" alt="\text{VR\subseteq\{a\backslash B\}^*\backslash\{case,loop,end,input,output\}\backslash\{\varepsilon\}" valign="middle" />.
Dabei ist <img src="/img/cache/d99ca7c96340f698d32bb600e8e93725.gif" alt="B:=\{\rotate{-90}],:,=,\longr,,,;,\overline\varepsilon,\varepsilon,\ ',|\}" valign="middle" /> die
Menge der Sonderzeichen.</p>
<p>In einem <img src="/img/cache/c019131f2e8c9166d8d088543eb8c145.gif" alt="\overline{LP(A)" valign="middle" />-Programm, das Forderung (2) erf&uuml;llt, mu&szlig;
streng zwischen dem Variablennamen x und dem Zeichen x
unterschieden werden, wobei x ein Buchstabe aus A ist. Die Definition
von <img src="/img/cache/edd25afc0ad473b16119c88c5420034e.gif" alt="\overline{LP(A)}" valign="middle" /> schlie&szlig;t Fehlinterpretationen jedoch aus.</p>
<p><strong>(6.5.2) Satz:</strong> Sei A endliches Alphabet mit <img src="/img/cache/2a836dc11b29913dd95ab5e7030f47a6.gif" alt="A_{\text{min}}\subset A" valign="middle" />. Dann
existiert in <img src="/img/cache/cfbd1cf8450867f3e221b6dba73ea5ea.gif" alt="\overline{L_2(A)}" valign="middle" /> ein selbstreproduzierendes Programm,
falls <img src="/img/cache/edd25afc0ad473b16119c88c5420034e.gif" alt="\overline{LP(A)}" valign="middle" /> Forderung (2) erf&uuml;llt.</p>
<!--p.134-->
<p><strong>Beweis:</strong> Betrachte das Programm <img src="/img/cache/760777db71b289551f6a37329df527cf.gif" alt="\pi^2_{\text{rep}}" valign="middle" /></p>
<img src="/img/cache/aa73430dcea8087377bfeed2ef67d990.gif" alt="
\text{\underline{input};}\\
\text{a:=\'input;a:=\';;}\\
\text{c:=\':=\'\';;}\\
\text{d:=\'\'\';;}\\
\text{e:=lnloocppnoodpnnooepsnooipunoou\';;}\\
\begin{array}{lllll}
\text{i:=\'loop e}	&amp;\text{case}	&amp; \text{l \longr loop a}&amp;\text{case}	&amp;\text{ i \longr t:=t|i,}\\
			&amp;		&amp;			&amp;		&amp;\text{n \longr t:=t|n,}\\
			&amp;		&amp;			&amp;		&amp;\text{p \longr t:=t|p,}\\
			&amp;		&amp;			&amp;		&amp;\text{u \longr t:=t|u,}\\
			&amp;		&amp;			&amp;		&amp;\text{t \longr t:=t|t,}\\
			&amp;		&amp;			&amp;		&amp;\text{; \longr t:=t|;,}\\
			&amp;		&amp;			&amp;		&amp;\text{a \longr t:=t|a,}\\
			&amp;		&amp;			&amp;		&amp;\text{: \longr t:=t|:,}\\
			&amp;		&amp;			&amp;		&amp;\text{= \longr t:=t|=,}\\
			&amp;		&amp;			&amp;\text{end,}\\
			&amp;		&amp; \text{n \longr loop d}&amp;\text{case}	&amp;\text{\' \longr t:=t|\',}\\
			&amp;		&amp;			&amp;\text{end,}\\
			&amp;		&amp; \text{o \longr t:=t|;,}\\
			&amp;		&amp; \text{c \longr t:=t|c,}\\
			&amp;		&amp; \text{p \longr loop c}&amp;\text{case}	&amp;\text{: \longr t:=t|:,}\\
			&amp;		&amp;			&amp;		&amp;\text{= \longr t:=t|=,}\\
			&amp;		&amp;			&amp;		&amp;\text{\' \longr t:=t|\',}\\
			&amp;		&amp;			&amp;\text{end,}\\
			&amp;		&amp; \text{d \longr t:=t|d,}\\
			&amp;		&amp; \text{e \longr t:=t|e,}\\
			&amp;		&amp; \text{s \longr loop e}&amp;\text{case}	&amp;\text{l \longr t:=t|l,}\\
			&amp;		&amp;			&amp;		&amp;\text{n \longr t:=t|n,}\\
			&amp;		&amp;			&amp;		&amp;\text{o \longr t:=t|o,}\\
			&amp;		&amp;			&amp;		&amp;\text{c \longr t:=t|c,}\\
			&amp;		&amp;			&amp;		&amp;\text{p \longr t:=t|p,}\\
			&amp;		&amp;			&amp;		&amp;\text{d \longr t:=t|d,}\\
			&amp;		&amp;			&amp;		&amp;\text{e \longr t:=t|e,}\\
			&amp;		&amp;			&amp;		&amp;\text{s \longr t:=t|s,}\\
			&amp;		&amp;			&amp;		&amp;\text{i \longr t:=t|i,}\\
			&amp;		&amp;			&amp;		&amp;\text{u \longr t:=t|u,}\\
			&amp;		&amp;			&amp;\text{end,}\\
			&amp;		&amp; \text{i \longr t:=t|i,}\\
\end{array}
" valign="middle" /><br />
<!--p.135-->
<img src="/img/cache/2d4d8748027a02ff26ba8e71dc66c7f0.gif" alt="
\begin{array}{lllll}
\text{         }	&amp;		&amp; \text{u \longr loop i}&amp;\text{case}	&amp;\text{a \longr t:=t|a,}\\
			&amp;		&amp;			&amp;		&amp;\text{c \longr t:=t|c,}\\
			&amp;		&amp;			&amp;		&amp;\text{d \longr t:=t|d,}\\
			&amp;		&amp;			&amp;		&amp;\text{e \longr t:=t|e,}\\
			&amp;		&amp;			&amp;		&amp;\text{i \longr t:=t|i,}\\
			&amp;		&amp;			&amp;		&amp;\text{l \longr t:=t|l,}\\
			&amp;		&amp;			&amp;		&amp;\text{n \longr t:=t|n,}\\
			&amp;		&amp;			&amp;		&amp;\text{o \longr t:=t|o,}\\
			&amp;		&amp;			&amp;		&amp;\text{p \longr t:=t|p,}\\
			&amp;		&amp;			&amp;		&amp;\text{s \longr t:=t|s,}\\
			&amp;		&amp;			&amp;		&amp;\text{t \longr t:=t|t,}\\
			&amp;		&amp;			&amp;		&amp;\text{u \longr t:=t|u,}\\
			&amp;		&amp;			&amp;		&amp;\text{: \longr t:=t|:,}\\
			&amp;		&amp;			&amp;		&amp;\text{= \longr t:=t|=,}\\
			&amp;		&amp;			&amp;		&amp;\text{\' \longr t:=t|\',}\\
			&amp;		&amp;			&amp;		&amp;\text{; \longr t:=t|;,}\\
			&amp;		&amp;			&amp;		&amp;\text{\longr \longr t:=t|\longr,}\\
			&amp;		&amp;			&amp;		&amp;\text{\rotate{-90}] \longr t:=t|\rotate{-90}],}\\
			&amp;		&amp;			&amp;\text{end,}\\
			&amp;\text{end},\\
			&amp;\text{output t\';;}\\
\text{loop e}		&amp;\text{case}	&amp; \text{l \longr loop a}&amp;\text{case}	&amp;\text{ i \longr t:=t|i,}\\
			&amp;		&amp;			&amp;		&amp;\text{n \longr t:=t|n,}\\
			&amp;		&amp;			&amp;		&amp;\text{p \longr t:=t|p,}\\
			&amp;		&amp;			&amp;		&amp;\text{u \longr t:=t|u,}\\
			&amp;		&amp;			&amp;		&amp;\text{t \longr t:=t|t,}\\
			&amp;		&amp;			&amp;		&amp;\text{; \longr t:=t|;,}\\
			&amp;		&amp;			&amp;		&amp;\text{a \longr t:=t|a,}\\
			&amp;		&amp;			&amp;		&amp;\text{: \longr t:=t|:,}\\
			&amp;		&amp;			&amp;		&amp;\text{= \longr t:=t|=,}\\
			&amp;		&amp;			&amp;\text{end,}\\
			&amp;		&amp; \text{n \longr loop d}&amp;\text{case}	&amp;\text{\' \longr t:=t|\',}\\
			&amp;		&amp;			&amp;\text{end,}\\
			&amp;		&amp; \text{o \longr t:=t|;,}\\
			&amp;		&amp; \text{c \longr t:=t|c,}\\
			&amp;		&amp; \text{p \longr loop c}&amp;\text{case}	&amp;\text{: \longr t:=t|:,}\\
			&amp;		&amp;			&amp;		&amp;\text{= \longr t:=t|=,}\\
			&amp;		&amp;			&amp;		&amp;\text{\' \longr t:=t|\',}\\
			&amp;		&amp;			&amp;\text{end,}\\
\end{array}
" valign="middle" /><br />
<!--p.136-->
<img src="/img/cache/0a892d4f43d6b97cae8ba947b486cd2c.gif" alt="
\begin{array}{lllll}
\text{         }	&amp;		&amp; \text{d \longr t:=t|d,}\\
			&amp;		&amp; \text{e \longr t:=t|e,}\\
			&amp;		&amp; \text{s \longr loop e}&amp;\text{case}	&amp;\text{l \longr t:=t|l,}\\
			&amp;		&amp;			&amp;		&amp;\text{n \longr t:=t|n,}\\
			&amp;		&amp;			&amp;		&amp;\text{o \longr t:=t|o,}\\
			&amp;		&amp;			&amp;		&amp;\text{c \longr t:=t|c,}\\
			&amp;		&amp;			&amp;		&amp;\text{p \longr t:=t|p,}\\
			&amp;		&amp;			&amp;		&amp;\text{d \longr t:=t|d,}\\
			&amp;		&amp;			&amp;		&amp;\text{e \longr t:=t|e,}\\
			&amp;		&amp;			&amp;		&amp;\text{s \longr t:=t|s,}\\
			&amp;		&amp;			&amp;		&amp;\text{i \longr t:=t|i,}\\
			&amp;		&amp;			&amp;		&amp;\text{u \longr t:=t|u,}\\
			&amp;		&amp;			&amp;\text{end,}\\
			&amp;		&amp; \text{i \longr t:=t|i,}\\
			&amp;		&amp; \text{u \longr loop i}&amp;\text{case}	&amp;\text{a \longr t:=t|a,}\\
			&amp;		&amp;			&amp;		&amp;\text{c \longr t:=t|c,}\\
			&amp;		&amp;			&amp;		&amp;\text{d \longr t:=t|d,}\\
			&amp;		&amp;			&amp;		&amp;\text{e \longr t:=t|e,}\\
			&amp;		&amp;			&amp;		&amp;\text{i \longr t:=t|i,}\\
			&amp;		&amp;			&amp;		&amp;\text{l \longr t:=t|l,}\\
			&amp;		&amp;			&amp;		&amp;\text{n \longr t:=t|n,}\\
			&amp;		&amp;			&amp;		&amp;\text{o \longr t:=t|o,}\\
			&amp;		&amp;			&amp;		&amp;\text{p \longr t:=t|p,}\\
			&amp;		&amp;			&amp;		&amp;\text{s \longr t:=t|s,}\\
			&amp;		&amp;			&amp;		&amp;\text{t \longr t:=t|t,}\\
			&amp;		&amp;			&amp;		&amp;\text{u \longr t:=t|u,}\\
			&amp;		&amp;			&amp;		&amp;\text{: \longr t:=t|:,}\\
			&amp;		&amp;			&amp;		&amp;\text{= \longr t:=t|=,}\\
			&amp;		&amp;			&amp;		&amp;\text{\' \longr t:=t|\',}\\
			&amp;		&amp;			&amp;		&amp;\text{; \longr t:=t|;,}\\
			&amp;		&amp;			&amp;		&amp;\text{, \longr t:=t|,,}\\
			&amp;		&amp;			&amp;		&amp;\text{\longr \longr t:=t|\longr,}\\
			&amp;		&amp;			&amp;		&amp;\text{\rotate{-90}] \longr t:=t|\rotate{-90}],}\\
			&amp;		&amp;			&amp;\text{end,}\\
			&amp;\text{end},\\
			&amp;\text{output t;;}\\
\end{array}
" valign="middle" />
<p><img src="/img/cache/760777db71b289551f6a37329df527cf.gif" alt="\pi^2_{\text{rep}}" valign="middle" /> ist offensichtlich ein g&uuml;ltiges <img src="/img/cache/edd25afc0ad473b16119c88c5420034e.gif" alt="\overline{LP(A)}" valign="middle" />-Programm.</p>
<!--p.137-->
<p><strong>Zu zeigen:</strong> <img src="/img/cache/760777db71b289551f6a37329df527cf.gif" alt="\pi^2_{\text{rep}}" valign="middle" /> reproduziert sich selbst.</p>
<p>Da <img src="/img/cache/760777db71b289551f6a37329df527cf.gif" alt="\pi^2_{\text{rep}}" valign="middle" /> keine Eingabe besitzt, ist die Behauptung, da&szlig; sich
<img src="/img/cache/760777db71b289551f6a37329df527cf.gif" alt="\pi^2_{\text{rep}}" valign="middle" /> selbstreproduziert, gleichwertig mit der Aussage, da&szlig;
der Inhalt der Variablen t bei Ausf&uuml;hrung der letzten Anweisung
"<strong>output</strong> t" gleich <img src="/img/cache/760777db71b289551f6a37329df527cf.gif" alt="\pi^2_{\text{rep}}" valign="middle" /> ist.</p>
<ol type="I">
    <li>Im folgenden bezeichne [x] den Inhalt der Variablen mit
    dem Namen x. <img src="/img/cache/0cf5d36ccce29b0d9dc0a6c4b161aac7.gif" alt="x\in\{a,c,d,e,i,t\}\subset A_{\text{min}}" valign="middle" />.</li>
    <li>Auf Grund der Definition der <strong>loop</strong>-Schleife ist klar, da&szlig;
    die 4 inneren <strong>loop</strong>-Schleifen jeweils den Inhalt ihrer
    Laufvariablen an [t] h&auml;ngen und [t] somit verl&auml;ngern. Es
    sei hier folgende Abk&uuml;rzung vereinbart:<br />
<img src="/img/cache/3951055438d667958f3299fe089888e3.gif" alt="
{([t]:=[t][y]):=}\left\{
    \begin{array}{lll}
	\text{\underline{loop} y}&amp;\text{\underline{case}} &amp; \dots &amp; \longr &amp; \dots\\
				&amp;			&amp;	&amp; \vdots\\
				&amp;			&amp;	&amp; \vdots\\
				&amp;\text{\underline{end}}\\
    \end{array}
\right.\\
y\in\{a,c,d,e,i\}.
" valign="middle" />
    <p>Die Abk&uuml;rzung [t]:=[t]x hingegen bedeutet das
    Anh&auml;gen des Zeichens <img src="/img/cache/15ba9457f86ec9a30bc9c1186628cce1.gif" alt="x \in A" valign="middle" /> an den Inhalt von [t].</p></li>
    <li>Mit Hilfe der unter II. getroffenen Abk&uuml;rzungen l&auml;&szlig;t
    sich <img src="/img/cache/760777db71b289551f6a37329df527cf.gif" alt="\pi^2_{\text{rep}}" valign="middle" /> in der folgenden Form formulieren:
<pre class="source"><strong>input;</strong>
a:='input;a:=';;
c:=':='';;
d:=''';;
e:='lnlnoocppnoodpnnooepsnooipunoou';;
i:='loop e case l <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> [t]:=[t][a],
                n <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> [t]:=[t][d],
		o <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> [t]:=[t];,
		c <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> [t]:=[t]c,
		p <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> [t]:=[t][c],
		d <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> [t]:=[t]d,
		e <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> [t]:=[t]e,
		s <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> [t]:=[t][e],
		i <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> [t]:=[t]i,
		u <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> [t]:=[t][i],
<!--p.138-->
	    end;output t';;
[i]
</pre></li>
</ol>
<p>Die &auml;u&szlig;ere <strong>loop</strong>-Schleife arbeitet nun die Laufvariable e ab.
e enth&auml;lt genau die stringweise Kodierung von <img src="/img/cache/760777db71b289551f6a37329df527cf.gif" alt="\pi^2_{\text{rep}}" valign="middle" />. Die
Kodierung ist durch Hinschreiben der Alternativenliste gegeben.
Die &auml;u&szlig;ere <strong>loop</strong>-Schleife selbst dekodiert [e] und erzeugt
sukzessive <img src="/img/cache/760777db71b289551f6a37329df527cf.gif" alt="\pi^2_{\text{rep}}" valign="middle" />. In <img src="/img/cache/760777db71b289551f6a37329df527cf.gif" alt="\pi^2_{\text{rep}}" valign="middle" /> kommen nur Zeichen aus <img src="/img/cache/5a9b6cb6b5a0aed5cc079fc95b4e2283.gif" alt="A_{\text{min}}" valign="middle" /> vor.
Daher ist <img src="/img/cache/98ca861d3a3714a0af85c82f4131f65e.gif" alt="\pi^2_{\text{rep}}\in\overline{LP(A)}" valign="middle" /> f&uuml;r jedes <img src="/img/cache/a9bfde0666face79488a0b0a43e57c37.gif" alt="A\supset A_{\text{min}}" valign="middle" />, falls <img src="/img/cache/edd25afc0ad473b16119c88c5420034e.gif" alt="\overline{LP(A)}" valign="middle" />
Forderung (2) erf&uuml;llt.</p>
<p>Da die Schachtelungstiefe der <strong>loop</strong>-Schleifen in <img src="/img/cache/760777db71b289551f6a37329df527cf.gif" alt="\pi^2_{\text{rep}}" valign="middle" /> 2 ist,
folgt der Satz.</p>
<div align="right">%</div>
<p>Aus dem Programm <img src="/img/cache/760777db71b289551f6a37329df527cf.gif" alt="\pi^2_{\text{rep}}" valign="middle" /> aus dem obigen Beweis l&auml;&szlig;t sich ein
Programm <img src="/img/cache/6005e729c5bb9771453aaafc6273921b.gif" alt="\pi^1_{\text{rep}}" valign="middle" /> gewinnen, daa mit der <strong>loop</strong>-Schachtelungstiefe 1
auskommt.</p>
<p>Wir konstruieren <img src="/img/cache/6005e729c5bb9771453aaafc6273921b.gif" alt="\pi^1_{\text{rep}}" valign="middle" /> aus <img src="/img/cache/760777db71b289551f6a37329df527cf.gif" alt="\pi^2_{\text{rep}}" valign="middle" />, indem wir die &auml;u&szlig;ere
<strong>loop</strong>-Schleife eliminieren. Die &auml;u&szlig;ere <strong>loop</strong>-Schleife arbeitet
den Inhalt der Variablen e ab. Der Inhalt von e ist 31 Zeichen
lang. Wir listen nun f&uuml;r jedes der 31 Zeichen den Anweisungsteil
der Alternativenliste auf, den es kodiert. Da e seine
Kodierung enth&auml;lt und die Variable e bei Eliminierung der
&auml;u&szlig;eren <strong>loop</strong>-Schleife &uuml;berflussig wird, reduziert sich die
Anzahl dieser Anweisungsteile auf 25. Bei nunmehr 25 Zeichen
und insgesamt 10 Alternativen ist klar, da&szlig; einige Alternativen
mehrfach geschrieben werden m&uuml;ssen. Damit wird gleichzeitig
deutlich, da&szlig; die &auml;u&szlig;ere <strong>loop</strong>-Schleife von <img src="/img/cache/760777db71b289551f6a37329df527cf.gif" alt="\pi^2_{\text{rep}}" valign="middle" /> nur
abk&uuml;rzenden Charakter besitzt.</p>
<pre class="source"><img src="/img/cache/6005e729c5bb9771453aaafc6273921b.gif" alt="\pi^1_{\text{rep}}" valign="middle" /> = <strong>input</strong>;
        a:='input;a:=';;
	c:=':='';;
	d:=''';;
	i:='&lt;Alternative f&uuml;r l>;
            &lt;Alternative f&uuml;r n>;
            &lt;Alternative f&uuml;r l>;
<!--p.139-->
            &lt;Alternative f&uuml;r n>;
            &lt;Alternative f&uuml;r o>;
            &lt;Alternative f&uuml;r o>;
            &lt;Alternative f&uuml;r c>;
            &lt;Alternative f&uuml;r p>;
            &lt;Alternative f&uuml;r p>;
            &lt;Alternative f&uuml;r n>;
            &lt;Alternative f&uuml;r o>;
            &lt;Alternative f&uuml;r o>;
            &lt;Alternative f&uuml;r d>;
            &lt;Alternative f&uuml;r p>;
            &lt;Alternative f&uuml;r n>;
            &lt;Alternative f&uuml;r n>;
            &lt;Alternative f&uuml;r o>;
            &lt;Alternative f&uuml;r o>;
            &lt;Alternative f&uuml;r i>;
            &lt;Alternative f&uuml;r p>;
            &lt;Alternative f&uuml;r u>;
            &lt;Alternative f&uuml;r n>;
            &lt;Alternative f&uuml;r o>;
            &lt;Alternative f&uuml;r o>;
            &lt;Alternative f&uuml;r u>;
	    output t';;
        &lt;Alternative f&uuml;r l>;
        &lt;Alternative f&uuml;r n>;
        &lt;Alternative f&uuml;r l>;
        &lt;Alternative f&uuml;r n>;
        &lt;Alternative f&uuml;r o>;
        &lt;Alternative f&uuml;r o>;
        &lt;Alternative f&uuml;r c>;
        &lt;Alternative f&uuml;r p>;
        &lt;Alternative f&uuml;r p>;
        &lt;Alternative f&uuml;r n>;
        &lt;Alternative f&uuml;r o>;
        &lt;Alternative f&uuml;r o>;
        &lt;Alternative f&uuml;r d>;
        &lt;Alternative f&uuml;r p>;
        &lt;Alternative f&uuml;r p>;
        &lt;Alternative f&uuml;r n>;
<!--p.140-->
        &lt;Alternative f&uuml;r o>;
        &lt;Alternative f&uuml;r o>;
        &lt;Alternative f&uuml;r i>;
        &lt;Alternative f&uuml;r p>;
        &lt;Alternative f&uuml;r u>;
        &lt;Alternative f&uuml;r n>;
        &lt;Alternative f&uuml;r o>;
        &lt;Alternative f&uuml;r o>;
        &lt;Alternative f&uuml;r u>;
	<strong>output</strong> t
</pre>
<p>Dabei sind die Teile in spitzen Klammern zu ersetzen:</p>
<p><img src="/img/cache/23bbdbcf160fd9e35daadb4bbcf36c04.gif" alt="
\begin{array}{ll}
    \text{&lt;Alternative f\ddot{u}r l&gt; durch}\\
    &amp; \fbox {
    \begin{array}{llll}
	\text{loop a}	&amp; \text{case}	&amp; i &amp; \longr t:=t|i,\\
			&amp;		&amp; n &amp; \longr t:=t|n,\\
			&amp;		&amp; p &amp; \longr t:=t|p,\\
			&amp;		&amp; u &amp; \longr t:=t|u,\\
			&amp;		&amp; t &amp; \longr t:=t|t,\\
			&amp;		&amp; ; &amp; \longr t:=t|;,\\
			&amp;		&amp; a &amp; \longr t:=t|a,\\
			&amp;		&amp; : &amp; \longr t:=t|:,\\
			&amp;		&amp; = &amp; \longr t:=t|=,\\
			&amp; \text{end}\\
    \end{array}
    }\\
    \text{&lt;Alternative f\ddot{u}r n&gt; durch}\\
    &amp; \fbox {
    \begin{array}{llll}
	\text{loop d}	&amp; \text{case}	&amp; \text{\'} &amp; \longr t:=t|\text{\'},\\
			&amp; \text{end}\\
    \end{array}
    }\\
    \text{&lt;Alternative f\ddot{u}r o&gt; durch} &amp; \fbox{t:=t|;}\\
    \text{&lt;Alternative f\ddot{u}r c&gt; durch} &amp; \fbox{t:=t|c}\\
    \text{&lt;Alternative f\ddot{u}r p&gt; durch}\\
    &amp; \fbox {
    \begin{array}{llll}
	\text{loop c}	&amp; \text{case}	&amp; : &amp; \longr t:=t|:,\\
			&amp;		&amp; = &amp; \longr t:=t|=,\\
			&amp; 		&amp; \text{\'} &amp; \longr t:=t|\text{\'},\\
			&amp; \text{end}\\
    \end{array}
    }\\
    
    \text{&lt;Alternative f\ddot{u}r d&gt; durch} &amp; \fbox{t:=t|d}\\
    \text{&lt;Alternative f\ddot{u}r i&gt; durch} &amp; \fbox{t:=t|i}\\    
\end{array}
" valign="middle" /><br />
<!--p.141-->
<img src="/img/cache/cb62778f95aa7d717f08cbe708e37669.gif" alt="
\begin{array}{ll}
    \text{&lt;Alternative f\ddot{u}r u&gt; durch}\\
    &amp; \fbox {
    \begin{array}{llll}
	\text{loop i}	&amp; \text{case}	&amp; a &amp; \longr t:=t|a,\\
			&amp;		&amp; c &amp; \longr t:=t|c,\\
			&amp;		&amp; d &amp; \longr t:=t|d,\\
			&amp;		&amp; e &amp; \longr t:=t|e,\\
			&amp;		&amp; i &amp; \longr t:=t|i,\\
			&amp;		&amp; l &amp; \longr t:=t|l,\\
			&amp;		&amp; n &amp; \longr t:=t|n,\\
			&amp;		&amp; o &amp; \longr t:=t|o,\\
			&amp;		&amp; p &amp; \longr t:=t|p,\\
			&amp;		&amp; s &amp; \longr t:=t|s,\\
			&amp;		&amp; t &amp; \longr t:=t|t,\\
			&amp;		&amp; u &amp; \longr t:=t|u,\\
			&amp;		&amp; : &amp; \longr t:=t|:,\\
			&amp;		&amp; = &amp; \longr t:=t|=,\\
			&amp;		&amp; \text{\'} &amp; \longr t:=t|\text{\'},\\
			&amp;		&amp; ; &amp; \longr t:=t|;,\\
			&amp;		&amp; , &amp; \longr t:=t|,,\\
			&amp;		&amp; \longr &amp; \longr t:=t|\longr,\\
			&amp;		&amp; \rotate{-90}] &amp; \longr t:=t|\rotate{-90}],\\
			&amp; \text{end}\\
    \end{array}
    }
\end{array}
" valign="middle" /></p>
<p>Offensichtlich gilt: <img src="/img/cache/6005e729c5bb9771453aaafc6273921b.gif" alt="\pi^1_{\text{rep}}" valign="middle" />, reproduziert sich selbst. Da
<img src="/img/cache/1f9f52b67dedd2d67a631b4f22d14db6.gif" alt="\pi^1_{\text{rep}}\in A^*_{\text{min}}" valign="middle" />, k&ouml;nnen wir den folgenden Satz formulieren:</p>
<p><strong>(6.5.3) Satz:</strong> Sei A endliches Alphabet mit <img src="/img/cache/2a836dc11b29913dd95ab5e7030f47a6.gif" alt="A_{\text{min}}\subset A" valign="middle" />, Dann
existiert in <img src="/img/cache/565c52b8f98942a3f50240f16d0bf191.gif" alt="\overline{L_1(A)}" valign="middle" /> ein selbstreproduzierendes Programm,
falls <img src="/img/cache/edd25afc0ad473b16119c88c5420034e.gif" alt="\overline{LP(A)}" valign="middle" /> Forderung (2) erf&uuml;llt.</p>
<p>Nach der recht einfachen Konstruktion von <img src="/img/cache/6005e729c5bb9771453aaafc6273921b.gif" alt="\pi^1_{\text{rep}}" valign="middle" /> aus <img src="/img/cache/760777db71b289551f6a37329df527cf.gif" alt="\pi^2_{\text{rep}}" valign="middle" />
k&ouml;nnte man versucht sein, aus <img src="/img/cache/6005e729c5bb9771453aaafc6273921b.gif" alt="\pi^1_{\text{rep}}" valign="middle" /> ein selbstreproduzierendes
Programm <img src="/img/cache/3f0982b9451bc89143756dbed573bf4e.gif" alt="\pi^0_{\text{rep}}" valign="middle" /> gewinnen zu wollen, das ganz ohne <strong>loop</strong>-Schleifen
auskommt. Zu diesem Zweck m&uuml;&szlig;ten in <img src="/img/cache/6005e729c5bb9771453aaafc6273921b.gif" alt="\pi^1_{\text{rep}}" valign="middle" /> die
noch verbleibenden <strong>loop</strong>-Schleifen</p>
<pre class="source">
             &lt;Alternative f&uuml;r l>;
             &lt;Alternative f&uuml;r n>;
             &lt;Alternative f&uuml;r p>;
             &lt;Alternative f&uuml;r u>;
</pre>
<!--p.142-->
<p>eliminiert werden. Die erste dieser <strong>loop</strong>-Schleifen lie&szlig;e
sich ohne weiteres in eine Folge von Grundanweisungen zerlegen,
da sie, wie schon die &auml;u&szlig;ere <strong>loop</strong>-Schleife von <img src="/img/cache/760777db71b289551f6a37329df527cf.gif" alt="\pi^2_{\text{rep}}" valign="middle" />,
nur abk&uuml;rzenden Charakter hat. Schwierigkeiten ergeben sich
bei &lt;Alternative f&uuml;r n>. &lt;Alternative f&uuml;r n> lie&szlig;e sich
ohne <strong>loop</strong> wie folgt schreiben:<br />
<img src="/img/cache/5400e6c7f5f08d69caa3c73c5092bae2.gif" alt="\hspace{100}\text{t:=t|\'}" valign="middle" /></p>
<p>Da auf &lt;Alternative f&uuml;r n) ein Semikolon folgt, w&uuml;rde die
Textkonstante von i den Teilstring t:=t|'; und damit die
f&uuml;r Textkonstanten verbotene Kombination '; enthalten
(vgl. 6.4.). &lt;Alternative f&uuml;r n> l&auml;&szlig;t sich also nicht durch
einen sequentiellen Programmteil ersetzen. Dieser Umstand
liegt jedoch nur an der in 6.4. vorgenommenen Definition
der Textkonstanten in <img src="/img/cache/edd25afc0ad473b16119c88c5420034e.gif" alt="\overline{LP(A)}" valign="middle" />-Programmen. Es ist durchaus
denkbar, da&szlig; er sich bei einer anderen Definition der Textkonstanten
vermeiden lie&szlig;e. &Auml;hnliches gilt f&uuml;r &lt;Alternative
f&uuml;r p>.</p>
<p>Anders liegen allerdings die Verh&auml;ltnisse bei &lt;Alternative
f&uuml;r u>. Diese <strong>loop</strong>-Schleife dient dazu, den Inhalt
der Variablen i an. den Inhalt der Variablen t zu h&auml;ngen.
&lt;Alternative f&uuml;r u) ist nun aber selbst <strong>textueller</strong>
Bestandteil des Inhalts von i.</p>
<pre>		i:='..........&lt;Alternative f&uuml;r u>..........'</pre>
<p>&lt;Alternative f&uuml;r u> la&szlig;t sich nicht durch eine Sequenz von
Grundanweisungen ersetzen. Es l&auml;&szlig;t sich aus <img src="/img/cache/6005e729c5bb9771453aaafc6273921b.gif" alt="\pi^1_{\text{rep}}" valign="middle" /> kein
selbstreproduzierendes Programm gewinnen, das ohne <strong>loop</strong>-Schleifen
auskommt. Es gilt sogar:</p>
<p><strong>(6.5.4) Satz:</strong> F&uuml;r jedes endliche Alphabet A gilt:<br />
Es existiert kein selbstreproduzierendes Programm
in <img src="/img/cache/45fae55e34171c38b570152d08a6eef0.gif" alt="\overline{LP_0(A)}" valign="middle" /></p>
<p><strong>Beweis:</strong> Sei <img src="/img/cache/edd25afc0ad473b16119c88c5420034e.gif" alt="\overline{LP(A)}" valign="middle" /> &uuml;ber dem endlichen Alphabet A vorgelegt.
Sei die notwendige Forderung (2) erf&uuml;llt.</p>
<p><strong>Annahme:</strong> Es existiert selbstreproduzierendes Programm
<img src="/img/cache/9a9799a64c546f9ef925b51159828491.gif" alt="\pi^0\in\overline{LP_0(A)}" valign="middle" />. Dann hat <img src="/img/cache/0e247a5641367657d284b8c40b71ff8d.gif" alt="\pi^0" valign="middle" /> den Aufbau:</p>
<!--p.143-->
<img src="/img/cache/d688c069f55913493447709e6533b80a.gif" alt="\pi^0=\text{\underline{input}; AW_{\pi^0}; \underline{output} t}" valign="middle" />
<p>In <img src="/img/cache/3c4567ebcf55e1f78059eed33a910786.gif" alt="AW_{\pi^0}" valign="middle" /> mu&szlig; der Text <img src="/img/cache/0e247a5641367657d284b8c40b71ff8d.gif" alt="\pi^0" valign="middle" /> aufgebaut werden. Da
keine <strong>loop</strong>-Schleifen zur Verf&uuml;gung stehen, sind
nur zwei M&ouml;glichkeiten zur Erzeugung des Textes
<img src="/img/cache/0e247a5641367657d284b8c40b71ff8d.gif" alt="\pi^0" valign="middle" /> in <img src="/img/cache/71ea8ce72c9e5eca55ccbabef6fab479.gif" alt="AW_{\pi^0" valign="middle" /> gegeben.</p>
<p><strong>1. Fall:</strong> Der Text <img src="/img/cache/0e247a5641367657d284b8c40b71ff8d.gif" alt="\pi^0" valign="middle" /> wird, en bloc mit Hilfe einer Grundanweisung
vom Typ <img src="/img/cache/5b6f0f60c37ff5ffce55a023aa65079e.gif" alt="\gamma_6" valign="middle" /> erzeugt. Dann gilt f&uuml;r <img src="/img/cache/0e247a5641367657d284b8c40b71ff8d.gif" alt="\pi^0" valign="middle" /> die
Textgleichung<br />
<img src="/img/cache/1788eb9f92c8864038518dd2cb984ff0.gif" alt="\pi^0=\text{\underline{input};t:=\'\pi^0\';\underline{output} t}" valign="middle" /><br />
Diese Gleichung kann aber von keinem endlichen
Text <img src="/img/cache/0e247a5641367657d284b8c40b71ff8d.gif" alt="\pi^0" valign="middle" /> erf&uuml;llt werden. Widerspruch!</p>
<p><strong>2. Fall:</strong> Der Text <img src="/img/cache/d4c98d75e25f5d28461f1da221eb7a95.gif" alt="\pi_0" valign="middle" /> wird in <img src="/img/cache/3c4567ebcf55e1f78059eed33a910786.gif" alt="AW_{\pi^0}" valign="middle" /> zeichenweise mit
Anweisungen vom Typ <img src="/img/cache/6b362d1b588c3abdd9c41933926fa747.gif" alt="\gamma_3'" valign="middle" /> aufgebaut. Da <img src="/img/cache/0e247a5641367657d284b8c40b71ff8d.gif" alt="\pi^0" valign="middle" /> ungleich dem
leeren Wort seih mu&szlig;, kommt in <img src="/img/cache/3c4567ebcf55e1f78059eed33a910786.gif" alt="AW_{\pi^0}" valign="middle" /> mindestens
einmal die Anweisung t:=t|x; mit <img src="/img/cache/15ba9457f86ec9a30bc9c1186628cce1.gif" alt="x \in A" valign="middle" /> vor. Diese
Anweisung umfa&szlig;t 7 Zeichen. Als String interpretiert
ist sie textueller Bestandteil von <img src="/img/cache/0e247a5641367657d284b8c40b71ff8d.gif" alt="\pi^0" valign="middle" />. Die Anweisung
kann nur h&ouml;chstens eines seiner 7 Zeichen an
die Ausgabevariable t h&auml;ngen. Daraus folgt, da&szlig;
mindestens 6 Zeichen unbearbeitet bleiben. F&uuml;r diese
6 Zeichen sind dann weitere 6 Befehle vom Typ <img src="/img/cache/6b362d1b588c3abdd9c41933926fa747.gif" alt="\gamma_3'" valign="middle" />
notwendig. Diese 6 Anweisungen hinterlassen ihrerseits
36 unbearbeitete Zeichen, u.s.w.</p>
<p>Um also einen Text der L&auml;nge <img src="/img/cache/432e7f7800e5150ec09374bf7b3acddc.gif" alt="k\ge0" valign="middle" /> mit Anweisungen
vom Typ <img src="/img/cache/6b362d1b588c3abdd9c41933926fa747.gif" alt="\gamma_3'" valign="middle" /> zu erzeugen, braucht man mindestens
ein Programm der L&auml;nge <img src="/img/cache/f6ce32f6f2be48cd4361d35ec0480a25.gif" alt="k\cdot7" valign="middle" />.</p>
<p>Damit gibt es kein <strong>endliches</strong> Programm der L&auml;nge
k, das nur mit Anweisungen vom Typ <img src="/img/cache/6b362d1b588c3abdd9c41933926fa747.gif" alt="\gamma_3'" valign="middle" /> einen
<strong>endlichen</strong> Text der L&auml;nge k aus dem leeren Wort
aufbauen kann, insbesondere nicht seinen eigenen Text.
<img src="/img/cache/0e247a5641367657d284b8c40b71ff8d.gif" alt="\pi^0" valign="middle" /> ist also nicht endlich und damit kein Programm.
Widerspruch!</p>
<div align="right">%</div>
<p><strong>(6.5.5) Bemerkung:</strong> In Kapitel 2 wurde die Existenz
selbstreproduzierender PL(A)-Programme nachgewiesen
(Satz (2.8.7)). Dieser Nachweis beruhte neben dem
<!--p.144-->
- T45 -
Rekursionstheorem (Satz (2.8.4)) auf dar Existenz
einer universellen Funktion f&uuml;r die Funktionenklasse
<img src="/img/cache/30347e3a58a21c9a79456ac9d69bfe7f.gif" alt="\calP^1_1" valign="middle" />.<br />
Die Klasse aller Wortfunktionen<br />
<img src="/img/cache/17118433989021af7c0292842a9758d1.gif" alt="\varphi\ :\  (A^*)^r\longr(A^*)^s,\ r,s\ge0\ ," valign="middle" /><br />
die sich mittels <img src="/img/cache/edd25afc0ad473b16119c88c5420034e.gif" alt="\overline{LP(A)}" valign="middle" />-Programmen berechnen lassen,
ist eine Funktionenklasse, die nur aus totalen
Funktionen besteht; <img src="/img/cache/edd25afc0ad473b16119c88c5420034e.gif" alt="\overline{LP(A)}" valign="middle" />-Programme halten immer an.
In [5] Seite 47 wird gezeigt, da&szlig; es f&uuml;r <img src="/img/cache/edd25afc0ad473b16119c88c5420034e.gif" alt="\overline{LP(A)}" valign="middle" />-berechenbare
Funktionen keine universelle <img src="/img/cache/edd25afc0ad473b16119c88c5420034e.gif" alt="\overline{LP(A)}" valign="middle" />-berechenbare
Funktion geben kann. Trotzdem gibt es in
<img src="/img/cache/63bb117a2be1d6662bbcb7b23477a251.gif" alt="\overline{LP(A_{\text{min}})}" valign="middle" /> selbstreproduzierende Programme.
Universalit&auml;t kann also keine notwendige Voraussetzung f&uuml;r
Selbstreproduktion sein. Es mu&szlig; also auch andere
(direktere!) Wege als der in Kapitel 2 beschrittene
Weg geben, um die Existenz selbstreproduzierender
Programme theoretisch nachzuweisen.</p>
<h3><a name="c66"></a>6.6. Selbstreproduktionssatz f&uuml;r <img src="/img/cache/edd25afc0ad473b16119c88c5420034e.gif" alt="\overline{LP(A)}" valign="middle" />-Programme</h3>
<p>In Kapitel 5 zeigten, die S&auml;tze (5.2.4) und (5.3.1) die
Existenz selbstreproduzierender Versionen beliebiger SIMULA-
bzw. PASCAL-Programme. Ein analoger Satz l&auml;&szlig;t sich auch f&uuml;r
<img src="/img/cache/edd25afc0ad473b16119c88c5420034e.gif" alt="\overline{LP(A)}" valign="middle" />-Programme beweisen. Ersetzt man in Abschnitt 5.1. die
Sprechweise "Eingabedatei" und "Ausgabedatei" wieder durch
"Eingabevariable" bzw. "Ausgabevariable", so ist auch die
selbstreproduzierende Version f&uuml;r <img src="/img/cache/edd25afc0ad473b16119c88c5420034e.gif" alt="\overline{LP(A)}" valign="middle" />-Programme erkl&auml;rt.</p>
<p>Sei A ein beliebiges endliches Alphabet, sei <img src="/img/cache/1623c801fd1f0ff3038caa795ad85937.gif" alt="\pi\in\overline{LP(A)}" valign="middle" />.
M&ouml;glicherweise existiert in <img src="/img/cache/edd25afc0ad473b16119c88c5420034e.gif" alt="\overline{LP(A)}" valign="middle" /> keine selbstreproduzierende
Version <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /> zu <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> (etwa weil die in <img src="/img/cache/edd25afc0ad473b16119c88c5420034e.gif" alt="\overline{LP(A)}" valign="middle" /> verwendeten
Variablennamen nicht aus <img src="/img/cache/1304435c8bc4c0f5b8ecbe7f16727d75.gif" alt="A^*" valign="middle" /> sind), sondern erst in der Sprache
<img src="/img/cache/4fd069d93a608bb7e4d2ea795ca650e3.gif" alt="\overline{LP(B)}" valign="middle" /> mit einem entsprechend "gro&szlig;en" Alphabet <img src="/img/cache/5aa0ac144e79f720cb55fb0836781a64.gif" alt="B \supset A" valign="middle" />. Nach
Definition (5.1.4) w&auml;re ein solches <img src="/img/cache/f01169ccbba3128072fa0641d7a1d539.gif" alt="\tilde\pi\in\overline{LP(B)}" valign="middle" /> keine
selbstreproduzierende Version von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" />, da es mit einem anderen
Datenbereich arbeitet. Definition (5.1.4) ist aber erf&uuml;llt,
wenn man <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> ebenfalls als Programm aus <img src="/img/cache/4fd069d93a608bb7e4d2ea795ca650e3.gif" alt="\overline{LP(B)}" valign="middle" /> auffa&szlig;t, was ja
wegen <img src="/img/cache/0829539f10804a325eaceff2c3c43ac1.gif" alt="A \subset B" valign="middle" /> durchaus zu vertreten ist: Die von <img src="/img/cache/1623c801fd1f0ff3038caa795ad85937.gif" alt="\pi\in\overline{LP(A)}" valign="middle" /> realisierte
<!--p.145-->
Funktion ist gleich der Restriktion der von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> als
<img src="/img/cache/cb4781b107b10908602fd9b077f1c664.gif" alt="\overline{LP(B)" valign="middle" />-Programm realisierten Funktion auf <img src="/img/cache/40c4665a2dcf60b453500dcf8eb0bdaf.gif" alt="(A^*)^r,\ r\ge0" valign="middle" /> (vgl.
Definition (5.1.1)).</p>
<p>Dieser Sichtweise entspricht Satz (6.6.1).</p>
<p><strong>(6.6.1) Selbstreproduktionssatz f&uuml;r <img src="/img/cache/edd25afc0ad473b16119c88c5420034e.gif" alt="\overline{LP(A)}" valign="middle" />-Programme</strong></p>
<p>Seien A ein endliches Alphabet, <img src="/img/cache/1623c801fd1f0ff3038caa795ad85937.gif" alt="\pi\in\overline{LP(A)}" valign="middle" />. Dann gibt
es ein endliches Alphabet <img src="/img/cache/0e53bc26b00b63916fef34480055399d.gif" alt="B,\ A \subset B" valign="middle" />, so da&szlig; gilt:</p>
<ol type="a">
    <li>Es existiert eine selbstreproduzierende Version
    <img src="/img/cache/3a16028adfd8b703d008e941f7f1d2ea.gif" alt="\pi\in\overline{LP(B)}" valign="middle" /> von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> (wobei <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> als Element aus <img src="/img/cache/4fd069d93a608bb7e4d2ea795ca650e3.gif" alt="\overline{LP(B)}" valign="middle" />
    aufzufassen ist).</li>
    <li><img src="/img/cache/aefbb55b88780dc5cb5578793699b0d7.gif" alt="
\tilde\pi\in
\left\{
    \text{\overline{LP_2(B)} , falls \pi \in \overline{LP_j(A)} , j=0,1}\\
    \text{\overline{LP_i(B)} , falls \pi \in \overline{LP_i(A)} , i \ge 2}
\right.
    " valign="middle" /></li>
</ol>
<p><strong>Beweis:</strong> Seien A beliebiges endliches Alphabet, <img src="/img/cache/1623c801fd1f0ff3038caa795ad85937.gif" alt="\pi\in\overline{LP(A)}" valign="middle" />.
O.B.d.A. seien alle Variablennamen aus <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> nicht aus
{c,d,e,i,t}.</p>
<p><em>Konstruktion der selbstreproduzierenden Version <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /></em></p>
<p><img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> hat den folgenden Aufbau</p>
<img src="/img/cache/d832c8f979e3c0e903a66899df57c3a5.gif" alt="
\begin{array}{lll}
\pi=&amp; \text{\underline{input}}	&amp; y_1, \dots, y_r;\\
    &amp;				&amp; AW_\pi;\\
    &amp; \text{\underline{output}}	&amp; z_1, \dots, z_w,\ \ \ r,w\ge0
\end{array}
" valign="middle" />
<p>Sei <img src="/img/cache/5f72e7ea87beb2bdcfec31888ea4bc76.gif" alt="A_\pi" valign="middle" /> die Menge aller Zeichen, aus denen das Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" />
zusammengesetzt ist. Der String <img src="/img/cache/f2970a41e57060372c23072999da8ad4.gif" alt="S\in A^*_\pi" valign="middle" /> sei wie folgt definiert:</p>
<pre>
    S:=input <img src="/img/cache/57c484111bc3adf5b1c751c0aef203e4.gif" alt="y_1,\dots,y_r" valign="middle" />;<img src="/img/cache/e138b6015eb8c53e318a0d830ec4b75a.gif" alt="\underline{AW_\pi}" valign="middle" />;
                         <img src="/img/cache/65532efbf8fbd662e6ab99f1bfb0bbf7.gif" alt="\uparrow" valign="middle" />
             (hiermit ist nat&uuml;rlich der <strong>Text</strong> des
	      Anweisungsteils von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> gemeint)
</pre>
<p>Es gilt: <img src="/img/cache/5f4d092bdd945dfbf6d6dcbf1c6a9208.gif" alt="\pi=S \circ \text{output } z_1,\dots,z_w" valign="middle" />.</p>
<p>S wird in eine Folge von <img src="/img/cache/faf1b3a30453e631b14c4b627225001e.gif" alt="n\ge1" valign="middle" /> Teilstrings <img src="/img/cache/e406ac4d7c470823a8619c13dd7101be.gif" alt="s_i" valign="middle" /> zerlegt mit:</p>
<ol type="i">
    <li><img src="/img/cache/361ec12274d571a0c4702a9c4524955b.gif" alt="s_i=\text{\';    oder  \';}" valign="middle" /> ist nicht in <img src="/img/cache/e406ac4d7c470823a8619c13dd7101be.gif" alt="s_i" valign="middle" /> enthalten</li>
<!--p.146-->
    <li><img src="/img/cache/e406ac4d7c470823a8619c13dd7101be.gif" alt="s_i" valign="middle" /> enth&auml;lt '; nicht <img src="/img/cache/83bb46813b72c08be9f1a3c70bfb4752.gif" alt="\Rightarrow s_{i+1}=\text{\';  },i \le n" valign="middle" /></li>
    <li><img src="/img/cache/c4d9c0700f8977add12a515b7d11861c.gif" alt="s_1 \circ s_2 \circ \dots \circ s_n=S" valign="middle" /></li>
</ol>
<p>(<em>Zur Erinnerung:</em> '; dient als Endemarkierung von Textkonstanten
und darf selbst nicht Teiistring einer Textkonstanten
sein.)</p>
<p>Weitere Vorbereitungen:</p>
<ul>
    <li><img src="/img/cache/405e36052790da2328089342fac14295.gif" alt="\calJ:=\{s_1,\dots,s_n\}" valign="middle" /> <strong>Menge</strong> der Teilstrings.</li>
    <li>q sei die Anzahl der Teilstrings von S, die ungleich
    '; sind. Es gilt <img src="/img/cache/43637af6a1e7e9143dda6d36e15e3927.gif" alt="1 \le q \le n" valign="middle" />.</li>
    <li><img src="/img/cache/afabe0a22611148dd6aa250829411e3b.gif" alt="x_1,\dots,x_{2q}" valign="middle" /> seien Zeichen, die weder in {c,d,e,i,t}
    noch als Variablennamen in <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> vorkommen.</li>
    <li><img src="/img/cache/e6f2846d83a2db009f2e90f9f4067f1e.gif" alt="B:=A \cup A_\pi \cup A_{\text{min}} \cup \{x_1,\dots,x_{2q}\}" valign="middle" /><br />
    B ist ein endliches Aiphabet und l&auml;&szlig;t sich als solches
    in der Form <img src="/img/cache/a84a764a9e9d85e24362f52ceb4e667c.gif" alt="B:=\{b_1,\dots,b_\alpha\}" valign="middle" /> schreiben, wobei <img src="/img/cache/7b7f9dbfea05c83784f8b85149852f08.gif" alt="\alpha" valign="middle" /> die
    Kardinalit&auml;t von B ist.</li>
    <li>Definition der Funktionen <img src="/img/cache/e3556d90f5424558d9b8d28fae296683.gif" alt="\calG" valign="middle" /> und <img src="/img/cache/9ee7ebd7ca9329b9d4039f04132b5c5d.gif" alt="\tilde\calG" valign="middle" />:<br />
<img src="/img/cache/9c0d97d3e64fad21f8c82a42da60ad85.gif" alt="
\begin{array}{lcll}
\calG\ :&amp; [q]	&amp; \longr &amp; \calJ\\
	&amp; i	&amp; \longr &amp; \text{s_j, wobei s_j der i-te Teilstring ungleich \'; ist.}\\
\tilde\calG\ :
	&amp; [n]	&amp; \longr &amp; B^*\\
	&amp; i	&amp; \longr &amp; {
	\left\{
	    \text{no, falls s_i=\';}\\
	    \text{x_j, falls s_i der j-te Teilstring ungleich '; ist.}
	\right. }
\end{array}
" valign="middle" /></li>
    <li>Sei v eine zul&auml;ssige Variable, dann sei die Anweisung<br />
<img src="/img/cache/9e950f022903fd2c1b12b4685ff4bc43.gif" alt="
\begin{array}{lllcl}
    \text{\underline{loop} v}&amp;\text{\underline{case}}	&amp; b_1 \longr t:=t|b_1,\\
			    &amp;				&amp; \dots\ \dots\ \dots\\
			    &amp;				&amp; b_\alpha \longr t:=t|b_\alpha,\\
			    &amp;\text{\underline{end}}
\end{array}
" valign="middle" /><br />
    durch <strong>loop</strong> v abgek&uuml;rzt.</li>
</ul>
<p>Nach diesen Vorbereitungen l&auml;&szlig;t sich <img src="/img/cache/f01169ccbba3128072fa0641d7a1d539.gif" alt="\tilde\pi\in\overline{LP(B)}" valign="middle" /> angeben:</p>
<!--p.147-->
<pre class="source"><img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /> = 
<img src="/img/cache/54dbe5ef61d2f9977c7be03737833609.gif" alt="s_1" valign="middle" /> ..... <img src="/img/cache/effb8304d535bcb6e9e858a75593e93e.gif" alt="s_n" valign="middle" />        <img src="/img/cache/ecd8d6224a73d01b9d78156c7ae0c367.gif" alt="\fbox{\text{=\underline{input} y_1,\dots,y_r; AW_\pi}}" valign="middle" />
<img src="/img/cache/aa687da0086c1ea060a8838e24611319.gif" alt="x_1" valign="middle" />:='<img src="/img/cache/3dc303de9333710cf47bf601b897a6a6.gif" alt="\calG(1)" valign="middle" />';;
<img src="/img/cache/8732099f74d777a67257cb2f04ead3d8.gif" alt="x_2" valign="middle" />:='<img src="/img/cache/8cbba1478622a261c58a62f63ee826d5.gif" alt="\calG(2)" valign="middle" />';;
.............
<img src="/img/cache/ca7f076fd16d9f003adeba177eb6e410.gif" alt="x_q" valign="middle" />:='<img src="/img/cache/212e050083a418adc96bebed165f9c59.gif" alt="\calG(q)" valign="middle" />';;
c:=':='';;
d:=''';
e:='<img src="/img/cache/18bdd05fc0a89d6ffd77cb2064ae35c5.gif" alt="\tilde\calG(1)" valign="middle" /> ..... <img src="/img/cache/a094cc7ea82ac48f4a7f2fef9cde0f76.gif" alt="\tilde\calG(n)" valign="middle" />
    <img src="/img/cache/b2009d12b4e604d7a298fa20b0fba0b4.gif" alt="x_1px_{q+1}" valign="middle" />noo
    ............
    <img src="/img/cache/76527cbec80fa1feadf0b3a819f23b36.gif" alt="x_qpx_{q+q}" valign="middle" />noo
    cppnoodpnnooepsnooipunoou';;
i:='loop e case <img src="/img/cache/aa687da0086c1ea060a8838e24611319.gif" alt="x_1" valign="middle" /> <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> t:=t|<img src="/img/cache/aa687da0086c1ea060a8838e24611319.gif" alt="x_1" valign="middle" />,
                <img src="/img/cache/8732099f74d777a67257cb2f04ead3d8.gif" alt="x_2" valign="middle" /> <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> t:=t|<img src="/img/cache/8732099f74d777a67257cb2f04ead3d8.gif" alt="x_2" valign="middle" />,
		...................
		<img src="/img/cache/ca7f076fd16d9f003adeba177eb6e410.gif" alt="x_q" valign="middle" /> <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> t:=t|<img src="/img/cache/ca7f076fd16d9f003adeba177eb6e410.gif" alt="x_q" valign="middle" />,
		c <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> t:=t|c,
		d <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> t:=t|d,
		e <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> t:=t|e,
		i <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> t:=t|i,
		<img src="/img/cache/beced39fddd8bd82fc7cbb4b023116c4.gif" alt="x_{q+1}" valign="middle" /> <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> loop <img src="/img/cache/aa687da0086c1ea060a8838e24611319.gif" alt="x_1" valign="middle" />,
		<img src="/img/cache/611d558b0ba02e750f00118493a32f00.gif" alt="x_{q+2}" valign="middle" /> <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> loop <img src="/img/cache/8732099f74d777a67257cb2f04ead3d8.gif" alt="x_2" valign="middle" />,
		.....................
		<img src="/img/cache/73c0e317eae8ea1442a4a415d70092b7.gif" alt="x_{q+q}" valign="middle" /> <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> loop <img src="/img/cache/ca7f076fd16d9f003adeba177eb6e410.gif" alt="x_q" valign="middle" />,
		n <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> loop d case ' <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> t:=t|',
		               end,
		o <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> t:=t|;,
		p <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> loop c case : <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> t:=t|:,
				    = <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> t:=t|=,
				    ' <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> t:=t|',
		               end,
		s <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> loop e,
		u <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> loop i,
           end; output <img src="/img/cache/a1dd1b5347cb468401d2a095aecda5db.gif" alt="z_1,\dots,z_w," valign="middle" />t ';;
<strong>loop</strong> e <strong>case</strong> <img src="/img/cache/aa687da0086c1ea060a8838e24611319.gif" alt="x_1" valign="middle" /> <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> t:=t|<img src="/img/cache/aa687da0086c1ea060a8838e24611319.gif" alt="x_1" valign="middle" />,
            <img src="/img/cache/8732099f74d777a67257cb2f04ead3d8.gif" alt="x_2" valign="middle" /> <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> t:=t|<img src="/img/cache/8732099f74d777a67257cb2f04ead3d8.gif" alt="x_2" valign="middle" />,
	    ...................
<!--p.148-->
	    <img src="/img/cache/ca7f076fd16d9f003adeba177eb6e410.gif" alt="x_q" valign="middle" /> <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> t:=t|<img src="/img/cache/ca7f076fd16d9f003adeba177eb6e410.gif" alt="x_q" valign="middle" />,
	    c <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> t:=t|c,
	    d <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> t:=t|d,
	    e <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> t:=t|e,
	    i <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> t:=t|i,
	    <img src="/img/cache/beced39fddd8bd82fc7cbb4b023116c4.gif" alt="x_{q+1}" valign="middle" /> <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> <strong>loop</strong> <img src="/img/cache/aa687da0086c1ea060a8838e24611319.gif" alt="x_1" valign="middle" />,
	    <img src="/img/cache/611d558b0ba02e750f00118493a32f00.gif" alt="x_{q+2}" valign="middle" /> <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> <strong>loop</strong> <img src="/img/cache/8732099f74d777a67257cb2f04ead3d8.gif" alt="x_2" valign="middle" />,
	    .....................
	    <img src="/img/cache/73c0e317eae8ea1442a4a415d70092b7.gif" alt="x_{q+q}" valign="middle" /> <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> <strong>loop</strong> <img src="/img/cache/ca7f076fd16d9f003adeba177eb6e410.gif" alt="x_q" valign="middle" />,
	    n <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> <strong>loop</strong> d <strong>case</strong> ' <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> t:=t|',
	                   <strong>end</strong>,
	    o <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> t:=t|;,
	    p <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> <strong>loop</strong> c <strong>case</strong> : <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> t:=t|:,
	    			= <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> t:=t|=,
	    			' <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> t:=t|',
	                   <strong>end</strong>,
	    s <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> <strong>loop</strong> e,
	    u <img src="/img/cache/b27423ceebc4690281c87a5fe35c3360.gif" alt="\longr" valign="middle" /> <strong>loop</strong> i,
       <strong>end;</strong>
       <strong>output</strong> <img src="/img/cache/a1dd1b5347cb468401d2a095aecda5db.gif" alt="z_1,\dots,z_w," valign="middle" />t
</pre>
<p><em>Behauptung:</em> <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /> ist selbstreproduzierende Version von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" />.</p>
<p>Programm <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /> beginnt mit der Eingabe der Eingabevariablen
von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> und der Abarbeitung des vollst&auml;ndigen Anweisungsteils
von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" />. Am Ende von <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /> werden die Ausgabevariablen von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" />
ausgegeben. Diese Ausgabevariablen <img src="/img/cache/a7365a43951094d20783872291b70b0d.gif" alt="z_1,\dots,z_w" valign="middle" /> werden nicht
durch Anweisungen au&szlig;erhalb des Anweisungsteils von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> ver&auml;ndert.
<img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /> gibt zus&auml;tzlich die Variable t aus. Zum Nachweis,
da&szlig; <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /> selbstrenroduzierende Version von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> ist, gen&uuml;gt es
also zu zeigen, da&szlig; am Ende der Programmausf&uuml;hrung der Inhalt
von t gleich <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /> ist.</p>
<p>Die Variablen <img src="/img/cache/b9015b1d90c8c43740bce3a07937c0a9.gif" alt="x_1,\dots,x_q,c,d,e" valign="middle" /> und i enthalten - bis
auf einige einzelne Zeichen - den Programmtext <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /> in zerlegter
Form. Die Aufgabe der <strong>loop</strong>-Schleife von <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /> ist es,
die in den Variablen gespeicherten Teilstrings zum Text <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" />
zusammenzuf&uuml;gen. Die &auml;u&szlig;ere <strong>loop</strong>-Schleife</p>
<!--p.149-->
<pre class="source"><strong>loop</strong> e <strong>case</strong> ..... <strong>end</strong>;</pre>
<p>wird durch die Variable e gesteuert, e enth&auml;lt den Text <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" />
in kodierter Form. Die Kodierung ist direkt aus der Alternativenliste
ersichtlich. F&uuml;r jedes Zeichen der Textkonstanten
e wird genau ein Teilstring des Programms <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /> an
den Inhalt der Variablen t geh&auml;ngt. Die Textkonstante e
l&auml;&szlig;t sich grob in drei Teile gliedern:</p>
<pre>
Teil I  : <img src="/img/cache/18bdd05fc0a89d6ffd77cb2064ae35c5.gif" alt="\tilde\calG(1)" valign="middle" /> ..... <img src="/img/cache/a094cc7ea82ac48f4a7f2fef9cde0f76.gif" alt="\tilde\calG(n)" valign="middle" />
Teil II : <img src="/img/cache/b2009d12b4e604d7a298fa20b0fba0b4.gif" alt="x_1px_{q+1}" valign="middle" />noo
          ............
          <img src="/img/cache/76527cbec80fa1feadf0b3a819f23b36.gif" alt="x_qpx_{q+q}" valign="middle" />noo
Teil III: cppnoodpnnooepsnooipunoou
</pre>
<p>Teil I bewirkt, da&szlig;</p>
<pre>	input <img src="/img/cache/a704cadb074f7e6de15ab4fc4ba63367.gif" alt="y_1,\dots,y_r; AW_\pi;" valign="middle" /></pre>
<p>an den Inhalt der zun&auml;chst leeren Variablen t geh&auml;ngt wird.</p>
<p>Teil II verl&auml;ngert den Inhalt von t um die Programmzeilen</p>
<pre>
	<img src="/img/cache/aa687da0086c1ea060a8838e24611319.gif" alt="x_1" valign="middle" />:='<img src="/img/cache/3dc303de9333710cf47bf601b897a6a6.gif" alt="\calG(1)" valign="middle" />';;		bis
        <img src="/img/cache/ca7f076fd16d9f003adeba177eb6e410.gif" alt="x_q" valign="middle" />:='<img src="/img/cache/212e050083a418adc96bebed165f9c59.gif" alt="\calG(q)" valign="middle" />';;
</pre>
<p>Teil III bewirkt, da&szlig; der restliche Programmtext von <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /> an
den Inhalt von  t geh&auml;ngt wird. Dies folgt aus der v&ouml;lligen
Analogie zu <img src="/img/cache/760777db71b289551f6a37329df527cf.gif" alt="\pi^2_{\text{rep}}" valign="middle" /> aus dem Beweis von Satz (6.5.2).</p>
<p>Mit Teil III ist die Variable e vollst&auml;ndig abgearbeitet,
und die Ausf&uuml;hrung der &auml;u&szlig;eren <strong>loop</strong>-Schleife bricht ab.
Damit stoppt auch das Gesamtprogramm, und <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /> wird als Inhalt
von t ausgegeben. <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /> erf&uuml;llt also Definition (5.1.4)(ii) und
ist somit selbstreproduzierende Version von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" />.</p>
<p>Die "reproduzierende" <strong>loop</strong>-Schleife in <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /> hat die
<strong>loop</strong>-Schachtelungstiefe 2 und steht <strong>neben</strong> dem Anweisungsteil von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" />.
Die <strong>loop</strong>-Schachtelungstiefe von <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" /> ist daher mindestens 2,
aber beschr&auml;nkt durch die <strong>loop</strong>-Schachtelungstiefe von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" />.
Damit ist auch die zweite Aussage des Satzes erf&uuml;llt.</p>
<div align="right">%</div>
<!--p.150-->
<p><strong>(6.6.2) Bemerkung:</strong></p>
<ol type="I">
    <li>Aus dem Beweis von Satz (6.6.1) l&auml;&szlig;t sich <strong>direkt</strong>
    ein Algorithmus zur Ermittlung einer selbstreproduzierenden.
    Version zu einem gegebenen <img src="/img/cache/edd25afc0ad473b16119c88c5420034e.gif" alt="\overline{LP(A)}" valign="middle" />-Programm
    gewinnen. Dieser Algorithmus ist jedoch
    stark verbesserungsbed&uuml;rftig.
    <p><strong>Beispiele:</strong></p>
    <ul>
	<li>Die Wahl des Alphabets B l&auml;&szlig;t sich
	verfeinern. Man kommt mit "kleinerem"
	Alphabet B aus, als im Beweis
	angegeben.</li>
	<li>Die <strong>loop</strong>-Schleifen vom Typ
	<pre class="source"><strong>loop</strong> v</pre>
	enthalten viele unn&uuml;tze Alternativen,
	die im Beweis zugunsten einer
	einheitlichen Schreibweise in Kauf
	genommen werden.</li>
    </ul></li>
    <li>Die im Beweis von (6.6.1) vorgenommene Konstruktion
    orientiert sich eng an dem Programm <img src="/img/cache/760777db71b289551f6a37329df527cf.gif" alt="\pi^2_{\text{rep}}" valign="middle" /> aus 6.5.
    Eine Konstruktion mit Hilfe des <img src="/img/cache/4e33432b3bb3485c4c3bde3928fcd771.gif" alt="\overline{LP_1(A_{\text{min}})" valign="middle" />-Programms
    <img src="/img/cache/6005e729c5bb9771453aaafc6273921b.gif" alt="\pi^1_{\text{rep}}" valign="middle" /> w&uuml;rde zu selbstreproduzierenden Versionen <img src="/img/cache/4572aaed84f0855701bd0af7c49314a7.gif" alt="\tilde\pi" valign="middle" />
    f&uuml;hren mit<br />
<img src="/img/cache/2d9d4d9868c860a5c59a69858c54d322.gif" alt="
\tilde\pi\in {
    \left\{
	\text{\overline{LP_1(B)} , falls \pi \in \overline{LP_0(A)}}\\
	\text{\overline{LP_i(B)} , falls \pi \in \overline{LP_i(A)}, i \ge 1 .}
    \right.
}
" valign="middle" /><br />
    Diese Konstruktion w&auml;re aber noch schwieriger zu
    &uuml;berschauen als die Konstruktion mittels <img src="/img/cache/760777db71b289551f6a37329df527cf.gif" alt="\pi^2_{\text{rep}}" valign="middle" />.</li>
</ol>
<!--p.151-->
<h2><a name="c7"></a>7. Leben bei Programmen?</h2>
<h3><a name="c71"></a>7.1. Einleitung</h3>
<p>In den vorangegangenen Kapiteln wurde die Existenz selbstreproduzierender Programme sowohl in Assembler-Sprachen als auch in h&ouml;heren Programmiersprachen nachgewiesen. Speziell Kapitel 5 zeigt, da&szlig; es nicht nur unendlich viele selbstreproduzierende Programme gibt, sondern da&szlig; sich jede Programmieraufgabe effektiv mit einem selbstreproduzierenden Programm bew&auml;ltigen l&auml;&szlig;t; Grenzen sind nur durch die technisch physikalischen Gegebenheiten einer konkreten Rechenanlage gesetzt.</p>
<p>Elektronische Datenverarbeitungsanlagen arbeiten nicht hundertprozentig fehlerfrei. Schalt- und &uuml;bertragungsfehler sind jederzeit m&ouml;glich, wenn auch sehr unwahrscheinlich.</p>
<p><strong>Beispiel:</strong> Aus Gr&uuml;nden der Effizienzsteigerung und der besseren Nutzbarmachung einzelner hardware-Komponenten werden immer h&auml;ufiger einzelne Rechner zu Rechnernetzen [21] zusammengeschaltet. Da die Entfernung der Einzelrechner zueinander oft mehrere Hundert Kilometer betr&auml;gt, stellt die &uuml;bertragung der Daten zwischen den Rechnern eines Netzes ein besonderes Problem dar. Je nach Art des gew&auml;hlten physikalischen &uuml;bertragungsweges liegt die Fehlerrate bei der Daten&uuml;bermittlung zwischen 10<sup>-4</sup> und 10<sup>-7</sup> bit/sec (10<sup>-5</sup> bit/sec beim &ouml;ffentlichen Telefonnetz) [21] [12]. Durch hard- und softwarem&auml;&szlig;ige Ma&szlig;nahmen (z.B. Verwendung fehlerkorrigierender Kodes [11], Kommunikationsprotokolle [21]), die in ihrer Gesamtheit als Fehlerkontrolle bezeichnet werden, kann die Rate der unerkannten Fehler niedriger gehalten werden. So liegt z.B. Die Bitfehlerrate f&uuml;r Bit&uuml;bertragung beim ARPA-Netz [12] bei 10<sup>-12</sup> bit/sec.</p>
<!--p.152-->
<p>Es besteht die M&ouml;glichkeit, da&szlig; bei der Selbstreproduktion eines Programms <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> Fehler unterlaufen (z.B. bei der &uuml;bertragung der Kopie aus dem Arbeitsspeicher in den Hintergrundspeicher). Diese Fehler k&ouml;nnen dazu f&uuml;hren, da&szlig; effektiv ein anderes Programm <img src="/img/cache/f363134a5e0301d040670dd7d57ff6e2.gif" alt="\pi' \neq \pi" valign="middle" /> reproduziert wird. Falls <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle" /> ein syntaktisch korrektes Programm ist, kann <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle" /> durchaus wieder selbstreproduzierend sein und dabei eine andere Funktion realisieren als <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" />. Dieser Sachverhalt erinnnert stark an Reproduktion und Mutation lebender Zellen in der Biologie. Reproduktion und Mutation geh&ouml;ren nach Ansicht der Biologie zu den Grundeigenschaften alles Lebendigen. Es dr&auml;ngt sich in diesem Zusammenhang die Frage auf, ob sich Programmen noch weitere lebenskennzeichnende Prozesse zuordnen lassen. Ist es vielleicht sogar m&ouml;glich, in Anlehnung an die Biologie von lebendigen Programmen zu sprechen? Die Beantwortung dieser Fragestellungen st&ouml;&szlig;t auf eine Vielzahl von Schwierigkeiten, von denen die beiden folgenden wohl zu den bedeutsameren geh&ouml;ren.</p>
<ul>
    <li>Die moderne Biologie ist sich durchaus nicht einig, wenn es darum geht, die charakteristischen Merkmale des Lebens auf eindeutige Weise zu definieren (vgl. 7.2.).</li>
    <li>Biologisches Leben basiert auf einem &auml;u&szlig;erst vielschichtigen Zusammenspiel von biochemischen Reaktionen. Bestimmten Makromolek&uuml;len, namentlich Nukleins&auml;ure- und Aminos&auml;uremolek&uuml;le, fallen dabei Schl&uuml;sselpositionen zu [13J. Alle irdischen Lebensformen werden von dem Zusammenwirken von Nuklein- und Aminos&auml;uren bestimmt. Die Frage, ob andere Lebensformen als die uns vertrauten denkbar sind, versucht die Biologie zu beantworten, indem sie das Problem untersucht, ob die Funktionen der Nuklein- bzw. Aminos&auml;uren durch andere Makromolek&uuml;lsorten ersetzt werden k&ouml;nnen [13]. Diesem Vorgehen l&auml;&szlig;t sich die Auffassung entnehmen, da&szlig; Leben immer chemophysikalischen Ursprungs ist. Leben bei Computerprogrammen w&auml;re in diesem Sinne
<!--p.153-->
    unm&ouml;glich.</li>
</ul>
<p>Die Suche nach "Leben" bei Programmen wird also sicherlich von philosophischen Problemen und Problemen der theoretischen Biologie begleitet sein. Es liegt daher auch nicht in der Absicht dieses und der beiden letzten Kapitel, "Leben" bei Programmen zu definieren. Die abschlie&szlig;enden Kapitel der vorliegenden Arbeit sind eher als ein erster Versuch zur Erschlie&szlig;ung des dargelegten Problemkreises, verbunden mit einigen Denkm&ouml;glichkeiten, zu verstehen.</p>
<h3><a name="c72"></a>7.2. Biologisches Leben</h3>
<p>Die moderne Biologie ist immer noch auf der Suche nach einer einheitlichen Definition des Lebens. Aus der Vielzahl rezenter und ausgestorbener Lebensformen lassen sich jedoch einige gemeinsame Eigenschaften alles Lebendigen extrahieren. So sind nach einer weitverbreiteten Auffassung</p>
<ul>
    <li>Stoffwechsel ( + Regelung )</li>
    <li>Zellreproduktion und Mutation</li>
</ul>
<p><em>die</em> Schl&uuml;sselprozesse des Lebens. Diese Schl&uuml;sselprozesse dienen der Erhaltung der Individuen, der Vermehrung und dem Erbwandel (vgl. [13]  Seite 24 ff). Es gibt Auffassungen von Leben, die auch Reizbarkeit und Bewegung als charakteristische Aspekte des Lebendigen anf&uuml;hren (vgl. [15]  Seite 335)</p>
<strong>Stoffwechsel</strong>
<p>Die "Grundeinheit" des Lebens ist die Zelle. Alle. Lebewesen sind aus Zellen aufgebaut. Sowohl Zellen als auch Lebewesen stellen begrenzte Stoffsysteme dar. Eine Zelle nimmt aus ihrer Umgebung st&auml;ndig Stoffe auf, wandelt sie intern um und gibt sie in ver&auml;nderter Form wieder
<!--p.154-->
an ihre Umwelt ab. Da jede Zelle auf diese Weise st&auml;ndig von Stoffen durchstr&ouml;mt wird, wird das System "Zelle" als Flie&szlig;system (Abb. 7.2.A) bezeichnet [13]. Flie&szlig;systeme sind <em>offene</em> Systeme [2]. Die Stoffumwandlungen in Zellen laufen in geordneten Bahnen ab. Es stellt sich ein sogenanntes <em>Flie&szlig;gleichgswicht</em> ein. (In [2] Seite 158 wird die Auffassung vertreten, da&szlig; alle charakteristischen Eigenschaften lebender Organismen direkte Konsequenzen des Flie&szlig;gleichgewichts sind). Offene Systeme im Flie&szlig;gleichgewicht streben unabh&auml;ngig von den Anfangsbedingungen einem konstanten Zustand entgegen. Dieser Zustand hei&szlig;t <em>station&auml;rer</em> Zustand. Stofflich gleiche Flie&szlig;systeme streben, sofern sie sich in einer gleichen Umgebung befinden, dem gleichen station&auml;ren Zustand entgegen, auch wenn die Anfangsbedingungen unterschiedlich sein m&ouml;gen. Man kann also von einer gewissen Selbstregulationsf&auml;higkeit der Lebewesen bzgl. des Stoffwechsels sprechen.</p>
<div align="center">
    <img src="img/mjk00/abb72a.gif" alt="Abb. 7.2.A" />
    <p><strong>Abb. 7.2.A</strong></p>
</div>
<p>Schema eines chemischen Flie&szlig;systems: Die Stoffe A<sub>i</sub> treten in das System ein. Innerhalb des Systems werden mittels Binnenreaktionen die Stoffe B<sub>j</sub> erzeugt. Die (Abfall-) Produkte C<sub>k</sub> treten aus dem System aus.</p>
<!--p.155-->
<p>Der Stoffwechsel wird h&auml;ufig, rein heuristisch, in den <em>Baustoffwechsel</em> und den <em>EnergiestoffWechsel</em> differenziert. W&auml;hrend der Baustoffwechsel dem materiellen Aufbau bzw. dem Wachstum der Lebewesen dient, liefert der Energiestoffwechsel die zur Aufrechterhaltung der Lebensprozesse notwendige Energie.</p>
<p><strong>Reproduktion und Mutation</strong></p>
<p>Bei lebenden Organismen beruht die Vermehrung auf Zellteilung. Die Teilung einer Zelle erfolgt dabei so, da&szlig; die entstehenden Tochterzellen, die gleiche Struktur und das gleiche Ablaufschema der Stoffwechselreaktionen erhalten wie die Elterzelle(n) (Singular bei ungeschlechtlicher, Plural bei geschlechtlicher Vermehrung). Aus dem oben &uuml;ber Flie&szlig;systeme Gesagten folgt, da&szlig; die Tochterzellen dem gleichen station&auml;ren Zustand zustreben wie die Elterzelle(n), vorausgesetzt, die Umweltbedingungen sind w&auml;hrend und nach der Zellteilung identisch. Auf diese Weise "ererben" die Tochterzellen den Zustand der Elterzelle(n). Die Struktur einer Zelle und die in der Zelle ablaufenden Stoffwechselreaktionen werden durch Proteine bestimmt. Damit eine Tochterzelle den gleichen station&auml;ren Zustand wie die Elterzelle(n) bei konstanten Umweltverhaltnissen erreichen kann, gen&uuml;gt es also, bei der Zellreproduktion daf&uuml;r zu sorgen, da&szlig;</p>
<ul>
    <li>in den Tochterzellen die gleichen Proteine gebildet werden wie in der (den) Slterzelle(n),</li>
    <li>sich diese Bildung in der zeitlich richtigen Reihenfolge vollzieht.</li>
</ul>
<p>Die zur Synthese der Proteine notwendige Information enth&auml;lt jede Zelle in Form speziell strukturierter Nukleins&auml;uremolek&uuml;le. Diese Molek&uuml;le werden als DNS, einzelne funktionelle Molek&uuml;labschnitte als Gene [27] bezeichnet. Damit die Tochterzellen in der Lage sind, die gleichen Proteine zu bilden wie die Elterzelle(n),
<!--p.156-->
bekommt jede Tochterzelle bei der Reproduktion eine identische KoDie der DNS-Molek&uuml;le der Elterzelle, also identische Gene mit; bei geschlechtlicher Vermehrung handelt es sich um eine Kombination der DNS-Molek&uuml;le der Elterzellen (allele Gene). Die Elterzeilen vererben also den Bauplan der in ihnen gebildeten Proteine. Unterlaufen bei der Replikation der DNS-Molek&uuml;le Fehler und werden die fehlerhaften Kopien an die Tochterzellen weitergegeben, so werden in den Tochterzellen andere Proteine erzeugt als in den Elterzellen. Es werden dann i.a. in den Tochterzellen andere Binnenreaktionen  erfolgen. In den Tochterzellen wird sich trotz sonst gleicher Umweltbedingungen ein anderes Flie&szlig;gleichgewicht als in den Elterzellen einstellen. Auch der station&auml;re Zustand der Tochterzellen wird ein anderer sein. Man bezeichnet bei lebenden Organismen solche sprunghaften &auml;nderungen des Erbgutes (Genom) als Mutation. Mutationen erfolgen immer zuf&auml;llig und ungerichtet. Mutationen werden nicht nur durch fehlerhafte Kopierprozesse hervorgerufen, sondern k&ouml;nnen auch bei bereits "fertigen" Seilen durch spontane &auml;nderungen der DNS-Molek&uuml;le entstehen.</p>
<p>Diese beiden extrem kurzen und nicht ann&auml;hernd vollst&auml;ndigen &uuml;berblicke &uuml;ber Stoffwechsel, Reproduktion und Mutation von Lebewesen sollen als Grundlage zu den folgenden &uuml;berlegungen dienen.</p>
<h3><a name="c73"></a>7.3.Selbstreproduzierende Programme und Leben</h3>
<p>Im Gegensatz zu naturlichen Lebewesen sind Programme in erster Linie <em>Informationen</em> und als solche nicht stofflich. Damit Information verf&uuml;gbar ist, mu&szlig; sie in einer interpretierbaren Form zug&auml;nglich sein.</p>
<p>Beispiele:</p>
<ul>
    <li>Lochstreifen</li>
    <li>Lochkarten</li>
    <li>Formulierung mit "Papier und Beistift"</li>
</ul>
<!--p.157-->
<p>Programme werden in der Regel erstellt, um sie von einer konkreten Rechenmaschine ausf&uuml;hren zu lassen. Im Rechner sind dann Programme digital dargestellt und f&uuml;r den Rechner interpretierbar, vorausgesetzt sie werden als syntaktisch und semantisch<sup><a href="#p158_1" name="b158_1">1)</a></sup> korrekt vom vorhandenen Rechner akzeptiert. Gehen wir einmal von der vertrauten Darstellung der Programme im Rechner aus, so m&uuml;ssen wir uns dennoch st&auml;ndig im Klaren sein, da&szlig; Programme in ihrer Existenz an keine der m&ouml;glichen Darstellungsformen gebunden sind. Wegen ihres mehr abstrakten als stofflichen Daseins ben&ouml;tigen Programme auch keinen Stoffwechsel, um ihre Existenz zu erhalten. Die Tatsache, da&szlig; Energie ben&ouml;tigt wird, um ein Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> auf einer Rechenanlage auszuf&uuml;hren, kann nat&uuml;rlich nicht als (Energie-) Stoffwechsel betrachtet werden, da die Zufuhr von Energie</p>
<ul>
    <li>nicht vom Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> aktiv gesteuert wird,</li>
    <li>nicht der Erhaltung des Programms <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" />, sondern der Interpretation von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> dient.</li>
</ul>
<p>Programme sind auf Rechenanlagen in irgendwelchen Speichermedien abgespeichert. Es gibt Speichertypen, gewisse Halbleiterspeicher (Charge-Coupled Devices), die in gewissen Zeitabst&auml;nden eine Erneuerung der enthaltenen Information ben&ouml;tigen  [11] . In solchen Speichern abgelegte Programme ben&ouml;tigen also regelm&auml;&szlig;ig Energie, um verf&uuml;gbar zu bleiben. Auch eine solche Energiezufuhr kann man, aus den gleichen Gr&uuml;nden wie oben, nicht im entferntesten als Energiestoffwechsel ansehen.</p>
<p>Es hat also wenig Sinn, im Hinblick auf Programme, auch wenn man von der festen Darstellung auf einer konkreten Rechenanlage ausgeht, ein Analogen zum Stoffwechsel lebender Organismen zu suchen.</p>
<p>Anders liegen die Verh&auml;ltnisse allerdings bzgl. Reproduktion und Mutation. Die vielen Beispiele selbstreproduzierender Programme in den vorangegangenen Kapiteln zeigen, da&szlig; es durchaus Programme gibt, die zur identischen Reproduktion f&auml;hig sind. Allen Beispielprogrammen in h&ouml;heren Programmiersprachen war gemeinsam,</p>
<!--p.158-->
<p>da&szlig; sie an irgendeiner Stelle ihren eigenen Bauplan in kodierter Form enthalten (vgl. etwa Inhalt der Komponente  C[23] in <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /><sub>3</sub> aus Abschnitt 3.2.5., Textkonstante der Prozedur AB in <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /><sub>4</sub> aus Abschnitt 3.2.7.). Dieser Bauplan l&auml;&szlig;t einen Vergleich mit der DNS lebender Zellen zu. Der Zusammenbau der Kopien selbstreproduzierender Programme mittels des Bauplans ist vergleichbar (zugegeben sehr gewagt) mit der Proteinsynthese bei Zellen. Man sollte sich jedoch einschr&auml;nkend vergegenw&auml;rtigen, da&szlig; die Selbstreproduktion von Programmen im strengen Sinne keine Autoreproduktion darstellt, wie dies bei Organismen der Fall ist. Dies liegt daran, da&szlig; die Reproduktion von Programmen von au&szlig;en veranla&szlig;t wird (Steuerung durch das Betriebssystem) und die Initiative nicht beim Programm selbst liegt.</p>
<p>M&ouml;gliche Schalt- und Ubertragungsfehler in elektronischen Rechenanlagen k&ouml;nnen dazu f&uuml;hren, da&szlig; bei der Selbstreproduktion von Programmen Fehler entstehen (vgl. 7.1.). Mutationen sind also in diesem Sinne jederzeit m&ouml;glich.</p>
<p>Insgesamt ergibt sich also, da&szlig; sich von den biologisches Leben ausmachenden Schl&uuml;sselprozessen bei Programmen nur Entsprechungen bzgl. Reproduktion und Mutation finden lassen. Systeme, die nur die Eigenschaften der Reproduktion und Mutation enthalten, sind daher im Sinne der Biologie nicht als lebendig zu bezeichnen. Insofern sind auch selbstreproduzierende Programme nicht lebendig. Selbstreproduzierende Programme lassen sich somit auch nicht mit lebendigen Organismen vergleichen. Die Biologie kennt jedoch Strukturen, die durchaus einen Vergleich mit selbstreproduzierenden Programmen zulassen.</p>
<h3><a name="c74"></a>7.4. Selbstreproduzierende Programme und Viren</h3>
<p>Viren wurden lange Zeit als einfachste Organismen angesehen. Sie sind sehr viel einfacher gebaut als einzellige
<!--p.159-->
Lebewesen. In Wirklichkeit stellen Viren jedoch keine vollst&auml;ndigen Organismen dar, sondern sind subzellulare Gebilde, die fast nur aus DNS bestehen. Bei manchen Viren sind die DNS-Molek&uuml;le noch mit einer H&uuml;lle aus Proteinen, Fettstoffen und anderen organischen Substanzen umgeben. Viren verf&uuml;gen &uuml;ber keinen eigenen Stoffwechsel. Erst wenn Viren in eine lebende Zelle eindringen, zeigen sie Lebenserscheinungen in Form von Reproduktion und Mutation. Sie ben&ouml;tigen zu ihrer eigenen Vermehrung also den Stoffwechsel echter Organismen. Au&szlig;erhalb lebender Organismen sind Viren tot, sie k&ouml;nnen sich dann sogar zu Kristallen anordnen, was von Lebewesen nicht bekannt ist. Von den Schl&uuml;sselprozessen des Lebens weisen Viren also nur Reproduktion und Mutation auf und das auch nur dann, wenn eine fremde Stoffwechselmaschinerie Baustoffe und Energie zur Verf&uuml;gung stellt. Diese Zusammenh&auml;nge sind in &auml;hnlicher Form auch bei selbstreproduzierenden Programmen festzustellen. Solange ein selbstreproduzierendes Programm sich nicht im Speicher einer Rechenanlage befindet, kommt ihm bis auf seinen Informationsgehalt keine Bedeutung zu. Erst im Rechner und dann auch erst , wenn das Programm wirklich l&auml;uft ist ein selbstreproduzierendes Programm in der Lage zur Reproduktion und Mutation. Dem Programm steht dann Energie, die vom Rechner geliefert wird, zur Verf&uuml;gung. Es bleibt jedoch bei aller &auml;hnlichkeit zu beachten, da&szlig; ein Virus aktiv seine Reproduktion einleitet, indem es in das Baustoff und Energie liefernde System "Zelle" eindringt. Das kann ein selbstreproduzierendes Programm nicht, auch wenn es sich im Speicherplatz und Energie liefernden System "Rechner" befindet. Es bleibt auf Aktivierung durch das Betriebssystem angewiesen.</p>
<!--p.160-->
<h2><a name="c8"></a>8. Modelle f&uuml;r konkurrierendes Verhalten selbstrenroduzierender Programme</h2>
<h3><a name="c81"></a>8.1. Motivation</h3>
<p>Wie die Biologie lehrt, sind lebende Organismen vielschichtigen Konkurrenzk&auml;mpfen unterworfen. Diese Konkurrenzk&auml;mpfe betreffen nicht nur einzelne Individuen, sondern ganze Arten (bzw. Populationen [24] Seite 337 ). Um erfolgreich zu sein, m&uuml;ssen diese Arten eine gewisse Variabilit&auml;t ihres Erbgutes (Genom) aufweisen. Nur so k&ouml;nnen sie sich einerseits gegen&uuml;ber der unbelebten Umwelt, die sich st&auml;ndig ver&auml;ndert, und andererseits gegen&uuml;ber der Konkurrenz anderer Arten behaupten. Die Eigenschaften der Arten und Individuen sind also st&auml;ndig in Beziehung zur belebten und unbelebten Umwelt zu sehen (&ouml;kologie, vgl. [27] Seite 199 ff).</p>
<p>Selbstreproduzierende Programme, die sich in einer Rechenanlage befinden, sind von der "Umwelt" Rechner (= hardware + Systemsoftware) umgeben. Das Speichermedium, das die Programme enth&auml;lt, ist sogar ein Teil dieser Umwelt. Als "belebte" Umwelt lassen sich andere, ebenfalls im Rechner befindliche selbstreproduzierende Programme ansehen. Die M&ouml;glichkeit der Mutation (s.o. 7.3. ) bef&auml;higt selbstreproduzierende Programme zur Evolution (s.u. 9.1. ). Es ist also nicht auszuschlie&szlig;en, da&szlig; die Wechselwirkungen selbstreproduzierender Programme miteinander und mit dem umgebenden Rechnersysterm zu anderen selbstreproduzierenden Programmen mit immer neuen Eigenschaften f&uuml;hren k&ouml;nnen. Die folgenden (spekulativen!) Modelle sollen versuchen, eine Vorstellung von derartigen auf Wechselwirkungen beruhenden Verhaltensweisen selbstreproduzierender Programme zu vermitteln.</p>

<h3><a name="c82"></a>8.2. Ein einfaches Grundmodell</h3>
<p>Das nachfolgend beschriebene Grundmodell MOD1 geht von dem Hintergrund einer herk&ouml;mmlichen Rechenanlage mit "von Neu-man Architektur" aus [12]. Eine solche Rechenanlage zeichnet sich in moderner Sicht durch einen (Zentral-)Prozessor
<!--p.161-->
und ein oder mehrere E/A-Kan&auml;le (extrem: E/A-Prozessoren) aus. Es herrscht multiprogramming Betrieb: K Programme <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /><sub>1</sub>, ..., <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /><sub>k</sub>, k&ouml;nnen zeitlich verzahnt, jedoch <em>nicht</em> durchgehend parallel verarbeitet werden. Die Programme sind nur zeitlich alternierend aktiv. In diesem Zusammenhang sind auch Begriffe wie time slicing und time sharing zu erw&auml;hnen [1].</p>
<p>Selbstreproduzierende Programme werden in MOD1 durch 2 Gr&ouml;&szlig;en charakterisiert.</p>
<ul>
<li>Die Laufzeit (sprich: Reproduktionszeit)</li>
<li>Die r&auml;umliche Beziehung (bzgl, Speicher) zwischen Programm  und dessen erzeugter Kopie.</li>
</ul>

<h4><a name="c821"></a>8.2.1. Informelle Beschreibung von MOD1</h4>
<ol type="i">
<li><strong>Programme:</strong> Programme werden mit ihrem Namen identifiziert. Hinter diesem Namen verschwindet die Programmstruktur vollkommen. Wichtiger sind hingegen andere Daten:
<ol type="a">
<li>Die individuelle Anzahl der Zeittakte, die erforderlich sind, damit ein Programm sich reproduzieren kann.</li>
<li>Die Mindestentfernung, in der die Kopie im Speicher angelegt wird (vgl. (ii)).</li>
</ol>
Das Modell eines Programms ist somit ein Tripel, bestehend aus Programmname, Reproduktionszeit und Kopiedistanz.</li>
<li><strong>Speicher:</strong> Der Speicher ist eindimensional, beidseitig unendlich und in Speicherzellen unterteilt. Je zwei benachbarte Speicherzellen sind direkt miteinander verbunden. Jede Speicherselle ist in der Lage, genau ein Programm  - unabh&auml;ngig von dessen physikalischer L&auml;nge  - aufzunehmen. Fast alle Speicherzellen sind leer.</li>
<li><strong>Zeitverhalten:</strong> Anfangs wird der leere Speicher mit
<!--p.162-->

einer festen Zahl <em>NUM</em> von seibstreproduzierenden Programmen <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /><sub>1</sub>, ..., <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /><sub>NUM</sub> initialisiert. Jedes Programm <img src="/img/cache/68df4fedda3a6ee42485d71ce568ba2e.gif" alt="\pi_j" valign="middle" /> erh&auml;lt zyklisch f&uuml;r einen Zeittakt die "Aktivit&auml;t" zugeteilt. Diese zyklische "Aktivierung" ist m&ouml;glich, da sich zu jedem Zeitpunkt nur endlich viele Programme im Speicher aufhalten. W&auml;chst die Anzahl der Programme durch Reproduktionen an, so vergr&ouml;&szlig;ert sich der Zyklus entsprechend. Jedes Programm im Speicher ist nach einer individuellen Anzahl von Zeittakten, in denen es "aktiv" war (Reproduktionszeit), in der Lage, sich selbst zu reproduzieren.</li>
<li><strong>R&auml;umliches Verhalten:</strong> Ein Programm legt seine Kopie in einem individuellen Mindestabstand nach rechts oder links an. Ist die ausgew&auml;hlte Speicherzelle besetzt, so werden alle weiteren folgenden Speicherzellen getestet. Die Kopie wird dann in die erste freie Zelle abgelegt. Diese existiert wegen (ii) immer. Es entstehen also hinsichtlich des Speicherplatzbedarfs keine Konflikte.</li>
</ol>

<p>MOD1 vermeidet Kollisionen. Die Programme k&ouml;nnen sich nicht gegenseitig in Bedr&auml;ngnis bringen. Es gibt keine ausgezeichneten Programme, die in der Lage sind, andere Programme zu zerst&ouml;ren, indem sie deren Speicher beanspruchen. In diesem Sinne sind alle Programme &auml;quivalent. Die Vermeidung von Kollisionen wird durch die Unendlichkeit des Speichers unterst&uuml;tzt. Jedes Programm (Individuum) ist best&auml;ndig und produziert w&auml;hrend seines ewigen Daseins identische Kopien (Nachkommen). Die Menge der vorhandenen Programme (Population) steigt st&auml;ndig an. Bildhaft gesprochen gibt es in MOD1 keinen "Kampf ums Dasein", sondern friedliche Koexistenz. In einem solchen Modell gibt es keine Evolution, Die Motoren der Evolution, Mutation und Selektion, sind ohne Bedeutung, da es keinen Selektionsdruck gibt (s.u.).</p>
<!--p.163-->

<h4><a name="c822"></a>8.2.2. MOD1 als SIMULA-Programm</h4>
<ol type="i">
<li><p><strong>Programme:</strong></p>
<p>Umsetzung des Programme bestimmenden Tripels in die SIMULA-Struktur:</p>
<pre><strong>call</strong> PROGRAM;
     <strong>begin</strong>
     <strong>integer</strong> DELY, DISTANCE, IDENT;
     <strong>end</strong>;
</pre>

<p>
<code>DELY</code> <img src="/img/cache/7b5706c92a949a258e3cad097464d1cd.gif" alt="\leftarrow" valign="middle" /> Reproduktionszeit<br />
<code>DISTANCE</code> <img src="/img/cache/7b5706c92a949a258e3cad097464d1cd.gif" alt="\leftarrow" valign="middle" /> Mindestentfernung der Kopie<br />
<code>IDENT</code> <img src="/img/cache/7b5706c92a949a258e3cad097464d1cd.gif" alt="\leftarrow" valign="middle" /> Identifizierung des Programms</p>
</li>
<li><p><strong>Speicher:</strong></p>
<p>Jede Speicherzelle ist in der Lage, ein Objekt vom Typ <code>PROGRAM</code> aufzunehmen. Sie ist au&szlig;erdem mit ihren beiden Nachbarzellen verbunden. Diesen Eigenschaften tr&auml;gt die SIMULA-Struktur CELL Rechnung:</p>

<pre><strong>class</strong> CELL;
      <strong>begin</strong>
      <strong>ref</strong> (PROGRAM) CONTENS;
      <strong>ref</strong> (CELL) LEFT,RIGHT;
      <strong>integer</strong> TIMECOUNT;
      <strong>end</strong>;
</pre>
<p>(bzgl. <code>TIMECOUNT</code> s.u.)</p>
<p>Der Speicher selbst wird also als doppelt verkettete lineare Liste dargestellt ( [28]  Seite 233 ff). Anfangs wird ein v&ouml;llig leerer Speicher der festen L&auml;nge N angelegt. Je nach Bedarf werden an seine Enden neue Speicherzellen angeh&auml;ngt, so da&szlig; der Speicher potentiell unendlich ist, aber zu jedem Zeitpunkt eine feste L&auml;nge aufweist. Die beiden Zeiger
<!--p.164-->

<code>FIRST</code> und <code>LAST</code> vom Typ <strong>ref</strong> (<code>CELL</code>) markieren das jeweils aktuelle linke bzw. rechte Ende der Liste. Die Funktionsprozeduren</p>

<pre><strong>ref</strong> (CELL) <strong>procedure</strong> ADDLEFT;</pre> und
<pre><strong>ref</strong> (CELL) <strong>procedure</strong> ADDRIGHT;</pre>

<p>bewerkstelligen das Anh&auml;ngen einer neuen Speicherzelle an die bisherige Liste.</p>

<p><strong>Beispiel:</strong></p>
<div align="center">
    <img src="img/mjk00/p165_1.gif" alt="" />
</div>
<p>Situation vor Aufruf von <code>ADDLEFT</code></p>
<div align="center">
    <img src="img/mjk00/p165_2.gif" alt="" />
</div>
<p>Situation nach Aufruf von <code>ADDLEFT</code></p>
<p>Analog <code>ADDRIGHT</code>.</p>
</li>
<li><p><strong>Zeitverhalten:</strong></p>
<p>
<em>Startsituation</em>: Zu Beginn der Simulation wird der noch leere Speicher mit einer festen Anzahl von Programmen (Objekten des Typs <code>PROGRAM</code>) <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /><sub>i</sub>, i=1,...,NUM
<!--p.165-->

initialisiert. Es gibt M <img src="/img/cache/de44c582df9d8d29dbbd70aca311c641.gif" alt="\leq" valign="middle" /> NUM verschiedene Programme. Daraus ergibt sich, da&szlig; schon anfangs Programme mehrfach im Speicher vorhanden sein k&ouml;nnen. Da in den Speicherzellen die Programme nicht explizit stehen, sondern durch Verweise repr&auml;sentiert werden, m&uuml;ssen die Programme <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /><sub>j</sub> irgendwo ausf&uuml;hrlich gespeichert sein. Zu diesem Zweck dient  <code><strong>ref</strong> (PROGRAM) <strong>array</strong> P[1:M]</code>; &uuml;ber den Zeiger P[j] besteht immer Zugriffsm&ouml;glichkeit auf das Programm <img src="/img/cache/68df4fedda3a6ee42485d71ce568ba2e.gif" alt="\pi_j" valign="middle" />. Das Kopieren eines Programms <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /><sub>j</sub> wird durch Setze eines weiteren Zeigers auf <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /><sub>j</sub> realisiert. Diese Vorgehensweise zwingt fast dazu, vom "<strong>Programmtyp</strong>" <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /><sub>j</sub> zu sprechen, w&auml;hrend die Zeiger auf <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /><sub>j</sub> die eigentlichen Programme oder Exemplare dieses Typs darstellen. Der Sprachgebrauch ist hier nicht eindeutig festzulegen. Ohne sprachliche Verwirrung zu stiften, werden wir deshalb im folgenden <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /><sub>j</sub> sowohl als Programm als auch als Programmtyp bezeichnen, je nachdem, welche Bezeichnung gerade angebracht erscheint. Das Feld <code><strong>integer array</strong> ST[1:M]</code> enth&auml;lt zu jedem Zeitpunkt der Simulation in den Komponenten ST[j] die momentane Anzahl der Exemplare des Programms P[j]. Zu Beginn der Simulation gilt also</p>

<img src="/img/cache/cf55d6380f1512bc8f7bf76f85b1c138.gif" alt="\sum_{j=1}^{M}ST[j]=NUM" valign="middle" />

<p>Einlesen der <code>NUM</code> Zahlenpaare (<code>PI,WHERE</code>) liefert die raumliche Anordnung der <code>NUM</code> Programme: Das Programm <code>P[PI]</code> steht in der vom Zeiger <code>LEFT</code> aus gerechnet <code>WHERE</code>-ten Speicherzelle. (siehe Abbildung 8.2.2.A)</p>
<div align="center">
    <img src="img/mjk00/abb822a.gif" alt="Abb. 8.2.2.A" />
    <p>Abb. 8.2.2.A</p>
</div>
<!--p.166-->

<p><em>Simulation</em>: TIME-mal wird der Speicher von links nach rechts mittels des Zeigers C vom Typ <strong>ref</strong> (CELL) durchlaufen. Bei jeder Zelle wird getestet, ob sie leer ist oder nicht. Ist die Zelle leer, so geschieht nichts. Ist die Zelle durch ein Programm belegt, so wird weiter getestet, ob bei dieser Zelle</p>

<p><code>TIMECOUNT+1 = CONTENS.DELY</code></p>

<p>gilt. Im Ja-Fall wird eine Kopie des betreffenden Programms angelegt und TIMECOUNT wieder auf 0  gesetzt (ein neuer Reproduktionszyklus des betreffenden Programms kann beginnen). Andernfalls wird TIMECOUNT um 1 erh&ouml;ht. Es kann geschehen, da&szlig; zum Anlegen einer Kopie der Speicher am rechten Ende verl&auml;ngert werden mu&szlig;; dann ist darauf zu achten, da&szlig; der Speicher nur bis zu seinem rechten Ende zu Beginn des betreffenden Durchlaufs durchlaufen wird. Erst der Durchlauf, der den n&auml;chsten Zyklus simuliert, erfa&szlig;t den nun zus&auml;tzlichen Speicherbereich. Dies wird durch die Variable</p>
<p><code><strong>ref</strong> (CELL) OLD_LAST</code></p>
<p>unterst&uuml;tzt.</p>
<pre><strong>for</strong> T:=1 <strong>step</strong> 1 <strong>until</strong> TIME <strong>do</strong>
<strong>begin</strong>
  C:-FIRST;
  OLD_LAST:-LAST;
  <strong>while</strong> C=/=OLD_LAST.RIGHT <strong>do</strong>
  <strong>begin</strong>
    [Erh&ouml;he C.TIMECOUNT um 1];
    <strong>if</strong> C.TIMECOUNT=C.CONTENS.DELY
    <strong>then</strong> [Kopiere das Programm C.CONTENS; Setze C.TIMECOUNT zur&uuml;ck auf 0;]
    C:-C.RIGHT
  <strong>end</strong>
<strong>end</strong>;
</pre>
</li>
<!--p.167-->

	<li>	<p><strong>R&auml;umliches Verhalten:</strong></p>
		<p>Sei nun beim i-ten Durchlauf, i <img src="/img/cache/de44c582df9d8d29dbbd70aca311c641.gif" alt="\leq" valign="middle" /> TIME, durch den Speicher der Zeiger C auf eine Speicherzelle gesto&szlig;en, deren Programm <code><img src="/img/cache/68df4fedda3a6ee42485d71ce568ba2e.gif" alt="\pi_j" valign="middle" /> = C.CONTENS</code> reproduktionsbereit ist, das hei&szlig;t:</p>
		<p><code>C.TIMECOUNT+1 = C.CONTENS.DELY</code></p>
		<p><img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /><sub>j</sub> wird nun kopiert. Ob die Kopie rechts oder links von der Zelle, auf die C zeigt, angelegt wird, entscheidet die Prozedur COPY mit Hilfe der SIMULA-Zufallszahlenfimktion RANDINT.<sup><a href="#p168_1" name="b168_1">1)</a></sup></p>
<pre><strong>procedure</strong> COPY(C); <strong>ref</strong> (CELL) C;
<strong>if</strong> RANDINT (1,2,U) = 1
<strong>then</strong> COPY_LEFT(C)
<strong>else</strong> COPY_RIGHT(C);
</pre>
		<p>Entsprechend der getroffenen Entscheidung wird also die Prozedur COPY_LEFT bzw. COPY_RIGHT aufgerufen, dieden eigentlichen Kopierproze&szlig; durchf&uuml;hrt.</p>
<pre><strong>procedure</strong> COPY_RIGHT(C); <strong>ref</strong> (CELL) C;
<strong>begin</strong>
  <strong>ref</strong> (CELL) HELP; 
  [Setze HELP auf c];
  [Bewege HELP um soviele Zellen nach rechts, 
   wie die Komponente DISTANCE des Programms
   <code><img src="/img/cache/68df4fedda3a6ee42485d71ce568ba2e.gif" alt="\pi_j" valign="middle" /> (=C.CONTENS)</code> angibt. Wird dabei vorzeitig
   das Ende des Speichers erreicht, so erweitere
   mittels ADDRIGHT den Speicher um entsprechend
   viele Zellen an seinem rechten Ende. ]
  <strong>if</strong> HELP.CONTENS==<strong>none</strong>
  <strong>then</strong>
       [Lege die Kopie <img src="/img/cache/68df4fedda3a6ee42485d71ce568ba2e.gif" alt="\pi_j" valign="middle" /> in der leeren
        Zelle ab, auf die HELP Zeigt
        (= HELP.CONTENS:-P[j])]
  <strong>else</strong>
       [Bewege HELP solange im Speicher weiter
        nach rechts, bis HELP auf eine leere
        Speicherzelle zeigt, oder das rechte
        Ende des Speichers erreicht ist. Ist
        letzteres der Fall, so setze
</pre>
<!--p.168-->
<div align="center">
	<img src="img/mjk00/abb822b.gif" alt="Abb.:8.2.2.B" />
	<p>Abb. 8.2.2.B</p>
</div>
<!--p.169-->
<pre>
        HELP:-ADDRIGHT; Lege die Kopie von <img src="/img/cache/68df4fedda3a6ee42485d71ce568ba2e.gif" alt="\pi_j" valign="middle" />
        in der Zelle ab, auf die HELP zeigt. ]
<strong>end</strong>;
</pre>
	<p>Anhang C.1. zeigt MODI in ausf&uuml;hrlicher Form als lauff&auml;higes SIMULA-Programm. Die Datenstrukturen dieses Programms verdeutlicht Abbildung 8.2.2.B..</p>
	<strong>Eingabeparameter des SIMULA-Programms f&uuml;r MOD1:</strong>
	<ol>
		<li>Die Anfangsl&auml;nge des Speichers <img src="/img/cache/78d9dc6c665f9a9e2b81c280a13771b7.gif" alt="\longrightarrow" valign="middle" /> N</li>
		<li>Die Anzahl der unterschiedlichen Programmtypen <img src="/img/cache/78d9dc6c665f9a9e2b81c280a13771b7.gif" alt="\longrightarrow" valign="middle" /> M</li>
		<li>Die M Programme (Typen), charakterisiert durch M Zahlenpaare <img src="/img/cache/78d9dc6c665f9a9e2b81c280a13771b7.gif" alt="\longrightarrow" valign="middle" /> DELY,DISTANCE</li>
		<li>Die Anzahl der sich anfangs im Speicher befindlichen Programme <img src="/img/cache/78d9dc6c665f9a9e2b81c280a13771b7.gif" alt="\longrightarrow" valign="middle" /> NUM</li>
		<li>Die Verteilung der NUM Programme im Speicher, angegeben durch Num Zahlenpaare <img src="/img/cache/78d9dc6c665f9a9e2b81c280a13771b7.gif" alt="\longrightarrow" valign="middle" /> PI,WHERE</li>
		<li>Die Anzahl der vorgesehenen Speicherdurchlaufe <img src="/img/cache/78d9dc6c665f9a9e2b81c280a13771b7.gif" alt="\longrightarrow" valign="middle" /> TIME</li>
	</ol></li>
</ol>

<h4><a name="c823"></a>8.2.3. Absichten von MOD1</h4>
<p>Simulationsmodelle bzw. -programme haben in der Regel experimentellen Charakter. Die Erkenntnisse, die sich mittels MOD1 gewinnen lassen, sind beschr&auml;nkt und gr&ouml;&szlig;tenteils vorherberechenbar; sie ben&ouml;tigen kein Experiment. Der einzige Nichtdeterminismus liegt in der zuf&auml;lligen Wahl der Richtung, in der die Kopie eines Programms im Speicher angelegt wird. MOD1 ist als Grundmodell zu werten, auf das weitere Modelle mit mehr M&ouml;glichkeiten aufbauen. Au&szlig;erdem demonstriert MOD1 einen gewissen Satz von Grundelementen, die auch den weiteren Modellen M0D2 und MOD3 zu eigen sind. Es handelt sich dabei um</p>
<!--p.170-->
<ol type="i">
<li>Modell f&uuml;r Programme</li>
<li>Modell f&uuml;r Speicher</li>
<li>zeitliches Verhalten</li>
<li>r&auml;umliches Verhalten</li>
</ol>

<p>Durch &auml;nderung einer oder mehrerer dieser 4  Komponenten lassen sich andere Grundmodelle erzielen; besonders (iv) d&uuml;rfte sehr viele Variationsm&ouml;glichkeiten bieten, (i) bis (iv) sind nicht ganz unabh&auml;ngig von einander. Die Charakterisierung der Programme durch die Gr&ouml;&szlig;en <code>DELY</code> und <code>DISTANCE</code> bestimmt das zeitliche Verhalten (iii) (mittels <code>DELY</code>) und das r&auml;umliche Verhalten (iv) (mittels <code>DISTANCE</code>) wesentlich mit.</p>

<p>Die Wahl von (i) bis (iv) ist auch vor dem Hintergrund der unterstellten "von Neuman Architektur" des Rechners zu sehen . Eine charakteristische Eigenschaft der von Neuman-Rechner ist die Tatsache, da&szlig; es zu jedem Zeitpunkt nur jeweils einen Strom von Instruktionen und Daten gibt. Man spricht daher auch von SISD-Maschinen (single-instruction single-data stream) [12]. F&uuml;r moderne Rechnersysteme trifft diese Charakterisierung jedoch nicht ganz zu, da durch Hinzunahme weiterer Prozessoren, speziell E/A-Prozessoren, das SISD-Prinzip durchbrochen wird; es liegt eigentlich MIMD-Organisation (multiple-instruction multiple-data stream) vor. Trotzdem wird man heutige Rechner kaum als MIMD-Rechner bezeichnen, da die Anzahl der gleichzeitig arbeitenden Prozessoren sehr klein ist. Die Idee, die hinter MIMD steht, ist jedoch eine gro&szlig;e Zahl (ca. 100 bis 1000) [26]  unabh&auml;ngiger Prozessoren, um ein H&ouml;chstma&szlig; an Parallelverarbeitung zu erzielen. Neben SISD-und MIMD-Maschinen gibt es au&szlig;erdem noch die Klassen der SIMD (single-instruction multiple-data stream)- und der MISD (multiple-instruction single-data stream)-Maschinen. Nahezu alle heutigen Rechner sind im weitesten Sinne SISD-Maschinen. Es entsteht also die Frage:</p>
<p>Welche Modelleigenschaften m&uuml;&szlig;te MOD1 haben, wenn
<!--p.171-->

MODT als Grundmodell f&uuml;r unorthodoxe Rechenanlagen (=nicht SISD-Hechner) [6]  gedacht w&auml;re?</p> <p>Voraussetzung ist nar&uuml;rlich die Existenz selbstreproduzierender Programme auf solchen Maschinen.</p>

<h4><a name="c824"></a>8.2.4. Einige Aspekte des SIMULA-Programms f&uuml;r MOD1</h4>
<ol type="I">
<li>Wie in 8.2.3. erw&auml;hnt liefert MOD1 keine experimentellen Ergebnisse bzgl. des zahlenm&auml;&szlig;igen Verhaltens der einzelnen Programmtypen. Da in MODT alle Programme best&auml;ndig sind und alle reproduktionsf&auml;higen Exemplare sich unbedingt reproduzieren, gilt f&uuml;r jeden Programmtyp <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /><sub>j</sub>, j<img src="/img/cache/986c22f151c46acac223b858e3fcf6fd.gif" alt="\in" valign="middle" />[M]:
<p>Die Anzahl S<sub>j</sub>(T) der Exemplare nach dem T-ten Speicherdurchlauf betr&auml;gt</p>
<p><img src="/img/cache/5dbc98dcc983a70728bd082d1a47546e.gif" alt="S" valign="middle" /><sub>j</sub>(0) * 2<sup>(T <img src="/img/cache/e6adf0240356afd2ea1a68a1903b29fd.gif" alt="\div" valign="middle" /> DELY-Komponente von <img src="/img/cache/68df4fedda3a6ee42485d71ce568ba2e.gif" alt="\pi_j" valign="middle" />)</sup>
wobei S<sub>j</sub>(0) die Anzahl der Exemplare von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /><sub>j</sub> vor Beginn der Simulation ist.</p>

S<sub>j</sub>(T) kann f&uuml;r jedes <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /><sub>j</sub> nach jedem WHEN_CON-ten Speicherdurchlauf mittels
<pre>
  <strong>procedure</strong> CONTROL;
</pre>
<p>in tabellarischer Form ausgedruckt werden.</p></li>
<li>In Anbetracht des ungehinderten numerischen Anwachsens der Programmzahl ist sicherlich die r&auml;umliche Anordnung der einzelnen Exemplare von gr&ouml;&szlig;erem Interesse. Das r&auml;umliche Verhalten (iv) in MOD1 ist recht willk&uuml;rlich gew&auml;hlt und soll hier auch nicht n&auml;her analysiert werden; andere r&auml;umliche Verhalten sind denkbar. Dem SIMULA-Programm f&uuml;r MOD1 sind daher zwei Prozeduren beigef&uuml;gt, die unabh&auml;ngig vom gew&auml;hlten r&auml;umlichen Verhalten dessen Analyse unterst&uuml;tzen. Es handelt sich dabei um
<!--p.172-->

<pre>
  <strong>procedure</strong> DUMP;
</pre>

<p>DUMP gibt den Inhalt des gesamten Speichers von links nach rechts aus, indem f&uuml;r eine leere Zelle das Zeichen "<img src="/img/cache/4b4efc2fbe82a047fc08c83ea081f1d9.gif" alt="\star" valign="middle" />" und f&uuml;r eine besetzte Zelle die Komponente IDENT des gespeicherten Programms ausgedruckt wird.</p>
<pre>
  <strong>procedure</strong> AVERAGE;
</pre>

<p>AVERAGE gibt in tabellarischer Form die durch¬schnittliche Entfernung der Exemplare der jeweiligen Programmtypen an.  Grundlage ist der Abstand 1 f&uuml;r direkt benachbarte Speicherzellen.</p>

<p>Die Aufrufe von DUMP und AVERAGE werden durch die <strong>integer</strong>-Variablen WHEN_DUM und WHEN_AVE gesteuert. DUMP wird nach jedem WHEN_DUM-ten Speicherdurchlauf aufgerufen, entsprechend AVERAGE.</p></li>

<li><p>Aus I und II ergibt sich, da&szlig; die in Anhang C.1. wiedergegebene Implementierung von MOD1 drei mo¬dellunabh&auml;ngige Eingabeparameter, n&auml;mlich</p>
<pre>
  WHEN_CON
  WHEN_DUM
  WHEN_AVE
</pre>
<p>enth&auml;lt, die die Ausgabe steuern.</p></li>

<li><p><strong>Aufwand:</strong></p>
<p><em>Speicherplatz:</em> In MOD1 ist ile  Anzahl der vorhandenen Programmtypen konstant. Damit haben auch die Felder ST und P w&auml;hrend der Simulation eine konstante Gr&ouml;&szlig;e. Nur die den Speicher darstellende Liste wird - bei hinreichend gro&szlig;er Anzahl TIME der Speicherdurchl&auml;ufe  -  w&auml;hrend der Simulation anwachsen. Wie stark dieses Wachstum w&auml;hrend eines Speicherdurchlaufs ist, h&auml;ngt von den vorhandenen Programmtypen
<!--p.173-->

ab. Bei kleinen Reproduktionszeiten (Komponente DELY) der Programme und gro&szlig;en Entfernungen der Kopien (Komponente DISTANCE) erfolgt die Zu nahme besonders schnell. Da die Gesamtzahl der vorhandenen Programraexemplare (siehe I.) exponentiell ansteigt, w&auml;chst auch die L&auml;nge des Speichers im Verlauf der Simulation insgesamt exponentiell; die vorgenannten Kriterien machen daher nur einen Faktor aus.</p>

<p><em>Laufzeit:</em> Die Laufzeit des SIMULA-Programms f&uuml;r MOD1 h&auml;ngt von allen Modellparametern ab. Eine genaue Absch&auml;tzung kann im Rahmen dieser Arbeit nicht mehr vorgenommen werden. Da der Zeitaufwand f&uuml;r einen Speicherdurchlauf von der L&auml;nge des Speichers abh&auml;ngt, ergibt sich auf jeden Fall ein exponentieller Zusammenhang zwischen der Anzahl der Speicherdurchl&auml;ufe und der Laufzeit von MOD1.</p>

<p>Das exponentielle Verhalten des Aufwands macht MOD1 f&uuml;r statistische Zwecke wenig brauchbar und unterstreicht die Bedeutung von MOD1 als ein ledigliches Grundmodell. Das ungehinderte exponentielle Anwachsen an Programmexemplaren wird in den folgenden Modellen durch ein ge&auml;ndertes r&auml;umliches Verhalten und durch Einf&uuml;hrung von konkurrierendem Verhalten verhindert.</p></li></ol>
<!--p.174-->

<h3><a name="c83"></a>8.3. Ein Modell mit konkurrierendem Verhalten</h3>
<p>Im Grundmodell MOD1 kann jedes reproduktionsf&auml;hige Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> seine Kopie <img src="/img/cache/78ff957ab4e820df035c310e66c93c8e.gif" alt="\overline{\pi}" valign="middle" /> ungehindert in einer freien Speicherzelle ablegen. Insofern gibt es zwischen den Programmen keine echten Konfliktsituationen und damit keine Konkurrenz. Das Fehlen von Konkurrenz in MOD1 macht das Eintreten von Evolution unm&ouml;glich. Ein weiterer Aspekt von MOD1 ist die Best&auml;ndigkeit der Programme.</p>
<p>In Form von MOD2 soll nun MOD1 dahingehend erweitert werden, da&szlig; Programme in der Lage sind, ihre Kopien in bereits durch andere Programme besetzte Speicherzellen zu schreiben. Dabei werden die alten Inhalte der Speicherzellen, also Programme, gel&ouml;scht. Es wird zweierlei erreicht:</p>
<ol>
	<li>Es gibt Konflikte zwischen den Programmen. Die Konsequenz ist Konkurrenz.</li>
	<li>Das &uuml;berschreiben von Programmsn bedeutet deren Vernichtung. Es tritt also eine Art "Sterben" von Programmen auf.</li>
</ol>
<p>Konkurrierendes Verhalten ist ein spezielles Verhalten von Programmen untereinander. Wir fuhren daher ganz allgemein</p>
<pre>(v)   Verhalten der Programme untereinander</pre>
<p>als weitere Modellkomponente ein. In 8.3.1. erfolgt eine detaillierte Beschreibung von MOD2.</p>

<h4><a name="c831"></a>8.3.1. Informelle Beschreibung von MOD2</h4>
<ol type="i">
	<li>	<p><strong>Programme:</strong> Die einzige charakteristische Gr&ouml;&szlig;e eines Programms ist seine Laufzeit (=Reproduktionszeit). Die Laufzeit ist gleich der Anzahl von Zeittakten, die das Programm jeweils aktiv sein mu&szlig;, um sich reproduzieren zu k&ouml;nnen.</p>
		<p>Das Modell eines Programms ist somit ein 2-Tupel, bestehend aus der Programmidentifikation und der Laufzeit.</p></li>
<!--p.175-->
 	<li><strong>Speicher:</strong> Wie in MOD1.</li>
	<li><strong>Seitverhalten:</strong> Wie in MOD1.</li>
	<li><strong>R&auml;umliches Verhalten:</strong> Zu jedem Zeitpunkt t sind nur endlich viele Speicherzellen belegt. Unter den belegten Speicherzellen gibt es daher immer eine am weitesten links und eine am weitesten rechts stehende Speicherzelle l(t) bzw. r(t). l(t) und r(t) begrenzen den Speicherbereich, in dem sich belegte Zellen befinden. Die Speicherzelle, in der ein Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> seine Kopie <img src="/img/cache/78ff957ab4e820df035c310e66c93c8e.gif" alt="\overline{\pi}" valign="middle" /> ablegt, soll nicht beliebig von diesem abgegrenzten Speicherhereich entfernt liegen, sondern nur um eine konstante Anzahl von Zellen. Es ergibt sich also als Zielbereich f&uuml;r eine Kopie ein durch L(t) und R(t) abgegrenzter Speicherbereich (Abb. 8.3.1.A). Innerhalb dieses Speicherbereichs ist jede Zelle gleichwahrscheinliches Ziel f&uuml;r die Kopie <img src="/img/cache/78ff957ab4e820df035c310e66c93c8e.gif" alt="\overline{\pi}" valign="middle" />.
<div align="center">
    <img src="img/mjk00/abb831a.gif" alt="8.3.1.A" />
    <p>Abb.: 8.3.1.A</p>
</div>
		<p>Ein derartiges r&auml;umliches Verhalten garantiert eine kontrollierte Ausbreitung der Programme. Es k&ouml;nnen nicht pl&ouml;tzlich beliebig weit entfernte und isolierte "Populationen" entstehen.</p>
	</li>
<!--p.176-->
 	<li><strong>Verhalten der Programme untereinander:</strong> Ist ein Programm <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> reproduktionsf&auml;hig, so wird gem&auml;&szlig; (iv) eine beliebige Speicherzelle ausgew&auml;hlt, in der die Kopie <img src="/img/cache/78ff957ab4e820df035c310e66c93c8e.gif" alt="\overline{\pi}" valign="middle" /> abgelegt werden soll. Ist diese Speicherzelle leer, so tritt kein Konflikt auf. Andernfalls ist die Speicherzelle bereits mit einem Programm <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle" /> besetzt, und ein Entscheidungsmechanismus mu&szlig; herangezogen werden um zu bestimmen, ob <img src="/img/cache/78ff957ab4e820df035c310e66c93c8e.gif" alt="\overline{\pi}" valign="middle" /> das Programm <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle" /> &uuml;berschreiben darf oder nicht. F&auml;llt die Entscheidung positiv aus, so &uuml;berschreibt <img src="/img/cache/78ff957ab4e820df035c310e66c93c8e.gif" alt="\overline{\pi}" valign="middle" /> das Programm <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle" />, ist sie negativ, so hat <img src="/img/cache/78ff957ab4e820df035c310e66c93c8e.gif" alt="\overline{\pi}" valign="middle" /> keine Ausweichm&ouml;glichkeit und wird eliminiert. Ein Konfliktfall endet also immer f&uuml;r eines der beteiligten Programme "t&ouml;dlich".</li>
</ol>
<p>Erst durch Angabe des in (v) genannten Entscheidungsmechanismus wird die Beschreibung von MOD2 vollst&auml;ndig. Es sind sicherlich sehr viele Entscheidungsmechanismen f&uuml;r MOD2 denkbar, die auf unterschiedlichsten Faktoren beruhen. Wir wollen, um MOD2 m&ouml;glichst einfach zu halten, einen Entscheidungsmechanismus angeben, der nur auf den beiden jeweils aufeinandertreffenden Programmen beruht. Damit dieser Entscheidungsmechanismus nicht zu starr wird, wird er mit Wahrscheinlichkeiten belegt, was indirekt doch eine Ber&uuml;cksichtigung weiterer, allerdings unbekannter, Faktoren bedeutet.</p>

<p><strong>(8.3.1.1) Definition:</strong> Sei n<img src="/img/cache/986c22f151c46acac223b858e3fcf6fd.gif" alt="\in" valign="middle" />N. Eine n<img src="/img/cache/60c13e05d3ec8c10b8564eae7023d9db.gif" alt="\times" valign="middle" />n-Matrix
V = (v<sub>ij</sub>)<img src="/img/cache/583c901cf677108080b8abea7a029bf3.gif" alt="\in\wr\wr" valign="middle" /><sub>n</sub>(<img src="/img/cache/24c8b71eb3c8121becf7796ea3150bfd.gif" alt="\Re" valign="middle" />) (Ring der n-reihigen Matrizen &uuml;ber dem K&ouml;rper der reellen Zahlen) hei&szlig;t n-reihige Vorrangmatrix, falls gilt:<br />

V<sub>ij</sub><img src="/img/cache/986c22f151c46acac223b858e3fcf6fd.gif" alt="\in" valign="middle" />[0,1] <img src="/img/cache/c341c139b568018b935b0d660db43420.gif" alt="\subset\Re" valign="middle" />&nbsp;&nbsp;&nbsp;f&uuml;r alle i,j<img src="/img/cache/986c22f151c46acac223b858e3fcf6fd.gif" alt="\in" valign="middle" />[n]<br />

Sei <img src="/img/cache/44c29edb103a2872f519ad0c9a0fdaaa.gif" alt="P" valign="middle" />:= {<img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /><sub>1</sub>,...,<img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /><sub>M</sub>] die Menge der in MOD2 vorkommenden Programmtypen. Eine M-reihige Vorrangmatrix zusammen mit einer entsprechenden Interpretation liefert einen Entscheidungsmechanismus f&uuml;r MOD2.</p>
<!--p.177-->

<p><strong>(8.3.1.2) Definition:</strong> <em>Sei M die Anzahl der in MOD2 vorkommenden Programmtypen. Sei V = (v<sub>ij</sub>) eine M-reihige Vorrangmatrix. Die Komponenten v<sub>ij</sub> werden wie folgt interpretiert:<br />

Soll die Kopie <img src="/img/cache/78ff957ab4e820df035c310e66c93c8e.gif" alt="\overline{\pi}" valign="middle" /> eines Programms <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> vom Typ <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /><sub>i</sub> in einer Speicherzelle abgelegt werden, in der sich bereits ein Programm <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle" /> des Typs <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /><sub>j</sub> befindet, so bedeutet v<sub>ij</sub>:<br />

Mit der Wahrscheinlichkeit v<sub>ij</sub> &uuml;berschreibt <img src="/img/cache/78ff957ab4e820df035c310e66c93c8e.gif" alt="\overline{\pi}" valign="middle" /> das Programm <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle" />.
<br />
Mit der Wahrscheinlichkeit (1-v<sub>ij</sub>) &uuml;berschreibt <img src="/img/cache/78ff957ab4e820df035c310e66c93c8e.gif" alt="\overline{\pi}" valign="middle" /> das Programm <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle" /> nicht, <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle" /> bleibt erhalten und <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> wird eliminiert.</em></p>

<p>Als Entscheidungsmechanismen f&uuml;r MDD2 sind genau die M-reihigen Vorrangmatrizen zugelassen. Die Vorrangmatrix ist also ein Parameter von MOD2. Durch die Vorrangrmatrix erh&auml;lt MOD2 einen nichtdeterministischen Charakter.</p>

<h4><a name="c832"></a>8.3.2. MOD2 als SIMULA-Programm</h4>
<ol type="i">
<li><strong>Programme:</strong>
<p>Im Gegensatz zu MOD1 werden. Programme durch die einfachere SIMULA-Struktur</p>
<pre><strong>class</strong> PROGRAM;
  <strong>begin</strong>
  <strong>integer</strong> IDERT,DELY;
  <strong>end</strong>;
</pre>

<p><code>IDENT</code> <img src="/img/cache/7b5706c92a949a258e3cad097464d1cd.gif" alt="\leftarrow" valign="middle" /> Identifizierung</p>
<p><code>DELY</code> <img src="/img/cache/7b5706c92a949a258e3cad097464d1cd.gif" alt="\leftarrow" valign="middle" /> Reproduktionszeit</p>
<p>dargestellt.</p>
</li>

<li><strong>Speicher:</strong>

<p>Die Realisierung des Speichers ist mit Schwierigkeiten verbunden. 
<!--p.178-->

Einerseits mu&szlig; der Speicher potentiell unendlich sein (Listenkonzept), andererseits ist wegen 8.3.2.(iv) direkter Zugriff auf die Speicherzellen w&uuml;nschenswert (Arraykonzept). Da Listenkonzept und Arraykonzept nicht miteinander vereinbar sind, mu&szlig; bei einer Kompromi&szlig;l&ouml;sung irgendwo die Priorit&auml;t gesetzt werden. Direkter Zugriff wirkt sich g&uuml;nstig auf die Laufzeit von MOD2 aus. Wir setzen deshalb hier die Priorit&auml;t und stellen den Speicher als <strong>array</strong> dar. Um der geforderten Unendlichkeit des Speichers wenigstens gerecht zu werden, mu&szlig; es sich dabei um dynamische <strong>arrays</strong> handeln. Dynamische <strong>arrays</strong> sind in SIMULA im Rahmen des Klassenkonzepts m&ouml;glich:</p>

<pre><strong>class</strong> STORAGE(Q); <strong>integer</strong> Q;
  <strong>begin</strong>
  <strong>ref</strong> (CELL) <strong>array</strong> ELEMENT(1:Q);
  <strong>end</strong>;
</pre>

<p>wobei die einzelnen Speicherzellen (Typ : CELL) wie in MOD1 dargestellt werden:</p>

<pre><strong>class</strong> CELL;
  <strong>begin</strong>
  <strong>ref</strong> (PROGRAM) CONTENS;
  <strong>integer</strong> TIMECOUNT;
  <strong>end</strong>;
</pre>


<p>Zugriff auf den Speicher liefert der globale Zeiger <strong>ref</strong> (STORAGE) STORSPOINTER.</p>
<p>Zu Beginn der Simulation wird der Speicher mit N Speicherzellen initialisiert. Dies geschieht durch die Zuweisung</p>

<pre>STOREPOINTER: <strong>new</strong> STORAGE(N);</pre>

<p>W&auml;hrend der Simulation wird der Speicher immer dichter mit Programmen "besiedelt" und mu&szlig; von Zeit zu Zeit erweitert werden. Wann der Speicher erweitert wird, gibt die integer Variable PERCENT an: Ist der
<!--p.179-->

Speicher zu PERCENT %  belegt  -  getestet wird dies mit Hilfe von <strong>boolean procedure</strong> OVERFLOW -  , so wird eine Erweiterung des Speichers vorgenommen. Die Erweiterung des Speichers wird durch die Prozedur</p>

<pre><strong>procedure</strong> NEW_STORAGE(MORE); <strong>integer</strong> MORE;
</pre>
<p>vorgenommen. NEW_STORAGE generiert ein neues Objekt der L&auml;nge N+2*MORE vom Typ STORAGE, kopiert den Inhalt des alten Speichers in dieses neue Objekt und setzt den globalen Zeiger STOREPOINTER entsprechend um (Abb. 8.3.2.A). Nach Ablauf von NEW_STORAGE ist der Speicher an jedem Ende um MORE Zellen erweitert und die Variable N, die immer die aktuelle L&auml;nge des Speichers angibt, um 2*MORE vergr&ouml;&szlig;ert.</p>

<div align="center">
	<img src="img/mjk00/abb832a.gif" alt="Abb.:8.3.2.A" />
	<p>Abb.: 8.3.2.A</p>
</div>

<p>Die den Mechanismus der Speichererweiterung bestimmenden Gr&ouml;&szlig;en PERCENT und MORE sind wichtige Parameter von MOD2 als SIMULA-Programm. Je kleiner PERCENT und je gr&ouml;&szlig;er MORE gew&auml;hlt sind, desto besser wird die Unendlichkeit des Speichers angen&auml;hert. Setzt man PERCENT> 100, so artet die
<!--p.180-->
Realisierung von MOD2 in ein Modell mit endlichem Speicher aus.</p></li>
<li><p><strong>Zeitverhalten:</strong></p>
<p><em>Startsituation:</em> Zu Beginn der Simulation werden wie in MOD1 die M Programme (besser: Programmtypen) <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /><sub>1</sub>,...<img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /><sub>M</sub> eingelesen und im Feld</p>

<pre>
  <strong>ref</strong> (PROGRAM) <strong>array</strong> P [1:M];
</pre>

<p>abgespeichert. Das Feld</p>
<pre><strong>integer array</strong> ST [1:M]
</pre>

<p>enth&auml;lt zu jedem Zeitpunkt der Simulation in den Komponenten ST[j] die momentane Anzahl der im Speicher befindlichen Exemplare des Programms <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /><sub>j</sub>. Die Anfangsbelegung von ST wird ebenfalls eingelesen, da sie angibt, mit wievielen Exemplaren der einzelnen Programme der Speicher initialisiert wird. Der leere Speicher mit der Startl&auml;nge N wird initialisiert, indem f&uuml;r jedes j <img src="/img/cache/986c22f151c46acac223b858e3fcf6fd.gif" alt="\in" valign="middle" /> [M] die ST [j] Exemplare des Programms <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /><sub>M</sub> in den Speicher geschrieben (durch Setzen von Verweisen) werden. Die zuf&auml;llige Verteilung der Programme im Speicher wird mittels des Zufallszahlengenerators RANDINT(1,N,U) gew&auml;hrleistet; jede Speicherzelle ist gleichwahrscheinlich. Es wird jedoch verhindert, da&szlig; bereits bei Initialisierung Programme &uuml;berschrieben werden. Selbstverst&auml;ndlich mu&szlig; gelten:</p>

<p><img src="/img/cache/5a953860f19a2ada30d69dad59494fc4.gif" alt="\sum_{j=1}^{M}" valign="middle" /> ST[j] <img src="/img/cache/de44c582df9d8d29dbbd70aca311c641.gif" alt="\leq" valign="middle" /> N</p>


<p>Zum Abschlu&szlig; der Initialisierung wird die M-reihige Vorrangmatrix eingelesen und im Feld</p>
<pre>
CONFLICT [1:M,1:M]
</pre>
<p>abgespeichert.</p>

<p><em>Simulation:</em> TIME-mal wird der Speicher von rechts nach links bzw. von links nach rechts durchlaufen. Jede Durchlaufrichtung ist gleichwahrscheinlich.
<!--p.181-->

Durch zuf&auml;llige Wahl der Durchlaufrichtung soll eine Bevorzugung einzelner Programme vermieden werden. W&auml;hrend eines Durchlaufs wird f&uuml;r jede nicht leere Speicherzelle die Prozedur MATCH aufgerufen. MATCH testet, ob das in der betreffenden Speicherzelle befindliche Programm reproduktionsf&auml;hig ist und legt eventuell eine Kopie des Programms an. Damit ist es m&ouml;glich, da&szlig; ein Aufruf von MATCH die prozentuale Speicherbelegung gr&ouml;&szlig;er als PEECENT werden l&auml;&szlig;t und ein Aufruf von NEW_STORAGE notwendig wird:</p>

<pre><strong>for</strong> T=1 <strong>step</strong> 1 <strong>until</strong> TIME <strong>do</strong>
<strong>begin</strong>
  [Lege Durchlaufrichtung fest];
  <strong>if</strong> [Durchlaufrichtung = 'von rechts nach links']
  <strong>then</strong>
  <strong>begin</strong>
    <strong>for</strong> I:=1 <strong>step</strong> 1 <strong>until</strong> N <strong>do</strong>
    <strong>if</strong> [I-te Zelle ungleich leer]
    <strong>then</strong>
    <strong>begin</strong>
      MATCH(I);
      <strong>if</strong> OVERFLOW <strong>then</strong> NEY_STORAGE(MORE)
    <strong>end</strong>
  <strong>end</strong>
  <strong>else</strong>
  <strong>for</strong> I:=N <strong>step</strong> -1 <strong>until</strong> 1 <strong>do</strong>
  <strong>if</strong> [I-te Zelle ungleich leer]
  <strong>then</strong>
  <strong>begin</strong>
    MATCH (I);
    <strong>if</strong> OVERFLOW <strong>then</strong> NEW_STORAGE(MORE)
  <strong>end</strong>
<strong>end</strong> + * *   SIMULATION   * * +;
</pre>
<!--p.182-->

<p><em>Funktionsweise der Prozedur MATCH:</em></p>

<pre><strong>procedure</strong> MATCH(I); <strong>integer</strong> I;
<strong>begin</strong>
<img src="/img/cache/4b4efc2fbe82a047fc08c83ea081f1d9.gif" alt="\star" valign="middle" />
<img src="/img/cache/4b4efc2fbe82a047fc08c83ea081f1d9.gif" alt="\star" valign="middle" />
<img src="/img/cache/4b4efc2fbe82a047fc08c83ea081f1d9.gif" alt="\star" valign="middle" />
  <strong>boolean</strong> IS_COPY;
  IS COPY:=<strong>false</strong>;
  [Erh&ouml;he TTMECOUNT-Komponente der l-ten Speicherzeile um 1 ;]
  <strong>if</strong>
    [TIMECOUNT-Komponente der I-ten Speicherzelle gleich DELY
     Komponente des in der I-ten Speicherzelle befindlichen
     Programms]
  <strong>then</strong>
  <strong>begin</strong>
    <strong>comment</strong>  * * * Reproduktion des in der I-ten
                           Zelle befindlichen Programms * * * ;
    [Setze TIMECOUNT-Komponente der I-ten Speicherzelle auf 0];
    [W&auml;hle eine zuf&auml;llige Zelle des Speichers aus.
     Sei die Wahl auf die W-te Speicherzelle gefallen];
    <strong>comment</strong> * * * siehe dazu unten (iv) * * * ;
    <strong>if</strong> [W-te Speicherzelle gleich leer]
    <strong>then</strong>
    <strong>begin</strong>
      <strong>comment</strong> * * * Ungehindertes Ablegen der Kopie* * *;
      [Schreibe Kopie in die W-te Speicherzelle];     IS_COPY:=true end eise begin
    <strong>end</strong>
    <strong>else</strong>
    <strong>begin</strong>
      <strong>comment</strong> * * * W-te  Speicherzelle ist bereits besetzt « * * * ;
      [Treffe Entscheidung mittels der Vorrangmatrix, ob die Kopie
       des in der I-ten Zelle befindlichen Programms das Programm in
       der W-ten Zelle &uuml;berschreiben darf];
      <strong>comment</strong> * * * siehe unten (v) * * * ;
<!--p.183-->

      <strong>if</strong> [&uuml;berschreiben nicht m&ouml;glich]
      <strong>then</strong> <strong>comment</strong> * * *  es geschieht nichts * * *
      <strong>else</strong>
      <strong>begin</strong>
        [Schreibe Kopie in die W-te Speicherzelle]
        IS COPY:=<strong>true</strong>
      <strong>end</strong>
    <strong>end</strong>;
    <strong>comment</strong> * * * Falls das Programm aus Speicherzelle I seine
                  Kopie im Speicher ablegen konnte, mu&szlig; noch in
                  Abh&auml;ngigkeit von der Durchlaufrichtung die
                  Komponente TIMECOUNT der W-ten Speicherzelle
                  gesetzt werden * * * ;
    <strong>if</strong> IS_COPY
    <strong>then</strong>
    <strong>begin</strong>
      <strong>if</strong> W <img src="/img/cache/de44c582df9d8d29dbbd70aca311c641.gif" alt="\leq" valign="middle" /> 1
      <strong>then</strong>
      <strong>begin</strong>
        <strong>if</strong> [Durchlaufrichtung = 'von links nach rechts']
        <strong>then</strong> [{TIMECOUNT-Komponente von Zelle W}:=0]
        <strong>else</strong> [{TIMECQUNT-Komponente von Zelle W}:=-1]
      <strong>end</strong>
      <strong>else</strong>
      <strong>if</strong> [Durchlaufrichtung = 'von links nach rechts']
      <strong>then</strong> [{TIMECOUNT-Komponente von Zelle W}:=-1]
      <strong>else</strong> [{TIMECQUNT-Komponente von Zelle W}:=0]
    <strong>end</strong>
  <strong>end</strong>
<strong>end</strong> * * * MATCH * * * ;
</pre>
</li>

<li><p><strong>R&auml;umliches Verhalten:</strong></p>
<p>Die Auswahl der Speicherzelle, in die ein Programm seine Kopie ablegt, erfolgt &uuml;ber die SIMULA-Zufallsfunktion RANDINT in Form des Aufrufs</p>
<pre>RANDINT(1,N,U_CELL)</pre>
<!--p.184-->

<p>wobei N die aktuelle L&auml;nge des Speichers und U_CELL ein von RANDINT ben&ouml;tigter <strong>name</strong>-Parameter ist. Jede der N Speicherzellen ist gleichwahrscheinlich (vgl. genaue Beschreibung der Funktion RANDINT in [25] ). Die Auswahl der Speicherzellen f&uuml;r die Kopie weicht geringf&uuml;gig von der in 8.3.1.(iv) beschriebenen ab. Zusammen mit der Speichererweiterungsstrategie aus 8.3.2.(iii) ergibt sich jedoch der in 8.3.1-(iv) beschriebene Gesamteffekt.</p></li>

<li><p><strong>Verhalten der Programme untereinander:</strong></p>
<p>In der SIMULA-Version von MOD2 wird die Vorrangmatrix V = (V<sub>ij</sub>) nicht als Element aus <img src="/img/cache/a8e452f48b18bb5f92dc1f981f18fffb.gif" alt="\wr\wr" valign="middle" /><sub>M</sub>(<img src="/img/cache/24c8b71eb3c8121becf7796ea3150bfd.gif" alt="\Re" valign="middle" />), sondern als Element aus <img src="/img/cache/a8e452f48b18bb5f92dc1f981f18fffb.gif" alt="\wr\wr" valign="middle" /><sub>M</sub>(<img src="/img/cache/8d9c307cb7f3c4a32822a51922d1ceaa.gif" alt="N" valign="middle" />) dargestellt:</p>
<pre>  <strong>integer array</strong> CONFLICT [1:M,1:M]</pre>
<p>Jedes v<sub>ij</sub>(=CONFLICT[i,j]) wird als "v<sub>ij</sub> Hundertstel" interpretiert. Daher nimmt jedes v<sub>ij</sub> h&ouml;chstens den Wert 100 an. v<sub>ij</sub> = 0  kann aus programmtechnischen Gr&uuml;nden nicht zugelassen werden (Abweichung von 8.3.1.(v)).</p>


<p><em>Beispiel:</em></p>
<pre>
     M = 5
     Konflikt eines Programms <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> vom Typ <img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle" /> mit 
     einem Programm, <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle" /> vom Typ <img src="/img/cache/3d7f13d8a7fc36e2f1db05664d74ff57.gif" alt="\pi_3" valign="middle" />, d.h. <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" />
     versucht <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle" /> zu &uuml;berschreiben:
     Entscheidung (vgl. Beschreibung der Prozedur MATCH):

     if CONFLICT[2,3]&lt;RANDINT(1,100,U_CONFLICT)
     then [<img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> &uuml;berschreibt <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle" /> nicht]
     else [<img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> &uuml;berschreibt <img src="/img/cache/f81795f5cd2e69b9e65cb1adf15c681c.gif" alt="\pi'" valign="middle" />]
</pre>
</li>
</ol>
<p>Anhang C.2. zeigt MOD2 als ausf&uuml;hrlich kommentiertes SIMULA-Programm. Einen &uuml;berblick &uuml;ber die in diesem Programm benutzten Datenstrukturen gibt Abb. 8.3.2.B..</p>
<!--p.185-->
<div align="center">
	<img src="img/mjk00/abb832b.gif" alt="Abb.  8.3.2.B" />
	<p>Abb.  8.3.2.B</p>
</div>
<!--p.186-->

<p><strong>Eingabeparameter des SIMULA-Programms f&uuml;r MOD2:</strong></p>
<ol>
	<li>Die Anfangsl&auml;nge des Speichers <img src="/img/cache/78d9dc6c665f9a9e2b81c280a13771b7.gif" alt="\longrightarrow" valign="middle" /> N</li>
	<li>Die Anzahl der unterschiedlichen Programmtypen <img src="/img/cache/78d9dc6c665f9a9e2b81c280a13771b7.gif" alt="\longrightarrow" valign="middle" /> M</li>
	<li>Die M Programmtypen, charakterisiert durch die Gr&ouml;&szlig;e DELY, und ihre jeweilige Anfangsh&auml;ufigkeit <img src="/img/cache/78d9dc6c665f9a9e2b81c280a13771b7.gif" alt="\longrightarrow" valign="middle" /> DELY,ST [...]</li>
	<li>Die M*M Elemente der Vorrangmatrix. Jedes Element ist aus [100] <img src="/img/cache/78d9dc6c665f9a9e2b81c280a13771b7.gif" alt="\longrightarrow" valign="middle" /> CONFLICT</li>
	<li>Die Anzahl der vorgesehenen Speicherdurchlaufe <img src="/img/cache/78d9dc6c665f9a9e2b81c280a13771b7.gif" alt="\longrightarrow" valign="middle" /> TIME</li>
	<li>Die Speicherparameter <img src="/img/cache/78d9dc6c665f9a9e2b81c280a13771b7.gif" alt="\longrightarrow" valign="middle" /> MORE,PERCENT</li>
</ol>

<h4><a name="c833"></a>8.3.3. Einige Aspekte des SIMULA-Programms f&uuml;r MOD2</h4>
<ol type="I">
	<li>Das SIMULA-Programm f&uuml;r MOD2 gestattet Simulationen sowohl mit endlichem als auch mit unendlichem Speicher (abh&auml;ngig von PERCENT).</li>
	<li>Zur Unterst&uuml;tzung der Ausgabe werden die Prozeduren DUMP und CONTROL in das Programm eingef&uuml;gt. Daher enthalt das Programm die beiden modellunabh&auml;ngigen Parameter
	WHEN_DUM und WHEN_CON (vgl, 8.2.4.I.und II.)</li>
	<li>Mit Hilfe des Programms f&uuml;r MOD2 lassen sich gewisse Fragsstellungen experimentell untersuchen. Z.B.:
	<ol>
		<li>Inwieweit kann eine relativ schwache Stellung eines Programmtyps in der Vorrangmatrix durch eine kleine Reproduktionszeit kompensiert werden, so da&szlig; sich dieser Programmtyp gegen&uuml;ber seinen Konkurrenten behaupten kann?</li>
		<li>Seien K Programmtypen, repr&auml;sentiert durch ihre
<!--p.187-->
		DELY-Komponenten, und eine entsprechende Vorrangmatrix gegeben. Wie entwickelt sich das anzahlm&auml;&szlig;ige Verh&auml;ltnis der Exemplare der einzelnen Programmtypen bei fortschreitender Simulationsdauer? Wie lange dauert es, bis der eine oder andere Programmtyp ausgemerzt ist? Kann ein Programmtyp nach endlicher Simulationsdauer alle anderen Progranmtypen verdr&auml;ngen?</li>
		<li>Fragen der obigen Art in Abh&auml;ngigkeit von der "Populationsdichte" (gesteuert durch die Speicherparameter MORE und PERCENT).</li>
		<li>viele weitere Fragen.</li>
	</ol>
	<p>Das SIMULA-Programm f&uuml;r MOD2 bietet ein weites Experimentierfeld, was schon aus der Vielzahl der Eingabeparameter ersichtlich ist. Leider kann keine der obigen Fragestellungen im Rahmen dieser Arbeit mehr n&auml;her untersucht werden.</p>
	</li>
    <li><p><strong>Aufwand:</strong></p>
    <p><em>Speicherplatz:</em> Die Anzahl der in MOD2 vorhandenen verschiedenen Programmtypen bleibt w&auml;hrend der gesamten Simulation konstant. Damit bleibt auch der durch die Felder CONFLICT, ST und P bedingte Speicherplatzaufwand konstant. Nur das den Speicher simulierende dynamische Feld, auf das der Zeiger STOREPOINTER verweist, kann, w&auml;hrend der Simulation gr&ouml;&szlig;er werden. In welchem Ma&szlig;e dieses Feld w&auml;chst, h&auml;ngt von den Parametern MORE und PERCENT ab (vgl. 8.3.2.(ii)). Ist PERCENT>100 gew&auml;hlt, so bleibt die Gr&ouml;&szlig;e des Feldes immer konstant, andernfalls nimmt die Gr&ouml;&szlig;e im Verlauf der Simulation zu. Die Zunahme erfolgt exponentiell mit der Anzahl der Speicherdurchl&auml;ufe. Der Faktor (100-PERCENT)/100 (relative Anzahl der freien Speicherzellen) sorgt jedoch daf&uuml;r, da&szlig; diese Zunahme nicht so ungehemmt erfolgt wie im SIMULA-Programm zu MOD1, Zu beachten ist, da&szlig; eine Vergr&ouml;&szlig;erung des Feldes immer mit der Generierung eines neuen Objekts vom Typ STORAGE verbunden ist (Aufruf von NEW_STORAGE). Das jeweils alte Objekt
<!--p.188-->
    bleibt im Speicher vorhanden.</p>
    <p><em>Laufzeit:</em> Die Laufzeit ist im wesentlichen von der Anzahl der Speicherdurchl&auml;ufe und der L&auml;nge des den Speicher simulierenden Feldes abh&auml;ngig. Da die Gr&ouml;&szlig;e dieses Feldes exponentiell zur Anzahl der Speicherdurchl&auml;ufe w&auml;chst, h&auml;ngt auch die Laufzeit exponentiell von der Anzahl der Speicherdurchl&auml;ufe ab. Auch in bezug auf die Laufzeit hat der Faktor (100-PERCENT)/100 eine hemmende Wirkung. Extremf&auml;lle:</p>
    <ol type="a">
	    <li>Die L&auml;nge des Speichers ist nicht beschr&auml;nkt, aber der Speicher ist zu jedem Zeitpunkt der Simulation relativ wenig belegt (PERCENT klein gew&auml;hlt). Dann sind Konflikte relativ selten und die Programme k&ouml;nnen ihre Kopien nahezu ungehindert ablegen; die Gesamtzahl, der Programmexemplare steigt fast ungehemmt exponentiell an. Die Situation ist dann mit der in MOD1 vergleichbar (vgl. 8.2.4.IV.).</li>
    	<li>Die L&auml;nge des simulierten Speichers ist konstant (PERCENT > 100). Dann sind von irgendeinem Speicherdurchlauf an alle Speicherzellen besetzt. Die Laufzeit ist dann, im wesentlichen proportional zur Anzahl der Speicherdurchl&auml;ufe, da die Laufzeit der Prozedur MATCH (eine andere wird nicht mehr aufgerufen) durch eine Konstante beschr&auml;nkt ist.</li>
    </ol>
    </li>
    <li>Beim Aufruf von NEW_STORAGE wird der Speicher um die konstante Anzahl von 2*MORE Elementen erweitert. G&uuml;nstiger w&auml;re es wohl, wenn die Anzahl der zus&auml;tzlichen Elemente in einem konstanten prozentualen Verh&auml;ltnis zur jeweils momentanen L&auml;nge des Speichers stehen w&uuml;rde.</li>
</ol>
<!--p.189-->
<h2><a name="c9"></a>9. Evolution bei Programmen</h2>
<h3><a name="c91"></a>9.1. Motivation</h3>
<p>Lebende Pflanzen- und Tierorganismen waren nicht immer
so beschaffen wie heute. Vielmehr haben sie sich unter
langsamer, aber stetiger Abwandlung ihrer Eigenschaften
aus anderen (einfacheren) Lebewesen entwickelt. Man
bezeichnet diesen Vorgang als biologische Evolution.
Evolution findet auch heute noch, allerdings kaum merklich,
statt. Eine kausale Erkl&auml;rung f&uuml;r die biologische
Evolution versucht die Evolutionstheorie anzugeben. Die
moderne Evolutionstheorie l&auml;&szlig;t sich in wenigen Worten
wie folgt darlegen (vgl. [24] [13] [27] [15]):</p>
<p>Lebewesen erzeugen viel mehr Nachkommen, als zur
Erhaltung ihrer jeweiligen Art notwendig w&auml;re. Diese
Nachkommen variieren in ihrem Genbestand (s. 7.2.). Auch
Nachkommen derselben Eltern sind in der Regel nicht alle
gleich. Die Ver&auml;nderlichkeit des Genbestands wird durch
die F&auml;higkeit der Gene zur Mutation (s. 7.2.) bewirkt.
Die Mutationsrate lebender Organismen ist &auml;u&szlig;erst gering
und liegt bei etwa <img src="/img/cache/6edf763703b89d98480ec50f62ab6b47.gif" alt="10^{-4}" valign="middle" /> bis <img src="/img/cache/3907c05eab507b9f90ead1144d524c7c.gif" alt="10^{-7}" valign="middle" /> pro Gen. (Diese Werte
gelten unabh&auml;ngig von der Generationsdauer der einzelnen
Arten und sind selbst ein Ergebnis der Evolution:
Sie bewirken eine ausreichende Anpassungsf&auml;higkeit der
Arten, ohne da&szlig; die Arten in ihrem Genbestand instabil
werden). Da die Gene die Eigenschaften eines Individuums
ausmachen, unterscheiden sich die &uuml;berzahlreichen
Nachkommen in ihren Eigenschaften. Die Lebewesen stehen
untereinander in einem st&auml;ndigen Wettbewerb um g&uuml;nstige
Lebensbedingungen. Es herrscht ein permanenter Kampf ums
Dasein (struggle for life). Es &uuml;berleben nur die an die
Umwelt bestangepa&szlig;ten Nachkommen (survival of the fittest).
Nur diese Individuen gelangen zur Fortpflanzung.
Die anhaltende nat&uuml;rliche Auslese (natural selection)
bewirkt, da&szlig; die weniger tauglichen Individuen einer
Population ([24] S.337) zur&uuml;ckgedr&auml;ngt und schlie&szlig;lich
<!--p.190-->
ausgemerzt werden. Der Zwang zur bestm&ouml;glichen Anpassung
an die Umwelt (Selektionsdruck) f&uuml;hrt zu immer
optimaleren Eigenschaften der Lebewesen (transformierende
Selektion). Ungeachtet, ob eine solche Anpassung - bei
gleichgebliebener Umwelt - bereits eingetreten ist,
entstehen mit konstanter Rate neue Mutationen. Ist die
Anpassung weit fortgeschritten, so nimmt die Wahrscheinlichkeit
f&uuml;r "positive" Mutationen ab. In diesem Fall
sorgt die Selektion daf&uuml;r, da&szlig; die genetische Zusammensetzung
einer Population konstant bleibt, indem auftretende
"negative" Mutationen - wenn diese nicht schon
letal verlaufen sind - wieder beseitigt werden
(stabilisierende Selektion). Entstehen jedoch positive
Mutationen, oder ver&auml;ndert sich die Umwelt erneut, so
tritt wieder transformierende Selektion ein. Mutation
und Selektion stellen die eigentlichen "Motoren" der
Evolution dar. F&uuml;r die Evolution k&ouml;nnen allerdings noch
andere Faktoren eine Rolle spielen, z.B. Isolation,
Zufallswirkung ([15] Seite 317 ff.), geschlechtliche
oder ungeschlechtliche Vermehrung.</p>
<p>In 7.4. wurden selbstreproduzierende Programme mit
Viren verglichen. Obwohl Viren keine Lebewesen sind,
la&szlig;t sich an ihnen Evolution beobachten. Die Gr&uuml;nde
daf&uuml;r sind:</p>
<ul>
	<li>Viren sind zu <strong>Mutationen</strong> f&auml;hig</li>
	<li>Viren befinden sich ebenfalls in einem Kampf ums
	Dasein und sind daher der Selektion unterworfen.</li>
</ul>
<p>Es liegt der Schlu&szlig; nahe, da&szlig; Evolution auch bei
selbstreproduzierenden Programmen m&ouml;glich ist, falls diese
Mutation und Selektion gleichzeitig ausgesetzt sind. In
8.3. haben wir mit MOD2 ein Modell f&uuml;r konkurrierendes
Verhalten ( = Kampf ums Dasein) von Programmen entwikkelt.
Die Programmtypen in MOD2 lassen sich durch ihre
Reproduktionszeit und ihre Stellung in der Vorrangmatrix
beschreiben. In MOD2 werden sich diejenigen Programme
behaupten, die in der Vorrangmatrix eine g&uuml;nstige
Stellung einnehmen, also relativ leicht Speicherplatz
<!--p.191-->
f&uuml;r ihre Kopien finden, bzw. die eine kurze Reproduktionszeit
aufweisen. Es herrscht in MOD2 also Selektionsdruck
in Richtung</p>
<ul>
	<li>kurze Reproduktionszeit</li>
	<li>g&uuml;nstige Stellung in der Vorrangmatrix.</li>
</ul>
<p>W&uuml;rde es einem Programmtyp gelingen, eine k&uuml;rzere
Reproduktionszeit zu erlangen, oder eine bessere Stellung
in der Vorrangmatrix einzunehmen, so w&uuml;rden seine
einzelnen Exemplare den in MOD2 vorhandenen Konkurrenzkampf
besser bestehen k&ouml;nnen. Als Ursache f&uuml;r solche
Ver&auml;nderungen kommt Mutation in Frage. In 9.2. wird
MOD2 dahingehend erweitert, da&szlig; Programme die M&ouml;glichkeit
erhalten zu mutieren. Damit liegt dann ein Modell
vor, in dem alle Voraussetzungen f&uuml;r das Eintreten von
Evolution gegeben sind. Die SIMULA-Version dieses
Modells stellt dann ein Rechnerprogramm zur Simulation
von Evolution bei selbstreproduzierenden Programmen dar.</p>
<p>Bei dieser Gelegenheit sei erw&auml;hnt, da&szlig; Rechnerprogramme
ganz allgemein ein ad&auml;quates Mittel zur Simulation von
Evolutionsprozessen darstellen. Der Grund ist, da&szlig;
Evolution (biologische, chemische, kosmische,...) in der
Regel einen sehr langen Zeitraum ben&ouml;tigt, um merkliche
Ver&auml;nderungen hervorzurufen und daher Simulationsmodelle
immer vor dem Problem stehen, diesen Zeitraum, in dem ja
st&auml;ndig etwas "geschieht", zu simulieren. Nur mit schnellen
Rechenanlagen, die eine Vielzahl von Operationen in
Sekundenbruchteilen durchf&uuml;hren k&ouml;nnen, ist man in der
Lage, diesen Zeitraum auf ein ertr&auml;gliches Ma&szlig; zu
komprimieren (vgl. [8]).</p>
<h3><a name="c92"></a>9.2. Ein Modell MOD3 f&uuml;r Evolution selbstreproduzierender Programme</h3>
<p>Wir gehen von der Vorstellung aus, da&szlig; w&auml;hrend der
Reproduktion eines Programms <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> mit einer gewissen
<!--p.192-->
Wahrscheinlichkeit <img src="/img/cache/03b632315ee5bee654b60a6bd902a249.gif" alt="p_1" valign="middle" /> (Modellparameter) Fehler unterlaufen,
so da&szlig; die Kopie <img src="/img/cache/25f7eb9c7732511318bb616f28fc5936.gif" alt="\overline\pi" valign="middle" /> von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> verschieden ist und in diesem
Sinne eine Mutation des Programms <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> darstellt. I.a. werden
die Fehler minimal und die Unterschiede von <img src="/img/cache/4f08e3dba63dc6d40b22952c7a9dac6d.gif" alt="\pi" valign="middle" /> und <img src="/img/cache/25f7eb9c7732511318bb616f28fc5936.gif" alt="\overline\pi" valign="middle" />
gering sein. Da in MOD3 Programme durch ihre Peproduktionszeit
und ihre Stellung in der Vorrangmatrix
beschrieben werden, m&uuml;ssen sich Mutationen in einer &Auml;nderung
dieser Werte nach au&szlig;en bemerkbar machen, vorausgesetzt,
<img src="/img/cache/25f7eb9c7732511318bb616f28fc5936.gif" alt="\overline\pi" valign="middle" /> ist noch ein selbstreproduzierendes Programm.
F&uuml;hrt eine Mutation nicht zu einem selbstreproduzierenden
Programm, so liegt eine Letalmutation vor. Da Mutationen
immer sprunghaft und ungerichtet verlaufen, ist
das Auftreten einer Letalmutation jederzeit m&ouml;glich. In
MOD3 gibt die Wahrscheinlichkeit <img src="/img/cache/6fe97b358b528edc477ba63d50b652af.gif" alt="p_2" valign="middle" /> (Modellparameter)
ein Ma&szlig; f&uuml;r die H&auml;ufigkeit der letal ausgehenden
Mutationen an. Jede nicht letal verlaufende Mutation bringt
im Grunde ein erstes Exemplar eines neuen Programmtyps
hervor. Entsprechend werden Mutanten in MOD3 registriert,
ohne da&szlig; jedoch die "Abstammung" der Mutante verloren
geht. Jedes Auftreten einer nicht letalen Mutation bewirkt
also in MOD3 immer eine Vergr&ouml;&szlig;erung der Vielfalt
an vorhandenen Programmtypen. Da durch den Konkurrenzkampf
der Programme untereinander ein Selektionsdruck
in Richtung k&uuml;rzere Reproduktionszeit (h&ouml;here
Vermehrungsrate) bzw. g&uuml;nstige Stellung in der Vorrangmatrix
besteht, werden diejenigen Mutanten gegen&uuml;ber ihren
Originalprogrammen im Vorteil sein, die bzgl. dieser Werte
Verbesserungen aufweisen (Erh&ouml;hung der Fitne&szlig;). Solche
Mutanten werden - unter gewissen Nebenbedingungen -
in der Lage sein, die Prograramtypen, denen die Ursprungsprogramme
angeh&ouml;ren, zu verdr&auml;ngen (Selektion).
Selbstverst&auml;ndlich stellen durch Mutation entstehende Programmtypen
keine endg&uuml;ltigen Formen dar, sondern k&ouml;nnen selbst
wieder Mutationen hervorbringen. Da die Reproduktion von Programmen
wie eine "ungeschlechtliche" Vermehrung verl&auml;uft,
kann jede Mutante als Ausgangspunkt einer sich potentiell
aufzeigenden "Linie" auseinander hervorgehender
Programme (Typen) (Klons siehe [24] Seite 313) verstanden
werden.</p>
<!--p.193-->
<h4><a name="c921"></a>9.2.1. Informelle Beschreibung von MOD3</h4>
<ol type="i">
	<li><strong>Programme:</strong> In MOD3 werden Programme durch ihre
	Reproduktionszeit und ihren Namen repr&auml;sentiert.
	Stellt ein Programm eine Mutation dar, so gibt der
	Name Aufschlu&szlig; &uuml;ber die "Abstammung" des Programms.</li>
	<li><strong>Speicher:</strong> Wie in MOD2.</li>
	<li><strong>Zeitverhalten:</strong> Wie in MOD2. Allerdings ist ein
	Programm, das zum Zeitpunkt t reproduktionsf&auml;hig ist,
	also so viele Zeittakte aktiv war, wie seine
	Reproduktionszeit angibt, in der Lage, eine Mutation
	hervorzubringen. Die Wahrscheinlichkeit f&uuml;r eine
	Mutation betr&auml;gt <img src="/img/cache/03b632315ee5bee654b60a6bd902a249.gif" alt="p_1" valign="middle" />. Mit der Wahrscheinlichkeit <img src="/img/cache/6fe97b358b528edc477ba63d50b652af.gif" alt="p_2" valign="middle" />
	verl&auml;uft die Mutation letal. Verl&auml;uft die Mutation nicht
	letal, so unterscheiden sich Mutante und Originalprogramm
	mit der Wahrscheinlichkeit <img src="/img/cache/d0d86973559623638ebba252bd3f172d.gif" alt="p_3" valign="middle" /> in der Komponente
	DELY. Mit der Wahrscheinlichkeit <img src="/img/cache/93134e38ef1d1bf606c18921a053bc65.gif" alt="1-p_3" valign="middle" /> liegt der
	Unterschied im Konfliktverhalten (Vorrangmatrix) gegen&uuml;ber
	anderen Programmen. Das Auftreten einer nicht
	letalen Mutation bewirkt die Erh&ouml;hung der Anzahl M
	der momentanen Programmtypen in MOD3 um 1. Stellt die
	Kopie eines Programms eine Mutation dar, so wird mit
	der Mutante weiter verfahren, als handele es sich um
	eine korrekte Kopie.</li>
	<li><strong>R&auml;umliches Verhalten:</strong> Wie in MOD2. Mutanten und
	korrekte Kopien werden gleich behandelt.</li>
	<li><strong>Verhalten der Programme untereinander:</strong> Wie in MOD2
	wird das Verhalten der Programme untereinander durch
	eine Vorrangmatrix gesteuert. Beim Auftreten einer
	nicht letalen Mutation mu&szlig; die Vorrangmatrix um eine
	Spalte und eine Zeile erweitert werden, um die
	Konfliktf&auml;lle zwischen Programmen des neuen Typs mit den
	Programmen der alten Typen zu regeln.</li>
</ol>
<h4><a name="c922"></a>9.2.2. MOD3 als SIMULA-Programm</h4>
<ol type="i">
	<li><strong>Programme:</strong><br />
	Ein Programm(-typ) wird durch die SIMULA-Struktur
<!--p.194-->
<pre class="source"><strong>class</strong> PROGRAM;
      <strong>begin</strong>
      <strong>integer</strong> IDENT,DELY,MUT;
      <strong>text</strong> PROGNAME;|    |
      <strong>end</strong>; |  |     |    |
           |  |     |    Anzahl der Mutationen
           |  |     Reproduktionszeit
           |  Identifizierung
           Name des Programms
</pre>
	dargestellt. Die Komponenten DELY und PROGNAME
	ergeben sich aus der Beschreibung in 9.2.1.(i).
	Die Komponente PROGNAME w&uuml;rde zur Identifizierung
	der einzelnen Programmtypen ausreichen. Trotzdem
	kann auf die Gr&ouml;&szlig;e IDENT aus programmtechnischen
	Gr&uuml;nden (<strong>array</strong>-Zugriffe) nicht verzichtet werden.
	Die Komponente MUT gibt zu jedem Zeitpunkt die
	Anzahl der Mutanten an, die aus dem dargestellten
	Programm hervorgegangen sind.</li>
	<li><strong>Speicher:</strong><br />
	Die Darstellung des Speichers erfolgt wie im
	SIMULA-Programm f&uuml;r MOD2. Auch der Mechanismus der
	Speichererweiterung sowie dessen Steuerung &uuml;ber
	die <strong>integer</strong>-Gr&ouml;&szlig;en MORE und PERCENT werden
	&uuml;bernommen. (Prozeduren: NEW_STORAGE,OVERFLOW)</li>

    <li><strong>Zeitverhalten:</strong><br />
	Zun&auml;chst ist zu bemerken, da&szlig; w&auml;hrend der Simulation
	die Anzahl M der vorhandenen Programmtypen
	i.a. nicht konstant bleibt. Somit sind alle Felder,
	die in MOD2 M Komponenten aufweisen, in MOD3 von
	variabler L&auml;nge. Entsprechendes gilt f&uuml;r die
	Vorrangmatrix. Es m&uuml;ssen also in MOD3 einige Felder
	dynamisch angelegt werden:
<!--p.195-->
<pre class="source"><strong>class</strong> PROG(P);<strong>integer</strong> P;		] anstelle von
<strong>begin</strong>					] <strong>ref</strong> (PROGRAM)
<strong>ref</strong> (PROGRAM) <strong>array</strong> VECTOR[1:P];	] <strong>array</strong> P[1:M]
<strong>end</strong>;					]
					]
<strong>ref</strong> (PROG) PROGPOINTER;			]

<strong>class</strong> ST(P);<strong>integer</strong> P;			] anstelle von
<strong>begin</strong>					] <strong>integer array</strong>
<strong>integer array</strong> S[1:P]			] ST[1:M]
<strong>end</strong>;					]
					]
<strong>ref</strong> (ST) STPOINTER;			]

<strong>class</strong> CONFLICT(P);<strong>integer</strong> P;		] anstelle von
<strong>begin</strong>					] <strong>integer array</strong>
<strong>integer array</strong> MAT[1:P,1:P];		] CONFLICT[1:M,1:M]
<strong>end</strong>;					]
					]
<strong>ref</strong> (CONFLICT) CONPOINTER;		]
</pre>
	<p><em>Startsituation</em> Die Beschreibung der Startsituation
	&uuml;bertr&auml;gt sich aus 8.3.2.(iii) unter Ber&uuml;cksichtigung
	der gerade beschriebenen organisatorischen &Auml;nderungen
	der Datenstrukturen. Es bleibt nur zu vermerken,
	wie die beiden zus&auml;tzlichen Komponenten MUT
	und PROGNAME initialisiert werden. Sei <img src="/img/cache/c2be60453333f62302349283c4c3e389.gif" alt="\{\pi_1,\dots,\pi_M\}" valign="middle" />
	die Menge der anfangs vorkommenden Programmtypen,
	dann wird bei der Initialisierung</p>
	<ul>
		<li>die Komponente MUT f&uuml;r jedes <img src="/img/cache/68df4fedda3a6ee42485d71ce568ba2e.gif" alt="\pi_j" valign="middle" /> auf 0 gesetzt</li>
		<li>der Textkomponenten PROGNAME der Wert "P1"
		f&uuml;r den Programmtyp <img src="/img/cache/4d50b474c7a8b790bdd18aa1ee199f42.gif" alt="\pi_1" valign="middle" />, "P2" f&uuml;r den
		Programmtyp <img src="/img/cache/02fc6fab57d99e7a38e3a731de42063e.gif" alt="\pi_2" valign="middle" />, u.s.w., zugewiesen.</li>
	</ul>
	<p><em>Simulation:</em> Die Beschreibung der Simulation kann
	im wesentlichen aus 8.3.2.(iii) &uuml;bernommen werden.</p>
<!--p.196-->
	<p>Da MOD3 eine echte Erweiterung von MOD2 darstellt,
	bedarf es jedoch einiger Erg&auml;nzungen, die die
	Erzeugung und Behandlung von Mutationen betreffen.
	Diese Erg&auml;nzungen &auml;u&szlig;ern sich in einem Satz von
	Prozeduren, die s&auml;mtlich von der Prozedur MATCH
	aufgerufen werden. Bevor wir die so erweiterte
	Prozedur MATCH angeben k&ouml;nnen, m&uuml;ssen diese
	zus&auml;tzlichen Prozeduren erl&auml;utert werden.</p>
	<p>Die modellwirksamen Eigenschaften eines Programms
	sind die Komponente DELY und die Stellung
	des Programms in der Vorrangmatrix. Nur Mutationen
	in einer dieser beiden Eigenschaften haben in
	MOD3 einen Selektionswert. In der SIMULA-Version
	von MOD3 werden Mutationen von Programmen mittels
	der Funktionsprozedur</p>
<pre class="source"><strong>ref</strong> (PROGRAM) <strong>procedure</strong> MUTANT(X); <strong>ref</strong> (PROGRAM) X;</pre>
	<p>erzeugt. MUTANT liefert als Ergebnis einen Zeiger
	auf ein Objekt vom Typ PROGRAM. Dieses Objekt
	unterscheidet sich geringf&uuml;gig in einer der oben
	genannten modellwirksamen Eigenschaften von dem in
	Form des Zeigers X an die Prozedur &uuml;bergebenen
	Originalprogramm und stellt in diesem Sinne eine
	Mutante dar. Das Auftreten einer Mutation bewirkt
	immer das Erscheinen eines neuen Programmtyps und
	macht die Erh&ouml;hung der Variablen M, die zu jedem
	Zeitpunkt die Anzahl der im Modell vorhandenen
	Programmtypen angibt, um 1 erforderlich. Diese
	Erh&ouml;hung wird bereits vor dem Aufruf der Prozedur
	MUTANT vorgenommen.</p>
	<p><em>Funktionsweise von MUTANT:</em></p>
	<ol type="I">
		<li>Zun&auml;chst legt MUTANT ein neues Objekt vom Typ
		PROGRAM an und initialisiert die nicht unmittelbar
		modellrelevanten Komponenten. Dieses &uuml;ber
		den Zeiger HELP adressierte Objekt wird als
		Mutante des Programms X aufgebaut.
<!--p.197-->
<pre class="source"><strong>ref</strong> (PROGRAM) HELP;
HELP:-<strong>new</strong> PROGRAM;
HELP.MUT:=0;
HELP.IDENT:=M;
HELP.PROGNAME:-CREATE_NAME;
<strong>comment</strong> Beschreibung von CREATE_NAME s.u.;
X.MUT:=X.MUT+1;
<strong>comment</strong> *** Die Komponente MUT des. Original-
            programms X wird erh&ouml;ht, um die
	    Mutation dieses Programms zu re-
 	    gistrieren. *** ;
</pre></li>
		<li>Da die Mutante einen neuen Programmtyp
		darstellt, mu&szlig; die Vorrangmatrix um eine
		zus&auml;tzliche Zeile und Spalte erweitert werden. Zum
		Zeitpunkt des Aufrufs von MUTANT steht noch
		nicht fest, ob sich die Mutante etablieren
		kann oder im Anschlu&szlig; an ihre Generierung
		wieder eleminiert wird (vgl. unten Funktionsweise
		der Prozedur MATCH). Daher f&uuml;hrt MUTANT
		die Erweiterung der Vorrangmatrix noch nicht
		aus, sondern erzeugt als Seiteneffekt nur die
		Zeile und die Spalte, um die die Vorrangmatrix
		bei Etablierung erweitert werden mu&szlig;. Die Zeile
		und die Spalte werden in Form des Datentyps
<pre class="source"><strong>class</strong> FIELD(P); <strong>integer</strong> P;
   <strong>begin</strong>
   <strong>integer array</strong> V[1:2,1:P];
   <strong>comment</strong> *** V[1,...]  entspricht der Spalte
               V[2,...]  entspricht der Zeile ***;
   <strong>end</strong>;
</pre>
		zusammengefa&szlig;t. MUTANT erzeugt ein Objekt vom
		Typ FIELD und weist es der globalen Variablen
		CHANGE.CONFLICT zu:
<pre class="source">CHANGE_CONFLICT:-<strong>new</strong> FIELD(M);</pre>
		<p>Die Komponenten der X.IDENT-ten Zeile bzw.
		Spalte der Vorrangmatrix regeln die Konflikte
		zwischen Exemplaren des Programms X und den
<!--p.198-->		
		Exemplaren der anderen Programmtypen. Bzgl.
		der Konflikte weist die Mutante ein dem
		Programm X &auml;hnliches Verhalten auf. Daher wird
		die X.IDENT-te Spalte in die erste, Zeile von
		CHANGE CONFLICT.V und die X.IDENT-te Zeile
		in die zweite Zeile von CHANGE_CONFLICT.V
		kopiert. Siehe Abb. 9.2.2.A.</p>
<div align="center">
	<img src="img/mjk00/abb922a.gif" alt="Abb. 9.2.2.A" />
	<p>Abb. 9.2.2.A</p>
</div>
<!--p.199-->
		<p>CHANGE_CONFLICT.V(1,M),<br />
		CHANGE_CONFLICT.V(1,X.IDENT) und<br />
		CHANGE_C0NFLICT.V(2,X.IDENT) stellen die Komponenten
		dar, die in der erweiterten Vorrangmatrix
		die innerartlichen Konflikte zwischen Exemplaren
		der Mutante HELP bzw. zwischen Exemplaren der
		Mutante und des Originalprogramms X regeln
		sollen und werden zu diesem Zweck neu generiert.
		Dies geschieht mit Hilfe der Zufallsfunktion
		RANDINT. Wegen der engen Verwandschaft zwischen
		Mutante und Originalprogramm weichen die Werte
		dieser Komponenten um h&ouml;chstens 100% von der
		Komponente in der alten Vorrangmatrix ab, die
		die innerartlichen Konflikte zwischen Exemplaren
		des Programms X regelt. Bis auf diese 3 
		otwendigerweise neuen Werte weist die Mutante also
		bisher das gleiche Konfliktverhalten auf wie das
		Originalprogramm.</p></li>
		<li>In welcher der beiden modellrelevanten Eigenschaften
		sich das Programm X von seiner Mutante
		unterscheidet, wird bestimmt mittels der Gr&ouml;&szlig;e
		PROB_DELY (PROB_DELY stellt den Modellparameter
		<img src="/img/cache/27891916a1046af3e16ebad2de8fa34c.gif" alt="\p_3" valign="middle" /> auf Programmebene dar). Mit der
		Wahrscheinlichkeit PROB_DELY*<img src="/img/cache/599ba39d43ef5e5056aa8b82d12608b2.gif" alt="10^{-3}" valign="middle" /> mutiert (&uuml;ber
		Zufallsfunktion RANDINT) die DELY-Komponente des
		Programms X. Mit der Wahrscheinlichkeit
		1-PROB_DELY*<img src="/img/cache/599ba39d43ef5e5056aa8b82d12608b2.gif" alt="10^{-3}" valign="middle" /> erh&auml;lt die Mutante ein in Bezug
		auf einen der anderen in MOD3 vorhandenen Programmtypen
		(also nicht X) ver&auml;ndertes Konfliktverhalten
		als das Originalprogramm X.
		<ul>
			<li>Unterscheiden sich die Mutante und das
			Originalprogramm in ihren DELY-Komponenten, so
			liegt der Unterschied bei h&ouml;chstens 100%:
<pre class="source">
  HELP.DELY:=RANDINT(1,2*X.DELY,U_DELY2)
  <strong>while</strong> HELP.DELY=X.DELY <strong>do</strong>
  HELP.DELY:=RANDINT(1,2*X.DELY,U_DELY2)
</pre></li>
			<li>Erh&auml;lt die Mutante ein anderes Konfliktverhalten
			als das Originalprogramm X, so wird
<!--p.200-->
			genau eine Komponente des Feldes
			CHANGE_CONFLICT um h&ouml;chstens 100% ge&auml;ndert.
			Es mu&szlig; sich dabei um eine Komponente handeln,
			die aus der alten Vorrangmatrix &uuml;bernommen
			worden ist. Die Komponente darf also
			nicht die Indizes [1,M], [2,M], [1,X.IDENT]
			und [2,X.IDENT] aufweisen und wird mittels
			der Zufallsfunktion RANDINT ausgew&auml;hlt:
<pre class="source"><strong>integer</strong> I,J,K,U_CONFLICT;
   .
   .
   .
J:=X.IDENT;
<strong>while</strong> J=X.IDENT <strong>do</strong>
<strong>begin</strong>
J:=RANDINT(1,2*(M-1),U_CONFLICT);
<strong>if</strong> J&le;M-1
<strong>then</strong> I:=1
<strong>else</strong>
<strong>begin</strong>
I:=2;
J:=J-(M-1)
<strong>end</strong>
<strong>end</strong>;
K:=RANDINT(1,2*CHANGE_CONFLICT.V[I,J],U_CONFLICT);
<strong>while</strong> K=CHANGE_CONFLICT.V[I,J] <strong>do</strong>
K:=RANDINT(1,2*CHANGE_CONFLICT.V[I,J],U_CONFLICT);
CHANGE_CONFLICT.V[I,J]:=K;
</pre>
			</li>
		</ul></li>
		<li>Nach Abschlu&szlig; von III. liegen die fertige Mutante
		sowie die &Auml;nderungszeile und -spalte der Vorrangmatrix
		in Form von HELP bzw. CHANGE_CONFLICT vor.
		Da MUTANT eine Funktionsprozedur ist, wird MUTANT
		mit der Anweisung MUTANT:=HELP beendet.
    <!-- /li -->
<!--p.201-->
	<!-- /ol -->
	<p><strong>Beispiel:</strong></p>
<div align="center">
	<img src="img/mjk00/p202_1.gif" alt="" />
</div>
		Eine Mutation tritt auf:
<div align="center">
	<img src="img/mjk00/p202_2.gif" alt="" />
</div>
<!--p.202-->
<div align="center">
	<img src="img/mjk00/p203_1.gif" alt="" />
</div>													
		In der Prozedur MUTANT wird die Komponente PROGMAME
		der generierten Mutante durch Aufruf der Funktionsprozedur
<pre class="source"><strong>text procedure</strong> CREATE_NAME(X); <strong>ref</strong> (PROGRAM) X;</pre>
		gesetzt.</li>
	</ol>
<!--p.203-->
	<p><em>Funktionsweise von CREATE_NAME:</em></p>
	<p>CREATE_MAME besitzt als formalen Eingabeparameter
	X einen Zeiger auf ein Objekt vom Typ PROGRAM und
	liefert als Ergebnis einen Text. Dieser Text stellt
	den Namen einer Mutante des Programms X dar und
	wird aus den Komponenten X.MUT und X.PROGNAME
	erzeugt, indem an den Text X.PROGNAME das Zeichen
	"." gefolgt von der Zahl X.MUT (als Text interpretiert)
	geh&auml;ngt wird.</p>
	<p><em>Beispiel</em></p>
	<ol type="a">
		<li><br /><img src="/img/cache/262a0b8a1037068a5bfd9708048eb4e2.gif" alt="
\begin{array}{cccccc}
X \longr&amp; \fbox{\ \ \ 1\ \ \ }&amp;\fbox{\ \ \ 11\ \ \ }	&amp;\fbox{\ \ \ 3\ \ \ }	&amp;\fbox{\ \ \ \ \ \ P1\ \ \ \ \ \ }\\
	&amp; \uparrow	&amp; \uparrow	&amp; \uparrow	&amp; \uparrow\\
	&amp; \text{IDENT}	&amp; \text{DELY}	&amp; \text{MUT}	&amp; \text{PROGNAME}\\
\end{array}\\
\text{CREATE\underline{  }NAME = P1.3}\\
		" valign="middle" /></li>
		<li><br /><img src="/img/cache/cf7d6a34bccef1d2a14dca1fad3b62c0.gif" alt="
\begin{array}{cccccc}
X \longr&amp; \fbox{\ \ \ 5\ \ \ }&amp;\fbox{\ \ \ 3\ \ \ }	&amp;\fbox{\ \ \ 1\ \ \ }	&amp;\fbox{\ \ \ \ \ \ P1.3\ \ \ \ \ \ }\\
\end{array}\\
\text{CREATE\underline{  }NAME = P1.3.1}
		" valign="middle" /></li>
	</ol>
	<p>Da beim Auftreten einer Mutation eines Programms
	dessen Komponente MUT um 1 erh&ouml;ht wird, liefert
	dieser Mechanismus f&uuml;r aufeinanderfolgende Mutationen
	desselben Programms verschiedene Namen. Da
	der aktuelle Parameter f&uuml;r X selbst eine Mutante
	sein kann (s. Beispiel b)), l&auml;&szlig;t sich der
	Komponente PROGNAME eines Programms stets dessen
	"stammesgeschichtliche Entwicklung" zur&uuml;ckverfolgen
	(siehe Abb. 9.2.2.B). Dies w&auml;re an Hand der
	<strong>intege</strong>r-Komponenten IDENT, die in MOD2 zur
	Identifizierung der Programme ausreichte, nicht
	m&ouml;glich.</p>
<!--p.204-->
<img src="/img/cache/464c57bc61c9b40c20435300e74f288b.gif" alt="
\begin{array}{c}
	&amp;		&amp;	&amp;		&amp; P1.1.1	&amp; \vdots\\
	&amp;		&amp;	&amp; \swarrow 	&amp; P1.1.2	&amp; \vdots\\
	&amp;		&amp;	&amp; \swarrow 	&amp; \vdots	&amp; \vdots\\
	&amp;		&amp; P1.1	&amp;		&amp; \vdots	&amp; \vdots\\
	&amp; \swarrow	&amp;	&amp;		&amp; \vdots	&amp; \vdots\\
P1 	&amp;		&amp;	&amp;		&amp; \vdots	&amp; \vdots\\
	&amp; \nwarrow	&amp;	&amp;		&amp; \vdots	&amp; \vdots\\
	&amp;		&amp; P1.2	&amp;		&amp; \vdots	&amp; \vdots\\
	&amp;		&amp; \vdots&amp; \nwarrow	&amp; \vdots	&amp; \vdots\\
	&amp;		&amp; \vdots&amp; \nwarrow	&amp; P1.2.2	&amp; \vdots\\
	&amp;		&amp; \vdots&amp;		&amp; P1.2.1	&amp; \vdots\\
	&amp;		&amp; P2.1	&amp;		&amp; \vdots	&amp; \vdots\\
	&amp; \swarrow	&amp;	&amp;		&amp; \vdots	&amp; \vdots\\
P2 	&amp; \longl	&amp; P2.2	&amp;		&amp; \vdots	&amp; \vdots\\
\vdots	&amp; \nwarrow	&amp;	&amp;		&amp; \vdots	&amp; \vdots\\
\vdots	&amp;		&amp; P2.3	&amp;		&amp; \vdots	&amp; \vdots\\
\vdots	&amp;		&amp; \vdots&amp;		&amp; \vdots	&amp; \vdots\\
\vdots	&amp;		&amp; \vdots&amp; 		&amp; \vdots	&amp; \vdots\\
\vdots	&amp;		&amp; \vdots&amp;		&amp; \vdots	&amp; \vdots\\	
\text{Name der } &amp;	&amp;\text{Namen der} &amp;	&amp; \text{Namen der}\\
\text{Original-} &amp;	&amp;\text{Mutanten } &amp;	&amp; \text{Mutanten} &amp; \dots\\
\text{programme} &amp;	&amp;\text{erster Stufe} &amp;	&amp; \text{zweiter Stufe\\
\end{array}
" valign="middle" />
<p>Abb. 9.2.2.B</p>
	<p>Wie schon wiederholt erw&auml;hnt, stellt das Auftreten
	einer Mutation i.a. eine Vergr&ouml;&szlig;erung der Anzahl
	der aktuellen Parametertypen dar. Das macht sich
	schon in der (zun&auml;chst vorl&auml;ufigen) Erh&ouml;hung der
	Variablen M bemerkbar. Kann sich die Mutante etablieren
	(s.u. Beschreibung der Prozedur MATCH), so
	m&uuml;ssen die dynamischen <strong>arrays</strong> erweitert werden, die
	die Mutante speichern, registrieren bzw. verwalten.
	Diese Erweiterungen werden durch Aufrufe der Prozeduren</p>
<pre class="source"><strong>procedure</strong> NEW_PROG(P); <strong>ref</strong> (PROGRAM) P;
<strong>procedure</strong> NEW_ST(T); <strong>ref</strong> (PROGRAM) T;   und
<strong>procedure</strong> NEW_CONFLICT(A); <strong>integer array</strong> A;
</pre>
	<p>gew&auml;hrleistet.</p>
	<p><em>Funktionsweise von NEW_PROG:</em></p>
	<p>Der Zeiger PROGPOINTER verweist auf dasjenige Feld,
<!--p.205-->
	mit dessen Hilfe die eigentliche Abspeicherung der
	Programme (Typen) erfolgt. Beim Auftreten einer
	Mutation - die Mutante wird in Form des Zeigers
	P als Parameter an NEW_PROG &uuml;bergeben - mu&szlig;
	dieses Feld um eine Komponente erweitert werden.
	Realisiert wird dieses durch Generierung eines
	neuen Feldes (Objekt vom Typ PROG), einen einfachen
	Kopierproze&szlig; und anschlie&szlig;endes Umsetzen des
	Zeigers PROGPOINTER. Siehe Abb. 9.2.2.C.</p>
<div align="center">
	<img src="img/mjk00/abb922c.gif" alt="Abb. 9.2.2.C" />
	<p>Abb. 9.2.2.C</p>
</div>
<!--p.206-->
	<p><em>Funktionsweise von NEW_ST:</em></p>
	<p>Das Feld, auf das der Zeiger STPOINTER verweist,
	enth&auml;lt zu jedem Zeitpunkt der Simulation in der
	i-ten Komponente die momentane Anzahl der Exemplare
	des i-ten Programmtyps. Das Feld wird beim
	Auftreten einer Mutation um eine Komponente zur
	Registrierung der Exemplare der Mutante erweitert.
	Die zus&auml;tzliche Komponente wird mit 1 initialisiert.
	Ansonsten analog zu NEW_PROG. Siehe Abb. 9.2.2.D.</p>
<div align="center">
	<img src="img/mjk00/abb922d.gif" alt="" />
	<p>Abb. 9.2.2.D</p>
</div>
	<p><em>Funktionsweise von NEW_CONFLICT:</em></p>
	<p>Der Zeiger CONPOINTER verweist auf das Feld, das die
	Vorrangmatrix speichert. Beim Auftreten einer Mutation
	mu&szlig; dieses Feld um eine Spalte und eine Zeile
	erweitert werden. Diese Zeile und Spalte entsprechen
	dem Konfliktverhalten der Mutante. Zeile und
<!--p.207-->
	Spalte werden in Form des formalen Parameters
	<strong>integer array</strong> A an NEW_CONFLICT &uuml;bergeben. Der
	Aufruf von NEW_CONFLICT erfolgt mit dem durch
	CHANGE_CONFLICT adressierten Feld als aktueller
	Parameter. Dieses Feld wird vor Aufruf von
	NEW_CONFLICT von der Prozedur MUTANT generiert
	(s.o. Funktionsweise der Prozedur MUTANT). Im
	&uuml;brigen erfolgt der Ablauf von NEW_CONFLICT, wie
	Abb. 9.2.2.E zeigt, analog zu NEW_PROG und
	NEW_ST.</p>
	<p>Abb. 9.2.2.E greift das Beispiel aus der
	Beschreibung der Prozedur MUTANT auf.</p>
<div align="center">
	<img src="img/mjk00/abb922e.gif" alt="Abb. 9.2.2.E" />
	<p>Abb. 9.2.2.E</p>
</div>
	<p>Nach Erl&auml;uterung der der Erzeugung und Behandlung
	von Mutationen dienenden Prozeduren sind wir in der
	Lage, die Prozedur MATCH anzugeben. MATCH stellt,
	wie schon im SIMULA-Programm zu MOD2 (s. 8.3.2.),
	das Herzst&uuml;ck der Simulation dar. Das &uuml;bergeordnete
	Simulationsschema, wie es in 8.3.2.(iii) Seite
	182 angegeben ist, kann vollst&auml;ndig &uuml;bernommen
	werden.</p>
<pre class="source"><strong>procedure</strong> MATCH(I); <strong>integer</strong> I;
<strong>begin</strong>
  .
  .
  .
  <strong>boolean</strong> IS_COPY;
  IS COPY:=false;
  [ Erh&ouml;he TIMECOUNT-Komponente der I-ten Speicher- ]
  [ zelle um 1.                                     ] ;
  <strong>if</strong> [ TIMECOUNT-Komponente der I-ten Speicherzelle ]
     [ gleich DELY-Komponente des in der I-ten Spei-]
     [ cherzelle befindlichen Programms             ]
  <strong>then</strong>
  <strong>begin</strong>
    <strong>comment</strong> *** Reproduktion des in der I-ten Zelle
                befindlichen Programms *** ;
    [ Setze TIMECOUNT-Komponente der I-ten Speicher- ]
    [ zelle auf 0                                    ] ;

    [ W&auml;hle eine zuf&auml;llige Zelle des Speichers aus.    ]
    [ Sei die Wahl auf die W-te Speicherzelle gefallen.] ;
    <strong>comment</strong> *** Siehe dazu oben 8.3.2.(iv) *** ;
    [ Treffe Entscheidung, ob das in der I-ten Spei- ]
    [ cherzelle befindliche Programm mutiert.        ] ;
    <strong>comment</strong> *** Die Mutationswahrscheinlichkeit be-
                tr&auml;gt PR0B_MUT*<img src="/img/cache/6472b2f9e70aac629d7e2763a59f0066.gif" alt="10^{-8}" valign="middle" /> = <img src="/img/cache/03b632315ee5bee654b60a6bd902a249.gif" alt="p_1" valign="middle" /> (Modell-
		parameter), Die <strong>integer</strong>-Gr&ouml;&szlig;e PROB_
		MUT stellt den Modellparameter <img src="/img/cache/03b632315ee5bee654b60a6bd902a249.gif" alt="p_1" valign="middle" />
		auf Programmebene dar. *** ;
<!--p.209-->
    <strong>if</strong> [ Programm in der I-ten Speicherzelle mutiert. ]
    <strong>then</strong>
    <strong>begin</strong>
       [ Treffe Entscheidung, ob die Mutation letal verl&auml;uft. ] ;
       <strong>comment</strong> *** Die Wahrscheinlichkeit f&uuml;r den letalen Ver-
                   lauf einer Mutation betr&auml;gt PROB_LETAL*<img src="/img/cache/1ec79e91d92df04471972727d4bb9404.gif" alt="10^{-6}" valign="middle" />
		   = <img src="/img/cache/6fe97b358b528edc477ba63d50b652af.gif" alt="p_2" valign="middle" /> (Modellparameter). Die <strong>integer</strong>-Gr&ouml;&szlig;e
		   PROB_LETAL stellt den Modellparameter <img src="/img/cache/6fe97b358b528edc477ba63d50b652af.gif" alt="p_2" valign="middle" />
		   auf Programmebene dar. *** ;
       <strong>if</strong> [ Letaler Verlauf der Mutation ]
       <strong>then</strong> [ Erh&ouml;he die Komponente MUT des in der I-ten Zelle ]
            [ gespeicherten Programms um 1.                    ] ;
            comment *** Dies geschieht zur Registrierung der
                        Mutation. Im Falle einer nicht letalen
		        Mutation wird die Erh&ouml;hung der Kompo-
		        nente MUT von der Prozedur MUTANT vor-
		        genommen. ***
       <strong>else</strong>
       <strong>begin</strong>
         <strong>comment</strong> *** Existenzf&auml;hige Mutation *** ;
         M:=M+1;
         <strong>comment</strong> *** Rettung der alten Vorrangmatrix und des
                     alten Programmspeichers *** ;
         OLD_CONPOINTER:-CONPOINTER;
	 OLD_PROGPOINTER:-PROGPOINTER;
	 [ Erzeuge Mutante des in der I-ten Speicherzelle be-  ]
	 [ findlichen Programms (Aufruf MUTANT). Trage den von ]
	 [ MUTANT erzeugten neuen Prograramtyp in den Programm-]
	 [ speicher ein (Aufruf NEW_PROG). Erweitere die Vor-  ]
	 [ rangmatrix (Aufruf NEW_CONFLICT).                   ]
	 <strong>comment</strong> *** CONPOINTER und PROGPOINTER verweisen auf
	             die neue Vorrangmatrix bzw. den neuen
		     Programmspeicher *** ;
	 <strong>if</strong> [ W-te Speicherzelle leer ]
	 <strong>then</strong>
	 <strong>begin</strong>
           <strong>comment</strong> *** Ungehindertes Ablegen der erzeugten
	               Mutante im Speicher ***;
<!--p.210-->
           [ schreibe die Mutante in die W-te Speicherzelle ] ;
	   NEW_ST;
	   IS_COPY:=true
	 <strong>end</strong>
	 <strong>else</strong>
	 <strong>begin</strong>
           <strong>comment</strong> *** W-te Speicherzelle ist bereits
	               besetzt. *** ;
           [ Treffe Entscheidung mittels der neuen Vorrangmatrix, ]
	   [ ob die Mutante das in der W-ten Zelle befindliche    ]
	   [ Programm &uuml;berschreiben darf.                         ]
	   <strong>comment</strong> *** Siehe unten (v) *** ;
           <strong>if</strong> [ &Uuml;berschreiben nicht m&ouml;glich]
           <strong>then</strong>
           <strong>begin</strong>
             <strong>comment</strong> *** Vernichtung der Mutante, Wiederherstellung
	                 der alten Tabellen *** ;
             M:=M-1;
             CONPOINTER:-OLD_CONPOINTER;
             PROGPOINTER:-OLD_PROGPOINTER
           <strong>end</strong>
           <strong>else</strong>
           <strong>begin</strong>
             <strong>comment</strong> *** Die Mutante kann das in der W-ten
                         Zelle befindliche Programm &uuml;berschreiben. *** ;
	     [ Schreibe Mutante in die W-te Speicherzelle ] ;
	     NEW_ST;
	     IS_COPY:=true
	   <strong>end</strong>
	 <strong>end</strong>
       <strong>end</strong>
     <strong>end</strong>
     <strong>else</strong>
     <strong>begin</strong>
       <strong>comment</strong> *** Das Programm in der I-ten Speicherzelle
                   erzeugt eine korrekte Kopie ohne Mutation *** ;
       <strong>if</strong> [ W-te Speicherzelle leer ]
       <strong>then</strong>
<!--p.211-->
       <strong>begin</strong>
         <strong>comment</strong> *** Ungehindertes Ablegen der Kopie *** ;
	 [ Schreibe Kopie in die W-te Speicherzelle ] ;
	 IS_COPY:=true
       <strong>end</strong>
       <strong>else</strong>
       <strong>begin</strong>
         <strong>comment</strong> *** W-te Speicherzelle bereits besetzt *** ;
	 [ Treffe Entscheidung mittels der Vorrangmatrix, ob ]
	 [ die Kopie des in der I-ten Zelle befindlichen     ]
	 [ Programms das Programm in der W-ten Zelle &uuml;ber-   ]
	 [ schreiben darf.                                   ]
	 <strong>comment</strong> *** Siehe unten (v) *** ;
	 <strong>if</strong> [ &Uuml;berschreiben nicht m&ouml;glich ]
	 <strong>then</strong>
	   <strong>comment</strong> *** Es geschieht nichts *** ;
	 <strong>else</strong>
	 <strong>begin</strong>
           [ Schreibe Kopie in die W-te Speicherzelle ] ;
	   IS_COPY:=true
	 <strong>end</strong>
       <strong>end</strong>
     <strong>end</strong>;
     <strong>comment</strong> *** Falls das Programm aus Speicherzelle I
                 seine Mutante/Kopie im Speicher ablegen
		 konnte, mu&szlig; noch in Abh&auml;ngigkeit von
		 der Durchlaufrichtung die Komponente
		 TIMECOUNT der W-ten Speicherzelle
		 gesetzt werden ***;
     <img src="/img/cache/678614555c8184bb905e8808b2692c69.gif" alt="\sout[+1]\otimes" valign="middle" />          (s.S.184)
  <strong>end</strong>
<strong>end</strong> *** MATCH *** ;
</pre>
	</li>
<!--p.212-->
	<li><strong>Raumliches Verhalten:</strong><br />
	Wie im SIMULA-Programm f&uuml;r MOD2 da die M&ouml;glichkeit
	der Mutation hier keine &Auml;nderung bedingt.</li>
	<li><strong>Verhalten der Programme untereinander:</strong><br />
	Wie im SIMULA-Programm f&uuml;r MOD2. Jedes Element <img src="/img/cache/cc107045855ba78caeca5f0886ce9c2c.gif" alt="v_{ij}" valign="middle" />
	der momentanen Vorrangmatrix wird jedoch als "<img src="/img/cache/cc107045855ba78caeca5f0886ce9c2c.gif" alt="v_{ij}" valign="middle" />
	Tausendstel" interpretiert, was eine Verfeinerung
	gegen&uuml;ber dem Programm f&uuml;r MOD2 darstellt. Die
	Elemente der jeweiligen Vorrangmatrix sind somit
	Elemente der Menge [1000].</li>
</ol>

<p>Anhang C.3. zeigt die Realisierung von MOD3 als ausf&uuml;hrlich
kommentiertes SIMULA-Programm. Einen &Uuml;berblick &uuml;ber
die in diesem Programm benutzten Datenstrukturen gibt
Abb. 9.2.2.F.</p>
<p><em>Eingabeparameter des SIMULA-Programms f&uuml;r MOD3:</em></p>
<ul>
	<li>Die Anfangsl&auml;nge des Speichers N</li>
	<li>Die anf&auml;ngliche Anzahl der
	unterschiedlichen Programmtypen M</li>
	<li>Die M anf&auml;nglichen Programmtypen,
	in Form der Gr&ouml;&szlig;e DELY
	und der Anfangsh&auml;ufigkeit DELY,STPOINTER.S[...]</li>
	<li>Die MxM Elemente der anf&auml;nglichen
	Vorrangmatrix. Jedes
	Element ist aus [1000]. CONPOINTER.MAT</li>
	<li>Die Zahlen, die die
	Wahrscheinlichkeiten f&uuml;r
	Mutationen, Letalmutationen und
	Mutationsart festlegen PROB_MUT<img src="/img/cache/b33904321519ab315f31d61e7e2ed855.gif" alt="\in[10^8]" valign="middle" /> PROB_LETAL<img src="/img/cache/21ac15b7c585d46e12b610c849551788.gif" alt="\in[10^6]" valign="middle" /> PROB_DELY<img src="/img/cache/6a28ae14b6c25b999c3d29247add94e4.gif" alt="\in[10^3]" valign="middle" /></li>
	<li>Die Anzahl der vorgesehenen
	Speicherdurchl&auml;ufe TIME</li>
	<li>Die Speicherparameter MORE,PERCENT</li>
</ul>
<!--p.213-->
<div align="center">
	<img src="img/mjk00/abb922f.gif" alt="Abb. 9.2.2.F" />
	<p>Abb. 9.2.2.F</p>
</div>
<!--p.214-->
<h4><a name="c923"></a>9.2.3. Einige Aspekte des SIMULA-Programms f&uuml;r MOD3</h4>
<ol type="I">
	<li>Das SIMULA-Programm f&uuml;r MOD3 gestattet Simulation
	sowohl mit endlichem als auch mit unendlichem Speicher
	(abh&auml;ngig von PERCENT).</li>
	<li>Zur Unterst&uuml;tzung der Ausgabe wurden die Prozeduren
	DUMP, CONTROL und AVERAGE in das Programm eingef&uuml;gt.
	Daher enth&auml;lt das Programm die drei modellunabh&auml;ngigen
	Parameter
<pre>
WHEN_DUM
WHEN_CON     und
WHEN_AVE     (vgl. 8.2.4. I. und II.)
</pre></li>
	<li>Wird PROB_MUT auf 0 gesetzt, also das Auftreten von
	Mutationen unterdr&uuml;ckt, so ergibt sich die SIMULA-Version
	von MOD2.</li>
	<li>Mit Hilfe des Programms f&uuml;r MOD3 lassen sich gewisse
	Fragestellungen experimentell untersuchen. Aus III.
	folgt, da&szlig; sich alle im Zusammenhang mit dem SIMULA-Programm
	f&uuml;r MOD2 stellenden Fragen auch mit dem
	Programm f&uuml;r MOD3 bearbeiten lassen. Das Programm f&uuml;r
	MOD3 erm&ouml;glicht dar&uuml;ber hinaus, Fragen im Hinblick
	auf Evolution zu bearbeiten. Z.B.:
	<ul>
		<li>Welche Mutationsh&auml;ufigkeit ist im vorhandenen
		Modell optimal?</li>
		<li>Welche Mutationsrate darf keinesfalls &uuml;berschritten
		werden, um die auftretenden Mutanten nicht
		instabil werden zu lassen?</li>
		<li>Durch entsprechendes Setzen von PROB_DELY sind
		differenzierte Betrachtungen im Hinblick auf die
		Selektionswirksamkeit der Reproduktionszeit
		(DELY-Komponente) und der Stellung in der
		Vorrangmatrix m&ouml;glich.</li>
		<li>Wie k&ouml;nnen sich Mutanten einerseits gegen&uuml;ber
		Exemplaren ihres eigenen Ursprungstyps und
		andererseits gegen&uuml;ber Exemplaren anderer Programmtypen
<!--p.215-->
		durchsetzen? (Die Beantwortung wird unterst&uuml;tzt
		durch die Programmnamen der Mutanten, die
		die "stammesgeschichtliche" Entwicklung der
		Mutanten enthalten (vgl. CREATE_NAME).</li>
		<li>Obige Fragen mit unterschiedlicher "Populationsdichte"
		(Steuerung &uuml;ber MORE und PERCENT)</li>
		<li>viele weitere Fragen.</li>
	</ul>
	Das SIMULA-Programm f&uuml;r MOD3 bietet also ebenfalls ein
	weites Experimentierfeld. Leider kann die eine oder
	andere der obigen Fragestellungen im Rahmen dieser
	Arbeit nicht mehr n&auml;her untersucht werden.</li>
	<li><strong>Aufwand:</strong><br />
	Ohne in Einzelheiten zu gehen ist klar, da&szlig; sowohl f&uuml;r
	den Speicherplatzaufwand, als auch f&uuml;r die Laufzeit
	die f&uuml;r das Programm f&uuml;r MOD2 gemachten Aussagen
	g&uuml;ltig sind. Der Aufwand w&auml;chst also i.a. exponentiell
	mit der Anzahl der Speicherdurchl&auml;ufe. Gehemmt wird
	dieses Wachstum durch einen Faktor, der um so einflu&szlig;reicher
	ist, je h&ouml;her die zul&auml;ssige Belegungsdichte
	des simulierten Speichers ist (vgl. 8.3.3.IV.). Ein
	gewisser Mehraufwand wird durch die komplizierten
	Datenstrukturen und die mutationsgenerierenden-
	und verwaltenden Prozeduren bewirkt (siehe Abb. 9.2.3.A).
	<table border="1" summary="Abb. 9.2.3.A">
	<tr><th>Prozedur</th><th>Aufwand f&uuml;r gro&szlig;es M</th></tr>
	<tr><td>MUTANT</td><td>O(M)</td></tr>
	<tr><td>CREATE_NAME</td><td>konstant</td></tr>
	<tr><td>NEW_PROG</td><td>O(M)</td></tr>
	<tr><td>NEW_ST</td><td>O(M)</td></tr>
	<tr><td>NEW_CONFLICT</td><td>O(<img src="/img/cache/c9a13a1909260a233dab3c6420bdc77b.gif" alt="M^2" valign="middle" />)</td></tr>
	<tr><td colspan="2">(M = Aktuelle Anzahl der vorhandenen Programmtypen)</td></tr>
	</table>
	<p>Abb. 9.2.3.A</p>
<!--p.216-->
	<p>Dieser Mehraufwand f&auml;llt jedoch kaum ins Gewicht,
	zumal es realistisch ist, von kleinen Mutationsraten
	auszugehen, so da&szlig; M ebenfalls klein bleibt.</p></li>
	<li>Es gilt auch f&uuml;r das SIMULA-Programm f&uuml;r MOD3 bzgl.
	des Speichererweiterungsmechanismus die Bemerkung
	8.3.3.IV..</li>
	<li>Im SIMULA-Programm f&uuml;r MOD3 unterscheiden sich
	Mutanten von ihren Originalprogrammen in genau einer
	modellrelevanten Gr&ouml;&szlig;e um maximal 100% (vgl. Beschreibung
	der Prozedur MUTANT). Dieser Spielraum von 100%
	ist willk&uuml;rlich gew&auml;hlt und lie&szlig;e sich sicher auch in
	Form eines variablen Parameters festlegen. Die kleinstm&ouml;gliche
	Mutationsrate betr&auml;gt in der SIMULA-Version
	von MOD3 <img src="/img/cache/6472b2f9e70aac629d7e2763a59f0066.gif" alt="10^{-8}" valign="middle" />. Dieser Wert orientiert sich an der
	Biologie und ist im Zusammenhang mit Evolution bei
	Rechnerprogrammen zumindest fraglich. Es bietet sich daher
	an, auch diesen Wert durch einen variablen Eingabeparameter
	zu ersetzen.
	<p>Analog: kleinstm&ouml;gliche Rate f&uuml;r Letalmutationen.</p></li>
</ol>
<!--p.217-->
<h2><a name="cl"></a>Literaturverzeichnis</h2>
<ol>
	<li>Beilner, H. : Betriebssysteme Vorlesungsskript, UNI DO, WS 1976/77</li>
	<li>Bertalanffy L. von : General System Theory George Braziller, New York, 1968</li>
	<li>Brainerd/Landweber : Theory of Computation John Wiley &amp; Sons, 1974</li>
	<li>Claus, V. : Rekursive Funktionen Vorlesungsbegleitmaterial, UNI DO, WS 1974/75</li>
	<li>Ehrich, H.D. : Berechenbarkeit, Vorlesungsskript, UNI DO, WS 1977/78</li>
	<li>Geschwind, H.W. : Design of Digital Computers - an Introduction, Springer-Verlag New York - Wien, 1967</li>
	<li>Hoffmann, G. : Programmiersprachen und ihre &Uuml;bersetzer, Vorlesungsbegleitmaterial, UNI DO, SS 1977</li>
	<li>Holland, J., An Arbor, Michigan, USA : Studies of the spontaneous emergence of self-replicating systems using cellular automata and formal grammars, Aus: Lindemayer/Rosenberg, Hrsg. : Automata, Languages, Development, North-Holland Publishing Company - 1976</li>
<!--p.218-->
	<li>Hopcroft, Ullman : Formal Languages and their Relation to Autoaata, Addison-Wesley, 1969</li>
	<li>Jensen, K. und Wirth, N. : pascal User Manual And Report, second edition, Springer-Verlag New York - Heidelberg - Berlin, 1973</li>
	<li>K&auml;stner, H. : Architektur und Organisation digitaler Rechenanlagen, Teubner Stuttgart 1978</li>
	<li>K&auml;stner, H. : Rechnerfeinstrukturen Vorlesungsskript, UNI PO, SS 1976</li>
	<li>Kaplan, R.W. : Der Ursprung des Lebens 2. Auflage, Georg Thieme Verlag Stuttgart 1978</li>
	<li>Lee, J.A.N. : Computer Semantics Van Nostrand Reinhold Company, 1972</li>
	<li>Linder, H. : Biologie J.B. Metzlersche Verlagsbuchhandlung Stuttgart</li>
	<li>Manna, Z. : Mathematical Theory of Computation McGraw-Hill 1974</li>
	<li>Reusch, B. : Grundlagen der theoretischen Informatik, Vorlesungsbegleitmaterial, UNI DO, SS 1977</li>
	<li>Rogers, H.Jr. : Theory of Recursive Functions and Effective Computability, McGraw-Hill Book Company, 1967</li>
<!--p.219-->
	<li>Rohlfing, H. : SIMULA - Sine Einf&uuml;hrung B.I. Hochschultaschenb&uuml;cher, Band 747</li>
	<li>Schnorr, C.P. : Rekursive Funktionen und ihre Komplexit&auml;t, Teubner Studienb&uuml;cher, Band 24</li>
	<li>Schnupp, P. : Rechnernetze Entwurf und Realisierung, De Gruyter - Berlin - New York, 1978</li>
	<li>Siemens-System 7-000 Beschreibung und Befehlsliste, Stand Januar 1976, Siemens Aktiengesellschaft</li>
	<li>Siemens-System 7.000 Siemens-System 4004 Betriebssystem BS 1000 F-Assembler Betriebssystem BS 2000 Assembler Beschreibung, Stand Dezember 1977, Siemens Aktiengesellschaft</li>
	<li>Siewing, H. Hrsg. : Evolution Gustav Fischer Verlag, Stuttgart - New York 1978</li>
	<li>SIMULA Programmer's Guide
		Siemens-System BS 2000, Version 0.0 September 78</li>
	<li>Stone, H.S. Hrsg. : Introduction to Computer Architecture, SCIENCE RESEARCH ASSOCIATES INC., 1975</li>
	<li>Vogel/Angermann : DTV-Atlas zur Biologie, Band 2 Deutscher Taschenbuch Verlag, 1968</li>
<!--p.220-->
	<li>Wirth, N. : Algorithmen und Datenstrukturen Teubner Taschenb&uuml;cher</li>
</ol>
<!--p.221-->
<hr />
<h2>Fu&szlig;noten</h2>
<p><a name="p001_1" href="#b001_1">1)</a> <small>(p.1)  </small> Auf die Schwierigkeiten, die sich bei der Definition von Leben ergeben, gehen wir ausf&uuml;hrlich in Kapitel 7 ein.</p>
<p><a name="p014_1" href="#b014_1">1)</a> <small>(p.14) </small> Notation: <img src="/img/cache/a535ea87b1d298be6e032b7877048455.gif" alt="[r] := \{1,\dots,r\}" valign="middle" /> f&uuml;r jedes <img src="/img/cache/563e454b34ec5af19eb9780800391e1a.gif" alt="r \in \mathbb{N}" valign="middle" /> nicht zu verwechseln mit Literaturverweisen.</p>
<p><a name="p019_1" href="#b019_1">1)</a> <small>(p.19) </small> Das Symbol l bezeichnet bei beliebigem Alphabet B die L&auml;ngenfunktion f&uuml;r Elemente aus <img src="/img/cache/5a4ca52d2f97862828a67f2bd32fa20b.gif" alt="B^*" valign="middle" />.</p>
<p><a name="p019_2" href="#b019_2">2)</a> <small>(p.19) </small> "%" wird als Endemarkierung f&uuml;r Beweise benutzt.</p>
<p><a name="p021_1" href="#b021_1">1)</a> <small>(p.21) </small> <img src="/img/cache/c9c55ccace42487f361931d32e609223.gif" alt="\Pi_i^n" valign="middle" /> bezeichnet in dem f&uuml;r n-Tupel &uuml;blichen Sinne die Projektion auf die i-te Komponente.</p>
<p><a name="p023_1" href="#b023_1">1)</a> <small>(p.23) </small> Zur Lambda-Notation siehe [20] Seite 13.</p>
<p><a name="p034_1" href="#b034_1">1)</a> <small>(p.34) </small> SIMULA-Beschreibung in [19].</p>
<p><a name="p045_1" href="#b045_1">1)</a> <small>(p.45) </small> Standard-Funktion siehe [19].</p>
<p><a name="p054_1" href="#b054_1">1)</a> <small>(p.54) </small> PASCAL-Beschreibung in [10].</p>
<p><a name="p098_1" href="#b098_1">1)</a> <small>(p.98) </small> <img src="/img/cache/211a775e4b0aae81f8d10df257a599b4.gif" alt="\quot\circ\quot" valign="middle" /> bezeichnet die Konkatenation von Worten; hier aus <img src="/img/cache/4c9d23d94380b5c3f9149b4fedc80c99.gif" alt="A^*_S" valign="middle" />.</p>
<p><a name="p104_1" href="#b104_1">1)</a> <small>(p.104)</small> Menge aller W&ouml;rter, die aus endlich vielen A zusammengesetzt sind.</p>
<p><a name="p107_1" href="#b107_1">1</a>  <small>(p.107)</small> Notation: <img src="/img/cache/b70979a357cfbe7c61e4c686ea2beb93.gif" alt="\perp" valign="middle" /> bedeutet undefiniert.</p>
<p><a name="p118_1" href="#b118_1">1)</a> <small>(p.118)</small> vgl. Fu&szlig;note auf Seite 19</p>
<p><a name="p132_1" href="#b132_1">1)</a> <small>(p.132)</small> entstehen durch <strong>konkrete</strong> Wahl von A und traten daher in <em>[...] /one string is out of xerox copied page - herm1t/</em></p>
<p><a name="p158_1" href="#b158_1">1)</a> <small>(p.158)</small> Semantisch hier im Sinne von;  keine Laufzeitfehler.</p>
<p><a name="p168_1" href="#b168_1">1)</a> <small>(p.168)</small> Siehe Beschreibung von RANDINT [25] Seite 4.-9</p>
[<a style="" href="/lib/?lang=DE&amp;index=SR#mjk00">zurück zum Index</a>] [<a href="/lib/mjk00.html#disqus_thread">Kommentare</a>]<br />    <div id="disqus_thread"></div>
    <script type="text/rocketscript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'vxheaven'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="/agreement.php">Terms of Use</a>!</small> <small>vxheaven.org aka vx.netlux.org</small></div>
<div style="margin-top: 2px; float: left;" class="adsapeu">
<script type="text/rocketscript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script>



</div>
<script data-rocketsrc="http://www.google-analytics.com/urchin.js" type="text/rocketscript"></script><script type="text/rocketscript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="/lib/index.php?lang=de&amp;id=mjk00">de</a><a href="/lib/index.php?lang=en&amp;id=mjk00">en</a><a href="/lib/index.php?lang=es&amp;id=mjk00">es</a><a href="/lib/index.php?lang=it&amp;id=mjk00">it</a><a href="/lib/index.php?lang=fr&amp;id=mjk00">fr</a><a href="/lib/index.php?lang=pl&amp;id=mjk00">pl</a><a href="/lib/index.php?lang=ru&amp;id=mjk00">ru</a><a href="/lib/index.php?lang=ua&amp;id=mjk00">ua</a></div>
</body>
</html>
