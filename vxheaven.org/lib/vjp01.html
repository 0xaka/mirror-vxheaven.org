<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title> JPanic 'Linux x64 Infection for Lamers (by a Lamer)' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Author" content="JPanic"/>
<meta name="KeyWords" lang="en" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, JPanic,Linux x64 Infection for Lamers (by a Lamer), resq, calls, define, table, read, stat, resw, syscall, section, index, memory, file, reading, find, write"/>
<meta name="Description" content="This article was written to help people new to x64 Linux beginning writing viruses quickly and easily. While writing &quot;Linux64.Retaliation&quot; I have decided to share what I have learnt as a Linux novice while working on my second Linux infecter. Please do not expect to find cutting edge information in this document. I would like to express my gratitude to Herm1t for his help and time, and pointing me in the right direction while I learnt these things. I am sure many of these basic things could also be applied to x86 (32-bit) Linux as well.As as side note, I can not find any source code or articles on any exist Linux x64 viruses/worms - so I can discuss none in this article. If you know of any, please let me know."/>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"047a5bcbf67431883fc9ed25fba33612",petok:"82a33bb8451632c33870d89d5e579c0416752d0f-1498756698-1800",zone:"vxheaven.org",rocket:"a",apps:{}}];document.write('<script type="text/javascript" src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=85b614c0f6/cloudflare.min.js"><'+'\/script>');}}catch(e){};
//]]>
</script>
<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="/style.css"/><link rel="canonical" href="http://vxheaven.org/lib/vjp01.html"/>
<script type="text/rocketscript" data-rocketsrc="https://apis.google.com/js/plusone.js">{"parsetags": "explicit"}</script>
</head>
<body bgcolor="#dbc8a0" text="#302000" link="#225599" vlink="#113366">
<div class="s1">
<div style="float:right;"><a href="/lib/index.php?tbs=1"><img src="/img/max.gif" alt="Maximize"/></a></div> <form id="lf" style="margin: 0; float: right;" method="get" action="/index.php"><input type="hidden" name="action" value="set"/><select name="lang" onchange="javascript:document.getElementById('lf').submit();"><option value="ru">Русский</option><option selected="selected" value="en">English</option><option value="ua">Українська</option><option value="de">Deutsch</option><option value="es">Español</option><option value="fr">Fran&ccedil;ais</option><option value="it">Italiano</option><option value="pl">Polski</option></select></form>
<div style="float: right;"><div id="plusone"></div></div>
<script type="text/rocketscript">gapi.plusone.render("plusone", {"size":"small","count":"true"});</script>
<div style="float: right;" class="addthis_toolbox addthis_default_style">
<script type="text/rocketscript">var addthis_config = { ui_click: true }</script>
<a style="text-decoration: none; font-size: 10pt;" href="/?action=addthis" class="addthis_button_compact">Bookmark</a>
<script type="text/rocketscript" data-rocketsrc="http://s7.addthis.com/js/250/addthis_widget.js#username=herm1t"></script>
</div>
<div style="float: right;">
<script type="text/rocketscript" data-rocketsrc="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<form action="/search.php" id="cse-search-box">
<input type="hidden" name="cx" value="002577580816726040001:z9_irkorydo"/>
<input type="hidden" name="cof" value="FORID:10"/>
<input type="hidden" name="ie" value="UTF-8"/>
<input type="text" name="q" size="12" value=" "/>
<input type="submit" name="sa" value="Search"/>
</form>
</div><h1><a href="/" style="text-decoration: none; color: #000000;">VX Heaven</a></h1>
<span class="nav"><a href="/lib/">Library</a> <a href="/vl.php">Collection</a> <a href="/src.php">Sources</a> <a href="/vx.php?id=eidx">Engines</a> <a href="/vx.php?id=tidx">Constructors</a> <a href="/vx.php?id=sidx">Simulators</a> <a href="/vx.php?id=uidx">Utilities</a> <a href="/links.php">Links</a> <a href="/donate.php" style="color: #706020" id="donate">Donate</a> <a href="/forum" style="text-decoration: underline;">Forum</a> </span><br clear="all"/>
</div>
<div class="s2"><h1>Linux x64 Infection for Lamers (by a Lamer)</h1><p><a href="/lib/?lang=en&amp;author=JPanic"> JPanic</a><br/> <em><a href="/vx.php?fid=2016#f2016">Valhalla #4</a></em><br/> <em>November 2013</em></p><script type="text/rocketscript">var disqus_url = 'http://vxheaven.org/lib/vjp01.html';</script>[<a style="" href="/lib/?lang=EN&amp;index=UN#vjp01">Back to index</a>] [<a href="/lib/vjp01.html#disqus_thread">Comments</a>]<br/> 
<ul>
<li><a href="#c1">Introduction</a></li>
<li><a href="#c2">Beginning: What goes x86 must come x64</a></li>
<li><a href="#c3">Beginning: Linux x64 System Calls</a></li>
<li><a href="#c4">Beginning: glibc Calls</a></li>
<li><a href="#c5">A Note: Signals</a></li>
<li><a href="#c6">Beginning: Elf64 File Format</a></li>
<li><a href="#c7">Recommendations: Working with Elf64 Files</a></li>
<li><a href="#c8">Made Simple: Elf64 Executable infection</a></li>
<li><a href="#c9">Made Simple: Elf64 Relocatable infection</a></li>
<li><a href="#ca">prelink (-u): The challenge</a></li>
<li><a href="#cb">prelink (-u): What You Need To Know</a></li>
<li><a href="#cc">Made Simple: .got.plt hooks for per-process residency</a></li>
<li><a href="#cd">Conclusions</a></li>
<li><a href="#ce">Links</a></li>
</ul>
<h2><a name="c1"></a>Introduction</h2>
<p>This article was written to help people new to x64 Linux beginning writing viruses quickly and easily. While writing "Linux64.Retaliation" I have decided to share what I have learnt as a Linux novice while working on my second Linux infecter. Please do not expect to find cutting edge information in this document. I would like to express my gratitude to Herm1t for his help and time, and pointing me in the right direction while I learnt these things. I am sure many of these basic things could also be applied to x86 (32-bit) Linux as well.</p>
<p>As as side note, I can not find any source code or articles on any exist Linux x64 viruses/worms - so I can discuss none in this article. If you know of any, please let me know.</p>
<h2><a name="c2"></a>Beginning: What goes x86 must come x64</h2>
<p>For those of you who have a background in x86 Linux viruses, this section just lets you know you have an easy path ahead of you. Writing an x64 Linux virus is no different from writing an x86 one.</p>
<p>You will find Linux infrastructure is still very much the same - same system calls - just with different numbers and calling convention, same ELF format - just with different field size, same programming technique - just with different architecture and registers. The layout of the file system is the same, the command line tools are the same etc.</p>
<p>Small differences (mentioned above) include difference in system calls. Some system calls have been removed, mainly deprecated and obsolete ones. This is really a good thing, since it makes our lives easier when choosing the correct system call to use. System call numbers and calling convention have changed too, but the behaviour of each call is very much the same.</p>
<p>The ELF64 format is very (very) similar to the ELF32 format, just with some different sized fields. You will find just about any infection method that is used on an ELF32 file will work with an ELF64 equivalent. Such things as .plt per-process residency will work too.</p>
<p>x64 instruction set is not that different from x86: just some extra registers and instructions, some very small differences but the same basic instructions and registers are there.</p>
<p>As a final note, let us consider Linux x86 (32-bit) virus 'Linux.Siilov'. This is a direct action and per-process resident ('execve' hook in .plt) ELF32 infector. The virus is written about 90%+ in C with a small amount of inline assembler for system call macros and .plt hooks. If we were to change the inline assembler code, and use ELF64 structures in ELF32 structures - there is no reason the virus could not be an x64 infector. Of course - we could use some conditional defines in the C source code, and be able to compile both an x86 and x64 version. This is something for us to think about.</p>
<h2><a name="c3"></a>Beginning: Linux x64 System Calls</h2>
<p>This section will focus on Linux system calls. Calls to the kernel in Linux are made using a 'SYSCALL' instruction. Think of this as very much like INT 80h in x86 Linux/BSD/OSX or interrupt calls in MS-DOS and Win16. The SYSCALL calling is as follows: the syscall number is loaded into RAX, arguments are loaded into their respective registers (see below) and the SYSCALL instruction is issued. Arguments are passed into registers: RDI, RSI, RDX, R10, R8, R9 in that order respectively. On return the return value is placed in RAX and registers RCX and R11 are clobbered. If the return value is between -4095 and -1 then an error has occurred - the error code can be retrieved by negating this value. I find the following procedure useful:</p>
<div class="asm" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: black; font-style: italic;">; Returns CF on Error.</span><br/>
_syscall_al<span style="color: #339933;">:</span>&nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">xor</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">ah</span><span style="color: #339933;">,</span><span style="color: #46aa03; font-weight: bold;">ah</span><br/>
_sycall<span style="color: #339933;">:</span>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Save Regs clobbered by kernel.</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">push</span>&nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rcx</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">push</span>&nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">r11</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Make the Call.</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">movzx</span> &nbsp; <span style="color: #46aa03; font-weight: bold;">rax</span><span style="color: #339933;">,</span><span style="color: #46aa03; font-weight: bold;">ax</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">syscall</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Return CF on Error.</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">cmp</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rax</span><span style="color: #339933;">,-</span><span style="color: #ff0000;">4095</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">cmc</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Restore Regs.</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">pop</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">r11</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">pop</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rcx</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retn<br/>
&nbsp;</div>
<p>This procedure will make a SYSCALL with the syscall number in AL or AX, saving the clobbered registers and returning the classic CF on error. While this may seem a lot of code, it really reduces code size since only AL or AX need to be loaded and you do not need to do the 'cmp rax,-4095' after each SYSCALL which would be longer than a 'CALL' instruction.</p>
<p>You can obtain the number of any supported syscall here:</p>
<pre class="source">'/usr/include/x86-64-linux-gnu/asm/unistd_64.h'</pre>
<p>Other useful information can be found in the directory of the above path and:</p>
<pre class="source">'/usr/include/asm-generic'</pre>
<p>You can find information on the system calls you need to make from the 'man' pages, e.g. # man 2 pread</p>
<p>Be warned that these man pages are technically for the 'glibc' versions of these calls (see the next section) but they still contain enough information to answer your questions.</p>
<p>Most useful syscall's to us include:</p>
<table summary="Linux x86_64 usefull syscall numbers">
<tr><td>0</td><td>sys_read</td></tr>
<tr><td>1</td><td>sys_write</td></tr>
<tr><td>2</td><td>sys_open</td></tr>
<tr><td>3</td><td>sys_close</td></tr>
<tr><td>4</td><td>sys_stat (sys_newstat)</td></tr>
<tr><td>5</td><td>sys_fstat (sys_newfstat)</td></tr>
<tr><td>6</td><td>sys_lstat (sys_newlstat)</td></tr>
<tr><td>8</td><td>sys_lseek</td></tr>
<tr><td>9</td><td>sys_mmap</td></tr>
<tr><td>10</td><td>sys_mprotect</td></tr>
<tr><td>11</td><td>sys_munmap</td></tr>
<tr><td>13</td><td>sys_rt_sigaction</td></tr>
<tr><td>14</td><td>sys_rt_sigprocmask</td></tr>
<tr><td>15</td><td>stub_rt_sigreturn</td></tr>
<tr><td>17</td><td>sys_pread64</td></tr>
<tr><td>18</td><td>sys_pwrite64</td></tr>
<tr><td>76</td><td>sys_truncate</td></tr>
<tr><td>77</td><td>sys_ftruncate</td></tr>
<tr><td>78</td><td>sys_getdents</td></tr>
<tr><td>79</td><td>sys_getcwd</td></tr>
<tr><td>80</td><td>sys_chdir</td></tr>
<tr><td>81</td><td>sys_fchdir</td></tr>
<tr><td>82</td><td>sys_rename</td></tr>
<tr><td>85</td><td>sys_creat</td></tr>
<tr><td>90</td><td>sys_chmod</td></tr>
<tr><td>91</td><td>sys_fchmod</td></tr>
<tr><td>92</td><td>sys_chown</td></tr>
<tr><td>93</td><td>sys_fchown</td></tr>
<tr><td>102</td><td>sys_getuid</td></tr>
<tr><td>235</td><td>sys_utime</td></tr>
</table>
<p>When looking for man pages on these calls, remove the 'sys_' or 'sys_rt_' prefixes. Note that many calls have a 'f' version that takes a file descriptor (fd - like a file handle in Windows) instead of a pathname. For example, sys_truncate will set the length of a file designated by name, while sys_ftruncate does the same thing but on an open file designated by file descriptor, not path.</p>
<p>Open, read, write, lseek, close calls are for file I/O and should be self-explanatory. sys_creat is like sys_open but exclusively for creating a new file.</p>
<p>sys_pread64 and sys_pwrite64 are useful too. They read or write from a file descriptor but with an extra argument specifying the origin (offset) of the read/write. This saves on 'lseek' calls. sys_pread64 and sys_pwrite64 do not modify the file pointer after a read/write.</p>
<p>sys_stat, sys_fstat and sys_lstat return a 'stat' structure that gives us much useful information about the file such as length and permissions. This 'stat' structure is given at the end of this section.</p>
<p>sys_mmap/sys_munmap can be used to memory-map a file, but also very useful to allocate memory using MAP_PRIVATE and MAP_ANONYMOUS. sys_mprotect can modify read/write/execute permissions of an area of memory - I find this useful for making the .text section writeable in the first generation of the virus.</p>
<p>sys_truncate and sys_ftruncate are used to set (grow or shrink) the size of a file.</p>
<p>sys_chmod and sys_fchmod can set the permissions of a file (if possible). sys_utime can set the creation and modification time-stamps of a file. sys_chown and sys_fchown set the owner of a file (by UID - user id) along with he group (by GID - group id).</p>
<p>sys_rename can rename a file.</p>
<p>sys_getcwd (get current working directory), sys_chdir and sys_fchdir are used for directory navigation.</p>
<p>sys_getdents queries a directory, reading in blocks of 'linux_dirent' structures for files in the directory. This is some-what like findfirst/findnext. The 'linux_dirent' structure is given at the end of this section.</p>
<p>sys_getuid tells us the current user id - always zero for 'root'.</p>
<p>sys_rt_sigaction, sys_rt_sigprocmask, stub_rt_sigreturn are used for 'signal' handlers - something like exception handling. See section on signal handlers later in this document.</p>
<p>The kernel (not glibc) stat structure is as follows:</p>
<div class="asm" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #0000ff; font-weight: bold;">struc</span> &nbsp; stat<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>st_dev &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; ID of device containing file</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>st_ino &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; inode number</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>st_nlink &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Number of hard links</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>st_mode&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resd</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; protection / permissions</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>st_uid &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resd</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; User ID of owner</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>st_gid &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resd</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Group ID of owner</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>__pad0 &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resd</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>st_rdev&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; device ID if special file</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>st_size&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; total size in bytes</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>st_blksize &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; block size for file I/O</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>st_blocks&nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Number of 512-byte blocks</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>st_atime &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Time of last access</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>st_atime_nsec&nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>st_mtime &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Time of last modification</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>st_mtime_nsec&nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>st_ctime &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Time of creation</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>st_ctime_nsec&nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>__unused &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">3</span><br/>
<span style="color: #0000ff; font-weight: bold;">endstruc</span><br/>
<br/>
<span style="color: #0000ff; font-weight: bold;">struc</span> &nbsp; linux_dirent<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>d_ino&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; inode number</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>d_off&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Offset to next linux_dirent </span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>d_reclen &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resw</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Length of this dirent</span><br/>
<span style="color: #0000ff; font-weight: bold;">endstruc</span><br/>
&nbsp;</div>
<p>d_name follows .d_reclen - ASCIIZ string of filename. Its length is (d_reclen - 2). Following is a padding byte. Last is BYTE d_type (offset (d_reclen - 1). We usually want d_type to be DT_REG.</p>
<h2><a name="c4"></a>Beginning: glibc Calls</h2>
<p>'glibc' is the GNU C Library. It contains C callable equivalent functions of most SYSCALL's with better error handling and some extra functionality. It additionally provides other functions not directly associated with SYSCALL's such as 'printf', 'fopen' and 'malloc'. glibc is Unix, Posix, and partly BSD compliant, making ideal for portable code written in C/C++. Using 'glibc' calls instead of SYSCALL's is another possibility in your virus especially one compiled in a language such as C or C++. Most compiled executables use glibc calls. Even if you do not intend to call glibc in your virus it is useful to know about, especially for per-process residency (see section '.got.plt hooks' below). Other advantages to using glibc include much more documentation (see 'man' pages). Many glibc calls are just 'wrappers' to SYSCALL's, usually with the return value modified. Not that structures used or returned by glibc calls are often different from their SYSCALL equivalent For example, the 'stat' structure returned by the glibc 'stat' call is different from the stat structure returned by sys_stat.</p>
<p>Arguments in x64 Linux are passed to a C callable function as follows: RDI, RSI, RDX, RCX, R8, R9 with the return value in RAX.</p>
<h2><a name="c5"></a>A Note: Signals</h2>
<p>Signals in Linux are used to catch events such as interrupts, segment faults, illegal opcodes, etc. Think of them as similar to SEH in Windows, but different. This section was mainly written to share an undocumented piece of information you need to know when installing signal handlers with SYSCALL's. Signal handlers are installed using sigaction function (sycall 13 - _rt_sigaction):</p>
<div class="c" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333;">int</span> sigaction<span style="color: black;">&#40;</span><span style="color: #993333;">int</span> signum<span style="color: #339933;">,</span> <span style="color: #993333;">struct</span> sigaction <span style="color: #339933;">*</span>act<span style="color: #339933;">,</span> <span style="color: #993333;">struct</span> sigaction <span style="color: #339933;">*</span>oldact<span style="color: black;">&#41;</span><span style="color: #339933;">;</span></div>
<p>See http://linux.die.net/man2/rt_sigaction</p>
<p>Let us note the following details before final note on sigaction call.</p>
<p>Some common signum values are:</p>
<div class="asm" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #0000ff; font-weight: bold;">%define</span> SIGILL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">04</span><br/>
<span style="color: #0000ff; font-weight: bold;">%define</span> SIGSEGV &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">11</span><br/>
<span style="color: #0000ff; font-weight: bold;">%define</span> SIGKILL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #ff0000;">9</span><br/>
&nbsp;</div>
<p>sigaction struc is as follows:</p>
<div class="asm" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #0000ff; font-weight: bold;">struc</span> &nbsp; sigaction<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>sa_handler &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>sa_flags &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>sa_restorer&nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>sa_mask&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">16</span><br/>
<span style="color: #0000ff; font-weight: bold;">endstruc</span><br/>
&nbsp;</div>
<p>sa_handler function is called with the following arguments:</p>
<ul>
<li>rdi = signal number (signum)</li>
<li>rsi = siginfo struc</li>
<li>rdx = sigcontext</li>
</ul>
<p>siginfo structure is as follows:</p>
<div class="asm" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #0000ff; font-weight: bold;">struc</span> &nbsp; siginfo<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>si_signo &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resd</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; 0</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>si_errno &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resd</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; 4</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>si_code&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resd</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; 8</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>unused &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resd</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; 12</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>_addr&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; 16</span><br/>
<span style="color: #0000ff; font-weight: bold;">endstruc</span><br/>
&nbsp;</div>
<p>sigcontext structure is of type 'ucontext' as follows:</p>
<div class="asm" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #0000ff; font-weight: bold;">struc</span> &nbsp; sigcontext<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span><span style="color: #46aa03; font-weight: bold;">r8</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +00</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span><span style="color: #46aa03; font-weight: bold;">r9</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +08</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span><span style="color: #46aa03; font-weight: bold;">r10</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +16</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span><span style="color: #46aa03; font-weight: bold;">r11</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +24</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span><span style="color: #46aa03; font-weight: bold;">r12</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +32</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span><span style="color: #46aa03; font-weight: bold;">r13</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +40</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span><span style="color: #46aa03; font-weight: bold;">r14</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +48</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span><span style="color: #46aa03; font-weight: bold;">r15</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +56</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span><span style="color: #46aa03; font-weight: bold;">rdi</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +64</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span><span style="color: #46aa03; font-weight: bold;">rsi</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +72</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span><span style="color: #46aa03; font-weight: bold;">rbp</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +80</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span><span style="color: #46aa03; font-weight: bold;">rdx</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +88</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span><span style="color: #46aa03; font-weight: bold;">rbx</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +96</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span><span style="color: #46aa03; font-weight: bold;">rax</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +104</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span><span style="color: #46aa03; font-weight: bold;">rcx</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +112</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span><span style="color: #46aa03; font-weight: bold;">rsp</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +120</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>rip&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +128</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>eflags &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +136</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span><span style="color: #46aa03; font-weight: bold;">cs</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resw</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +144</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span><span style="color: #46aa03; font-weight: bold;">gs</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resw</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +146</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span><span style="color: #46aa03; font-weight: bold;">fs</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resw</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +148</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>__pad0 &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resw</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +150</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>err&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +152</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>trapno &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +160</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>oldmask&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +168</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span><span style="color: #46aa03; font-weight: bold;">cr2</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +176</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>fpstate&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +184</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>reserved &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">8</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +192</span><br/>
<span style="color: #0000ff; font-weight: bold;">endstruc</span><br/>
<br/>
<span style="color: #0000ff; font-weight: bold;">struc</span> &nbsp; signalstack<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>ss_sp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>ss_flags &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>ss_size&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span><br/>
<span style="color: #0000ff; font-weight: bold;">endstruc</span><br/>
<br/>
<span style="color: #0000ff; font-weight: bold;">struc</span> &nbsp; ucontext<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>uc_flags &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +0x0</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>uc_link&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +0x8</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>uc_stack &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resb</span>&nbsp; &nbsp; signalstack_size&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; +0x10</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>uc_mcontext&nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resb</span>&nbsp; &nbsp; sigcontext_size &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; 28h</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>uc_sigmask &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">16</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; 128h</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; 228h</span><br/>
<span style="color: #0000ff; font-weight: bold;">endstruc</span><br/>
&nbsp;</div>
<p>Final and most important thing to note: Both include files and man pages state 'sa_restorer' field of sigaction struc is obsolete and unused. This appears to be for the glibc wrapper function only. When using raw SYSCALL we must provide 'sa_restorer' stub to execute 'sigreturn' SYSCALL or we will get a segment violation or some other error:</p>
<div class="asm" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">signal_restorer<span style="color: #339933;">:</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">push</span>&nbsp; &nbsp; <span style="color: #ff0000;">15</span>&nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; sigreturn</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">pop</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rax</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">syscall</span><br/>
&nbsp;</div>
<p>'RET' instruction is not needed.</p>
<h2><a name="c6"></a>Beginning: Elf64 File Format</h2>
<p>'Elf64' (Executable and Linkable Format 64-bit) is the file format used for x64 Linux executables, shared/dynamic libraries and relocatables (objects). All the structures and constants you need can be found in '/usr/include/elf.h' while:</p>
<p>http://www.openwatcom.org/ftp/devel/docs/elf-64-gen.pdf</p>
<p>There are three main elements to an Elf64 (Elf32) file: the ELF header (Ehdr), the Program headers (Phdr) and the Section headers (Shdr). Understanding these is enough to getting you infecting Elf64 files with the simpler methods.</p>
<p>The ELF header (Ehdr) is always at the immediate beginning of the file, and is the first thing to be checked. It has the following format:</p>
<div class="asm" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #0000ff; font-weight: bold;">struc</span> &nbsp; Elf64_Ehdr<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>e_ident&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resb</span>&nbsp; &nbsp; EI_NIDENT &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; 16-BYTE ELF identification</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>e_type &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resw</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Object file type</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>e_machine&nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resw</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Machine type</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>e_version&nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resd</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Object file version</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>e_entry&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Entry Point address</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>e_phoff&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Program Header offset</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>e_shoff&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Section Header offset</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>e_flags&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resd</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Processor specific flags</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>e_ehsize &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resw</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; ELF header size</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>e_phentsize&nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resw</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Program header entry size</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>e_phnum&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resw</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; No. of Program header entries</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>e_shentsize&nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resw</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Section header entry size</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>e_shnum&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resw</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; No. of Section header entries</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>e_shstrndx &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resw</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Section name string table index</span><br/>
<span style="color: #0000ff; font-weight: bold;">endstruc</span><br/>
&nbsp;</div>
<p>And the following constants are needed:</p>
<div class="asm" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #0000ff; font-weight: bold;">%define</span> EI_MAG0 &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">0</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; File identification [0..3]</span><br/>
<span style="color: #0000ff; font-weight: bold;">%define</span> EI_MAG1 &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">1</span><br/>
<span style="color: #0000ff; font-weight: bold;">%define</span> EI_MAG2 &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">2</span><br/>
<span style="color: #0000ff; font-weight: bold;">%define</span> EI_MAG3 &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">3</span><br/>
<span style="color: #0000ff; font-weight: bold;">%define</span> EI_CLASS&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">4</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; File class</span><br/>
<span style="color: #0000ff; font-weight: bold;">%define</span> EI_DATA &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">5</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Data encoding</span><br/>
<span style="color: #0000ff; font-weight: bold;">%define</span> EI_VERSION&nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">6</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; File version</span><br/>
<span style="color: #0000ff; font-weight: bold;">%define</span> EI_OSABI&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">7</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; OS/ABI identification</span><br/>
<span style="color: #0000ff; font-weight: bold;">%define</span> EI_ABIVERSION &nbsp; <span style="color: #ff0000;">8</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; ABI version</span><br/>
<span style="color: #0000ff; font-weight: bold;">%define</span> EI_PAD&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">9</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Start of padding bytes</span><br/>
<br/>
<span style="color: #0000ff; font-weight: bold;">%define</span> EI_NIDENT &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">16</span>&nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Size of e_ident[] in bytes</span><br/>
<br/>
<span style="color: #0000ff; font-weight: bold;">%define</span> ELF64_MAGIC &nbsp; &nbsp; <span style="color: #ff0000;">0x464C457F</span><br/>
&nbsp;</div>
<p>EI_MAG0, EI_MAG1, EI_MAG2, EI_MAG3, EI_CLASS, EI_DATA, EI_VERSION, EI_OSABI, and EI_ABIVERSION are indexes into the 'e_ident' field array of useful values. EI_PAD is the beginning of (currently) unused bytes in e_ident and EI_NIDENT is the total size of the e_ident byte array.</p>
<p>The first check you make to the Ehdr is whether it is an Elf64 file. This means that the first four bytes (e_ident[EI_MAG0..EI_MAG3]) must equal 'ELF64_MAGIC' ("\x7FELF"). We want e_ident[EI_CLASS] to be ELFCLASS64 (64-bit object) and e_ident[EI_DATA] to equal ELFDATA2LSB (little-endian data structures). For e_ident[EI_VERSION] we want EV_CURRENT, for e_ident[EI_OSABI] we want ELFOSABI_SYSV and for e_ident[EI_ABIVERSION] we want 0 (zero). The seven bytes at e_ident[EI_PAD] should be zero, but perhaps this is a place you can put an infection marker. Field eh_machine should be EM_X86_64 and field e_flags can be ignored. Fields e_ehsize, e_phentsize and e_shentsize should be checked too. They should be equal to the size of your Elf64_Ehdr struc, Elf64_Phdr struc and Elf64_Shdr structures respectively.</p>
<p>With these values checked, we can use e_type to identify the type of Elf64 object. Useful values are ET_REL (relocatable - same as an object file), ET_EXEC (executable) and ET_DYN (dynamic/shared library - much like a Windows .DLL). Now we can access the Program Headers (Elf64_Phdr) using e_phoff and e_phnum and Section Headers using e_shoff and e_shnum. We can also use e_shstrndx to locate the section containing the names of all other sections in ASCIIZ format. Finally e_entry hold the entrypoint for executables and shared libraries. We can hook this if we are not using EPO.</p>
<p>In executables and shared objects (dynamic libraries) the Program Headers (Phdr's) are used to define segments in which sections are grouped. Relocatable objects should <strong>not</strong> have any Phdr's, executables and libraries <strong>must</strong> have Phdr's. Program headers (especially PT_LOAD entries) can be thought of as similar to PE sections (not to be confused with Elf32/64 sections. They define a block of memory in the objects image, its address and size in memory, its properties and the image file offset and physical size, plus its alignment in memory. The Phdr structure is as follows:</p>
<div class="asm" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #0000ff; font-weight: bold;">struc</span> &nbsp; Elf64_Phdr<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>p_type &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resd</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Type of segment</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>p_flags&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resd</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Segment attributes</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>p_offset &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Offset in file</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>p_vaddr&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Virtual address in memory</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>p_paddr&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Reserved</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>p_filesz &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Size of segment in file</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>p_memsz&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Size of segment in memory</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>p_align&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Alignment of segment</span><br/>
<span style="color: #0000ff; font-weight: bold;">endstruc</span><br/>
&nbsp;</div>
<p>Field 'p_paddr' is reserved. Note that 'p_align' must be a power of 2, and p_offset and p_vaddr must be congruent modulo p_align. Common p_types are:</p>
<dl>
<dt>PT_NULL</dt><dd>An unused entry.</dd>
<dt>PT_LOAD</dt><dd>Defines a loadable segment. Note that this is possible the most important type when infecting Elf64 executables and libraries.</dd>
<dt>PT_DYNAMIC</dt><dd>This is present in dynamically bound object and contains information such as relocation information and libraries required, among other things. This is an array of Elf64_Dyn entries, the last of which is of type DT_NULL.</dd>
<dt>PT_INTERP</dt><dd>Contains a path to the Program Interpreter. This is an indicator that the 'dynamic loader' is used when loading/executing this file.</dd>
<dt>PT_NOTES</dt><dd>Contains information particular to the build toolset. Special information about compile and link information and so forth.</dd>
<dt>PT_SHLIB</dt><dd>Reserved.</dd>
<dt>PT_PHDR</dt><dd>Defines memory where the Phdr's will be in memory.</dd>
</dl>
<p>Other p_types are reserved as 'Environment Specific' or 'Processor Specific'. When infecting an Elf64 executable or shared object our virus must exist in a segment of memory defined by a Phdr entry of PT_LOAD. This may be a PT_LOAD entry already in the file, or one we create ourselves. For this segment we must set 'p_flags' to the correct combination of values (PF_X, PF_W, PF_R).</p>
<p>The section headers (Shdr's) and sections they define are perhaps the most complex and rich parts of an Elf64 file. Files of executable type do not need to have Shdr's, they can have Phdr's only. However, such files are very rare and not produced by normal compilers and assemblers. Shared libraries must have some sections, to define the library name and version, exports and other properties. Relocatable Elf64 files consist purely of Shdr's and sections (and the Elf64_Ehdr of-course). Elf64 sections can be considered similar to PE file data directories. While some sections contain raw data, many contain tables of entries specific to that section type. The format of a Elf64_Shdr entry is:</p>
<div class="asm" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #0000ff; font-weight: bold;">struc</span> &nbsp; Elf64_Shdr<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>sh_name&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resd</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Section name</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>sh_type&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resd</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Section type</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>sh_flags &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Section attributes</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>sh_addr&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Virtual address in memory</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>sh_offset&nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Offset in file</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>sh_size&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Size (in file) of section</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>sh_link&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resd</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Link to other section</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>sh_info&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resd</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Miscellaneous information</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>sh_addralign &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Address alignment boundary</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>sh_entsize &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">resq</span>&nbsp; &nbsp; <span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; Size of entries, if section has table</span><br/>
<span style="color: #0000ff; font-weight: bold;">endstruc</span><br/>
&nbsp;</div>
<p>Sections are referenced by their index in the Shdr table. The first Shdr entry (index 0) is always unused and has sh_type of SHT_NULL. The Elf64_Ehdr contains the field 'e_shstrndx' which gives the section index of the section containing the string table of section names. Using 'sh_name' as an index into this string table, we can retrieve the name of a section as an ASCIIZ string. Section types (sh_type) include, but are not limited to:</p>
<dl>
<dt>SHT_NULL</dt><dd>Entry is unused.</dd>
<dt>SHT_PROGBITS</dt><dd>Contains data used by the program.</dd>
<dt>SHT_SYMTAB</dt><dd>Contains a linker symbol table.</dd>
<dt>SHT_STRTAB</dt><dd>Contains a string table.</dd>
<dt>SHT_RELA</dt><dd>Contains 'rela' style relocation items.</dd>
<dt>SHT_REL</dt><dd>Contains 'rel' style relocation items.</dd>
<dt>SHT_HASH</dt><dd>Contains a symbol hash table.</dd>
<dt>SHT_DYNAMIC</dt><dd>Contains dynamic linking tables.</dd>
<dt>SHT_NOTE</dt><dd>Contains not information (like Phdr PT_NOTE)</dd>
<dt>SHT_NOBITS</dt><dd>Contains uninitialised space, does not occupy any space in file.</dd>
<dt>SHT_DYNSYM</dt><dd>Contains a dynamic loader symbol table.</dd>
</dl>
<p>Other 'Environment specific' or 'Processor specific' sections may be defined.</p>
<p>Fields sh_addr, sh_offset and sh_size provide us with the virtual address, physical offset and physical size in the file respectively. 'sh_addr' is unused in relocatable files. Section flags (sh_flags) can be:</p>
<dl>
<dt>SHF_WRITE</dt><dd>Section contains writeable data.</dd>
<dt>SHF_ALLOC</dt><dd>Section is allocated in memory image of program.</dd>
<dt>SHF_EXECINSTR</dt><dd>Section contains executable instructions.</dd>
</dl>
<p>'sh_addralign' describes the required alignment for this section. This value must be a power of 2. 'sh_entsize' contains the size in bytes of each entry in that section, for sections with fixed size entries. This value is often zero.</p>
<p>'sh_link' field contains the index of an associated section. What this index means depends on the type of section containing the sh_link reference:</p>
<dl>
<dt>SHT_DYNAMIC</dt><dd>sh_link contains an index to the string table section used by entries in this section.</dd>
<dt>SHT_HASH</dt><dd>sh_link contains an index to the symbol table for which the hash table applies.</dd>
<dt>SHT_REL/SHT_RELA</dt><dd>sh_link contains an index to the section of symbols referenced by the relocations.</dd>
<dt>SHT_SYMTAB/SHT_DYNSYM</dt><dd>sh_link contains an index to the string table section used by entries in this section.</dd>
</dl>
<p>'sh_info' field contains additional information about the section. Its meaning depends on the section type:</p>
<dl>
<dt>SHT_REL/SHT_RELA</dt><dd>sh_info contains index to the section for which the relocations apply.</dd>
<dt>SHT_SYMTAB/SHT_DYNSYM</dt><dd>sh_info contains the index of the first non-local symbol. That is the number of local symbols.</dd>
</dl>
<p>sh_info should be zero for other types of sections.</p>
<p>Common sections include (A = SHF_ALLOC, W = SHF_WRITE, X = SHF_EXEXINSTR)</p>
<table summary="ELF sections">
<tr><th>Section Name</th><th>Section Type</th><th>Flags</th><th>Use</th></tr>
<tr><td>.bss</td><td>SHT_NOBITS</td><td>A, W</td><td>Uninitialised data</td></tr>
<tr><td>.data</td><td>SHT_PROGBITS</td><td>A, W</td><td>Initialised data</td></tr>
<tr><td>.interp</td><td>SHT_PROGBITS</td><td>[A]</td><td>Program interpreter path name</td></tr>
<tr><td>.rodata</td><td>SHT_PROGBITS</td><td>A</td><td>Read-only data (constants and literals)</td></tr>
<tr><td>.text</td><td>SHT_PROGBITS</td><td>A, X</td><td>Executable code</td></tr>
<tr><td>.comment</td><td>SHT_PROGBITS</td><td>none</td><td>Version control information</td></tr>
<tr><td>.dynamic</td><td>SHT_DYNAMIC</td><td>A[, W]</td><td>Dynamic linking tables</td></tr>
<tr><td>.dynstr</td><td>SHT_STRTAB</td><td>A</td><td>String table for .dynamic section</td></tr>
<tr><td>.dynsym</td><td>SHT_DYNSYM</td><td>A</td><td>Symbol table for dynamic linking</td></tr>
<tr><td>.got</td><td>SHT_PROGBITS</td><td>Mach. dep.</td><td>Global offset table</td></tr>
<tr><td>.hash</td><td>SHT_HASH</td><td>A</td><td>Symbol hash table</td></tr>
<tr><td>.note</td><td>SHT_NOTE</td><td>none</td><td>Note section</td></tr>
<tr><td>.plt</td><td>SHT_PROGBITS</td><td>mach. dep.</td><td>Procedure linkage table</td></tr>
<tr><td>.rel&lt;name></td><td>SHT_REL</td><td>[A]</td><td>Relocations for section name</td></tr>
<tr><td>.rela&lt;name></td><td>SHT_RELA</td><td>[A]</td><td>Relocations for section name</td></tr>
<tr><td>.shstrtab</td><td>SHT_STRTAB</td><td>none</td><td>Section name string table</td></tr>
<tr><td>.strtab</td><td>SHT_STRTAB</td><td>none</td><td>String table</td></tr>
<tr><td>.symtab</td><td>SHT_SYMTAB</td><td>[A]</td><td>Linker symbol table</td></tr>
</table>
<p>Sections such as .text, .data and .rodata contain raw, unformatted data. Sections such as .interp, .dynamic, .dynstr, .rel(a)* and .symtab contain tables of the data structure appropriate to that section. String tables sections of type SHT_STRTAB) contain one ASCIIZ string after another, with strings referenced by their index (offset) into that section. The first entry (offset zero) of a string table is always a NULL byte, allowing for an empty string. In relocatable files, all in the relocatable are needed. In executable files some sections are needed by the dynamic loader, while others such as .text and .data are redundant. This is because the allocation of memory needed for them and the reading of the file, are all provided by the Phdr entries. Although they may not be used by the dynamic loader, they might be used by other tools that work with Elf64 files.</p>
<h2><a name="c7"></a>Recommendations: Working with Elf64 Files</h2>
<p>Some simple recommendations on working with Elf64 files. Firstly, and most basically I prefer to use pread/pwrite calls that take an offset of the read/write. This saves an 'lseek' and produces smaller code. Secondly, try to avoid unnecessary calls and file I/O. This can be done by only reading in everything you need only once and not writing it until the end. You should also check everything as you go before reading in anything else. For example, reading in the Ehdr and checking everything you can about it before reading in the Phdr's. Only if the Phdr's pass the test do you read in the Shdr's, and only if the Shdr's pass the test do you read in the section images. Of course, you could check certain fields of the files 'stat' structure, such as its length, before you even open the file.</p>
<p>I would also recommend only searching for sections by name when you have to. When you can use fields sh_link and sh_info, you should. For example you might find section '.plt' by name, but then you would find its relocations section by searching for a section of type SHT_REL or SHT_RELA with its sh_info field pointing to .plt index, rather than looking for '.rel.plt' or '.rela.plt'.</p>
<p>I think making a temporary copy of the victim file and infecting that copy is a good idea. This way if infection fails someway into the procedure, you can delete the temporary copy, leaving the original file unmodified. If infection succeeds you can delete the victim, rename the temporary file to the victim filename, and restore permissions, uid/gid, and timestamps.</p>
<p>Being able to read in an entire Elf64, modify it and rebuild it is strongly recommended. As you will see in sections on infection below, infection schemes can be as simple as appending the virus to an executable and modifying a Phdr. Maybe you do not need to deal with the entire Elf64 in such a case. However, for more complex infection schemes, epo, per-process residency etc. this comes in useful. You would have a routine that reads in an entire Elf64 file: first the Ehdr, then the Phdr's, then the Shdr's and finally the image (content) of each section (except of type SHT_NOBITS). This may use a bit more memory during infection (especially for large files), but will lead to simpler, smaller, faster code. You would then have the appropriate routines to re-write the Ehdr (if it has been modified), rewrite the Phdr's, rewrite the Shdr's and rewrite any section image. These routines can then be utilised in a single routine to rebuild the entire Elf64 file after modification. When allocating memory from the Phdr's, Shdr's and section images, allocate some extra memory for each. This way you can add extra headers or extra data (such as code/data, relocation items, dynamic symbols etc.) to a section if you need to.</p>
<p>When looking for relocations (".rel&lt;section>" or ".rela&lt;section>", dynamic symbols and their names (".dynsym" and ".dynstr") we are better off using Elf64 'rules' than their names.</p>
<p>Relocations: Relocations for a section can be found by looking for a section of type 'SHT_REL' or 'SHT_RELA' with an 'sh_index' field containing the index of the section for which we want relocations.</p>
<p>Symbol Table: Once we have the relocations for a section, the 'sh_link' field of the relocation sections Shdr will tell us the section index of the Symbol table used for that section.</p>
<p>Symbol Names: For sections containing symbols (type SHT_SYMTAB or SHT_DYNSYM) the 'sh_link' field will provide us with the section index of the string table for those symbols.</p>
<p>A note on relocation information (rel/rela .r_info field): This is a 64-bit value holding 2 32-bit fields. The high 32-bits hold the appropriate symbol index, the low 32-bits hold the relocation type. These macros should demonstrate this:</p>
<div class="c" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #339933;">#define ELF64_R_SYM(i)((i) &gt;&gt; 32)</span><br/>
<span style="color: #339933;">#define ELF64_R_TYPE(i)((i) &amp; 0xffffffff)</span><br/>
<span style="color: #339933;">#define ELF64_R_INFO(s, t)(((s) &lt;&lt; 32) + ((t) &amp; 0xffffffff))</span><br/>
&nbsp;</div>
<h2><a name="c8"></a>Made Simple: Elf64 Executable infection</h2>
<p>Perhaps there are 2 basic steps for parasitic infection of an executable:</p>
<ol>
<li>Incorporate the virus into the file and memory image of the executable.</li>
<li>Find a way for the virus to receive control.</li>
</ol>
<p>Let us consider the most basic facts for these 2 steps when infecting a Elf64 executable. First creation of the executable image from file to memory is done using the Phdr's in executables. Sections such as '.text' are ignored. So we must incorporate the virus into a Phdr (almost always of type PT_LOAD). This Phdr must also have the correct flags (memory permissions) for our virus: at least PF_X+PF_R, but possibly PF_W as well. Secondly the virus must gain control. The easiest way to do this in an Elf64 executable (as with most executables) is to hook the entrypoint. This is defined in the 'e_entry' field of the Ehdr. Of course you can play with sections such as .text and .plt to try different EPO (EntryPoint Obscuring) techniques.</p>
<p>Let us consider ways to incorporate the virus into the host's physical/virtual image. We could overwrite an unneeded section, perhaps of SHT_NOTE if it is inside a segment define by a Phdr and modify the Phdr to be executable. Or we could write the virus into alignment space between Phdr segments and modify the Phdr too. Both these techniques limit the size of the virus and the number of victims we could infect. Many Elf32 virus move the Ehdr and Phdr's back one page (4096 bytes) decreasing the memory address and growing the size of the first Phdr, writing the virus in the newly created space between the end of the Phdr table on the newly create page and the first section. Of course you must fix up all Phdr/Shdr offsets by 1 page that are after the new page. I have not tried this method on x64 Linux (only x86) but am not comfortable moving the headers back more than 1 page. This limits the virus size too.</p>
<p>My favourite solution is to append the virus, and create its own Phdr containing it. The Phdr can be created in two ways: if there is space between the last Phdr and the first section, we can add a new Phdr (and increment e_phnum in the Ehdr). We can also find an unneeded Phdr (such as PT_NOTE or PT_PHDR). The new Phdr should be of type PT_LOAD and p_flags should be PF_R+PF_X(+PF_W). p_offset and p_filesz should define the physical virus image in the file. p_memsz should be the size of the virus in memory. We must calculate p_vaddr and p_align by examining all other Phdr's: p_align for PT_LOAD segments may be 4k or 2mb, or possibly even something else, thus we must walk the Phdr's and fine the maximum alignment value used for PT_LOAD segments. For p_vaddr we must first find the maximum memory address used by other Phdr's in the executable. This is the maximum value of 'p_vaddr + p_memsz'. We must then align this value to a multiple of our new p_align and add the physical offset of the virus mod p_align. This is because the the virtual address of our PT_LOAD segment must be congruent to the file offset of the virus mod the alignment value: The following code will demonstrate finding a PT_NOTE or PT_PHDR entry, finding the correct (maximum) pt_align value, and the highest virtual address used in the executable before our virus. (PT_PHDR patching is experimental).</p>
<div class="asm" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">movzx</span> &nbsp; <span style="color: #46aa03; font-weight: bold;">rcx</span><span style="color: #339933;">,</span><span style="color: #0000ff; font-weight: bold;">word</span> <span style="color: black;">&#91;</span>Elf64_Ehdr<span style="color: #339933;">+</span>Elf64_Ehdr<span style="color: #339933;">.</span>e_phnum<span style="color: black;">&#93;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">lea</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rdx</span><span style="color: #339933;">,</span><span style="color: black;">&#91;</span>phdrs_buf<span style="color: black;">&#93;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">xor</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rbp</span><span style="color: #339933;">,</span><span style="color: #46aa03; font-weight: bold;">rbp</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; max virtual addr</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">push</span>&nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rbp</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; pointer in buffer of</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">pop</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rbx</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; target Phdr</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">push</span>&nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rbp</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">pop</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rdi</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; max align value</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>phdr_loop<span style="color: #339933;">:</span> &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">cmp</span> &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">dword</span> <span style="color: black;">&#91;</span><span style="color: #46aa03; font-weight: bold;">rdx</span><span style="color: #339933;">+</span>Elf64_Phdr<span style="color: #339933;">.</span>p_type<span style="color: black;">&#93;</span><span style="color: #339933;">,</span>PT_NOTE<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">je</span>&nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>phdr_found<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">cmp</span> &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">dword</span> <span style="color: black;">&#91;</span><span style="color: #46aa03; font-weight: bold;">rdx</span><span style="color: #339933;">+</span>Elf64_Phdr<span style="color: #339933;">.</span>p_type<span style="color: black;">&#93;</span><span style="color: #339933;">,</span>PT_PHDR<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">jne</span> &nbsp; &nbsp; <span style="color: #339933;">.</span>phdr_not_found<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>phdr_found<span style="color: #339933;">:</span>&nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">test</span>&nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rbx</span><span style="color: #339933;">,</span><span style="color: #46aa03; font-weight: bold;">rbx</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">cmovz</span> &nbsp; <span style="color: #46aa03; font-weight: bold;">rbx</span><span style="color: #339933;">,</span><span style="color: #46aa03; font-weight: bold;">rdx</span> <span style="color: black; font-style: italic;">; assign new target phdr</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>phdr_not_found<span style="color: #339933;">:</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">mov</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rax</span><span style="color: #339933;">,</span><span style="color: black;">&#91;</span><span style="color: #46aa03; font-weight: bold;">rdx</span><span style="color: #339933;">+</span>Elf64_Phdr<span style="color: #339933;">.</span>p_vaddr<span style="color: black;">&#93;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">add</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rax</span><span style="color: #339933;">,</span><span style="color: black;">&#91;</span><span style="color: #46aa03; font-weight: bold;">rdx</span><span style="color: #339933;">+</span>Elf64_Phdr<span style="color: #339933;">.</span>p_memsz<span style="color: black;">&#93;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">cmp</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rbp</span><span style="color: #339933;">,</span><span style="color: #46aa03; font-weight: bold;">rax</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">cmovb</span> &nbsp; <span style="color: #46aa03; font-weight: bold;">rbp</span><span style="color: #339933;">,</span><span style="color: #46aa03; font-weight: bold;">rax</span> &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; assign new max vaddr</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">cmp</span> &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">dword</span> <span style="color: black;">&#91;</span><span style="color: #46aa03; font-weight: bold;">rdx</span><span style="color: #339933;">+</span>Elf64_Phdr<span style="color: #339933;">.</span>p_type<span style="color: black;">&#93;</span><span style="color: #339933;">,</span>PT_LOAD<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">jne</span> &nbsp; &nbsp; <span style="color: #339933;">.</span>phdr_not_load<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">mov</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rax</span><span style="color: #339933;">,</span><span style="color: black;">&#91;</span><span style="color: #46aa03; font-weight: bold;">rdx</span><span style="color: #339933;">+</span>Elf64_Phdr<span style="color: #339933;">.</span>p_align<span style="color: black;">&#93;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">cmp</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rdi</span><span style="color: #339933;">,</span><span style="color: #46aa03; font-weight: bold;">rax</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">cmovb</span> &nbsp; <span style="color: #46aa03; font-weight: bold;">rdi</span><span style="color: #339933;">,</span><span style="color: #46aa03; font-weight: bold;">rax</span> <span style="color: black; font-style: italic;">; assign new alignment value</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>phdr_not_load<span style="color: #339933;">:</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">add</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rdx</span><span style="color: #339933;">,</span>Elf64_Phdr_size<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">loop</span>&nbsp; &nbsp; <span style="color: #339933;">.</span>phdr_loop<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">mov</span> &nbsp; &nbsp; <span style="color: black;">&#91;</span>max_phdr_vaddr<span style="color: black;">&#93;</span><span style="color: #339933;">,</span><span style="color: #46aa03; font-weight: bold;">rbp</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">mov</span> &nbsp; &nbsp; <span style="color: black;">&#91;</span>target_phdr<span style="color: black;">&#93;</span><span style="color: #339933;">,</span><span style="color: #46aa03; font-weight: bold;">rbx</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">mov</span> &nbsp; &nbsp; <span style="color: black;">&#91;</span>phdr_align<span style="color: black;">&#93;</span><span style="color: #339933;">,</span><span style="color: #46aa03; font-weight: bold;">rdi</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">cmp</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rbx</span><span style="color: #339933;">,</span><span style="color: #46aa03; font-weight: bold;">rcx</span> <span style="color: black; font-style: italic;">; [target_phdr]</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">je</span>&nbsp; &nbsp; &nbsp; error<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">cmp</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rbp</span><span style="color: #339933;">,</span><span style="color: #46aa03; font-weight: bold;">rcx</span> <span style="color: black; font-style: italic;">; [max_phdr_vaddr]</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">je</span>&nbsp; &nbsp; &nbsp; error<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">cmp</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rdi</span><span style="color: #339933;">,</span><span style="color: #46aa03; font-weight: bold;">rcx</span> <span style="color: black; font-style: italic;">; [phdr_align]</span><br/>
&nbsp;</div>
<p>Calculating the address in memory (p_vaddr) of our new segment based on the above loop would look something like this:</p>
<div class="asm" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">mov</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rax</span><span style="color: #339933;">,</span><span style="color: black;">&#91;</span>phdr_align<span style="color: black;">&#93;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">mov</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rbx</span><span style="color: #339933;">,</span><span style="color: black;">&#91;</span>virus_physical_offset<span style="color: black;">&#93;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">mov</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rcx</span><span style="color: #339933;">,</span><span style="color: black;">&#91;</span>max_phdr_vaddr<span style="color: black;">&#93;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">dec</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rax</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">and</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rbx</span><span style="color: #339933;">,</span><span style="color: #46aa03; font-weight: bold;">eax</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; rbx = offset of virus mod alignment</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">add</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rcx</span><span style="color: #339933;">,</span><span style="color: #46aa03; font-weight: bold;">rax</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">not</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rax</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">and</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rcx</span><span style="color: #339933;">,</span><span style="color: #46aa03; font-weight: bold;">rax</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; rcx = aligned vaddr of our Phdr entry</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">add</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rcx</span><span style="color: #339933;">,</span><span style="color: #46aa03; font-weight: bold;">rbx</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; rcx = new vaddr of our Phdr segment</span><br/>
&nbsp;</div>
<p>The target Phdr (PT_NOTE or PT_PHDR) should be changed to look something like this:</p>
<div class="asm" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>p_type &nbsp; &nbsp; &nbsp; &nbsp; = PT_LOAD<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>p_flags&nbsp; &nbsp; &nbsp; &nbsp; = PF_X<span style="color: #339933;">+</span>PF_R<span style="color: black;">&#40;</span><span style="color: #339933;">+</span>PF_W<span style="color: black;">&#41;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>p_offset &nbsp; &nbsp; &nbsp; = physical offset of virus <span style="color: #00007f; font-weight: bold;">in</span> file<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>p_vaddr&nbsp; &nbsp; &nbsp; &nbsp; = virtual address of virus as caluclated above<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>p_paddr&nbsp; &nbsp; &nbsp; &nbsp; = unused<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>p_filesz &nbsp; &nbsp; &nbsp; = size of the virus image <span style="color: #00007f; font-weight: bold;">in</span> the file<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>p_memsz&nbsp; &nbsp; &nbsp; &nbsp; = size of virus <span style="color: #00007f; font-weight: bold;">in</span> memory<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>p_align&nbsp; &nbsp; &nbsp; &nbsp; = alignment value as calculated above<span style="color: #339933;">.</span><br/>
&nbsp;</div>
<p>This concludes our look at infecting Elf64 executables.</p>
<h2><a name="c9"></a>Made Simple: Elf64 Relocatable infection</h2>
<p>Elf64 Relocatable files are what some would call 'object' files: fragments of code output by the compiler and then linked together to create the final executable. Relocatable infection has some nice properties: When an infected relocatable is linked into an executable it appears somewhere in the middle of the file, giving a 'code integration' like effect. Execution is handed over to the virus somewhere in the middle of the code flow, giving an EPO effect. When infecting a relocatable file we should make our code fully relocatable. This is because we do not know where the virus will end up in the final linked executable and we do not know if the infected relocatable will be linked into an executable or shared library. When infecting a relocatable we should heed the recommendations in the section 'Recommendations: Working with Elf64 Files' above. Routines to read in the entire file part-by-part, modify them, re-write them and completely rebuild the Elf64 file make our job easier. We should make sure that Ehdr field e_type is ET_REL and that there are <strong>no</strong> Phdr's. When adding data to a section, we should update its size in its Shdr entry for rebuilding the Shdr later on. Relocatable files often have Shdr entries <strong>not</strong> in order of the section offsets in the file. Before rebuilding we should create an array of section indexes and sort it by the offset of the section in the file (sh_offset). We should not modify the order of entries in the Shdr's however. To rebuild the Elf64 file we first write the Ehdr. We next write the section images: We write them in order of file offset. The first has offset after the Ehdr. Each section after that has offset of:</p>
<div class="c" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: black;">&#40;</span>prev_Shdr.<span style="color: #202020;">sh_offset</span> <span style="color: #339933;">+</span> prev_Shdr.<span style="color: #202020;">sh_size</span> aligned to current_Shdr.<span style="color: #202020;">sh_addralign</span><span style="color: black;">&#41;</span></div>
<p>That is the end of the last section image aligned to the section alignment field. Sections with sh_offset equal to zero or sh_type of SHT_NOBITS should have writing of the section image skipped. We must update the sh_offset field of each Shdr as we write the section to the file. Last we write the updated Shdr's at the end of the file and update Ehdr e_shoff field.</p>
<p>With this Elf64 infrastructure in place, Elf64 relocatable infection is not a difficult thing. Let us first consider the 2 basic steps for parasitic infection, stated in the previous section:</p>
<ol>
<li>Incorporate the virus into the file and memory image of the executable.</li>
<li>Find a way for the virus to receive control.</li>
</ol>
<p>Incorporating the virus into the relocatable file is the easiest step. We can do as little as appending the virus to the .text section. Of course, we can consider more elaborate infection schemes such as placing a (polymorphic) decryptor in .text and the encrypted virus in .data or .rodata. When doing such things we must create relocation items in .text for any pointer to data in a different section. Such relocation item is usually of type R_X86_64_64 so field 'r_info' of new relocation item should be (symbol &lt;&lt; 32) | R_X86_64_64. Symbol would usually be symbol 'SECTION' and section index and offset in section of relocation target.</p>
<p>Finding a way for the virus to receive control is the greater challenge, but still is not difficult. First option is a classic EPO technique. We can scan .text for sequence of instruction(s) save these bytes and patch it with CALL to virus. Note that you want to use a relative CALL and not a JMP because we do not know where the virus will be in the executable and this allows for the RIP to be on the stack. We then restore patched bytes or emulate them and return. Second method is more advanced. We 'hijack' a symbol pointing to code in .text, saves its target and set the new target to out virus. This way when code from another object/module links to that target (by name) the CALL is to the virus and not the original function. The virus runs and then passes control to the original function. With gcc compiled relocatables, symbols pointing to functions are always of the 'FUNC', so we choose a 'FUNC' call and hijack it. Some compilers/assemblers do not use symbol type 'FUNC'. NASM for example only uses symbols of type 'NOTYPE' to point to code. The solution is to find a symbol of type 'NOTYPE' pointing to code in .text section. We check that symbol target is in .text and seems to point to code. Such check could be for 'PUSH RBP / MOV RBP,RSP' or 3 PUSH's in a row, etc.</p>
<p>This concludes our look at infecting Elf64 relocatables.</p>
<h2><a name="ca"></a>prelink (-u): The challenge</h2>
<p>First of all, I would like to thank Herm1t for putting me onto this. From the 'prelink' manual: 'Prelink is a tool designed to speed up dynamic linking of ELF programs on various Linux architectures' developed by Jakub Jelinek. To speed up dynamic linking, prelink makes changes to the ELF files such as caching of symbol lookups, optimisation of relocations to be adjacent to corresponding symbols and reducing the number of non-sharable pages created by relocations. A detailed description of 'prelink' is outside the scope of this article, but the source code and manual can be found here:</p>
<p>http://people.redhat.com/jakub/prelink/</p>
<p>It is possible to say that the majority of Elf64 infection methods will work with a prelinked file and leave it there, but there is a challenge. First we must realise when prelink'ing a file, prelink stores 'undo' information allowing for the modifications to be undone, 'prelink -u file'. Attempting a 'prelink -u' on a file that has since been infected will almost always result in an error message or a corrupted file. The challenge is to find a way to infect prelink'd files so that a 'prelink -u' will not display any error messages, will undo the changes made by prelink, and at the same time leave the file infected and uncorrupted. I can tell you this can be done. There is a lesser challenge aswell. When processing libraries, prelink adds a 'DT_CHECKSUM' dynamic tag for which the integrity check of the library will fail if the library has been modified. Can we beat this? As a final note, prelink'd executables have some particular properties and requirements that other executables often will not have. It is my recommendation to have one infection routine for normal executables and a special one for executables that have been processed by prelink.</p>
<h2><a name="cb"></a>prelink (-u): What You Need To Know</h2>
<p>When infecting prelink'd executables there are some things we should know. First of all, the 'undo' information is held in a section called '.gnu.prelink_undo'. The presence of this section can be used as an indicator that the file is a prelink'd executable. The format and processing of this section will be discussed later in this section. Some preliminaries on sections: prelink expects '.gnu.prelink_undo' to be the second to last section of the file and '.shstrtab' (see Ehdr e_shstrndx) to be the last. prelink also expects the sections of the file as declared in the Shdr's to be in physical (file offset) order. Lastly, although Phdr's, not Shdr's, are used by the operating system to load the file image, prelink works exclusively with sections. This means that the virus should belong to a section or it could disappear. For example, if you append the virus and modify a Phdr, after a 'prelink -u' (if all the other checks below pass) the file will be truncated after the last section or Shdr's, the virus will be gone, and the file will be corrupt. So you must include the virus in a section - of course you must include the virus in a Phdr PT_LOAD segment as well.</p>
<p>Now we will discuss the .gnu.prelink_undo section. This must be the second to last section with .shstrtab following it, so any section you add for the virus must be inserted before it (both in Shdr table and in physical file image). The layout of .gnu.prelink_undo is quite simple: the original Ehdr, followed by the original Phdr's, followed by the original Shdr's. There is no padding or alignment between any of these. The first Shdr (SHT_NULL) is not included, so all section indexes are biased by -1. The first check prelink does on this section is its size. It must be:</p>
<div class="c" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333;">sizeof</span><span style="color: black;">&#40;</span>Ehdr<span style="color: black;">&#41;</span> <span style="color: #339933;">+</span> e_phnum <span style="color: #339933;">*</span> <span style="color: #993333;">sizeof</span><span style="color: black;">&#40;</span>Phdr<span style="color: black;">&#41;</span> <span style="color: #339933;">+</span> <span style="color: black;">&#40;</span>e_shnum <span style="color: #339933;">-</span> <span style="color: #0000dd;">1</span><span style="color: black;">&#41;</span> <span style="color: #339933;">*</span> <span style="color: #993333;">sizeof</span><span style="color: black;">&#40;</span>Shdr<span style="color: black;">&#41;</span>.</div>
<p>The next check is on the Ehdr. The Ehdr of the file must be consistent with the Ehdr in .gnu.prelink_undo. All fields must be updated except for e_phnum, e_shnum and e_shstrndx. These 3 values must be retained unless of course if you need to update e_phnum or e_shnum for additional Phdr or Shdr entries. Next we update the Phdr table in .gnu.prelink_undo to reflect changes made to the host Phdr's. The thing to note here is that prelink may add a Phdr entry. This means that we cannot just copy the Phdr's from the host to .gnu.prelink_undo over, and additionally that the index of a Phdr may be different in .gnu.prelink_undo compared to the host. So we must search the Phdr table in the undo section for our target Phdr entry by properties such as 'p_type' and 'p_offset' we then update this entry accordingly. If you have added an additional Phdr in the host you must also insert it before the Shdr table in undo section. Things are much the same for Shdr's, except you may end up appending an Shdr entry at the end of the section. If anything is inserted/appended to .gnu.prelink_undo, the sh_size field of the undo section.</p>
<p>One more thing to consider is dynamic tags DT_GNU_PRELINKED (.d_tag=0x6FFFFDF5) and DT_CHECKSUM (.d_tag=0x6FFFFDF8). These tags are only used in libraries, not executables. The first is a timestamp of when the library was prelink'd. The second is an integrity check value - a combined CRC32 of all the sections. To handle these fields after infection, we must have pointers to the .d_val field of both dynamic entries. We save the value of DT_GNU_PRELINKED and then zero both of them. Checksum value is combined CRC32 of all sections after section zero (SHT_NULL) that have SHF_ALLOC, SHF_WRITE or SHF_EXECINSTR set, have non-zero size and are not of type SHT_NOBITS. The following pseudo-code may help:</p>
<div class="c" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/*<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 'checksum' is a pointer d_val field for DT_CHECKSUM.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 'prelinked' is a pointer d_val field for DT_GNU_PRELINKED<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 'old_time' is an integer to store old timestamp.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; */</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* fix prelink checksum */</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">&#40;</span>checksum <span style="color: #339933;">!=</span> NULL<span style="color: black;">&#41;</span> <span style="color: black;">&#123;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">*</span>checksum <span style="color: #339933;">=</span> <span style="color: #0000dd;">0</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">&#40;</span>prelinked <span style="color: #339933;">!=</span> NULL<span style="color: black;">&#41;</span> <span style="color: black;">&#123;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_time <span style="color: #339933;">=</span> <span style="color: #339933;">*</span>prelinked<span style="color: #339933;">;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">*</span>prelinked <span style="color: #339933;">=</span> <span style="color: #0000dd;">0</span><span style="color: #339933;">;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">&#125;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">uint32_t</span> crc <span style="color: #339933;">=</span> <span style="color: #0000dd;">0</span><span style="color: #339933;">;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">&#40;</span>i <span style="color: #339933;">=</span> <span style="color: #0000dd;">1</span><span style="color: #339933;">;</span> i <span style="color: #339933;">&lt;</span> shnum<span style="color: #339933;">;</span> i<span style="color: #339933;">++</span><span style="color: black;">&#41;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">&#40;</span> <span style="color: black;">&#40;</span>shdr<span style="color: black;">&#91;</span>i<span style="color: black;">&#93;</span>.<span style="color: #202020;">sh_flags</span> <span style="color: #339933;">&amp;</span> <span style="color: black;">&#40;</span>SHF_ALLOC <span style="color: #339933;">|</span> SHF_WRITE <span style="color: #339933;">|</span> SHF_EXECINSTR<span style="color: black;">&#41;</span><span style="color: black;">&#41;</span> <span style="color: #339933;">&amp;&amp;</span> shdr<span style="color: black;">&#91;</span>i<span style="color: black;">&#93;</span>.<span style="color: #202020;">sh_size</span> <span style="color: #339933;">&amp;&amp;</span> <span style="color: black;">&#40;</span>shdr<span style="color: black;">&#91;</span>i<span style="color: black;">&#93;</span>.<span style="color: #202020;">sh_type</span> <span style="color: #339933;">!=</span> SHT_NOBITS<span style="color: black;">&#41;</span><span style="color: black;">&#41;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; crc <span style="color: #339933;">=</span> crc32<span style="color: black;">&#40;</span>crc<span style="color: #339933;">,</span> file <span style="color: #339933;">+</span> shdr<span style="color: black;">&#91;</span>i<span style="color: black;">&#93;</span>.<span style="color: #202020;">sh_offset</span><span style="color: #339933;">,</span> shdr<span style="color: black;">&#91;</span>i<span style="color: black;">&#93;</span>.<span style="color: #202020;">sh_size</span><span style="color: black;">&#41;</span><span style="color: #339933;">;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">*</span>checksum <span style="color: #339933;">=</span> crc<span style="color: #339933;">;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">&#125;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* restore prelinked time */</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">&#40;</span>prelinked <span style="color: #339933;">!=</span> NULL<span style="color: black;">&#41;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">*</span>prelinked <span style="color: #339933;">=</span> old_time<span style="color: #339933;">;</span><br/>
&nbsp;</div>
<p>CRC32 algorithm uses standard reverse polynomial of 0xEDB88320. Such CRC32 routines are dime-a-dozen in viruses, especially for Win32 imports. However, just like the 'prelink' source code, you might consider using a lookup table to speed things up, since section images could be quite large. Such code could look something like this:</p>
<div class="asm" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: black; font-style: italic;">; Create CRC32 lookup table.</span><br/>
gen_CRC32_table<span style="color: #339933;">:</span><span style="color: #00007f; font-weight: bold;">lea</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rdi</span><span style="color: #339933;">,</span><span style="color: black;">&#91;</span>CRC32_Table<span style="color: black;">&#93;</span> &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; 1024 byte buffer (256 DWORDs)</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">xor</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">ebx</span><span style="color: #339933;">,</span><span style="color: #46aa03; font-weight: bold;">ebx</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>dword_loop<span style="color: #339933;">:</span>&nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">push</span>&nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rbx</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">pop</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rax</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">push</span>&nbsp; &nbsp; <span style="color: #ff0000;">8</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">pop</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rcx</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>bit_loop<span style="color: #339933;">:</span>&nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">shr</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">eax</span><span style="color: #339933;">,</span><span style="color: #ff0000;">1</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">jnc</span> &nbsp; &nbsp; <span style="color: #339933;">.</span>no_xor<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">xor</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">eax</span><span style="color: #339933;">,</span>CRC32_POLY<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>no_xor<span style="color: #339933;">:</span><span style="color: #00007f; font-weight: bold;">loop</span>&nbsp; &nbsp; <span style="color: #339933;">.</span>bit_loop<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">stosd</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">inc</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">bl</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">jnz</span> &nbsp; &nbsp; <span style="color: #339933;">.</span>dword_loop<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>exit<span style="color: #339933;">:</span>&nbsp; <span style="color: #00007f; font-weight: bold;">ret</span><br/>
<br/>
<span style="color: black; font-style: italic;">; Calculate CRC32 of buffer taking last CRC32 as argument</span><br/>
<span style="color: black; font-style: italic;">; RDX = input crc32</span><br/>
<span style="color: black; font-style: italic;">; RSI = input buffer</span><br/>
<span style="color: black; font-style: italic;">; RCX = length in bytes</span><br/>
<span style="color: black; font-style: italic;">; Output: crc32 in RDX.</span><br/>
<span style="color: black; font-style: italic;">;</span><br/>
<span style="color: #00007f; font-weight: bold;">CRC32</span><span style="color: #339933;">:</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">lea</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rbx</span><span style="color: #339933;">,</span><span style="color: black;">&#91;</span>CRC32_Table<span style="color: black;">&#93;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">not</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">edx</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; invert input crc</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">xor</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">rax</span><span style="color: #339933;">,</span><span style="color: #46aa03; font-weight: bold;">rax</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">.</span>bloop&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">lodsb</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">xor</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">al</span><span style="color: #339933;">,</span><span style="color: #46aa03; font-weight: bold;">dl</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">shr</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">edx</span><span style="color: #339933;">,</span><span style="color: #ff0000;">8</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">xor</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">edx</span><span style="color: #339933;">,</span><span style="color: black;">&#91;</span><span style="color: #46aa03; font-weight: bold;">rbx</span><span style="color: #339933;">+</span><span style="color: black;">&#40;</span><span style="color: #46aa03; font-weight: bold;">rax</span><span style="color: #339933;">*</span><span style="color: #ff0000;">4</span><span style="color: black;">&#41;</span><span style="color: black;">&#93;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">loop</span>&nbsp; &nbsp; <span style="color: #339933;">.</span>bloop<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">not</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">edx</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; invert output crc</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">ret</span><br/>
&nbsp;</div>
<p>Such routines should provide a considerable speedup over 1-bit at a time CRC32 routines.</p>
<p>This ends our discussion of prelink'd executables (and shared libraries).</p>
<h2><a name="cc"></a>Made Simple: .got.plt hooks for per-process residency</h2>
<p>Per-process residency is made simple by hooking function pointers in section '.got.plt' (global offset table - procedure linkage table). Section '.plt' (procedure linkage table) imports exported addresses from libraries, much like the PE IAT (import address table). .plt section contains series of 'JMP' instructions to imported functions - this JMP is to qword pointer held in .got.plt. .got.plt section contains an array of 64-bit pointers to imported functions. When hooking functions (usually in glibc) parameters are passed in registers using C calling convention (see section on 'glibc' above). This can be useful in some circumstances such as using hooks to infect files accessed: Most calls that take filenames, take the path string in the first argument (RDI), for example open/fopen/execve/chmod.</p>
<p>Hooking of imported procedures takes 3 steps:</p>
<ol>
<li>Locating memory address of function pointer .got.plt at infection time.</li>
<li>Hooking the function at runtime.</li>
<li>Executing the hook and re-hooking when hook is called.</li>
</ol>
<p>To locate memory address of pointer function(s) we want to hook at infection time in memory, we must use relocation section, dynamic symbol section and dynamic symbol string table section associated with '.plt'. We then loop the dynamic symbol table looking for symbol with the name we want (using .st_name field of Elf64_Sym structure). When the correct symbol is found we must save the index of it: first symbol in dynamic symbol section has index of zero. Once we have the symbol index of the function(s) we must walk the relocation section of .plt to find the address in memory of the qword pointing to our function in .got.plt. We are looking for a relocation with .r_info field having type of 'R_X86_64_JUMP_SLOT' and symbol index of the symbol for our targeted function that we just found. If such relocation item is found, r_offset field contains the address in .got.plt of the qword pointing to our function. We must save this address for runtime hooking, saving some sentinel value such as NULL, if qword to hook is not found.</p>
<p>Hooking of the function at runtime is quite simple, with one caveat: we must re-hook every time the function is called. This is because dynamic loader function '_resolve' resolves the true address of the function and then writes it back on each call preventing future calls to our hook. So we must re-hook on each call. With this in mind, if we have the address of qword to hook in .got.plt (check we do not have sentinel value) we save the address in this qword (original function address) and replace it with our hook for the function, which will be called the first time the target function is called.</p>
<p>When executing the hook and re-hooking the function on each call, the procedure hook as a structure something like this.</p>
<ul>
<li>Save flags,regs</li>
<li>Do what we must do before original function is called</li>
<li>Restore flags,regs</li>
<li>Call original function</li>
<li>Save flags,regs</li>
<li>Re-hook function</li>
<li>Do what we must do after function has been called</li>
<li>Restore flags,regs</li>
<li>Return to caller.</li>
</ul>
<p>This concludes our section on per-process residency using .got.plt hooks.</p>
<h2><a name="cd"></a>Conclusions</h2>
<p>Hopefully this guide was useful enough to get you writing Linux x64 viruses, it is not hard. You can get more information from the 'Links' section following. So we can come to 2 conclusions:</p>
<ol>
<li>Writing a basic Linux x64 infector is not a difficult thing. All you need to know is out there.</li>
<li>When you get to hell - tell the devil 'JPanic' sent you.</li>
</ol>
<h2><a name="ce"></a>Links</h2>
<ul>
<li>http://www.linuxmanpages.com/ Linux 'man' pages.</li>
<li>http://linux.die.net/man/ Linux 'man' pages.</li>
<li>http://ubuntu.wikimedia.org/git/ubuntu-jaunty/arch/sh/include/asm/unistd_64.h unistd_64.h - syscall numbers.</li>
<li>http://www.openwatcom.org/ftp/devel/docs/elf-64-gen.pdf Elf64 File Format.</li>
<li>http://dyxa.com/code.php?file=linux/elf.h Elf64 'include' file - structures and constants.</li>
<li>http://llvm.org/docs/doxygen/html/Support_2ELF_8h_source.html LLVM Elf include file - structures and constants.</li>
<li><a href="http://www.vxheavens.com/herm1t/">http://www.vxheavens.com/herm1t/</a> Herm1t's page - A lot of info on Linux viruses.</li>
<li>http://www.mcafee.com/us/resources/white-papers/wp-linux-viruses-elf-file-format.pdf White Paper on ELF infection by Marius Van Oers for Virus Bulletin Con. 2000</li>
</ul>
[<a style="" href="/lib/?lang=EN&amp;index=UN#vjp01">Back to index</a>] [<a href="/lib/vjp01.html#disqus_thread">Comments</a>]<br/> <div id="disqus_thread"></div>
<script type="text/rocketscript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'vxheaven'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="/agreement.php">Terms of Use</a>!</small> <small>vxheaven.org aka vx.netlux.org</small></div>
<div style="margin-top: 2px; float: left;" class="adsapeu">
<script type="text/rocketscript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script>
</div>
<script data-rocketsrc="http://www.google-analytics.com/urchin.js" type="text/rocketscript"></script><script type="text/rocketscript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="/lib/index.php?lang=de&amp;id=vjp01">de</a><a href="/lib/index.php?lang=en&amp;id=vjp01">en</a><a href="/lib/index.php?lang=es&amp;id=vjp01">es</a><a href="/lib/index.php?lang=it&amp;id=vjp01">it</a><a href="/lib/index.php?lang=fr&amp;id=vjp01">fr</a><a href="/lib/index.php?lang=pl&amp;id=vjp01">pl</a><a href="/lib/index.php?lang=ru&amp;id=vjp01">ru</a><a href="/lib/index.php?lang=ua&amp;id=vjp01">ua</a></div>
</body>
</html>
