<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title> Z0mbie 'Плугинный вирус - версия 2.00' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Author" content="Z0mbie"/>
<meta name="KeyWords" lang="en" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, Z0mbie,Плугинный вирус - версия 2.00, list, compressed, size, взаимодействие, event, entry, unload, события, контейнер, ring, событий, этот, внешний, памяти, return"/>
<meta name="Description" content="Вот уже давно мысль о плугинных вирусах циркулирует в вирмэйкерских головах, не дает им покоя, иногда даже мешает спать. Сегодня это актуально, сегодня есть интернет и несметные полчища наших тайных обожателей - юзеров - раззявив ебала и занеся пакши над баттонами YES и OK, ждут, чтобы мы использовали их ресурсы."/>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"047a5bcbf67431883fc9ed25fba33612",petok:"0cf792405dcdf6fcb4ba4431ad1970bb65734ac6-1498757842-1800",zone:"vxheaven.org",rocket:"a",apps:{}}];document.write('<script type="text/javascript" src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=85b614c0f6/cloudflare.min.js"><'+'\/script>');}}catch(e){};
//]]>
</script>
<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="/style.css"/><link rel="canonical" href="http://vxheaven.org/lib/vzo64.html"/>
<script type="text/rocketscript" data-rocketsrc="https://apis.google.com/js/plusone.js">{"parsetags": "explicit"}</script>
</head>
<body bgcolor="#dbc8a0" text="#302000" link="#225599" vlink="#113366">
<div class="s1">
<div style="float:right;"><a href="/lib/index.php?tbs=1"><img src="/img/max.gif" alt="Maximize"/></a></div> <form id="lf" style="margin: 0; float: right;" method="get" action="/index.php"><input type="hidden" name="action" value="set"/><select name="lang" onchange="javascript:document.getElementById('lf').submit();"><option value="ru">Русский</option><option selected="selected" value="en">English</option><option value="ua">Українська</option><option value="de">Deutsch</option><option value="es">Español</option><option value="fr">Fran&ccedil;ais</option><option value="it">Italiano</option><option value="pl">Polski</option></select></form>
<div style="float: right;"><div id="plusone"></div></div>
<script type="text/rocketscript">gapi.plusone.render("plusone", {"size":"small","count":"true"});</script>
<div style="float: right;" class="addthis_toolbox addthis_default_style">
<script type="text/rocketscript">var addthis_config = { ui_click: true }</script>
<a style="text-decoration: none; font-size: 10pt;" href="/?action=addthis" class="addthis_button_compact">Bookmark</a>
<script type="text/rocketscript" data-rocketsrc="http://s7.addthis.com/js/250/addthis_widget.js#username=herm1t"></script>
</div>
<div style="float: right;">
<script type="text/rocketscript" data-rocketsrc="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<form action="/search.php" id="cse-search-box">
<input type="hidden" name="cx" value="002577580816726040001:z9_irkorydo"/>
<input type="hidden" name="cof" value="FORID:10"/>
<input type="hidden" name="ie" value="UTF-8"/>
<input type="text" name="q" size="12" value=" "/>
<input type="submit" name="sa" value="Search"/>
</form>
</div><h1><a href="/" style="text-decoration: none; color: #000000;">VX Heaven</a></h1>
<span class="nav"><a href="/lib/">Library</a> <a href="/vl.php">Collection</a> <a href="/src.php">Sources</a> <a href="/vx.php?id=eidx">Engines</a> <a href="/vx.php?id=tidx">Constructors</a> <a href="/vx.php?id=sidx">Simulators</a> <a href="/vx.php?id=uidx">Utilities</a> <a href="/links.php">Links</a> <a href="/donate.php" style="color: #706020" id="donate">Donate</a> <a href="/forum" style="text-decoration: underline;">Forum</a> </span><br clear="all"/>
</div>
<div class="s2"><h1>Плугинный вирус - версия 2.00</h1><p><a href="/lib/?lang=ru&amp;author=Z0mbie"> Z0mbie</a><br/></p><script type="text/rocketscript">var disqus_url = 'http://vxheaven.org/lib/vzo64.html';</script>[<a style="" href="/lib/?lang=RU&amp;index=VT#vzo64">Вернуться к списку</a>] [<a href="/lib/vzo64.html#disqus_thread">Комментарии</a>]<br/> 
<ol>
<li><a href="#c1">Введение</a></li>
<li><a href="#c2">Модульная структура в общем виде</a></li>
<li><a href="#c3">Внешний контейнер</a></li>
<li><a href="#c4">Плугины - на диске и в памяти</a></li>
<li><a href="#c5">Формат плугина</a></li>
<li><a href="#c6">Загрузчик</a></li>
<li><a href="#c7">Взаимодействие плугинов</a></li>
<li><a href="#c8">Взаимодействие плугинов через события</a></li>
<li><a href="#c9">Приоритет вызовов событий</a></li>
<li><a href="#ca">Взаимодействие плугинов через импорты/экспорты</a></li>
<li><a href="#cb">Взаимодействие плугинов с загрузчиком (аттач/детач)</a></li>
<li><a href="#cc">Оформление подпрограмм</a></li>
<li><a href="#cd">Обработка ошибок (SEH)</a></li>
<li><a href="#ce">Выбор числовых констант</a></li>
<li><a href="#cf">Фича: FUCKAPI</a></li>
</ol>
<h2><a name="c1"></a>1. Введение</h2>
<p>Вот уже давно мысль о плугинных вирусах циркулирует в вирмэйкерских головах, не дает им покоя, иногда даже мешает спать. Сегодня это актуально, сегодня есть интернет и несметные полчища наших тайных обожателей - юзеров - раззявив ебала и занеся пакши над баттонами YES и OK, ждут, чтобы мы использовали их ресурсы.</p>
<p>Почему плугины?</p>
<p>Да, вирус, состоящий из отдельных модулей, действительно сложнее написать. Но модульная структура просто предназначена для обновления через интернет; и кроме того, возможно по-разному комбинируя плугины создавать функционально различные вирусы. Трудно предвидеть сейчас, какими возможностями мы захотим чтобы обладал вирус, после того, как он разойдется по тысячам компьютеров. А обновление одного плугина намного проще, чем обновление всего вируса. И наконец, это возможность дальнейшего развития, это повод для вирмэйкеров объединить усилия.</p>
<p>На сегодня существует один реальный модульный вирус - это Hybris, и он показал себя отлично. Однако, моя субъективная оценка такова, что к хибрисовской системе плугинов трудно подключить что-нибудь свое, а построить на этой базе что-то действительно сложное, будет совсем не просто. Это не значит ничего плохого, хибрис по настоящему великолепен.</p>
<p>Просто мне этого мало.</p>
<p>Поэтому в то время, как в теплой бразилии рос хибрис, здесь, у нас, была предпринята попытка разработать свою собственную концепцию плугинного вируса, то есть вируса, по настоящему построенного на основе модулей: так, как я это вижу.</p>
<p>Основное отличие заключается вот в чем. У хибриса это действительно ПЛУГИНЫ, то есть просто дополнительные фичи, прикручиваемые к вирусу. В проекте PGN2, плюс к тому что есть у хибриса, абсолютно ВЕСЬ вирус состоит из МОДУЛЕЙ, каждый из которых может быть обновлен.</p>
<p>С другой стороны, хибрис направлен на интернет: большая часть его основных модулей ориетирована на распространение по сети. В проекте PGN2 распространение по интернету почти не поддерживается. То есть там все для этого есть, но самих плугинов для конкретно распространения - в опубликованных архивах - нет. Потому что PGN2 в первую очередь показывает реализацию модульной структуры, схему взаимодействия плугинов.</p>
<p>Далее вам представляется краткое описание системы PGN2.</p>
<h2><a name="c2"></a>2. Модульная структура в общем виде</h2>
<p>Вирус в зараженном файле: (местоположение расшифровщика и зашифрованных данных зависит от метода заражения)</p>
<pre>
 +---hostfile.exe/dll----+
 | [...]                 |
 | [расшифровщик]        |
 | [...]                 |
 | [зашифрованный вирус] |
 | [...]                 |
 +-----------------------+
</pre>
<p>Физическая (начальная) структура вируса, находящегося в зашифрованном файле, после расшифровки, выглядит так:</p>
<pre>
 +----------------------+
 | [LDRWIN32.bin]       | &lt;-- загрузчик, для распаковки/запуска плугинов,
 | [compressed_plugin1] |     необходим
 | [compressed_plugin2] | &lt;-- запакованные плугины в формате PGN2,
 | [...]                |     присутствие опционально
 | [DD 0]               | &lt;-- завершающий DWORD=0, необходим загрузчику
 +----------------------+
</pre>
<h2><a name="c3"></a>3. Внешний контейнер</h2>
<p>Внешний контейнер: (наличие контейнера опционально)</p>
<pre>
 +----------------------+
 | [compressed_plugin3] | &lt;-- плугины в формате PGN2,
 | [compressed_plugin4] |     присутствие опционально
 | [...]                |
 | [DD 0]               | &lt;-- завершающий DWORD=0, необходим загрузчику
 +----------------------+
</pre>
<p>Внешний контейнер - это файл, в котором хранится часть вирусных плугинов. Ни один плугин (кроме загрузчика) с внешним контейнером непосредственно не работает. При аттаче свежевыкачанного плугина этот плугин автоматически (загрузчиком) добавляется во внешний контейнер. Когда стартует инфицированный файл, содержащий более новую версию некоторого плугина, этот плугин также будет добавлен в контейнер. Когда запускается файл, содержащий более старую версию некоторого плугина, или не содержащий его, этот плугин будет взят загрузчиком из контейнера.</p>
<p>Таким образом, как только плугин принят из интернета и расшифрован, вызывается операция аттача плугина, и плугин</p>
<ol>
<li>добавляется во внешний контейнер (возможно, заменяя старую версию)</li>
<li>подключается к работающей копии вируса и исполняется.</li>
</ol>
<p>При последующем же запуске файла со старой версией плугина, этот плугин будет заменен более новым, хранящимся в контейнере. Также, все в дальнейшем инфицируемые файлы будут содержать самые последние плугины.</p>
<p>Единственно, пока еще не реализована возможность шифровки внешнего контейнера.</p>
<h2><a name="c4"></a>4. Плугина - на диске и в памяти</h2>
<p>Для удобства работы с плугинами они организованы в список. Структура вируса в памяти: (список плугинов в памяти)</p>
<pre>
LDRWIN32.PluginList DD ? &lt;-- указатель на первую запись
        |
 +--------------+ --> физический образ (сжатый, формат PGN2)
 | list entry 1 | --> образ в памяти (исполняющийся PE EXE)
 +--------------+
        |
 +--------------+ --> ...
 | list entry N | --> ...
 +--------------+
        |
       NULL
</pre>
<div class="asm" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">list_entry&nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">struc</span><br/>
list_phys &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">dd</span>&nbsp; &nbsp; &nbsp; ? &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; *pgn2_header, physical image</span><br/>
list_virt &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">dd</span>&nbsp; &nbsp; &nbsp; ? &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; *PE_in_memory, virtual image</span><br/>
list_next &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">dd</span>&nbsp; &nbsp; &nbsp; ? &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; next list entry or NULL</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ends<br/>
&nbsp;</div>
<p>Другими словами, на каждый плугин в памяти хранятся два образа: один - запакованный, то есть тот, который добавляется в каждый новый зараженный файл; а другой - распакованный в память PE EXE, который в настоящее время и исполняется.</p>
<h2><a name="c5"></a>5. Формат плугина</h2>
<p>Поскольку плугины представлены в формате PE EXE, писать их можно практически на чем угодно, подходящих компиляторов также полно, хотя мне вполне хватило tasm'а и borland c++.</p>
<p>Единственно, откомпилированные PE-файлы должны удовлетворять следующим требованиям:</p>
<ol>
<li>содержать фиксапы (если они используются в откомпилированном образе)</li>
<li>не содержать ресурсов (ресурсы будут поскипаны)</li>
</ol>
<p>После компилирования, с PE файлом следует сделать следующее:</p>
<dl>
<dt>Тулза PE2PGN:</dt>
<dd><ol>
<li>поскипать MZ-заголовок и DOS-овую часть</li>
<li>перерелоцировать на imagebase=0, physicaloffset=0</li>
<li>выкинуть ресурсы и фиксапы с типом 0</li>
<li>обнулить PE id, datetime, checksum, и прочие, в дальнейшем не используемые поля</li>
</ol></dd>
<dt>Тулза PACKER:</dt>
<dd><ol start="5">
<li>сжать файл</li>
</ol></dd>
<dt>Тулза HEADER:</dt>
<dd><ol start="6">
<li>добавить PGN2-заголовок (DWORD CRC32-id, DWORD version)</li>
</ol></dd>
</dl>
<p>Таким образом, физически плугины в формате PGN 2, а виртуально (в памяти) - в формате PE EXE.</p>
<pre>
 +---------------------+
 | CRC32-id            | ; crc32('имя плугина')
 +---------------------+
 | version             | ; версия
 +---------------------+
 | compressed_size     | ; длина запакованных данных (Z_CODING)
 +---------------------+
 | decompressed_size   | ; длинна распакованных данных
 +---------------------+
 | запакованный PE EXE | ; длина = compressed_size
 | ...                 |
 +---------------------+
</pre>
<div class="asm" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">pgn2_header &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">struc</span><br/>
pgn2_id &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">dd</span>&nbsp; &nbsp; &nbsp; ? &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; CRC32('lowercased name')</span><br/>
pgn2_version&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">dd</span>&nbsp; &nbsp; &nbsp; ? &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; 1,2,... &gt;=100000--not-in-file</span><br/>
pgn2_compressed &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">dd</span>&nbsp; &nbsp; &nbsp; ? &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; compressed data size</span><br/>
pgn2_decompressed &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">dd</span>&nbsp; &nbsp; &nbsp; ? &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; decompressed data size, PE format</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; BYTE * compressed_size</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ends<br/>
&nbsp;</div>
<p>DWORD CRC32-id, который идет до запакованного тела плугина - это CRC32 от имени плугина маленькими буквами.</p>
<p>DWORD version - это версия плугина, которая если >= 100000, то такой плугин не будет добавляться в новоинфицируемые файлы. Это значит, что такой плугин будет храниться только во внешнем контейнере, и подгружаться оттуда при каждом запуске, но никогда не будет включен в зараженный файл. Это фича используется тогда, когда новые версии этого плугина планируется постоянно выкачивать из инета.</p>
<p>В плане загрузки плугинов в память (а загружает их туда наш собственный загрузчик), существуют следующие отличия:</p>
<ul>
<li>imagebase больше не должен быть выровнен, нам это пофигу, так как
<ul style="list-style: none;">
<li>в ring3: выделение памяти через GlobalAlloc, align=DWORD</li>
<li>в ring0: выделение памяти через PageAllocate, align=4K</li>
</ul></li>
<li>большинство записей в PE-заголовке нулевые, т.е. не используются</li>
<li>аттрибуты и имена секций не имеют смысла (вся память r/w), нам нужны только оффсеты и длины</li>
<li>при импорте функций из других плугинов - имена плугинов начинаются на @</li>
<li>возможны любые импорты, экспорты и фиксапы,
<ul style="list-style: none;">
<li>также возможны экспорты из системных DLL'ек по именам</li>
</ul></li>
<li>не поддерживаются ресурсы</li>
<li>точка входа (если есть) вызывается первой</li>
<li>затем вызывается начальное событие</li>
<li>возможно наличие экспортируемой подпрограммы unload()</li>
<li>подпрограммы интерплугинного взаимодействия:
<ul style="list-style: none;">
<li>экспортируемая HandleEvent() и импортируемая Event() (опционально)</li>
</ul></li>
</ul>
<h2><a name="c6"></a>6. Загрузчик</h2>
<p>LDRWIN32 - это специальный плугин, содержащий в себе блок кода LDRWIN32.bin, причем каждый из них называется загрузчиком. LDRWIN32.bin - это блок кода, который просто содержится внутри соответствующего плугина, и выполняет следующие функции: если к этому блоку кода приписать пачку плугинов (запакованных, в формате PGN2), и передать ему управление, то он построит в памяти список плугинов, распакует туда PE EXE-образы и запустит вирус.</p>
<p>Более точно, задача загрузчика такая:</p>
<ul>
<li>взять все имеющиеся плугины;</li>
<li>загрузить дополнительные плугины из внешнего контейнера;</li>
<li>выбрать новейшие;</li>
<li>построить список плугинов;</li>
<li>распаковать плугины;</li>
<li>загрузить их в память как PE-файлы;</li>
<li>настроить фиксапы, ипморты и экспорты;</li>
<li>вызвать все точки входа (для каждого плугина);</li>
<li>послать плугинам начальное событие;</li>
<li>если событие не обработано, освободить память;</li>
<li>вернуться в программу-носитель.</li>
</ul>
<p>Также загрузчик содержит подпрограмму LDRWIN32.ldrwin32_copy(), которая вызывается для построения новой копии вируса (нового списка плугинов). Эта подпрограмма использует текущий список плугинов как родительский, и без чтения внешнего контейнера, просто выделяет память под копию списка и образы плугинов и копирует их туда, после чего генерит соответствующее событие. В настоящее время эта фича используется (под win9x) для построения второй активной копии вируса в ring-0.</p>
<p>Кроме того, плугин LDRWIN32 содержит следующие public-функции и переменные:</p>
<p>PluginList - указатель на первую запись списка плугинов. (см.PGN2.INC)</p>
<div class="asm" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">list_entry&nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">struc</span><br/>
list_phys &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">dd</span>&nbsp; &nbsp; &nbsp; ? &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; *pgn2_header, physical image</span><br/>
list_virt &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">dd</span>&nbsp; &nbsp; &nbsp; ? &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; *PE_in_memory, virtual image</span><br/>
list_next &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">dd</span>&nbsp; &nbsp; &nbsp; ? &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; next list entry or NULL</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ends<br/>
&nbsp;</div>
<p>Чтобы получить значение импортируемого DWORD'а, надо сделать так:</p>
<div class="asm" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">&nbsp; &nbsp; &nbsp; &nbsp; extrn &nbsp; TestDword<span style="color: #339933;">:</span><span style="color: #0000ff; font-weight: bold;">DWORD</span> &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; make imported entry</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">mov</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">eax</span><span style="color: #339933;">,</span> TestDword <span style="color: #339933;">+</span> <span style="color: #ff0000;">2</span>&nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; FF 25 xx xx xx xx: JMP DWORD PTR [xxxxxxxx]</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">mov</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">eax</span><span style="color: #339933;">,</span> <span style="color: black;">&#91;</span><span style="color: #46aa03; font-weight: bold;">eax</span><span style="color: black;">&#93;</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; = address</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">mov</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">eax</span><span style="color: #339933;">,</span> <span style="color: black;">&#91;</span><span style="color: #46aa03; font-weight: bold;">eax</span><span style="color: black;">&#93;</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; = value</span><br/>
&nbsp;</div>
<p>Вместо этого можно ипортировать функцию LDRWIN32.GetPluginList(), которая вернет значение PluginList в EAX.</p>
<h2><a name="c7"></a>7. Взаимодействие плугинов</h2>
<p>Реализованы две взаимодополняющих схемы взаимодействия плугинов: через внутренние события и через импортируемые/экспортируемые функции.</p>
<p>Отличие схем в том, что при взаимодействии через события, плугин(ы), принимающие события могут как присутствовать так и нет; но если некий плугин A импортирует функцию из плугина B, то плугин B присутствовать обязан, причем эта функция должна быть описана в его экспортах; в противном случае плугин А будет отключен.</p>
<p>Таким образом взаимодействие через импорты/экспорты обеспечивает доступ к основным, общим функциям, типа работы с памятью и файлами, а событиями обеспечивается подключение плугинов "на будущее".</p>
<h2><a name="c8"></a>8. Взаимодействие плугинов через события</h2>
<p>Под событиями имеется в виду внутренняя модель событий, но, конечно же, никак не маздайные события. Хотя и на них тоже можно бы было построить взаимодействие плугинов.</p>
<p>Общение между плугинами происходит так:</p>
<p>Для того, чтобы принимать события из других плугинов, плугин экспортирует функцию HandleEvent().</p>
<p>Для того, чтобы посылать события, плугин импортирует функцию Event() из загрузчика LDRWIN32.</p>
<p>У каждого события есть уникальный номер и один юзерский параметр.</p>
<p>Для вызова события, делаем так:</p>
<div class="asm" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">...</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">extern</span>&nbsp; Event<span style="color: #339933;">:</span>PROC&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; объявляем импортируемую процедуру, из LDRWIN32</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">...</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">push</span>&nbsp; &nbsp; &lt;user_param&gt;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">push</span>&nbsp; &nbsp; &lt;event_id&gt;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">call</span>&nbsp; &nbsp; Event &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; вызываем загрузчик,</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">add</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">esp</span><span style="color: #339933;">,</span> <span style="color: #ff0000;">8</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; он распределяет событие по всем плугинам</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">...</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">or</span>&nbsp; &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">eax</span><span style="color: #339933;">,</span> <span style="color: #46aa03; font-weight: bold;">eax</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">jnz</span> &nbsp; &nbsp; event_handled<br/>
event_not_handled<span style="color: #339933;">:</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">...</span><br/>
&nbsp;</div>
<p>или, на C++</p>
<div class="c" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">&nbsp; &nbsp; &nbsp; &nbsp; ...<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> __cdecl Event<span style="color: black;">&#40;</span>DWORD EventID<span style="color: #339933;">,</span> DWORD UserParam<span style="color: black;">&#41;</span><span style="color: #339933;">;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; ...<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">&#40;</span> Event<span style="color: black;">&#40;</span><span style="color: #339933;">&lt;</span>event_id<span style="color: #339933;">&gt;,</span> <span style="color: #339933;">&lt;</span>user_param<span style="color: #339933;">&gt;</span><span style="color: black;">&#41;</span> <span style="color: black;">&#41;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">&#123;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ... <span style="color: black; font-style: italic;">// event handled</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">&#125;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; ...<br/>
&nbsp;</div>
<p>Подпрограмма LDRWIN32.Event просто распределяет событие по тем плугинам, у которых есть public-подпрограмма HandleEvent.</p>
<p>Так что, для обработки событий, делаем так:</p>
<div class="asm" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">...</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #0000ff; font-weight: bold;">public</span>&nbsp; HandleEvent &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; объявляем экспортируемую подпрограмму</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">...</span><br/>
HandleEvent<span style="color: #339933;">:</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">mov</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">eax</span><span style="color: #339933;">,</span> <span style="color: black;">&#91;</span><span style="color: #46aa03; font-weight: bold;">esp</span><span style="color: #339933;">+</span><span style="color: #ff0000;">4</span><span style="color: black;">&#93;</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; event_id</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">mov</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">ecx</span><span style="color: #339933;">,</span> <span style="color: black;">&#91;</span><span style="color: #46aa03; font-weight: bold;">esp</span><span style="color: #339933;">+</span><span style="color: #ff0000;">8</span><span style="color: black;">&#93;</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; user_param</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">...</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f; font-weight: bold;">mov</span> &nbsp; &nbsp; <span style="color: #46aa03; font-weight: bold;">eax</span><span style="color: #339933;">,</span> <span style="color: #ff0000;">0</span><span style="color: #339933;">/</span><span style="color: #ff0000;">1</span><span style="color: #339933;">/-</span><span style="color: #ff0000;">1</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">; return value</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; retn<br/>
&nbsp;</div>
<p>или, на C++</p>
<div class="c" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> __export __cdecl HandleEvent<span style="color: black;">&#40;</span>DWORD EventID<span style="color: #339933;">,</span> DWORD UserParam<span style="color: black;">&#41;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">&#123;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">&#40;</span>EventID <span style="color: #339933;">==</span> <span style="color: #339933;">&lt;</span>some_event_id<span style="color: #339933;">&gt;</span><span style="color: black;">&#41;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">&#123;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #0000dd;">1</span><span style="color: #339933;">/-</span><span style="color: #0000dd;">1</span><span style="color: #339933;">;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">&#125;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #0000dd;">0</span><span style="color: #339933;">;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">&#125;</span><br/>
&nbsp;</div>
<p>Как видно, подпрограмма Event возвращает результат в EAX:</p>
<ul>
<li>0 если событие не было обработано</li>
<li>-1 если событие было обработано с результатом -1 (остановить распределение событий)</li>
<li>N если N плугинов обработали событие с результатом 1</li>
</ul>
<p>Очевидно, что после того, как некоторое событие обрабатывается (подпрограммой HandleEvent) с результатом -1, загрузчик просто останавливает распределение событий и возвращает -1 как результат. В остальных случаях LDRWIN32.Event просто суммирует результаты от HandleEvent()'ов (нули и единицы) и возвращает сумму.</p>
<h2><a name="c9"></a>9. Приоритет вызовов событий</h2>
<p>Предположим, что несколько плугинов висят на одном и том же событии, то есть ждут его, и затем производят какие-то действия.</p>
<p>Как выяснить, в каком порядке они (плугины) должны вызываться при распределении событий?</p>
<p>Для этого у каждого плугина есть параметр PRIORITY, от 0 до 10 включительно, в соответствии с которым загрузчик решает, какой плугин вызовется раньше, а какой позже.</p>
<p>По умолчанию значение PRIORITY должно быть равно 5, и изменять его не рекомендуется.</p>
<p>Если вы пишете плугин A, который должен (при одном и том же событии) быть вызван раньше плугина B, то поставьте для A значение PRIORITY на 1 меньше.</p>
<h2><a name="ca"></a>10. Взаимодействие плугинов через импорты/экспорты</h2>
<p>В дополнение к функциям HandleEvent() и Event(), которые суть основной способ коммуникации между плугинами, плугины могут использовать импорты и экспорты друг между другом, и иморты из системных DLL'ек по именам.</p>
<p>Единственное отличие от импортов из системных DLL'ек в том, что имена импортируемых плугинов в import table должны начинаться на @.</p>
<p>Пример .DEF-файла, передаваемого TLINK32'у при линковке плугина:</p>
<div class="def" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">EXPORTS<br/>
&nbsp; &nbsp; &nbsp; &nbsp; HandleEvent<br/>
IMPORTS<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Event = @LDRWIN32.Event<br/>
&nbsp; &nbsp; &nbsp; &nbsp; fuckit = KERNEL32.DeleteFileA<br/>
&nbsp; &nbsp; &nbsp; &nbsp; ...<br/>
&nbsp;</div>
<h2><a name="cb"></a>11. Взаимодействие поугинов с загркзчиком (аттач/детач)</h2>
<p>У плугинов может быть ненулевая точка входа (EntryPointRVA), которая вызывается сразу после того, как плугин будет загружен в память, но до посылки каких-либо событий. Во время этого вызова также возможно вызывать события. У процедуры EntryPoint() один DWORD-параметр, который обычно равен нулю. Но может также содержать и некоторое другое значение - код возврата из процедуры unload(). А эта процедура, если она в плугине есть, вызывается до того, как плугин будет выгружен из памяти, в случае апдейта плугина более новой версией, либо в случае просто выгрузки плугина из памяти. Если это выгрузка из памяти, то unload() должна освободить всю выделенную память и убить все созданные нити. Если это апдейт, то есть возможность передать некоторые данные из старой версии плугина в новую.</p>
<div class="c" style="font-family:monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333;">void</span> __export __cdecl EntryPoint<span style="color: black;">&#40;</span>DWORD oldver_unload_code<span style="color: black;">&#41;</span><br/>
<span style="color: black;">&#123;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">&#40;</span>oldver_unload_code <span style="color: #339933;">==</span> <span style="color: #0000dd;">0</span><span style="color: black;">&#41;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">&#123;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ... &nbsp; &nbsp; <span style="color: #339933;">;</span> просто загрузка в память<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">&#125;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">else</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">&#123;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ... &nbsp; &nbsp; <span style="color: #339933;">;</span> замена старой версии в рантайме<span style="color: #339933;">,</span> при этом oldver_unload_code<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #339933;">;</span> может быть указателем на некоторые данные<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">&#125;</span><br/>
<span style="color: black;">&#125;</span> <span style="color: black; font-style: italic;">//EntryPoint</span><br/>
<br/>
<span style="color: #993333;">int</span> __export __cdecl unload<span style="color: black;">&#40;</span><span style="color: #993333;">int</span> why<span style="color: black;">&#41;</span><br/>
<span style="color: black;">&#123;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">&#40;</span>why<span style="color: #339933;">==</span>UT_UNINSTALL<span style="color: black;">&#41;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">&#123;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ... &nbsp; &nbsp; <span style="color: #339933;">;</span> выгрузка из памяти<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #0000dd;">0</span><span style="color: #339933;">;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">&#125;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">&#40;</span>why<span style="color: #339933;">==</span>UT_UPDATE<span style="color: black;">&#41;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">&#123;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ... &nbsp; &nbsp; <span style="color: #339933;">;</span> апдейт<span style="color: #339933;">,</span> т.е. выгрузка<span style="color: #339933;">,</span> с тем чтобы заменить новой версией<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #0000dd;">1</span><span style="color: #339933;">;</span><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">&#125;</span><br/>
<span style="color: black;">&#125;</span> <span style="color: black; font-style: italic;">//unload</span><br/>
&nbsp;</div>
<p>Следующие две public-подпрограммы, существующие в загрузчике, позволяют производить аттач и детач плугинов в рантайме.</p>
<ol>
<li><pre>int __cdecl ldrwin32_attach(BYTE* buf, DWORD* bufsize)</pre>
<p>Приаттачить пачку плугинов. Буфер - набор запакованных плугинов, желательно чтобы все заканчивалось на 'DD 0'. То есть формат буфера такой же, как и у внешнего контейнера. Длина буфера используется на случай, когда не найден завершающий 'DD 0'.</p>
<p>Если один из этих новопришедших плугинов у нас уже есть, то в загрузчике происходит следующее:</p>
<ul>
<li>проверить, если пришедший плугин новый; обновить внешний контейнер</li>
<li>старые плугины: вызвать unload(UT_UPDATE), запомнить exitcode (exitcode может быть указателем на динамически-аллоцируемый блок)</li>
<li>старые плугины: освободить память</li>
<li>новые плугины: распаковать, загрузить в память, настроить импорты, экспорты, фиксапы</li>
<li>заново проверить наличие всех наобходимых экспортов между всеми плугинами, и пометить плугины, которым не хватает экспортов, как UNRESOLVED (и в дальнейшем они работать не будут)</li>
<li>новые плугины: вызвать точки входа, передавая exitcodе от соответствующих unload()'ов как параметр</li>
</ul>
<p>После аттача, генерится евент EV_LDRWIN32_ATTACHED</p></li>
<li><pre>void __cdecl ldrwin32_detach_me()</pre>
<p>Эта продпрограмма вызывается, когда какой-то плугин хочет себя отгрузить.</p>
<p>Вызывающий плугин в таком случае будет ЗАМЕНЕН фэйковым (нулевым) плугином с версией на 1 больше, но с тем же ID, и с нулевыми compressed/decompressed size.</p>
<p>Этот новый нулевой плугин будет сохранен во внешний контейнер, в дальнейшем по возможности замещая старую версию, которая захотела себя детачить.</p>
<p>Детач используется когда некий плугин считает, что выполнил свою миссию, и больше не должен на этой машиние исполняться никогда.</p>
<p>После детача генерится евент EV_LDRWIN32_DETACHED.</p></li>
</ol>
<h2><a name="cc"></a>12. Оформление подпрограмм</h2>
<p>Желательно, чтобы все public-подпрограммы были написаны согласно с cdecl конвенцией, то есть:</p>
<ul>
<li>порядок PUSHа параметров на стэк <em>обратный</em>, т.е. после CALL'а, первый (последний запушеный) параметр находится по адресу [ESP+4], 2й по [ESP+8].</li>
<li>выход из подпрограмм по RETN (0xC3)</li>
<li>после CALL'а вызывающий делает &lt;ADD ESP, 4 * число_параметров></li>
<li>подпрограммы могут изменять EAX,ECX,EDX</li>
<li>подпрограммы не могут изменять EBX,ESI,EDI,EBP</li>
<li>функции возвращают результат в EAX</li>
</ul>
<h2><a name="cd"></a>13. Обработка ошибок (SEH)</h2>
<ol>
<li>SEH'ом ошибки обрабатываются только во время вызовов EVENT'ов. Когда вызывается EntryPoint или unload(), никакого SEH'а, кроме общего, нет.
<p>Когда обрабатывается возникшая ошибка, загрузчик LDRWIN32 ищет адрес ошибки, затем по этому адресу - соответствующий плугин, и отключает этот плугин. (ставит флаг FL_PGN2_SEHERROR)</p>
<p>После этого происходит операция обновления межплугинных импортов/экспортов, и все плугины, директом (не через события) вызывающие глючный, будут также отключены. (UNRESOLVED)</p></li>
<li>Так как система PGN2 была разработана под win32/ring-3, т.е. win9x/ring0-код возможен, но не желателен, то логика работы не должна основываться на ring-0.
<p>Весь ring0-код должен быть по возможности коротким и независимым, дабы не сглючило.</p></li>
</ol>
<h2><a name="ce"></a>14. Выбор числовых констант</h2>
<p>В случае, если вы пишете плугин, который должен будет посылать события другим плугинам, для этих событий придется выбрать уникальные номера. Я предлагаю сделать это так: к имени плугина (маленькими буквами) припишите свой никнэйм и посчитайте от этого дела CRC32 (прилагается тулза CRC32). Затем прибавляя к полученному числу 0,1,2 и т.д. получите уникальные номера для ваших событий. Сделано это исключительно для того, чтобы номера событий не пересекались, в том фантастическом случае, если вы захотите поддержать проект парой своих собственных плугинов.</p>
<h2><a name="cf"></a>15. Фича: FUCKAPI</h2>
<p>Поскольку часть интерплугинного взаимодействия возлагается на импорты/экспорты, то плугины будут содержать имена своих public-подпрограмм, что хорошо для касперского, а значит плохо для нас.</p>
<p>Поэтому была придумана фича, кояя сделает изучение бинарной версии вируса незабываемой.</p>
<p>Итак, имена всех плугинов и public-процедур во всех плугинах, обрабатываются следующим образом:</p>
<ol>
<li>первый символ @ пропускается (если он есть)</li>
<li>от имени считается crc32</li>
<li>этим crc32 инициализируется randseed, после чего генерируется строка из псевдослучайных символов (1..255), в ту же длину</li>
</ol>
<p>Естественно, что это справедливо только для интерплугинных public-процедур, а при импорте из kernel'а имена останутся без изменений.</p>
[<a style="" href="/lib/?lang=RU&amp;index=VT#vzo64">Вернуться к списку</a>] [<a href="/lib/vzo64.html#disqus_thread">Комментарии</a>]<br/> <div id="disqus_thread"></div>
<script type="text/rocketscript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'vxheaven'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="/agreement.php">Terms of Use</a>!</small> <small>vxheaven.org aka vx.netlux.org</small></div>
<div style="margin-top: 2px; float: left;" class="adsapeu">
<script type="text/rocketscript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script>
</div>
<script data-rocketsrc="http://www.google-analytics.com/urchin.js" type="text/rocketscript"></script><script type="text/rocketscript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="/lib/index.php?lang=de&amp;id=vzo64">de</a><a href="/lib/index.php?lang=en&amp;id=vzo64">en</a><a href="/lib/index.php?lang=es&amp;id=vzo64">es</a><a href="/lib/index.php?lang=it&amp;id=vzo64">it</a><a href="/lib/index.php?lang=fr&amp;id=vzo64">fr</a><a href="/lib/index.php?lang=pl&amp;id=vzo64">pl</a><a href="/lib/index.php?lang=ru&amp;id=vzo64">ru</a><a href="/lib/index.php?lang=ua&amp;id=vzo64">ua</a></div>
</body>
</html>
