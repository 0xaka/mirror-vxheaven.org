<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Eric Filiol, Marko Helenius, Stefano Zanero 'Open problems in computer virology' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Author" content="Eric Filiol, Marko Helenius, Stefano Zanero"/>
<meta name="KeyWords" lang="en" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, Filiol, Eric; Helenius, Marko; Zanero, Stefano,Open problems in computer virology, computer, mathcal, integrity, complexity, quantum, theoretical, varphi, model, mail, virus, time, text, functions, detection, evolved"/>
<meta name="Description" content="In this article, we briefly review some of the most important open problems in computer virology, in three different areas: theoretical computer virology, virus propagation modeling and antiviral techniques. For each area, we briefly describe the open problems, we review the state of the art, and propose promising research directions."/>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"047a5bcbf67431883fc9ed25fba33612",petok:"c9b038def14403705eddc208163e1a6deae0926f-1498756888-1800",zone:"vxheaven.org",rocket:"a",apps:{}}];document.write('<script type="text/javascript" src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=85b614c0f6/cloudflare.min.js"><'+'\/script>');}}catch(e){};
//]]>
</script>
<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="/style.css"/><link rel="canonical" href="http://vxheaven.org/lib/aef03.html"/>
<script type="text/rocketscript" data-rocketsrc="https://apis.google.com/js/plusone.js">{"parsetags": "explicit"}</script>
</head>
<body bgcolor="#dbc8a0" text="#302000" link="#225599" vlink="#113366">
<div class="s1">
<div style="float:right;"><a href="/lib/index.php?tbs=1"><img src="/img/max.gif" alt="Maximize"/></a></div> <form id="lf" style="margin: 0; float: right;" method="get" action="/index.php"><input type="hidden" name="action" value="set"/><select name="lang" onchange="javascript:document.getElementById('lf').submit();"><option value="ru">Русский</option><option selected="selected" value="en">English</option><option value="ua">Українська</option><option value="de">Deutsch</option><option value="es">Español</option><option value="fr">Fran&ccedil;ais</option><option value="it">Italiano</option><option value="pl">Polski</option></select></form>
<div style="float: right;"><div id="plusone"></div></div>
<script type="text/rocketscript">gapi.plusone.render("plusone", {"size":"small","count":"true"});</script>
<div style="float: right;" class="addthis_toolbox addthis_default_style">
<script type="text/rocketscript">var addthis_config = { ui_click: true }</script>
<a style="text-decoration: none; font-size: 10pt;" href="/?action=addthis" class="addthis_button_compact">Bookmark</a>
<script type="text/rocketscript" data-rocketsrc="http://s7.addthis.com/js/250/addthis_widget.js#username=herm1t"></script>
</div>
<div style="float: right;">
<script type="text/rocketscript" data-rocketsrc="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<form action="/search.php" id="cse-search-box">
<input type="hidden" name="cx" value="002577580816726040001:z9_irkorydo"/>
<input type="hidden" name="cof" value="FORID:10"/>
<input type="hidden" name="ie" value="UTF-8"/>
<input type="text" name="q" size="12" value=" "/>
<input type="submit" name="sa" value="Search"/>
</form>
</div><h1><a href="/" style="text-decoration: none; color: #000000;">VX Heaven</a></h1>
<span class="nav"><a href="/lib/">Library</a> <a href="/vl.php">Collection</a> <a href="/src.php">Sources</a> <a href="/vx.php?id=eidx">Engines</a> <a href="/vx.php?id=tidx">Constructors</a> <a href="/vx.php?id=sidx">Simulators</a> <a href="/vx.php?id=uidx">Utilities</a> <a href="/links.php">Links</a> <a href="/donate.php" style="color: #706020" id="donate">Donate</a> <a href="/forum" style="text-decoration: underline;">Forum</a> </span><br clear="all"/>
</div>
<div class="s2"><h1>Open problems in computer virology</h1><p><a href="/lib/?lang=en&amp;author=Filiol%2C%20Eric">Eric Filiol</a>, <a href="/lib/?lang=en&amp;author=Helenius%2C%20Marko">Marko Helenius</a>, <a href="/lib/?lang=en&amp;author=Zanero%2C%20Stefano">Stefano Zanero</a><br/> <em><a href="/vx.php?fid=1951#f1951">Journal In Computer Virology vol. 1, no 2</a></em><br/> <em>ISSN 1772-9904</em><br/> <em>February 2006</em></p><script type="text/rocketscript">var disqus_url = 'http://vxheaven.org/lib/aef03.html';</script><div class="ci"><a href="/lib/?ci=aef03">1</a></div><img src="/img/pdf.gif" alt="PDF"/><a href="/lib/pdf/Open%20problems%20in%20computer%20virology.pdf">Download</a> PDF (166.67Kb) (You need to be registered on <a href="/forum">forum</a>)<br/>[<a style="" href="/lib/?lang=EN&amp;index=TH#aef03">Back to index</a>] [<a href="/lib/aef03.html#disqus_thread">Comments</a>]<br/> <form method="post" action="">
<img src="/img/cache/0b9fd596a90421f9f1f68a9760275737.gif" alt="\text{T_EX size}" valign="middle"/>
<select name="TeX_size"><option value="-2">-2</option><option value="-1">-1</option><option value="0" selected="selected">0</option><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option> </select>
<input type="submit" value="Scale"/>
</form><form method="post" action=""><input type="hidden" name="pages" value="1"/><input type="submit" value="Turn on page numbers"/></form>
<p><a href="http://www.springerlink.com/openurl.asp?genre=journal&amp;issn=1772-9890">Journal in Computer Virology</a></p>
<p><small>Received: 11 November 2005 / Accepted: 14 December 2005 / Published online: 22 February 2006 &copy; Springer-Verlag 2006</small></p>
<address>
<p>E. Filiol<br/>
Ecole Sup&eacute;rieure et d'application des Transmissions,<br/>
Laboratoire de virologie et de cryptologie,<br/>
B.P. 18, 35998 Rennes, France<br/>
E-mail: <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="a5c0c3ccc9cccac9e5c0d6c4d18bd1c0d7d7c08bc1c0c3c0cbd6c08bc2cad0d38bc3d7">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script></p>
<p>M. Helenius<br/>
Department of Computer and Information Sciences,<br/>
University of Tampere, Kanslerinrinne 1,<br/>
FIN-33014 Tampere, Finland<br/>
E-mail: <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="f596869d909894b59686db808194db939c">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script></p>
<p>S. Zanero<br/>
Dip. Elettronica e Informazione,<br/>
Politecnico di Milano,<br/>
Via Ponzio, 34/5, I-20133 Milano, Italy<br/>
E-mail: <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="700a111e15021f30151c15045e001f1c191d195e1904">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/rocketscript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script></p>
</address>
<h2>Abstract</h2>
<p>In this article, we briefly review some of the most important open problems in computer virology, in three different areas: theoretical computer virology, virus propagation modeling and antiviral techniques. For each area, we briefly describe the open problems, we review the state of the art, and propose promising research directions.</p>
<h2>1 Introduction</h2>
<p>Research in computer virology is still somehow controversial. A widely spread misconception believes that researching on computer virus propagation is neither interesting, nor productive: it is potentially dangerous, since it can lead to the development of more devastating techniques of viral infection, and in any case it is just a waste of time, because the job of fighting computer viruses is limited to the "catch, analyze, deploy signatures" cycle typical of the anti-virus industry.</p>
<p>This widespread belief explains why there are just a few research teams in universities and research organizations worldwide that deal with computer virology. An insufficient dissemination and knowledge of the few remarkable theoretical results that have been obtained until now in this field partly accounts for this belief. Upon closer examination, these results demonstrate that, on the contrary, a deep research in computer virology is absolutely urgent and essential.</p>
<p>In order to maintain a relatively efficient protection of our systems, in order to try and anticipate computer viral hazards before they actually materialize in the hands of attackers and malware writers, we need to understand in depth the threat we are facing, and how it is evolving. We cannot rely on a "wait and see" approach, but we must anticipate technological evolutions.</p>
<p>Unfortunately, many open problems still exist as far as computer virology is concerned, in both theoretical and technical aspects. Many other problems will doubtlessly emerge in the future, due to the ingenuity of malware writers. In the meantime, computer systems become more and more complex, more and more sensitive, making old virus protection and defense models progressively inadequate.</p>
<p>The purpose of this paper is to present what we believe to be the most interesting open problems in computer virology. We selected the problems whose resolution, or in-depth study, is likely to generate a valuable contribution to the level of the field, and also to improve the quality of detection and protection applications. Also, we tried to focus on theoretical problems in computer virology, which can motivate scholars in theoretical computer science or in mathematics to research in this field. Computer virology is not just an endless hunt between virus coders and antivirus labs, but offers a lot of theoretically deep problems to fathom.</p>
<p>We focused on four major aspects, which correspond to the general organization of the paper. Section 2 deals with open problems in theoretical computer virology. Founding fathers of this field, like Fred Cohen or Leonard Adleman, have produced essential theoretical results, thus giving birth to computer virology as we know it. But their seminal works have opened up other interesting problems that are still to be solved. Another aspect comes from the fact that the theoretical models they proposed tend to become unsuitable to describe some new viral risks. Many complexity issues still require researchers' attention. Classification aspects are worth considering in order to help to clearly identify the true and
 
complete nature of what the computer viral hazard is and how it may evolve in the future.</p>
<p>Section 3 considers open problems in virus propagation modeling techniques. We review the mainstream literature works on this topic, and show why new modeling techniques are needed to capture new trends in the propagation of common viruses, mass-mailers, random scanning worms of new conception, and we also briefly deal with various basic issues surrounding propagation modeling.</p>
<p>Section 4 deals with proposed countermeasures: how can they be validated before being implemented? Which new defensive techniques do we need to counter new developments we foresee in the next generations of aggressive malware?</p>
<p>Section 5 presents instead some practical and technical research areas that could benefit from a theoretically sound scientifical approach which is currently lacking. Finally, in section 6 we draw conclusive remarks on this review, and outline the most interesting issues for future research in the area.</p>
<h2>2 Open problems in theoretical computer virology</h2>
<h3>2.1 Theoretical definitions of viruses</h3>
<p>Let us recall the different theoretical definitions for computer viruses that have been proposed in previous research. It will help the reader to better understand what follows.</p>
<ul>
<li>Cohen's definition considers Turing machines [1]. The basic notion is that of viral set.
<p><strong>Definition 1 (Viral set)</strong> <em>For all Turing machines <img src="/img/cache/69691c7bdcc3ce6d5d8a1361f22d04ac.gif" alt="M" valign="middle"/> and all non-empty sets of Turing programs <img src="/img/cache/5206560a306a2e085a437fd258eb57ce.gif" alt="V" valign="middle"/>, the pair <img src="/img/cache/a68d675c477064e9adccbffee0fef3a2.gif" alt="(M, V)" valign="middle"/> is a viral set, if and only if, for each virus <img src="/img/cache/489f07bffe8b7e18a6112f5022b09410.gif" alt="v \in V" valign="middle"/>, for all histories of the machine <img src="/img/cache/69691c7bdcc3ce6d5d8a1361f22d04ac.gif" alt="M" valign="middle"/>, we have:</em></p>
<p><em>For all time instants <img src="/img/cache/5ac21cd527a99bb6b43d84ab4ba1cf25.gif" alt="t \in \mathbb{N}" valign="middle"/> and cells <img src="/img/cache/363b122c528f54df4a0446b6bab05515.gif" alt="j" valign="middle"/> of <img src="/img/cache/69691c7bdcc3ce6d5d8a1361f22d04ac.gif" alt="M" valign="middle"/> if</em></p>
<ol>
<li><em>the tape head is in front of cell <img src="/img/cache/363b122c528f54df4a0446b6bab05515.gif" alt="j" valign="middle"/> at time instant <img src="/img/cache/e358efa489f58062f10dd7316b65649e.gif" alt="t" valign="middle"/> and</em></li>
<li><em><img src="/img/cache/69691c7bdcc3ce6d5d8a1361f22d04ac.gif" alt="M" valign="middle"/> is in its initial state at time instant <img src="/img/cache/e358efa489f58062f10dd7316b65649e.gif" alt="t" valign="middle"/> and</em></li>
<li><em>the tape cells starting at index <img src="/img/cache/363b122c528f54df4a0446b6bab05515.gif" alt="j" valign="middle"/> holds the virus <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/>, then, there exists a virus <img src="/img/cache/68c0403d08fefde2fd7c9c6a680e79dd.gif" alt="v' \in V" valign="middle"/>, at time instant <img src="/img/cache/784cb234842e1f852ec8aefe7a5fbd04.gif" alt="t' &gt; t" valign="middle"/> and at index <img src="/img/cache/e791243cf0d230e7f49105130aeb078f.gif" alt="j'" valign="middle"/> such that</em>
<ol>
<li><em>index <img src="/img/cache/e791243cf0d230e7f49105130aeb078f.gif" alt="j'" valign="middle"/> is far enough from <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> position (start location <img src="/img/cache/363b122c528f54df4a0446b6bab05515.gif" alt="j" valign="middle"/>),</em></li>
<li><em>the tape cells starting at index <img src="/img/cache/e791243cf0d230e7f49105130aeb078f.gif" alt="j'" valign="middle"/> hold the virus <img src="/img/cache/b3afdc4dc7644ad636e084509b04ddab.gif" alt="v'" valign="middle"/> and</em></li>
<li><em>at some time instant <img src="/img/cache/eff9ec111ac240c3184120138ebd2899.gif" alt="t''" valign="middle"/> such that <img src="/img/cache/ffe77195c739daa8d7eb9365a26ae463.gif" alt="t &lt; t'' &lt; t'" valign="middle"/>, <img src="/img/cache/b3afdc4dc7644ad636e084509b04ddab.gif" alt="v'" valign="middle"/> is written by <img src="/img/cache/69691c7bdcc3ce6d5d8a1361f22d04ac.gif" alt="M" valign="middle"/>.</em></li>
</ol></li>
</ol>
<p><em>In an abridged way, we can write that <img src="/img/cache/5206560a306a2e085a437fd258eb57ce.gif" alt="V" valign="middle"/> is a viral set with respect to <img src="/img/cache/69691c7bdcc3ce6d5d8a1361f22d04ac.gif" alt="M" valign="middle"/>, if and only if,</em></p>
<div class="N5"><img src="/img/cache/1de09c5b9119f6e008efe98b844b92ab.gif" alt="[(M, V) \in \mathcal{V}]" valign="middle"/></div>
<p><em>and that <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> is a virus with respect to <img src="/img/cache/69691c7bdcc3ce6d5d8a1361f22d04ac.gif" alt="M" valign="middle"/>, if and only if,</em></p>
<div class="N5"><img src="/img/cache/ff98cb67acbd039157999eeaf63d1330.gif" alt="[v \in V]\ such\ that\ [(M, V)\in\mathcal{V}]." valign="middle"/></div>
<p>In this context, a "simple" virus can be described by a singleton viral set.</p>
</li>
<li>Adleman's definition as well as Zuo and Zhou's one relies on recursive functions [2,3] (we consider here the formalism adopted in [4] for the purpose of homogeneity with the next definition).
<p><strong>Definition 2 (Adleman's viruses)</strong> <em>A total computable function <img src="/img/cache/ad70146b431bea9ae74cf8385470c544.gif" alt="\mathcal{A}" valign="middle"/> is said to be an A-viral function (virus in the sense of Adleman) if for each system environment <img src="/img/cache/4880d580da2c5b89dfe202fd3ca19969.gif" alt="(r, d)" valign="middle"/>, one of the three following properties holds:</em></p>
<dl>
<dt><em>Injure</em></dt>
<dd>
<em><img src="/img/cache/4aab2deaf7dac6127c8e9dad47302517.gif" alt="\forall p, b \in \mathcal{D}\ \ \varphi_{\mathcal{A}(p)}(r, d) = \varphi_{\mathcal{A}(q)}(r, d). \hspace{100}(1)" valign="middle"/></em>
<p><em>This item corresponds to the execution of some viral functions independently from the infected program.</em></p>
</dd>
<dt><em>Infect</em></dt>
<dd>
<em><img src="/img/cache/216f929ce0f0e93fcd5073e888d9ba6f.gif" alt="\forall p \in \mathcal{D}\ \ \varphi_{\mathcal{A}(p)}(r, d) = \langle \varepsilon_{\mathcal{A}}(r'_1),\dots,\varepsilon_{\mathcal{A}}(r'_n), d'\rangle \hspace{100} (2)" valign="middle"/></em>
<p><em>where <img src="/img/cache/2e29f416958eb0e5e83f7a96da62f607.gif" alt="\varphi_p(r, d) = \langle r', d'\rangle" valign="middle"/> and <img src="/img/cache/ce7a8f83bc051b864f0e6f088020e469.gif" alt="\varepsilon_{\mathcal{A}}" valign="middle"/> is a computable selection function defined by</em></p>
<p><img src="/img/cache/5a5667a708d5d81ee5520e87e75f14aa.gif" alt="		
\varepsilon_{\mathcal{A}}(p) = \{
p\ \ \ or\\
\mathcal{A}(p)
" valign="middle"/></p>
<p><em>The second item corresponds to the case of infection (any program is potentially rewritten according to <img src="/img/cache/ad70146b431bea9ae74cf8385470c544.gif" alt="\mathcal{A}" valign="middle"/>; data are left unchanged).</em></p>
</dd>
<dt><em>Imitate</em></dt>
<dd>
<em><img src="/img/cache/aca975f48dc3066fc1e16e642087263f.gif" alt="\forall p \in \mathcal{D}\ \ \varphi_{\mathcal{A}(p)}(r, d) = \varphi_p(r, d).\hspace{100}(3)" valign="middle"/></em>
<p><em>The last item corresponds to mimic the original program (stealth purpose).</em></p>
</dd>
</dl>
<p>where <img src="/img/cache/eefecd9cb0345697ddaac0281588a08d.gif" alt="\mathcal{D}" valign="middle"/> denotes the computation domain. The reader will note that this definition is not constructive, as opposed to the next one.</p>
</li>
<li>Bonfante et al. [4,5] describe viruses as fixed points of a semi-computable function. They first consider the following definition:
<p><strong>Definition 3</strong> <em>Assume that <img src="/img/cache/17294f613b0fd19f088e163d30eacfaf.gif" alt="\mathcal{B}" valign="middle"/> is a computable function. A virus with respect to <img src="/img/cache/17294f613b0fd19f088e163d30eacfaf.gif" alt="\mathcal{B}" valign="middle"/> is a program <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> such that for each <img src="/img/cache/83878c91171338902e0fe0fb97a8c47a.gif" alt="p" valign="middle"/> and <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/> in the computation domain <img src="/img/cache/eefecd9cb0345697ddaac0281588a08d.gif" alt="\mathcal{D}" valign="middle"/>,</em></p>
<div class="N5"><img src="/img/cache/eabd2c07458e58802a7e5da6b8d65a19.gif" alt="\varphi_v(p, x) = \varphi_{\mathcal{B}(v,p)}(x)." valign="middle"/></div>
<p><em>The function <img src="/img/cache/17294f613b0fd19f088e163d30eacfaf.gif" alt="\mathcal{B}" valign="middle"/> is called the propagation function of the virus <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/>.</em></p>
<p>Then, the authors proved the following result:</p>
<p><strong>Theorem 1</strong> <em>Given a semi-computable function <img src="/img/cache/8fa14cdd754f91cc6554c9e71929cce7.gif" alt="f" valign="middle"/>, there is a virus <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> such that for any <img src="/img/cache/83878c91171338902e0fe0fb97a8c47a.gif" alt="p" valign="middle"/> and <img src="/img/cache/9dd4e461268c8034f5c8564e155c67a6.gif" alt="x" valign="middle"/> in <img src="/img/cache/eefecd9cb0345697ddaac0281588a08d.gif" alt="\mathcal{D}" valign="middle"/>, we have</em></p>
<div class="N5"><img src="/img/cache/83d1f962904c1a820e5876ca26d9eaec.gif" alt="\varphi_v(p, x) = f (v, p, x)." valign="middle"/></div>
<p>Recursion Theorem provides a fixed point <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> of the semicomputable function <img src="/img/cache/8fa14cdd754f91cc6554c9e71929cce7.gif" alt="f" valign="middle"/>. This fixed point <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> is a virus with respect to a propagation function <img src="/img/cache/4049e8d99fcfbeb5c84ce546f5e5e6eb.gif" alt="\mathcal{B}(v, p)" valign="middle"/>.</p>
<p>One of the most interesting characteristics of this approach is that such definitions and results are of constructive nature (in particular the reader will consider [4, section 4.6, Theorem 4]).</p>
</li></ul>
 
<h3>2.2 Complexity theoretic problems</h3>
<p>Studying complexity aspects of viral sets is of high importance since it quantifies the intractability of detection. Very few papers have been focused on the intractability of detection even if some major results have been established. Fred Cohen [1] proved that the general problem of viral detection was undecidable. This result refers to computability as presented by Rogers [6]. Most of the results on viruses concern undecidability and the hierarchies on the top of the Halting problem.</p>
<p>Later on, his Ph.D. tutor Adleman [2] gave complexity results on some particular instances of the general detection problem:</p>
<ul>
<li>The set <img src="/img/cache/bd2baee05a9ff4a7b9056cc917097cda.gif" alt="V = \{i|\varphi_i\text{ is a virus}\}" valign="middle"/> is <img src="/img/cache/ba0d501129e621abc42185dc86f414a9.gif" alt="\Pi_2" valign="middle"/>-complete [2, p 363].</li>
<li>The infected set of a virus <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> defined as <img src="/img/cache/8240bfc1cd3f9f3ae307dace53c97af4.gif" alt="I_v = \{i \in \mathbb{N}|(\exist j \in \mathbb{N}[i = v(j)]\}" valign="middle"/> is <img src="/img/cache/f2831c9cbac5b86ee2f36c60df812324.gif" alt="\Sigma_1" valign="middle"/>-complete [2, p. 371].</li>
</ul>
<p>D. Spinellis proved in 2003 that detection of bounded-length polymorphic viruses is a <em>NP</em>-complete problem [7]. When considering polymorphic viruses of (possibly) unbounded length, how does the detection complexity change? Such a question may appear only of theoretical interest, but in fact k-ary viruses (see section 2.3) can simulate this behavior. More recently, a few additional results have been published:</p>
<ul>
<li>In 2004, Zuo and Zhou [3] have exhibited viral sets that are <img src="/img/cache/f2831c9cbac5b86ee2f36c60df812324.gif" alt="\Sigma_1" valign="middle"/>-complete, <img src="/img/cache/ba0d501129e621abc42185dc86f414a9.gif" alt="\Pi_2" valign="middle"/>-complete or <img src="/img/cache/9d60405a6eb677304d17a8029570a1ad.gif" alt="\Sigma_3" valign="middle"/>-complete. Moreover, they also considered other viral sets that appear to be of even higher complexity.</li>
<li>In 2005, Bonfante et al. [4] gave other similar results.</li>
</ul>
<p>All these results refer to algorithmic complexity as considered in [8]. In this context, research is focused on classes of low complexity where either time or space are bounded.</p>
<p>Despite the fact that most of these theoretical results prove that the related detection problems are intractable, in practice it remains essential to identify classes of viral codes that effectively challenge protection policies. An interesting problem is to determine whether there exist viral sets of <img src="/img/cache/00a90587036019f4279b0ec99206f3a7.gif" alt="\Pi_n" valign="middle"/> or <img src="/img/cache/199ab0fddcf6057c1d12262475af4a8a.gif" alt="\Sigma_n" valign="middle"/> complexity (complete or not) for any given value of <img src="/img/cache/7b8b965ad4bca0e41ab51de7b31363a1.gif" alt="n" valign="middle"/>. From an intuitive point of view, the answer seems to be positive. Some new examples of viral codes suggests it. To carry matters to extremes, one could in fact consider indecidability as the infinite complexity (<img src="/img/cache/e71ee387dcee601f09f434aba8760fd5.gif" alt="n \rightarrow \infty" valign="middle"/>).</p>
<p>The answer to the previous problem in fact appeals to another problem: is it possible to classify viral codes according to the complexity class of their viral sets? Up to now, viral classification has been established by considering mathematical tools (Turing Machine [1], recursive functions [2,3], or fixed points of a semi-computable function [4,9]; see section 2.1). Classifications based on complexity, rather than on mathematical properties, could produce a better perception of the viral risk and hence new models for antiviral research. The classification according to detection complexity should help to better identify classes of viruses for which detection is of polynomial complexity. This approach was first suggested in [4, Theorem 14].</p>
<p>Recently Zuo and Zhou [10] presented new results on time complexity of computer viruses (virus running time, virus detection procedure). The authors pointed out some interesting open problems related to the time complexity issue. Their main results are:</p>
<ul>
<li>For any type of computer viruses, there exists a computer virus <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> whose infecting procedure has arbitrarily large time complexity.</li>
<li>For any type of computer viruses, there is a virus <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> such that any implementation of <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> can have arbitrarily large time complexity in its infection procedure.</li>
</ul>
<p>It is a well-known result [11] that there exists a computer virus <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> such that its infected programs set <img src="/img/cache/7becf419ca4290e38585809f5624b28d.gif" alt="I_v" valign="middle"/> is undecidable. This can formally be expressed by the fact that <img src="/img/cache/7becf419ca4290e38585809f5624b28d.gif" alt="I_v" valign="middle"/> is a non recursively enumerable set. Thus detecting all the programs infected by <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> requires to find a recursive set <img src="/img/cache/dcf5a9d1d0921e88bbbb7524c84d99af.gif" alt="\mathcal{C}" valign="middle"/> such that <img src="/img/cache/59cc9fe5b70c52888c14993be5677e24.gif" alt="I_v \subset \mathcal{C}" valign="middle"/>.</p>
<p>Considering the fact that existing computer viruses are almost always decidable, the authors of [10] then considered two unsolved questions:</p>
<ol>
<li>If <img src="/img/cache/7becf419ca4290e38585809f5624b28d.gif" alt="I_v" valign="middle"/> is decidable, what is its time complexity?</li>
<li>If <img src="/img/cache/7becf419ca4290e38585809f5624b28d.gif" alt="I_v" valign="middle"/> is undecidable, what is the time complexity of the recursive set containing <img src="/img/cache/7becf419ca4290e38585809f5624b28d.gif" alt="I_v" valign="middle"/>?</li>
</ol>
<p>They gave only a partial answer to the first question. They proved that for any undecidable computer virus, there is one detecting procedure of arbitrarily large complexity. As the authors noted in their article, in practice it is more desirable to consider the existence of a recursive set <img src="/img/cache/dcf5a9d1d0921e88bbbb7524c84d99af.gif" alt="\mathcal{C}" valign="middle"/> such that <img src="/img/cache/59cc9fe5b70c52888c14993be5677e24.gif" alt="I_v \subset \mathcal{C}" valign="middle"/> and whose characteristic function has a "low-time" complexity (polynomial). While this is trivial when <img src="/img/cache/f703ba235a550426057733223bd96282.gif" alt="\mathcal{C} = \mathbb{N}" valign="middle"/>, it is still an open problem to solve under the conditions that <img src="/img/cache/8c46622d7997a373464e8dccc7331dbb.gif" alt="(\mathbb{N} - \mathcal{C})" valign="middle"/> is infinite and <img src="/img/cache/dcf5a9d1d0921e88bbbb7524c84d99af.gif" alt="\mathcal{C}" valign="middle"/> is as small as possible.</p>
<h3>2.3 Viral and antiviral models problems</h3>
<p>Some recent viruses-found in the wild or studied as part of a prospective protection strategy-exhibit new structures, properties and/or behaviors. Most of the time, these viruses pose new threats that current antiviral models cannot deal with. The reason is that these new viruses develop a complex, sophisticated algorithmic that does not fit to the present viral models. A good example are the so called <em>k</em>-ary viruses (sometimes denoted as <em>combined viruses</em> or <em>viruses with "rendez-vous"</em>). These viruses combine their respective actions according to different modes of operation. A known example of a 2-ary virus is the combination of the <em>W32.Qaz</em> virus with the <em>W32.Funlove</em> virus.</p>
<p>Despite the fact that their attack scheme was not very sophisticated compared to what 2-ary viruses can theoretically do, this combination illustrates a new face of tomorrow's threats. In [9, pp. 135ff], a classification of this type of viruses has been sketched. Some particular types are exhaustively presented, from an algorithmic point of view, in [12]. However, a complete and exhaustive categorization of all
 
types of <em>k</em>-ary viruses and of their modes of combined action is still missing.</p>
<p>The difficulty of studying these particular viruses comes from the fact that they do not comply with existing models of computer viruses. As of now, computer virus models rely on the concept of "univariate" recursive functions <img src="/img/cache/ded525ee46a68c68d6bcb744685bba2e.gif" alt="f:\mathbb{N}\rightarrow\mathbb{N}" valign="middle"/>. Unfortunately, these functions do not take into account, among many other aspects, the time indexing which is an inherent characteristics of <em>k</em>-ary viruses due to some of their modes of operation (their respective action may occur with a different time reference or index). Multivariate vector recursive functions <img src="/img/cache/c001043e5a3dc77910f23c845e6d0553.gif" alt="f:\mathbb{N}^k\rightarrow\mathbb{N}^k" valign="middle"/> could be considered instead, in order to capture the concept of <em>k</em>-ary viruses. Three questions arise:</p>
<ul>
<li>Is a model based on multivariate vector recursive functions the best possible one for <em>k</em>-ary viruses? Considering the family of functions <img src="/img/cache/8137c23fd9197112e00c30d1fa5afb7c.gif" alt="(f_i)_{1\le i\le k}" valign="middle"/> with <img src="/img/cache/7e845b24a60c51e48b84cccfab103722.gif" alt="f_i:\mathbb{N}\rightarrow\mathbb{N}" valign="middle"/> could produce a more general and more efficient model, being a third-order logic model.</li>
<li>Will these models help to identify previously unforeseen classes of viruses?</li>
<li>What kind of corresponding antiviral models do we have to develop and what are the new complexity issues with respect to them?</li>
</ul>
<p>The next point deals with the classification of viral models themselves and their respective relationship. Existing models (Cohen's model based on Turing machines, Adleman's model based on recursive functions, and Bonfante et al.'s model based on solutions of a fixed point equation) are all second-order logic models, and have been proven to be largely equivalent. Antiviral models that have been built from them are equivalent too, and therefore are not different in their detection capabilities.</p>
<p>If we consider to create new viral models, let us call them <img src="/img/cache/07e2a877d8668cc414175c730fabb898.gif" alt="\mathcal{M}_1,\mathcal{M}_2,\dots,\mathcal{M}_n" valign="middle"/>, we can ask ourselves:</p>
<ul>
<li>Do we have a logical chain for all of them, that is to say <img src="/img/cache/9ce68bccf76fe17a5540a73e0785474f.gif" alt="\mathcal{M}_1\prec\mathcal{M}_2\prec\dots\mathcal{M}_n" valign="middle"/>? In this context, each new model <img src="/img/cache/93d60176c1346b89a006fd76e5fd7c21.gif" alt="\mathcal{M}_{n+1}" valign="middle"/> yields a generalization of the antiviral models that have been derived from previous viral models.</li>
<li>On the contrary, do we have a lattice structure for the viral models? In this case, there exists a finite number of pairs of models that are not comparable. In other words, for some pairs <img src="/img/cache/cef2fce7fa803e98fc31071b297c3f49.gif" alt="\mathcal{M}_i,\mathcal{M}_j" valign="middle"/>, neither <img src="/img/cache/898849808dfd6cca4ca9ed4bae0ad410.gif" alt="\mathcal{M}_i\prec\mathcal{M}_j" valign="middle"/> nor <img src="/img/cache/8227450de5dad6d7fd8d9defaa007d60.gif" alt="\mathcal{M}_j\prec\mathcal{M}_i" valign="middle"/>. In this context, we have the same organization for corresponding antiviral models. This implies a totally different, more challenging, management of viral detection.</li>
</ul>
<h3>2.4 Classification and identification problems</h3>
<p>The identification of new viral classes that may represent future threats is essential. This identification is quite always reactive, since it relies on code analysis. Another approach is to mathematically forecast new viral techniques or classes. As a representative example, Zuo and Zhou [3] have proven that polymorphic viruses with infinite forms exist. But until now, no such viruses have been created in the real world, excluding the trivial polymorphic viruses, e.g., the padding function [13]. It remains an open problem to determine whether this computability paradigm would produce non-trivial polymorphic viruses when considering real programs. Does Zuo and Zhou's class of specific polymorphic viruses effectively represent a practical risk? This problem may sound very provocative (in fact it would require us to write a virus), but only the proof-by-experience can give a definitive answer.</p>
<p>As far as polymorphic and metamorphic viruses are concerned, the classification of the mutation process is also an open problem. Detection is mostly based on heuristic techniques and their efficiency is regularly defeated by new mutation techniques. Let us recall that detection of bounded-length polymorphic viruses is a NP-complete problem [7]. In order to improve detection of poly/metamorphic viruses a new approach has to be found. Formally, Zou and Zhuo [3,10] have defined (following Adleman) polymorphic viruses as follows:</p>
<p><strong>Definition 4 (Polymorphic virus with two forms)</strong> <em>The pair <img src="/img/cache/f2d15124e5d0820e6547bc1aab8f3c24.gif" alt="(v, v')" valign="middle"/> of two different total recursive functions <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> and <img src="/img/cache/b3afdc4dc7644ad636e084509b04ddab.gif" alt="v'" valign="middle"/> is called a polymorphic virus with two forms if for all <img src="/img/cache/43dbfd4377fbcc6327639a4bed4afd1e.gif" alt="x, (v, v')" valign="middle"/> satisfies</em></p>
<div class="N5"><img src="/img/cache/b61641fcbfe3b26f2232759e32383703.gif" alt="
{	\varphi_{v(x)}(d, p) = \{
	\begin{align}
		&amp;&amp; D(d, p),			&amp;&amp;&amp; if T (d, p),\\
		&amp;&amp; \varphi_x(d, p[v'(S(p))]), 	&amp;&amp;&amp; if I (d, p),\\
		&amp;&amp; \varphi_x(d, p),		&amp;&amp;&amp; otherwise,
	\end{align}
	} \\
	and\\
	\varphi_{v'(x)}(d, p) = \{
	\begin{align}
		&amp;&amp; D(d, p),			&amp;&amp;&amp; if T (d, p),\\
		&amp;&amp; \varphi_x(d, p[v(S(p))]), 	&amp;&amp;&amp; if I (d, p),\\
		&amp;&amp; \varphi_x(d, p),		&amp;&amp;&amp; otherwise,
	\end{align}
" valign="middle"/></div>
<p>Real-life polymorphic viruses are then described by the two authors as a <img src="/img/cache/7b8b965ad4bca0e41ab51de7b31363a1.gif" alt="n" valign="middle"/>-tuple <img src="/img/cache/3c2c90d0ffcd5b84908fa350a4e93907.gif" alt="(v_1,v_2,\dots,v_n)" valign="middle"/> of <img src="/img/cache/7b8b965ad4bca0e41ab51de7b31363a1.gif" alt="n" valign="middle"/> different total recursive functions, under similar condition as in Definition 4. Metamorphic viruses are defined in much the same way, except that two selection functions <img src="/img/cache/be81fe0f3d9275a189495781bf2f49b8.gif" alt="S(p)" valign="middle"/> and <img src="/img/cache/1ce623ac75e2d7e4ca9dcd4cd6789f35.gif" alt="S'(p)" valign="middle"/>, which choose a program <img src="/img/cache/83878c91171338902e0fe0fb97a8c47a.gif" alt="p" valign="middle"/> to infect, are used instead of only one for polymorphic viruses. With this formalism, only a set-theoretic, computability approach is considered. In this context, this approach clearly relates to Cohen's formalism (concept of <em>Largest Viral Set with respect to a Turing machine</em>). The main drawback with the set approach comes from the fact that relationships between the evolved forms do not appear very clearly. On the contrary, polymorphism (and metamorphism) is generally and practically implemented as an algorithm that iterates over the different mutated forms. The function may be very complex (like cellular automata). In other words, polymorphism and metamorphism should be described by a functional approach rather as a viral set containing the different evolved forms of a given virus.</p>
<p>By considering the recursion theorem and the approach presented in [9, Chap. 1] and developed in [4,5], we can think
 
of a virus as a fixed point of the equation</p>
<div class="N5"><img src="/img/cache/028ed22ae39e1d03e271d4842f327105.gif" alt="\varphi_e(p, x) = f (e, p, x)." valign="middle"/></div>
<p>Then the functional description of polymorphism enables to see the <img src="/img/cache/865c0c0b4ab0e063e5caa3387c1a8741.gif" alt="i" valign="middle"/>th evolution of a virus <img src="/img/cache/9e3669d19b675bd57058fd4664205d2a.gif" alt="v" valign="middle"/> as the result of total recursive function <img src="/img/cache/8fa14cdd754f91cc6554c9e71929cce7.gif" alt="f" valign="middle"/>, iterated <img src="/img/cache/865c0c0b4ab0e063e5caa3387c1a8741.gif" alt="i" valign="middle"/> times. In other words, we have now to consider the equation</p>
<div class="N5"><img src="/img/cache/9d497b2b83518af8c06d217a863a4309.gif" alt="\varphi_e(p, x) = f^i(e, p, x)." valign="middle"/></div>
<p>Such a modeling opens interesting and unresolved problems, whose solution could provide a significant improvement in polymorphism detection:</p>
<ul>
<li>Is it possible to find some mathematical properties for the function <img src="/img/cache/8fa14cdd754f91cc6554c9e71929cce7.gif" alt="f" valign="middle"/> which could help to precisely characterize what polymorphism really is and to classify functions realizing code polymorphism (see [Remark 17]bkm)? We could imagine, as an example, some distance <img src="/img/cache/8277e0910d750195b448797616e091ad.gif" alt="d" valign="middle"/> between <img src="/img/cache/6ece2c69939d314fe790a3e7ab529fcd.gif" alt="f^{i-1}(e, p, x)" valign="middle"/> and <img src="/img/cache/edf874f9969cd65f09a7717a5fe24a2a.gif" alt="f^i(e, p, x)" valign="middle"/> which could reveal interesting invariant or probabilistically invariant properties. A first idea suggests to describe things in terms of function orbit and to focus on orbit properties.</li>
<li>From a practical point of view, each evolved form of a virus can be described as a binary sequence <img src="/img/cache/1df181eaa1bb40a0067c06ead197170d.gif" alt="v_i" valign="middle"/>, that is to say as a codeword of length <img src="/img/cache/d20caec3b48a1eef164cb4ca81ba2587.gif" alt="L" valign="middle"/> where <img src="/img/cache/d20caec3b48a1eef164cb4ca81ba2587.gif" alt="L" valign="middle"/> is the size of each evolved form. Without loss of generality, we can consider code mutation to be size-invariant, since generalization to code size variation is straightforward. Then, the set of all mutated forms can be described as a code of length <img src="/img/cache/d20caec3b48a1eef164cb4ca81ba2587.gif" alt="L" valign="middle"/> (see [14]). Then:
<ul>
<li>What is the code cardinality? This relates to the number of possible evolved forms. Obviously, the code cardinality is upper-bounded by <img src="/img/cache/251f43dff90d27c060706c621e2f837e.gif" alt="2^L" valign="middle"/>, but since any codeword of length <img src="/img/cache/d20caec3b48a1eef164cb4ca81ba2587.gif" alt="L" valign="middle"/> does not systematically represent a viable form from an execution point of view, the cardinality of the code is bound to be strictly less that <img src="/img/cache/251f43dff90d27c060706c621e2f837e.gif" alt="2^L" valign="middle"/>.</li>
<li>What is the code minimal distance? What is the average Hamming distance between two codewords (evolved forms) of a virus?</li>
<li>How mathematical tools of coding theory could be used and applied to help in mutation process characterization and detection?</li>
</ul></li>
<li>Considering the last point of the preceding item, we could for example use tools taken from signal processing (when considering a virus as a binary sequence or an octal sequence): the discrete cross-correlation function to measure similarity (at least from a probabilistic point of view) between to evolved forms. Knowing a given viral form, cross-correlation would probably help to find evolving features in an unknown (probably evolved) viral sequence. Autocorrelation function [9, Chap. 8, Exercises] is a noteworthy tool which can help detect some similarities inside a code and thus reveal some repetitive (dummy) code insertion for polymorphic purposes. Many discrete transforms commonly used in signal processing and coding theory should be considered as well to study and reveal mathematical properties of the iterated function describing a mutation process.</li>
</ul>
<p>Another interesting problem deals with the impact of quantum computing [15] on computer virology. With quantum computing many research fields have made essential progress. The best example is probably cryptography where problems of intractable complexity (for traditional computers) can be solved very easily by means of a quantum computer [16,17] The problem is twofold:</p>
<ul>
<li>Considering intractable viral detection problems, what would be the impact of quantum computing? Is it possible to imagine quantum viral detection algorithms (quantum antivirus)?</li>
<li>Considering quantum computers, what would then be a quantum computer virus? Consequently, what would be the effect of such a virus in terms of detection capabilities, when processed by a quantum antivirus?</li>
</ul>
<h2>3 Open problems in virus propagation modeling techniques</h2>
<h3>3.1 Need and requirements for propagation models</h3>
<p>Creating reliable models of virus and worm propagation is beneficial for many reasons. First, it allows researchers to better understand the threat posed by new attack vector and new propagation techniques. For instance, the use of conceptual models of worm propagation allowed researchers to predict the behavior of future malware, and later to verify that their predictions were substantially correct [18].</p>
<p>In second place, using such models, researchers can develop and test new and improved models for containment and disinfection of viruses without resorting to risky "in vitro" experimentation of zoo virus release and cleanup on testbed networks [19].</p>
<p>Finally, if these models are combined with good load modeling techniques such as the queueing networks, we can use them to predict failures of the global network infrastructure when exposed to worm attacks. Moreover, we can individuate and describe characteristic symptoms of worm activity, and use them as an early detection mechanism.</p>
<p>In order to be useful, however, such a model must exhibit some well-known characteristics: it must be accurate in its predictions and it must be as general as possible, while remaining as simple and as low-cost as possible. The importance of this work, and the shortcomings of many existing models, are described in [20].</p>
<h3>3.2 Open questions in modeling traditional viruses</h3>
<p>Viral code propagation vectors have evolved over the years, and propagation models also have evolved to keep pace. In
 
the beginning of the virus era, viruses infected host programs, and the most common vector of propagation was the exchange of files via magnetic supports. The same concept, in more recent times, has been extended to macro languages embedded in office automation suites, generating the so-called "macro viruses".</p>
<p>The first complete application of mathematical models to computer virus propagation appeared in [21]. The basic intuitions of this work still provide the fundamental assumptions of most computer epidemiological models. Epidemiological models abstract from the individuals, and consider them units of a population. Each unit can only be long to a limited number of states (Table 1 reports a widely accepted nomenclature): usually, the name of a model explicits the chain , e.g., a model where the susceptible population becomes infected, and then recovers, is called a SIR model.</p>
<p>Another typical simplification consists in avoiding a detailed analysis of virus transmission mechanics, translating them into a probability that an individual will infect another individual (with some parameters). In a similar way, transitions between other states of the model are described by simple probabilities. Such probabilities could be calculated directly by the details of the infection mechanism or, more likely, they can be inferred by fitting the model to actual propagation data. An excellent analysis of mathematics for infectious diseases in the biological world is available in [22].</p>
<p>Most epidemiological models, however, share two important shortcomings: they are <em>homogeneous</em>, i.e., an infected individual is equally likely to infect any other individual; and they are <em>symmetric</em>, which means that there is no privileged direction of transmission of the virus. The former makes these models inappropriate for illnesses that require a non-casual contact for transmission; the latter constitutes a problem, for instance, in the case of sexually-transmitted diseases.</p>
<p>In the case of computer viruses both problems are often present. Most individuals exchange programs and documents (by means of e-mails or diskettes) in almost closed groups, and thus an homogeneous model may not be appropriate. Furthermore, there are also "sources" of information and programs (e.g., computer dealers and software distributors) and "sinks" (final users): that makes asymmetry a key factor of data exchange.</p>
<p>In [21] Both of these shortcomings are addressed by transferring a traditional SIS model onto a directed random graph, and the important effects of the topology of the graph on propagation speed are analyzed. The authors describe the behavior of virus infections on <em>sparse</em> and <em>local</em> graphs. In a sparse graph, each node has a small, constant average degree; on the contrary, in a local graph, the probability of having a vertex between nodes <em>B</em> and <em>C</em> is significantly higher if both have a vertex connected to the same node <em>A</em>. The authors discuss that in the landscape of the beginnings of the 1990s the latter situation approximated very well the interaction between computer users. Among other results, it is shown that the more sparse a graph is, the slower is the spread of an infection on it; and higher the probability that an epidemic condition does not occur at all, which means that sparseness helps in containing <em>global</em> virus spread (while local spread is unhindered). Further elaborations on this type of model can be found in [23].</p>
<p><strong>Table 1</strong> Typical states for an epidemiological model</p>
<table summary="Table 1. Typical states for an epidemiological model">
<tr><td>M</td><td>Passive immunity</td></tr>
<tr><td>S</td><td>Susceptible state</td></tr>
<tr><td>E</td><td>Exposed to infection</td></tr>
<tr><td>I</td><td>Infective</td></tr>
<tr><td>R</td><td>Recovered</td></tr>
</table>
<p>These findings are useful and interesting. However, it must be noted that often a SIR model, in which a "cured" system is not susceptible any more, could approximate better the behavior of many real cases of propagation when a patch or antivirus signature is available. Also, the introduction of the Internet as a convenient and immediate way for software and data exchange has arguably made the assumptions of locality and sparseness of the graph no longer valid.</p>
<h3>3.3 Open questions in modeling mass-mailers</h3>
<p>With the widespread adoption of the Internet, mass-mailing worms began to appear. The damage caused by <em>Melissa</em> virus in 1999, <em>Love Letter</em> in 2000 and <em>Sircam</em> in 2001 demonstrated that tricking users into executing the worm code attached to an e-mail, or exploiting a vulnerability in a common e-mail client to automatically launch it, is a successful way to propagate viral code.</p>
<p>In a technical report Zou et al. [24] describe a model of e-mail worm propagation. The authors model the Internet e-mail service as an undirected graph of relationships between people. In order to build a simulation of this graph, they assume that each node degree is distributed on a power-law probability function, an assumption drawn by the analysis of distribution of discussion group sizes, which result to be heavy-tailed: since adding a group to the address book adds an edge towards all components of the group, the distribution of node degree results being heavy tailed too. Nowadays, discussion groups proactively filter attachments, so this assumption is challenged. Additionally, the authors employ a "small world" network topology, which seems to ignore completely the existence of interest groups and organizations, which naturally create clusters of densely connected vertexes. All these simplifications should be addressed in creating a good model of mass-mailer propagation.</p>
<p>Furthermore, the authors assume that each user "opens" an incoming virus attachment with a fixed probability, different for each user but constant in time. This does not describe very well the typical behavior of users. Indeed, most experienced users avoid virus attachments altogether, while unexperienced users open them easily, at least the first time.</p>
<p>Additionally, it is observed that since user e-mail checking time is much larger than the average e-mail transmission time, the latter can be disregarded in the model. Since the overall spread rate of viruses gets higher as the variability
 
of users' e-mail checking times increases, reliable statistics describing this process should be used in order to build better models of mass-mailer propagation.</p>
<p>Finally, when trying to determine the volume of messages generated by a mass mailer the fact that, in most cases, e-mail viruses install themselves as startup services on the system, and spread themselves at each opportunity, should be taken into account and properly modeled.</p>
<h3>3.4 Open questions in modeling scanning worms</h3>
<p>The concept of a self-contained, self-propagating program which does not require an host program to be carried around, was also developed early, but was somehow neglected for a long time. In 1988, however, the <em>Internet Worm</em> [25] changed the landscape of the threats. The Internet Worm was the first successful example of a self-propagating program which did not infect host files, but was self-contained. Moreover, it was the first really successful example of an active network worm, which propagated on the Internet by using well-known vulnerabilities of the UNIX operating system. Other worms used open network shares, or exploited vulnerabilities in operating systems and server software to propagate.</p>
<p>The random constant spread (RCS) model was developed by Staniford, Paxson and Weaver [18] using empirical data derived from the outbreak of the <em>Code Red</em> worm, a typical random scanning worm which propagates by using the <em>.ida vulnerability</em> discovered by eEye itself on June 18th 2001 [26], thus infecting vulnerable web servers running Microsoft IIS version 4.0 and 5.0. When Code Red infects an host, it spreads by launching 99 threads, which randomly generate IP addresses (excluding subnets 127.0.0.0/8, loopback, and 224.0.0.0/8, multicast) and try to compromise the hosts at those addresses using the same vulnerability.</p>
<p>A particularity of this worm is that it does not reside on the file system of the target machine, but it is carried over the network as the shellcode of the buffer overflow attack [27] it uses. When it infects an host, it resides only in memory: thus a simple reboot eliminates the worm, but does not avoid reinfection. Applying a patch to fix the IIS server or using temporary workarounds (e.g., activating a firewall, or shutting down the web server) makes instead the machine completely invulnerable to the infection. Thus, in order to model completely the worm we would need a SIR model where from I state we can either go to S or R state.</p>
<p>However, the RCS model makes a big approximation: it ignores that systems can be patched, powered and shut down, deployed or disconnected. In other words it is a simple SI model, with no recovery or immunization processes. This is only partially reasonable and justified by the speed of the worm propagation: in other words, the authors implicitly assume that the worm will peak before a remedy begins to be deployed.</p>
<p>An additional, more crucial approximation, is that the Internet topology is considered an undirected complete graph. In truth, the Internet being (as S. Breidbart defined it) "the largest equivalence class in the reflexive, transitive, symmetric closure of the relationship <em>can be reached by an IP packet from</em>", it is all but completely connected. In fact, recent researches [28] show that as much as the 5% of the routed (and used) address space is not reachable by various portions of the network, due to misconfiguration, aggressive filtering, or even commercial disputes between carriers.</p>
<p>Let <img src="/img/cache/8d9c307cb7f3c4a32822a51922d1ceaa.gif" alt="N" valign="middle"/> be the total number of vulnerable servers which can be potentially compromised from the Internet. Let <img src="/img/cache/a5f3c6a11b03839d46af9fb43c97c188.gif" alt="K" valign="middle"/> be the average compromise rate, i.e., the number of vulnerable hosts that an infected host can compromise on average per unit of time at the beginning of the outbreak. <img src="/img/cache/a5f3c6a11b03839d46af9fb43c97c188.gif" alt="K" valign="middle"/> averages out any difference in processor speed, network bandwidth and location of the infected host. The model also assumes that a machine cannot be compromised multiple times and that, <img src="/img/cache/f19901f1c817ad846a411e6712e8db66.gif" alt="2^{32}" valign="middle"/> being a very large address space, the chance that two different instances of the worm <em>simultaneously</em> trying to infect a single target is negligible. If <img src="/img/cache/351295f1bad57b1d5a4130dd7d753643.gif" alt="a(t)" valign="middle"/> is the proportion of vulnerable machines which have been compromised at the instant <img src="/img/cache/e358efa489f58062f10dd7316b65649e.gif" alt="t" valign="middle"/>, the RCS model is described by the simple differential equation:</p>
<div class="N5"><img src="/img/cache/840e6c15525945d3f913d6bca054633e.gif" alt="\frac{\text{d}a}{\text{d}t} = Ka(1 - a).\hspace{100}(4)" valign="middle"/></div>
<p>The solution of this equation is the well-known <em>logistic curve</em>. In [18] the authors fit their model to the "scan rate", or the total number of scans seen at a single site, instead than using the number of distinct attacker IP addresses, because this latter variable is distorted by time skew, unless the outbreak is observed from a very large address space, a concept known as a "network telescope" [29]. Researchers from CAIDA used data from such a telescope to describe the Code Red outbreak [30]. A total of about 359.000 hosts were infected by CRv2 in about 14h of activity. The worm was peaking when the self-deactivation mechanism it contained shut it down.</p>
<p>However, when we deal with UDP-based worms such as <em>Slammer</em> (which propagates by exploiting a buffer overflow vulnerability in Microsoft SQL Server) a radical change happens. Slammer had a doubling time of 8.5(±1)s, while Code Red had a doubling time of about 37min. Slammer infected more than 90% of vulnerable hosts within the first 10min. This is caused by the fact that TCP based worms have to establish a connection before actually exploiting the vulnerability: having to wait for answers, they are <em>latency limited</em>. UDP based worm, on the contrary, scans at the full speed allowed by the network bandwidth available, so they are <em>bandwidth limited</em>.</p>
<p>Slammer's spreading strategy is based on random scanning, similarly to Code Red. Thus, the RCS model should fit its growth, but it fails after a while. A common explanation for this failure is that the model does not take into due account bandwidth limitations on the global network: in other words, the failure and overload of links during worm propagation make the "global reachability" assumption less and less realistic as time goes on.</p>
<p>In [31] The RCS model was extended, creating a compartment-based model, in order to take into account the
 
existence of bottleneck Internet links. The propagation equation became thus a system of non-linear differential equations:</p>
<div class="N5"><img src="/img/cache/69c57c56b4ad2e98ab4933f2076846c7.gif" alt="\left\{
 \frac{\text{d}a_i}{\text{d}t} =
 \left[
  a_i K \frac{N_i}{N} + Q_i \sum_{j \ne i} Q_j \frac{N_j}{N} a_j K
 \right] (1 - a_i ),\hspace{100}(5)
" valign="middle"/></div>
<p>where we denote with <img src="/img/cache/173eda91467d59e92b43f2a1d21ee177.gif" alt="N_i" valign="middle"/> the number of susceptible hosts in the <img src="/img/cache/865c0c0b4ab0e063e5caa3387c1a8741.gif" alt="i" valign="middle"/>th compartment (<img src="/img/cache/ed1da370f964fa65cf033d5ebede60f8.gif" alt="AS_i" valign="middle"/>), with <img src="/img/cache/2aecb1dc57e87620a373d19b0a889efb.gif" alt="a_i" valign="middle"/> the proportion of infected hosts in the same compartment. We also suppose, for simplicity, that the average propagation speed <img src="/img/cache/a5f3c6a11b03839d46af9fb43c97c188.gif" alt="K" valign="middle"/> is constant in each compartment. <img src="/img/cache/073c2c8c3eed5aacbde9e64e4f6b5138.gif" alt="Q_i, 0 &lt; Q_i \le 1" valign="middle"/> is the fraction of attack packets that actually can get through the link of the <img src="/img/cache/865c0c0b4ab0e063e5caa3387c1a8741.gif" alt="i" valign="middle"/>-th compartment, and is a rough approximation of the bottleneck effect of the Internet links. Numerical simulations of the equation and its effects on the global growth of the worm and on the observation of the growth from a telescope are also presented.</p>
<p>This model is derived for a set of compartments with a single connection to the rest of the world, which is only partially realistic. A model for multi-homed compartments that are not just leaves, but that forward traffic following realistic Internet policies would be desirable.</p>
<p>Zou et al. [32] propose a different approach for modeling slow worms such as Code Red incorporating the Kermack-Mckendrick model for host disinfection into the RCS equations. Additionally, the authors propose that the infection rate <img src="/img/cache/a5f3c6a11b03839d46af9fb43c97c188.gif" alt="K" valign="middle"/> should be considered a function of time, because of intervening network saturation and router collapse. Basically they rewrite the model as:</p>
<div class="N5"><img src="/img/cache/c4515b79701429e9607e8f33468380cc.gif" alt="\frac{\text{d}a}{\text{d}t}= K(t) a (1 - a - q - r) - \frac{\text{d}r}{\text{d}t}, \hspace{100}(6)" valign="middle"/></div>
<p>where <img src="/img/cache/c9ef9cf8733ebf3f233aa6eafda45d88.gif" alt="q(t)" valign="middle"/> is the proportion of susceptible hosts that are immunized at time <img src="/img/cache/e358efa489f58062f10dd7316b65649e.gif" alt="t" valign="middle"/>, and <img src="/img/cache/8b8865815e7d75e1875e483544a9eeb4.gif" alt="r(t)" valign="middle"/> is the proportion of infected hosts that are cured and immunized at time <img src="/img/cache/e358efa489f58062f10dd7316b65649e.gif" alt="t" valign="middle"/>. This model is thus called the <em>two-factor worm model</em>. In order to complete the model, the authors make some debatable assumptions on <img src="/img/cache/c9ef9cf8733ebf3f233aa6eafda45d88.gif" alt="q(t)" valign="middle"/> and <img src="/img/cache/8b8865815e7d75e1875e483544a9eeb4.gif" alt="r(t)" valign="middle"/>. In particular (similarly to the kill signal theory described in [33]), the patching process is modeled as a "counter-worm":</p>
<div class="N5"><img src="/img/cache/9373821b86ed7623c1ab5303679de87c.gif" alt="\frac{\text{d}q}{\text{d}t} = \mu(1 - a - q - r)(a + r).\hspace{100}(7)" valign="middle"/></div>
<p>This equation is somehow arbitrary, and further analysis on the two-factor model is needed before it can be considered a sound model of viral propagation.</p>
<h3>3.5 Other open questions in propagation modeling</h3>
<p>Some authors [34] have explored discrete time models, in the hope to capture better the discrete time behavior of a worm. However, a continuous model is appropriate for such large scale models, and the epidemiological literature is clear in this direction. The benefits of using a discrete time model seem very limited, but this is difficult to say since the base assumptions of this particular model are not completely correct. More exploration of the usage of discrete time models could lead to interesting results.</p>
<p>It is important to note that modern viruses often use a mix of different techniques to spread (for instance, Sircam uses both mass mailing and open network shares, while <em>Nimda</em> uses four different mechanisms to propagate). We are not aware, however, of any existing model which takes into account multi-vector viruses and worms.</p>
<h2>4 Open problems in antiviral countermeasures</h2>
<h3>4.1 Monitoring and early warning</h3>
<p>In current infrastructure where worms are able to achieve quick penetration it is essential to research and develop methods for prevention that will prevent attacks as early as possible. For example, Ibrahim and al. [35] demonstrate this approach by proactive email worm prevention.</p>
<p>Because of the effects of distortion described in section 3.4, in [36] the models of active worm propagation are used to build an early monitoring and alerting system for TCP or UDP based worms, based on distributed <em>ingress</em> and <em>egress</em> sensors for worm activity. A data collection engine based on a Kalman filter is used to create an alerting system, capable of reliably setting off alarms as early as when the proportion of infected system is <img src="/img/cache/4efc112302a3241b66df3f3084726030.gif" alt="1% \le a \le 2%" valign="middle"/>. It is also shown that this early warning method works well also with fast spreading worms, and even if an hit-list start-up strategy is used.</p>
<p>However, we need more research in areas of proactive prevention. In general interesting areas could be network forensics, detecting infected host systems and preventing malicious operations from infected hosts.</p>
<h3>4.2 Virus resistant infrastructures</h3>
<p>If we develop further the concept of proactive prevention we may end up in research that will promote prevention as an inherent part of infrastructure design. We may find examples of such attempts from the development of IPv6 (Internet Protocol version 6), processor architecture design and buffer overflow [37] prevention techniques. However, we still need more holistic approaches. For example, security can be an inherent part of computer architecture and network architecture design [38]. Interesting questions may arise from construction of virus resistant and self-defending architectures.</p>
<h3>4.3 Integrity verification</h3>
<p>Viruses are a violation against system integrity. Unfortunately, in current systems integrity is difficult to verify and operating environments seldom support systematic integrity verification. There are solutions for system integrity verification, but integrity verification is not typically adapted as an inherent part of system design.</p>
<p>Radai established a theory of integrity verification related to computer virology [39,40]. Furthermore, Bontchev
 
presented some methods viruses can use to attack integrity checking programs and how the attacks could be prevented [41]. More recently, Filiol [9, Chap. 8] technically demonstrated how integrity checking can be bypassed. One interesting question could be: how to adapt integrity verification as securely as possible against malware attacks? For example, new information system architectures may be needed to support integrity verification.</p>
<h3>4.4 Effects of quarantine</h3>
<p>Quarantine is the world's oldest defense against viruses. In [42] a dynamic preventive quarantine system is proposed, which places suspiciously behaving hosts under quarantine for a fixed interval of time. Models and simulation of a quarantine system are proposed, however such a system would be difficult to deploy. Since hosts cannot be trusted to autoquarantine themselves, on most networks quarantine would act on remotely manageable enforcement points (i.e., firewalls and intelligent network switches). Since these components are limited, entire blocks of network would need to be isolated at once, increasing the probability that innocent hosts will be denied service as a side effect of the quarantine system.</p>
<p>In addition, as shown in [31], virus spread is not stopped but only slowed down inside each quarantined block. Moreover, it should be considered that the "kill signal" effect (i.e., the distribution of anti-virus signatures and patches) would be hampered by aggressive quarantine policies (something which is not taken into account in the modified Kerman-McKendrick models presented in [42]).</p>
<p>In [43] various containment strategies (content filtering and blacklisting) are simulated, deriving lower and upper bounds of efficacy. Albeit interesting, the results on blacklisting share the same weakness pointed out before: it's not realistic to think about a global blacklisting engine, enforced at network level.</p>
<p>More research on practical quarantining systems are needed in order to bring these approaches into real-world use. On a LAN, an intelligent network switch could be used to selectively shut down the ports of infected hosts, or to cut off an entire sensitive segment. Network firewalls and perimeter routers can be used to shut down the affected services. Reactive IDSs (the so-called "intrusion prevention systems") can be used to selectively kill worm connections based on attack signatures. Automatic reaction policies, however, are intrinsically dangerous. False positives and the possibility of fooling a prevention system into activating a denial-of-service are dangerous enough to make most network administrators wary.</p>
<h3>4.5 Immunization</h3>
<p>In [33] the effect of selective immunization of computers on a network is discussed. The dynamics of infection and the choice of immunization targets are examined for two network topologies: a hierarchical, tree-like topology (which is obviously not realistic for modeling the Internet), and a cluster topology. The results are interesting, but the exact meaning of "node immunization" is not defined. While such a study could be used to prioritize the process of patching on a widespread network, unless some new ideas for virus prevention are proposed, the practical possibilities of application for such a model seem extremely limited.</p>
<h3>4.6 Honeypots and tarpits</h3>
<p>Honeypots are fake computer system and networks, used as a decoy to cheat intruders. They are installed on dedicated machines, and left as a bait so that aggressors will lose time attacking them and trigger an alert. Since honeypots are not used for any production purpose, any request directed to the honeypot is at least suspect. Honeypots can be made up of real sacrificial systems, or of simulated hosts and services (created using Honeyd by Niels Provos, for example).</p>
<p>A honeypot could be used to detect the aggressive pattern of a worm through anomaly detection: since honeypots are empty of true users, any non-simulated traffic hitting them is suspicious. Repeated connections towards the same ports of the honeypot machines are a good indicator of a scanning worm at work. The honeypot can thus be used as an alerting system. Also, once a worm has entered a honeypot, its payload and replication behaviors can be easily studied, provided that an honeywall is used to quarantine the sacrificial hosts making them unable to actually attack the real hosts outside.</p>
<p>As an additional possibility, an honeypot can be used to slow down worm propagation, particularly in the case of TCP-based worms. By delaying the answers to the worm connections, a honeypot may be able to slow down its propagation; very much the same technique used in the LaBrea "tarpit" tool, which replies to any connection incoming on an unused IP address of a network, and simulates a TCP session with the possible aggressor. LaBrea slows down the connection: when data transfer begins, the TCP window size is set to zero, so that no data can be transferred. The connection is kept open, and any request to close the connection is ignored. This means that the worm will have to wait for a timeout in order to disconnect, since it uses the standard TCP stack of the host machine which follows RFC standards. A worm won't be able to detect this slowdown, and if enough fake targets are present, its growth will be slowed down. Obviously, a multithreaded worm will be less affected by this technique. This effect should be properly studied and modeled to evaluate its effectiveness.</p>
<h3>4.7 Counterattacks and good worms</h3>
<p>Counterattack may seem a viable cure to worms. When host A sees an incoming worm attack from host B, it knows that host B must be vulnerable to the particular exploit that the worm uses to propagate (unless the worm itself removed that
 
vulnerability as a result of infection). By using the same type of exploit, host A can automatically take control of host B and try to cure it from infection and patch it.</p>
<p>The first important thing to note is that, fascinating as the concept may seem, this is not legal, unless host B is under the control of the same administrator of host A. Additionally, automatically patching a remote host is always a dangerous thing, which can cause considerable unintended damage (e.g., breaking services and applications that rely on the patched component).</p>
<p>Another solution which in past proved to be worse than the illness is the release of a so-called "good" or "healing" worm, which automatically propagates in the same way the bad worm does, but carries a payload which patches the vulnerability. A good example of just how dangerous such things may be is the <em>Welchia</em> worm, which was meant to be a cure for <em>Blaster</em>, but actually caused devastating harm to the networks. Such proposals must be carefully evaluated, as was done in [44].</p>
<h2>5 Technical and practical research areas in computer virology</h2>
<h3>5.1 Anti-virus software evaluation</h3>
<p>It is very difficult to accurately evaluate the quality and the limitations inherent to the different antiviral products available today. Users can only compare marketing claims of each vendor, without any real information about the detection and disinfection power and efficiency. Notoriety, or market share, could be taken as an indicator. The raw percentage of viruses/malware that are effectively detected and efficiently disinfected can also be considered. But a little experience in antiviral software quickly shows that this approach is quite sterile.</p>
<p>The problem of having precise and efficient technical evaluation tools, and a clear methodology to use them, is of the highest importance. This problem must be considered in connection with a crucial property expressing the complexity virus writers must face to obtain technical information about the antivirus during a "black box analysis" process. The analysis of viral databases is probably the best example.</p>
<h3>5.2 Malware taxonomy and phylogeny</h3>
<p>As we have seen multiple times, recursive self-replication is the fundamental characteristic of a virus. However, when we go beyond that it becomes difficult to classify malware. Even a definition for the term "computer worm" has not been agreed on. For example, if we define that a virus must infect a host and a worm is self-contained, the meaning of "host" must be discussed. When we reach terms like "Trojan horse" and "spyware" the precise definitions is even more difficult. At least, the following reasons can be found:</p>
<ol>
<li>Malicious intentions are difficult (and sometimes impossible) to predict by analyzing program code.</li>
<li>A program may be used maliciously even when it is designed for beneficial purposes, and vice-versa.</li>
<li>There exist a number of "gray areas" where it is impossible to say whether a program belongs to a certain category or not.</li>
</ol>
<p>Despite the difficulties in defining malware, research on objective definitions and criteria for classification is needed. Brunnstein proposes an interesting classification scheme based on software disfunctions [45]. However, we also need practical definitions. In general interesting questions could be: what are different malware categories and sub-categories? What are the functionalities for a certain program category? What are the precise definitions? How to prove that a program code belongs to a certain category?</p>
<p>Even the naming convention of malware is still an open problem, perhaps one of the most crucial problems in modern computer virology. Unfortunately nobody proved that this is not an "undecidable problem". It is a matter of fact, however, that every antivirus company develops its own naming convention, ignoring the other ones. Very frequently, all these naming conventions appear to be at least partially incompatible, but unless a sound and rational classification base is developed, nobody will accept to give up. Recent developments [46,47] have shown that phylogeny models - i.e., taking into account the fact that programs may be evolved through code rearrangements or that viruses are rarely written from scratch and are mostly derived from known previous codes - is likely to produce the desired tools for a unified naming convention. But many problems still exist. The authors of [47] focused on permutations of code. They have identified some questions that are still to be solved. Moreover, they only consider sequence-based phylogeny models. Would it be possible to extend their approach to function-based phylogeny?</p>
<h3>5.3 Malware in smart phones</h3>
<p>Even a modest cellular phone includes software that controls the phones operations. Meanwhile phones are getting more and more properties of computers: connectivity, applications and calculation power. Although in Symbian smart phone operating system security is part of the design vulnerabilities may still remain. Jarmo [48] presents technical aspects of Symbian from the malware point of view and Reynaud-Plantey [49] recently analyzed some new aspects of the viral risk with respect to the Java language. MMS (Multimedia Messaging System), Bluetooth and vulnerabilities enable existence of viruses.</p>
<p>Research in computer virology is so far occasional in the area of smart phones. Still smart phones bring special aspects to research: mobility, cost of services and fixed wireless connections.</p>
 
<h2>6 Conclusions</h2>
<p>We have proposed some of the most interesting open research problems and areas in computer virology, with an emphasis on theoretical aspects. To begin, we focused on theoretical computer virology, presenting the core results already developed in literature, and the problems that are still waiting a solution. In particular, complexity problems, virus classification and new classes of viruses still need much research.</p>
<p>Virus propagation modeling techniques als need improvement in order to capture new trends in the propagation of common viruses, mass-mailers and random scanning worms. Proposed countermeasures are also described, along with open questions: how can they be validated before being implemented? Which new defensive techniques do we need against the next generations of aggressive malware?</p>
<p>Finally, we presented practical and technical research areas, to complete our review of open research issues: we focused on those problems that, in our view, could benefit from a more theoretically sound approach.</p>
<p>Of course, we have not addressed all open problems. For instance, there are interesting issues concerning programming languages, their semantics and computer viruses. We could wonder whether it is possible to develop a high-level programming language compiler which guarantees that no attacks can be performed. This type of questions is generally addressed in computer safety research, but will likely be deeply interesting in defeating computer malware.</p>
<p>In conclusion, since the research domain in computer virology is a new one, we can expect fundamental research outcomes to be found in the next few years, and to deeply influence the future of computer security technologies for virus defense.</p>
<h2>Acknowledgements</h2>
<p>We would like to thank Jean-Yves Marion for his valuable comments and his help in improving this paper. He very kindly helped in developing some of the points of this paper, and in particular pointed out the research trend on computer language safety.</p>
<h2>References</h2>
<ol>
<li>Cohen, F.: Computer Viruses. PhD Thesis, University of Southern California (1985)</li>
<li>Adleman, L.M.: <a href="/lib/ala01.html">An abstract theory of computer viruses</a>. In: Goldwasser, S. (ed.) Advances in cryptology - CRYPTO'88 - Lecture notes in computer science, vol. 403, pp. 354-374, Berlin Heidelberg New York: Springer 1988</li>
<li>Zuo, Z., Zhou, M.: <a href="/lib/mzz00.html">Some further theoretical results about computer viruses</a>. Comput J 47(6), 627-633 (2004)</li>
<li>Bonfante, G., Kaczmarek, M., Marion, J.-Y.: On abstract computer virology from a recursion-theoretic perspective. J Comput Virol 1(3-4), 45-54 (2006)</li>
<li>Bonfante, G., Kaczmarek, M., Marion, J.-Y.: <a href="/lib/agb00.html">Toward an abstract computer virology</a>. In: Proceedings of the ICTAC'05, lecture notes in computer science, vol. 3722, pp. 579-593. Berlin Heidelberg New York: Springer 2002, 41p (2005)</li>
<li>Rogers, H.: Theory of recursive functions and effective computability. McGraw Hill 1967</li>
<li>Spinellis, D.: <a href="/lib/ads03.html">Reliable identification of bounded-length viruses is np-complete</a>. IEEE Trans Inf Theory 49(1), 280-284 (2003)</li>
<li>Papadimitriou, C.H.: Complexity theory. Reading: Addison Wesley 1994</li>
<li>Filiol, E.: Computer viruses: from theory to applications, 1st edn. Berlin Heidelberg New York: Springer 2005</li>
<li>Zuo, Z., Zhou, M.: <a href="/lib/mzz01.html">On the time complexity of computer viruses</a>. IEEE Trans Inf Theo 51(8), 2962-2966 (2003)</li>
<li>Chess, D.M., White, S.R.: <a href="/lib/adc06.html">An undetectable computer virus</a>. In: Proceedings of the virus bulletin conference (2000)</li>
<li>Filiol, E.: Advanced viral techniques: mathematical and algorithmic aspects. Berlin Heidelberg New York: Springer 2006</li>
<li>Jones, N.D.: Computability and complexity: from a programming perspective. Cambridge: MIT 1997</li>
<li>MacWilliams, F.J., Sloane, N.J.A.: The theory of error-correcting codes. Amsterdam: North-Holland 1977</li>
<li>Hirvensalo, M.: Quantum computing, 2nd edn. Berlin HEidelberg New York: Springer 2004</li>
<li>Brassard, G.: A bibliography of quantum cryptography. SIGACT News 24(3), 16-20 (1993)</li>
<li>Shor, P.W.: Algorithms for quantum computation: Discrete logarithms and factoring. In: Proceedings of the 35th annual symposium on foundations of computer science. Los Alamitos: IEEE Comput Soceity Press (1994)</li>
<li>Staniford, S., Paxson, V., Weaver, N.: How to own the internet in your spare time. In: Proceedings of the 11th USENIX security symposium (Security '02), (2002)</li>
<li>Whalley, I., Arnold, B., Chess, D., Morar, J., Segal, A., Swimmer, M.: An environment for controlled worm replication and analysis. In: Proceedings of the virus bulletin conference (2000)</li>
<li>White, S.R.: <a href="/lib/asw01.html">Open problems in computer virus research</a>. In: Proceedings of the virus bulletin conference (1998)</li>
<li>Kephart,J.O.,White,S.R.: <a href="/lib/ajk06.html">Directed-graph epidemiological models of computer viruses</a>. In: IEEE symposium on security and privacy, pp 343-361 (1991)</li>
<li>Hethcote, H.W.: The mathematics of infectious diseases. SIAM Rev 42(4), 599-653 (2000)</li>
<li>Billings, L., Spears, W.M., Schwartz, I.B.: <a href="/lib/alb01.html">A unified prediction of computer virus spread in connected networks</a>. Phys Lett A 297, 261-266 (2002)</li>
<li>Zou, C.C., Towsley, D., Gong, W.: Email virus propagation modeling and analysis. Technical report TR-CSE-03-04, University of Massachussets, Amherst</li>
<li>Spafford, E.H.: Crisis and aftermath. Commun ACM 32(6), 678-687 (1989)</li>
<li>Permeh, R., Hassell, R.: Microsoft I.I.S. remote buffer overflow. Advisory AD20010618 (2001)</li>
<li>Aleph1' Levy, E.: Smashing the stack for fun and profit. Phrack Magazine 7(49) (1996)</li>
<li>Labovitz, A.A.C., Bailey, M.: Shining light on dark address space. Technical report, Arbor networks (2001)</li>
<li>Moore, D.: Network telescopes: Observing small or distant security events. In: Proceedings of the 11th USENIX security symposium (2002)</li>
<li>Moore, D., Shannon, C., Brown, J.: Code-red: a case study on the spread and victims of an internet worm. In: Proceedings of the ACM SIGCOMM/USENIX internet measurement workshop (2002)</li>
<li>Serazzi, G., Zanero, S.: Computer virus propagation models. In: Calzarossa, M.C., Gelenbe, E. (eds.) Tutorials of the 11th IEEE/ACM Int'l symp. on modeling, analysis and simulation of computer and telecom - systems - MASCOTS 2003. Berlin Heidelberg New York: Springer 2003</li>
<li>Zou, C.C., Gong, W., Towsley, D.: Code red worm propagation modeling and analysis. In: Proceedings of the 9th ACM conference on computer and communications security, pp 138-147. New York: ACM Press 2002</li>
<li>Wang, C., Knight, J.C., Elder, M.C.: On computer viral infection and the effect of immunization. In: ACSAC '00: proceedings of the 16th annual computer security applications conference, Washington, DC, USA, p 246. Dublin: IEEE Computer Society (2000)</li>
<li>Chen, Z., Gao, L., Kwiat, K.: Modeling the spread of active worms. In: Proceedings of IEEE INFOCOM 2003 (2003)</li>
 
<li>El-FarArun, I.K., Ford, R., Ondi, A., Pancholi, M.: Suppressing the spread of email malcode using short-term message recall. J Comput Virol 1(1-2), 4-12 (2005)</li>
<li>Zou, C.C., Gao, L., Gong, W., Towsley, D.: Monitoring and early warning for internet worms. In: Proceedings of the 10th ACM conference on computer and communication security, pp 190-199. New York: ACM Press 2003</li>
<li>Chien, E., Peter, S.: Blended attacks: Exploits, vulnerabilities and buffer-overflow techniques in computer viruses. In: Proceedings of virus bulletin conference 2002, pp 1-35 Oxfordshire: Virus Bulletin Ltd (2002)</li>
<li>Helenius, M.: Realisation ideas for secure system design. In: Gattiker, U.E. (ed.) EICAR Conference Best Paper Proceedings, Copenhagen (2003)</li>
<li>Yisrael, R. Checksumming techniques for anti-viral purposes. In: Proceedings of 1st international virus bulletin conference (1991)</li>
<li>Yisrael, R.: Integrity checking for anti-viral purposes: theory and practice. improved version of earlier conference paper http://www.virusbtn.com/OtherPapers/Integrity/integrity-ps.zip (1994)</li>
<li>Bontchev, V. <a href="/lib/avb04.html">Possible virus attacks against integrity programs and how to prevent them</a>. In: Proceedings of 2nd international virus bulletin conference, pp 131-141 (1992)</li>
<li>Zou, C.C., Gong, W., Towsley, D.: Worm propagation modeling and analysis under dynamic quarantine defense. In: Proceedings of the ACM CCS workshop on rapid malcode (WORM'03) (2003)</li>
<li>Moore, D., Shannon, C., Voelker, G.M., Savage, S.: Internet quarantine: requirements for containing self-propagating code. In: Proceedings of IEEE INFOCOM (2003)</li>
<li>Castaneda, F., Sezer, E.C., Xu, J.: Worm vs. worm: preliminary study of an active counter-attack mechanism. In: WORM '04: Proceedings of the 2004 ACM workshop on Rapid malcode, pp 83-93. New York: ACM Press, 2004</li>
<li>Brunnstein, K.: From antivirus to antimalware software and beyond: another approach to the protection of customers from dysfunctional system behaviour. In: Proceedings of 22nd national information systems security conference, 1999</li>
<li>Goldberg, L.A., Goldberg, P.W., Phillips, C.A., Sorkin, G.B.: Constructing computer virus phylogenies. J Algorithms 26, 188-208 (1998)</li>
<li>Karim, M.E., Walenstein, A., Lakhotia, A.: Malware phylogeny generation using permutations of code. J Comput Virol 1(1-2) 13-23 (2005)</li>
<li>Jarmo, N.:What makes symbian malware tick. In: Proceedings of virus bulletin conference, pp 115-120. England: Virus Bulletin Ltd 2005</li>
<li>Reynaud-Plantey, D.: New threats of java viruses. J Comput Virol 1(3-4), 32-43 (2005)</li>
</ol>
 
[<a style="" href="/lib/?lang=EN&amp;index=TH#aef03">Back to index</a>] [<a href="/lib/aef03.html#disqus_thread">Comments</a>]<br/> <div id="disqus_thread"></div>
<script type="text/rocketscript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'vxheaven'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="/agreement.php">Terms of Use</a>!</small> <small>vxheaven.org aka vx.netlux.org</small></div>
<div style="margin-top: 2px; float: left;" class="adsapeu">
<script type="text/rocketscript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script>
</div>
<script data-rocketsrc="http://www.google-analytics.com/urchin.js" type="text/rocketscript"></script><script type="text/rocketscript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="/lib/index.php?lang=de&amp;id=aef03">de</a><a href="/lib/index.php?lang=en&amp;id=aef03">en</a><a href="/lib/index.php?lang=es&amp;id=aef03">es</a><a href="/lib/index.php?lang=it&amp;id=aef03">it</a><a href="/lib/index.php?lang=fr&amp;id=aef03">fr</a><a href="/lib/index.php?lang=pl&amp;id=aef03">pl</a><a href="/lib/index.php?lang=ru&amp;id=aef03">ru</a><a href="/lib/index.php?lang=ua&amp;id=aef03">ua</a></div>
</body>
</html>
